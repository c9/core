{
  "Q": {
    "IPromise": {
      "then": "fn(onFulfill?: fn(value: T), IPromise: ?, onReject?: fn(error: ?), IPromise: ?) -> ?"
    },
    "Deferred": {
      "promise": "?",
      "resolve": "fn(value?: T)",
      "reject": "fn(reason: ?)",
      "notify": "fn(value: ?)",
      "makeNodeResolver": "fn() -> fn(reason: ?, value: T)"
    },
    "Promise": {
      "fin": "fn(finallyCallback: fn()) -> ?",
      "finally": "fn(finallyCallback: fn()) -> ?",
      "then": "fn(onFulfill?: fn(value: T), IPromise: ?, onReject?: fn(error: ?), IPromise: ?, onProgress?: Function) -> ?",
      "spread": "fn(onFulfill: fn(args: [?]), U: ?, onReject?: fn(reason: ?), U: ?) -> ?",
      "fail": "fn(onRejected: fn(reason: ?), IPromise: ?) -> ?",
      "catch": "fn(onRejected: fn(reason: ?), IPromise: ?) -> ?",
      "progress": "fn(onProgress: fn(progress: ?)) -> ?",
      "done": "fn(onFulfilled?: fn(value: T), onRejected?: fn(reason: ?), onProgress?: fn(progress: ?))",
      "nodeify": "fn(callback: fn(reason: ?, value: ?)) -> ?",
      "get": "fn(propertyName: String) -> ?",
      "set": "fn(propertyName: String, value: ?) -> ?",
      "delete": "fn(propertyName: String) -> ?",
      "post": "fn(methodName: String, args: [?]) -> ?",
      "invoke": "fn(methodName: String, args: [?]) -> ?",
      "fapply": "fn(args: [?]) -> ?",
      "fcall": "fn(args: [?]) -> ?",
      "keys": "fn() -> ?",
      "thenResolve": "fn(value: U) -> ?",
      "thenReject": "fn(reason: ?) -> ?",
      "tap": "fn(onFulfilled: fn(value: T)) -> ?",
      "timeout": "fn(ms: number, message?: string) -> ?",
      "delay": "fn(ms: number) -> ?",
      "isFulfilled": "fn() -> bool",
      "isRejected": "fn() -> bool",
      "isPending": "fn() -> bool",
      "inspect": "fn() -> ?",
      "!type": "fn(resolver: fn(resolve: fn(val: T, IPromise: ?, reject: fn(reason: ?), notify: fn(progress: ?))), Promise: ?, : ?, : ?, : ?, : ?, : ?, : ?, : ?)"
    },
    "PromiseState": {
      "state": "string",
      "value": "T",
      "reason": "?"
    },
    "when": "fn() -> ?",
    "fbind": "fn(method: fn(args: [?]), IPromise: ?, args: [?]) -> fn(args: [?])",
    "fcall": "fn(method: fn(args: [?]), args: [?]) -> ?",
    "send": "fn(obj: ?, functionName: string, args: [?]) -> ?",
    "invoke": "fn(obj: ?, functionName: string, args: [?]) -> ?",
    "mcall": "fn(obj: ?, functionName: string, args: [?]) -> ?",
    "denodeify": "fn(nodeFunction: Function, args: [?]) -> fn(args: [?])",
    "nbind": "fn(nodeFunction: Function, thisArg: ?, args: [?]) -> fn(args: [?])",
    "nfbind": "fn(nodeFunction: Function, args: [?]) -> fn(args: [?])",
    "nfcall": "fn(nodeFunction: Function, args: [?]) -> ?",
    "nfapply": "fn(nodeFunction: Function, args: [?]) -> ?",
    "ninvoke": "fn(nodeModule: ?, functionName: string, args: [?]) -> ?",
    "npost": "fn(nodeModule: ?, functionName: string, args: [?]) -> ?",
    "nsend": "fn(nodeModule: ?, functionName: string, args: [?]) -> ?",
    "nmcall": "fn(nodeModule: ?, functionName: string, args: [?]) -> ?",
    "all": "fn(promises: [?]) -> ?",
    "race": "fn(promises: [?]) -> ?",
    "allSettled": "fn(promises: [?]) -> ?",
    "allResolved": "fn(promises: [?]) -> ?",
    "spread": "fn(promises: [?], onFulfilled: fn(args: [T]), IPromise: ?, onRejected?: fn(reason: ?), IPromise: ?) -> ?",
    "timeout": "fn(promise: ?, ms: number, message?: string) -> ?",
    "delay": "fn(promise: ?, ms: number) -> ?",
    "isFulfilled": "fn(promise: ?) -> bool",
    "isRejected": "fn(promise: ?) -> bool",
    "isPending": "fn(promise: ?) -> bool",
    "defer": "fn() -> ?",
    "reject": "fn(reason?: ?) -> ?",
    "onerror": "fn(reason: ?)",
    "longStackSupport": "bool",
    "resolve": "fn(object: ?) -> ?",
    "noConflict": "fn() -> Q",
    "!type": "fn(promise: ?) -> ?"
  },
  "q": "Q",
  "!name": "Q"
}
