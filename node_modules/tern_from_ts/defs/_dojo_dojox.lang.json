{
  "dojox": {
    "lang": {
      "observable": {},
      "oo": {
        "Decorator": {
          "decorator": "Function",
          "value": "Object"
        },
        "Filter": {
          "bag": "Object",
          "filter": "Function"
        },
        "mixin": {},
        "rearrange": {},
        "aop": {
          "after": "Object",
          "afterReturning": "Object",
          "afterThrowing": "Object",
          "around": "Object",
          "before": "Object"
        },
        "general": {
          "after": "Object",
          "augment": "Object",
          "before": "Object",
          "override": "Object",
          "shuffle": "Object",
          "tap": "Object",
          "wrap": "Object"
        }
      },
      "aspect": {
        "advise": "fn(obj: Object, method: String, advice: Object)",
        "adviseRaw": "fn(obj: Object, methods: [?], advices: [?])",
        "getContext": "fn()",
        "getContextStack": "fn()",
        "proceed": "fn()",
        "unadvise": "fn(handle: Object)",
        "counter": {},
        "cflow": {},
        "memoizer": {},
        "memoizerGuard": {},
        "profiler": {},
        "timer": {},
        "tracer": {}
      },
      "async": {
        "any": "fn(x: ?)",
        "ifThen": "fn(cond: ?, ifTrue: ?, ifFalse: ?)",
        "loop": "fn(cond: ?, body: ?)",
        "par": "fn(x: ?)",
        "select": "fn(cond: ?, x: ?)",
        "seq": "fn(x: ?)",
        "timeout": {
          "failOn": "fn(ms: ?)",
          "from": "fn(ms: ?)"
        },
        "event": {
          "failOn": "fn(src: ?, name: ?)",
          "from": "fn(src: ?, name: ?)"
        },
        "topic": {
          "failOn": "fn(topic: ?)",
          "from": "fn(topic: ?)"
        }
      },
      "functional": {
        "buildLambda": "fn(s: String) -> String",
        "clearLambdaCache": "fn()",
        "every": "fn(a: [?], f: Function, o: Object) -> bool",
        "everyRev": "fn(a: [?], f: Function, o: Object) -> bool",
        "filter": "fn(a: [?], f: Function, o: Object) -> [?]",
        "filterIn": "fn(obj: Object, f: Function, o: Object) -> Object",
        "filterRev": "fn(a: [?], f: Function, o: Object) -> [?]",
        "foldl": "fn(a: [?], f: Function, z: Object, o: Object) -> ?",
        "foldl1": "fn(a: [?], f: Function, o: Object) -> ?",
        "foldr": "fn(a: [?], f: Function, z: Object, o: Object) -> Object",
        "foldr1": "fn(a: [?], f: Function, o: Object) -> ?",
        "forEach": "fn(a: [?], f: Function, o: Object) -> String",
        "forEachRev": "fn(a: [?], f: Function, o: Object)",
        "forIn": "fn(obj: Object, f: Function, o: Object) -> String",
        "keys": "fn(obj: Object) -> [?]",
        "lambda": {
          "buildLambda": "fn(s: String) -> String",
          "clearLambdaCache": "fn()",
          "every": "fn(a: [?], f: Function, o: Object) -> bool",
          "everyRev": "fn(a: [?], f: Function, o: Object) -> bool",
          "filter": "fn(a: [?], f: Function, o: Object) -> [?]",
          "filterIn": "fn(obj: Object, f: Function, o: Object) -> Object",
          "filterRev": "fn(a: [?], f: Function, o: Object) -> [?]",
          "foldl": "fn(a: [?], f: Function, z: Object, o: Object) -> ?",
          "foldl1": "fn(a: [?], f: Function, o: Object) -> ?",
          "foldr": "fn(a: [?], f: Function, z: Object, o: Object) -> Object",
          "foldr1": "fn(a: [?], f: Function, o: Object) -> ?",
          "forEach": "fn(a: [?], f: Function, o: Object) -> String",
          "forEachRev": "fn(a: [?], f: Function, o: Object)",
          "forIn": "fn(obj: Object, f: Function, o: Object) -> String",
          "keys": "fn(obj: Object) -> [?]",
          "lambda": "fn(s: Function) -> Function",
          "map": "fn(a: [?], f: Function, o: Object) -> [?]",
          "mapIn": "fn(obj: Object, f: Function, o: Object) -> Object",
          "mapRev": "fn(a: [?], f: Function, o: Object) -> ?",
          "rawLambda": "fn(s: String) -> ?",
          "reduce": "fn(a: [?], f: Function, z: Object) -> ?",
          "reduceRight": "fn(a: [?], f: Function, z: Object) -> ?",
          "repeat": "fn(n: number, f: Function, z: Object, o: Object) -> ?",
          "scanl": "fn(a: [?], f: Function, z: Object, o: Object) -> [?]",
          "scanl1": "fn(a: [?], f: Function, o: Object) -> [?]",
          "scanr": "fn(a: [?], f: Function, z: Object, o: Object) -> ?",
          "scanr1": "fn(a: [?], f: Function, o: Object) -> ?",
          "some": "fn(a: [?], f: Function, o: Object) -> bool",
          "someRev": "fn(a: [?], f: Function, o: Object) -> bool",
          "unfold": "fn(pr: Function, f: Function, g: Function, z: Object, o: Object) -> [?]",
          "until": "fn(pr: Function, f: Function, z: Object, o: Object) -> [?]",
          "values": "fn(obj: Object) -> [?]"
        },
        "map": "fn(a: [?], f: Function, o: Object) -> [?]",
        "mapIn": "fn(obj: Object, f: Function, o: Object) -> Object",
        "mapRev": "fn(a: [?], f: Function, o: Object) -> ?",
        "rawLambda": "fn(s: String) -> ?",
        "reduce": "fn(a: [?], f: Function, z: Object) -> ?",
        "reduceRight": "fn(a: [?], f: Function, z: Object) -> ?",
        "repeat": "fn(n: number, f: Function, z: Object, o: Object) -> ?",
        "scanl": "fn(a: [?], f: Function, z: Object, o: Object) -> [?]",
        "scanl1": "fn(a: [?], f: Function, o: Object) -> [?]",
        "scanr": "fn(a: [?], f: Function, z: Object, o: Object) -> ?",
        "scanr1": "fn(a: [?], f: Function, o: Object) -> ?",
        "some": "fn(a: [?], f: Function, o: Object) -> bool",
        "someRev": "fn(a: [?], f: Function, o: Object) -> bool",
        "unfold": "fn(pr: Function, f: Function, g: Function, z: Object, o: Object) -> [?]",
        "until": "fn(pr: Function, f: Function, z: Object, o: Object) -> [?]",
        "values": "fn(obj: Object) -> [?]",
        "array": {
          "buildLambda": "fn(s: String) -> String",
          "clearLambdaCache": "fn()",
          "every": "fn(a: [?], f: Function, o: Object) -> bool",
          "everyRev": "fn(a: [?], f: Function, o: Object) -> bool",
          "filter": "fn(a: [?], f: Function, o: Object) -> [?]",
          "filterIn": "fn(obj: Object, f: Function, o: Object) -> Object",
          "filterRev": "fn(a: [?], f: Function, o: Object) -> [?]",
          "foldl": "fn(a: [?], f: Function, z: Object, o: Object) -> ?",
          "foldl1": "fn(a: [?], f: Function, o: Object) -> ?",
          "foldr": "fn(a: [?], f: Function, z: Object, o: Object) -> Object",
          "foldr1": "fn(a: [?], f: Function, o: Object) -> ?",
          "forEach": "fn(a: [?], f: Function, o: Object) -> String",
          "forEachRev": "fn(a: [?], f: Function, o: Object)",
          "forIn": "fn(obj: Object, f: Function, o: Object) -> String",
          "keys": "fn(obj: Object) -> [?]",
          "lambda": "fn(s: Function) -> Function",
          "map": "fn(a: [?], f: Function, o: Object) -> [?]",
          "mapIn": "fn(obj: Object, f: Function, o: Object) -> Object",
          "mapRev": "fn(a: [?], f: Function, o: Object) -> ?",
          "rawLambda": "fn(s: String) -> ?",
          "reduce": "fn(a: [?], f: Function, z: Object) -> ?",
          "reduceRight": "fn(a: [?], f: Function, z: Object) -> ?",
          "repeat": "fn(n: number, f: Function, z: Object, o: Object) -> ?",
          "scanl": "fn(a: [?], f: Function, z: Object, o: Object) -> [?]",
          "scanl1": "fn(a: [?], f: Function, o: Object) -> [?]",
          "scanr": "fn(a: [?], f: Function, z: Object, o: Object) -> ?",
          "scanr1": "fn(a: [?], f: Function, o: Object) -> ?",
          "some": "fn(a: [?], f: Function, o: Object) -> bool",
          "someRev": "fn(a: [?], f: Function, o: Object) -> bool",
          "unfold": "fn(pr: Function, f: Function, g: Function, z: Object, o: Object) -> [?]",
          "until": "fn(pr: Function, f: Function, z: Object, o: Object) -> [?]",
          "values": "fn(obj: Object) -> [?]"
        },
        "listcomp": {},
        "object": {
          "buildLambda": "fn(s: String) -> String",
          "clearLambdaCache": "fn()",
          "every": "fn(a: [?], f: Function, o: Object) -> bool",
          "everyRev": "fn(a: [?], f: Function, o: Object) -> bool",
          "filter": "fn(a: [?], f: Function, o: Object) -> [?]",
          "filterIn": "fn(obj: Object, f: Function, o: Object) -> Object",
          "filterRev": "fn(a: [?], f: Function, o: Object) -> [?]",
          "foldl": "fn(a: [?], f: Function, z: Object, o: Object) -> ?",
          "foldl1": "fn(a: [?], f: Function, o: Object) -> ?",
          "foldr": "fn(a: [?], f: Function, z: Object, o: Object) -> Object",
          "foldr1": "fn(a: [?], f: Function, o: Object) -> ?",
          "forEach": "fn(a: [?], f: Function, o: Object) -> String",
          "forEachRev": "fn(a: [?], f: Function, o: Object)",
          "forIn": "fn(obj: Object, f: Function, o: Object) -> String",
          "keys": "fn(obj: Object) -> [?]",
          "lambda": "fn(s: Function) -> Function",
          "map": "fn(a: [?], f: Function, o: Object) -> [?]",
          "mapIn": "fn(obj: Object, f: Function, o: Object) -> Object",
          "mapRev": "fn(a: [?], f: Function, o: Object) -> ?",
          "rawLambda": "fn(s: String) -> ?",
          "reduce": "fn(a: [?], f: Function, z: Object) -> ?",
          "reduceRight": "fn(a: [?], f: Function, z: Object) -> ?",
          "repeat": "fn(n: number, f: Function, z: Object, o: Object) -> ?",
          "scanl": "fn(a: [?], f: Function, z: Object, o: Object) -> [?]",
          "scanl1": "fn(a: [?], f: Function, o: Object) -> [?]",
          "scanr": "fn(a: [?], f: Function, z: Object, o: Object) -> ?",
          "scanr1": "fn(a: [?], f: Function, o: Object) -> ?",
          "some": "fn(a: [?], f: Function, o: Object) -> bool",
          "someRev": "fn(a: [?], f: Function, o: Object) -> bool",
          "unfold": "fn(pr: Function, f: Function, g: Function, z: Object, o: Object) -> [?]",
          "until": "fn(pr: Function, f: Function, z: Object, o: Object) -> [?]",
          "values": "fn(obj: Object) -> [?]"
        },
        "reversed": {
          "buildLambda": "fn(s: String) -> String",
          "clearLambdaCache": "fn()",
          "every": "fn(a: [?], f: Function, o: Object) -> bool",
          "everyRev": "fn(a: [?], f: Function, o: Object) -> bool",
          "filter": "fn(a: [?], f: Function, o: Object) -> [?]",
          "filterIn": "fn(obj: Object, f: Function, o: Object) -> Object",
          "filterRev": "fn(a: [?], f: Function, o: Object) -> [?]",
          "foldl": "fn(a: [?], f: Function, z: Object, o: Object) -> ?",
          "foldl1": "fn(a: [?], f: Function, o: Object) -> ?",
          "foldr": "fn(a: [?], f: Function, z: Object, o: Object) -> Object",
          "foldr1": "fn(a: [?], f: Function, o: Object) -> ?",
          "forEach": "fn(a: [?], f: Function, o: Object) -> String",
          "forEachRev": "fn(a: [?], f: Function, o: Object)",
          "forIn": "fn(obj: Object, f: Function, o: Object) -> String",
          "keys": "fn(obj: Object) -> [?]",
          "lambda": "fn(s: Function) -> Function",
          "map": "fn(a: [?], f: Function, o: Object) -> [?]",
          "mapIn": "fn(obj: Object, f: Function, o: Object) -> Object",
          "mapRev": "fn(a: [?], f: Function, o: Object) -> ?",
          "rawLambda": "fn(s: String) -> ?",
          "reduce": "fn(a: [?], f: Function, z: Object) -> ?",
          "reduceRight": "fn(a: [?], f: Function, z: Object) -> ?",
          "repeat": "fn(n: number, f: Function, z: Object, o: Object) -> ?",
          "scanl": "fn(a: [?], f: Function, z: Object, o: Object) -> [?]",
          "scanl1": "fn(a: [?], f: Function, o: Object) -> [?]",
          "scanr": "fn(a: [?], f: Function, z: Object, o: Object) -> ?",
          "scanr1": "fn(a: [?], f: Function, o: Object) -> ?",
          "some": "fn(a: [?], f: Function, o: Object) -> bool",
          "someRev": "fn(a: [?], f: Function, o: Object) -> bool",
          "unfold": "fn(pr: Function, f: Function, g: Function, z: Object, o: Object) -> [?]",
          "until": "fn(pr: Function, f: Function, z: Object, o: Object) -> [?]",
          "values": "fn(obj: Object) -> [?]"
        },
        "sequence": {
          "buildLambda": "fn(s: String) -> String",
          "clearLambdaCache": "fn()",
          "every": "fn(a: [?], f: Function, o: Object) -> bool",
          "everyRev": "fn(a: [?], f: Function, o: Object) -> bool",
          "filter": "fn(a: [?], f: Function, o: Object) -> [?]",
          "filterIn": "fn(obj: Object, f: Function, o: Object) -> Object",
          "filterRev": "fn(a: [?], f: Function, o: Object) -> [?]",
          "foldl": "fn(a: [?], f: Function, z: Object, o: Object) -> ?",
          "foldl1": "fn(a: [?], f: Function, o: Object) -> ?",
          "foldr": "fn(a: [?], f: Function, z: Object, o: Object) -> Object",
          "foldr1": "fn(a: [?], f: Function, o: Object) -> ?",
          "forEach": "fn(a: [?], f: Function, o: Object) -> String",
          "forEachRev": "fn(a: [?], f: Function, o: Object)",
          "forIn": "fn(obj: Object, f: Function, o: Object) -> String",
          "keys": "fn(obj: Object) -> [?]",
          "lambda": "fn(s: Function) -> Function",
          "map": "fn(a: [?], f: Function, o: Object) -> [?]",
          "mapIn": "fn(obj: Object, f: Function, o: Object) -> Object",
          "mapRev": "fn(a: [?], f: Function, o: Object) -> ?",
          "rawLambda": "fn(s: String) -> ?",
          "reduce": "fn(a: [?], f: Function, z: Object) -> ?",
          "reduceRight": "fn(a: [?], f: Function, z: Object) -> ?",
          "repeat": "fn(n: number, f: Function, z: Object, o: Object) -> ?",
          "scanl": "fn(a: [?], f: Function, z: Object, o: Object) -> [?]",
          "scanl1": "fn(a: [?], f: Function, o: Object) -> [?]",
          "scanr": "fn(a: [?], f: Function, z: Object, o: Object) -> ?",
          "scanr1": "fn(a: [?], f: Function, o: Object) -> ?",
          "some": "fn(a: [?], f: Function, o: Object) -> bool",
          "someRev": "fn(a: [?], f: Function, o: Object) -> bool",
          "unfold": "fn(pr: Function, f: Function, g: Function, z: Object, o: Object) -> [?]",
          "until": "fn(pr: Function, f: Function, z: Object, o: Object) -> [?]",
          "values": "fn(obj: Object) -> [?]"
        },
        "zip": {},
        "fold": {},
        "scan": {}
      },
      "utils": {
        "coerceType": "fn(target: Object, source: Object) -> ?",
        "merge": "fn(object: Object, mixin: Object) -> ?",
        "updateWithObject": "fn(target: Object, source: Object, conv: bool) -> Object",
        "updateWithPattern": "fn(target: Object, source: Object, pattern: Object, conv: bool) -> Object"
      }
    }
  },
  "dojox/lang/observable": "exp",
  "dojox/lang/aspect": "exp",
  "dojox/lang/aspect/memoizerGuard": "exp",
  "dojox/lang/aspect/memoizer": "exp",
  "dojox/lang/aspect/counter": "exp",
  "dojox/lang/aspect/cflow": "exp",
  "dojox/lang/aspect/timer": "exp",
  "dojox/lang/aspect/profiler": "exp",
  "dojox/lang/aspect/tracer": "exp",
  "dojox/lang/async": "exp",
  "dojox/lang/async/event": "exp",
  "dojox/lang/async/timeout": "exp",
  "dojox/lang/async/topic": "exp",
  "dojox/lang/functional": "exp",
  "dojox/lang/functional/listcomp": "exp",
  "dojox/lang/functional/object": "exp",
  "dojox/lang/functional/zip": "exp",
  "dojox/lang/functional/array": "exp",
  "dojox/lang/functional/lambda": "exp",
  "dojox/lang/functional/reversed": "exp",
  "dojox/lang/functional/sequence": "exp",
  "dojox/lang/utils": "exp",
  "dojox/lang/oo/mixin": "exp",
  "dojox/lang/oo/Filter": "exp",
  "dojox/lang/oo/Decorator": "exp",
  "dojox/lang/oo/rearrange": "exp",
  "dojox/lang/oo/aop": "exp",
  "dojox/lang/oo/general": "exp",
  "!name": "dojox.lang"
}
