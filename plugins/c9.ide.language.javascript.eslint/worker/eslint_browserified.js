// generated using packager/eslint.js
define([], function() { return /******/ (function(modules) { // webpackBootstrap
 	var installedModules = {};
 	function __webpack_require__(moduleId) {
 		if(installedModules[moduleId]) {
 			return installedModules[moduleId].exports;
 		}
 		var module = installedModules[moduleId] = {
 			i: moduleId,
 			l: false,
 			exports: {}
 		};
 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
 		module.l = true;
 		return module.exports;
 	}
 	__webpack_require__.m = modules;
 	__webpack_require__.c = installedModules;
 	__webpack_require__.d = function(exports, name, getter) {
 		if(!__webpack_require__.o(exports, name)) {
 			Object.defineProperty(exports, name, {
 				configurable: false,
 				enumerable: true,
 				get: getter
 			});
 		}
 	};
 	__webpack_require__.n = function(module) {
 		var getter = module && module.__esModule ?
 			function getDefault() { return module['default']; } :
 			function getModuleExports() { return module; };
 		__webpack_require__.d(getter, 'a', getter);
 		return getter;
 	};
 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
 	__webpack_require__.p = "";
 	return __webpack_require__(__webpack_require__.s = 173);
 })
 ([
 (function(module, exports, __webpack_require__) {

"use strict";
var esutils = __webpack_require__(68);
var espree = __webpack_require__(69);
var anyFunctionPattern = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/;
var anyLoopPattern = /^(?:DoWhile|For|ForIn|ForOf|While)Statement$/;
var arrayOrTypedArrayPattern = /Array$/;
var arrayMethodPattern = /^(?:every|filter|find|findIndex|forEach|map|some)$/;
var bindOrCallOrApplyPattern = /^(?:bind|call|apply)$/;
var breakableTypePattern = /^(?:(?:Do)?While|For(?:In|Of)?|Switch)Statement$/;
var thisTagPattern = /^[\s*]*@this/m;

var COMMENTS_IGNORE_PATTERN = /^\s*(?:eslint|jshint\s+|jslint\s+|istanbul\s+|globals?\s+|exported\s+|jscs)/;
var LINEBREAKS = new Set(["\r\n", "\r", "\n", "\u2028", "\u2029"]);
var LINEBREAK_MATCHER = /\r\n|[\r\n\u2028\u2029]/;
var SHEBANG_MATCHER = /^#!([^\r\n]+)/;
var STATEMENT_LIST_PARENTS = new Set(["Program", "BlockStatement", "SwitchCase"]);
function isModifyingReference(reference, index, references) {
	var identifier = reference.identifier;
	var modifyingDifferentIdentifier = index === 0 || references[index - 1].identifier !== identifier;

	return identifier && reference.init === false && reference.isWrite() && modifyingDifferentIdentifier;
}
function startsWithUpperCase(s) {
	return s[0] !== s[0].toLocaleLowerCase();
}
function isES5Constructor(node) {
	return node.id && startsWithUpperCase(node.id.name);
}
function getUpperFunction(node) {
	while (node) {
		if (anyFunctionPattern.test(node.type)) {
			return node;
		}
		node = node.parent;
	}
	return null;
}
function isFunction(node) {
	return Boolean(node && anyFunctionPattern.test(node.type));
}
function isLoop(node) {
	return Boolean(node && anyLoopPattern.test(node.type));
}
function isInLoop(node) {
	while (node && !isFunction(node)) {
		if (isLoop(node)) {
			return true;
		}

		node = node.parent;
	}

	return false;
}
function isNullOrUndefined(node) {
	return module.exports.isNullLiteral(node) || node.type === "Identifier" && node.name === "undefined" || node.type === "UnaryExpression" && node.operator === "void";
}
function isCallee(node) {
	return node.parent.type === "CallExpression" && node.parent.callee === node;
}
function isReflectApply(node) {
	return node.type === "MemberExpression" && node.object.type === "Identifier" && node.object.name === "Reflect" && node.property.type === "Identifier" && node.property.name === "apply" && node.computed === false;
}
function isArrayFromMethod(node) {
	return node.type === "MemberExpression" && node.object.type === "Identifier" && arrayOrTypedArrayPattern.test(node.object.name) && node.property.type === "Identifier" && node.property.name === "from" && node.computed === false;
}
function isMethodWhichHasThisArg(node) {
	while (node) {
		if (node.type === "Identifier") {
			return arrayMethodPattern.test(node.name);
		}
		if (node.type === "MemberExpression" && !node.computed) {
			node = node.property;
			continue;
		}

		break;
	}

	return false;
}
function negate(f) {
	return function (token) {
		return !f(token);
	};
}
function hasJSDocThisTag(node, sourceCode) {
	var jsdocComment = sourceCode.getJSDocComment(node);

	if (jsdocComment && thisTagPattern.test(jsdocComment.value)) {
		return true;
	}
	return sourceCode.getCommentsBefore(node).some(function (comment) {
		return thisTagPattern.test(comment.value);
	});
}
function isParenthesised(sourceCode, node) {
	var previousToken = sourceCode.getTokenBefore(node),
		nextToken = sourceCode.getTokenAfter(node);

	return Boolean(previousToken && nextToken) && previousToken.value === "(" && previousToken.range[1] <= node.range[0] && nextToken.value === ")" && nextToken.range[0] >= node.range[1];
}
function isArrowToken(token) {
	return token.value === "=>" && token.type === "Punctuator";
}
function isCommaToken(token) {
	return token.value === "," && token.type === "Punctuator";
}
function isSemicolonToken(token) {
	return token.value === ";" && token.type === "Punctuator";
}
function isColonToken(token) {
	return token.value === ":" && token.type === "Punctuator";
}
function isOpeningParenToken(token) {
	return token.value === "(" && token.type === "Punctuator";
}
function isClosingParenToken(token) {
	return token.value === ")" && token.type === "Punctuator";
}
function isOpeningBracketToken(token) {
	return token.value === "[" && token.type === "Punctuator";
}
function isClosingBracketToken(token) {
	return token.value === "]" && token.type === "Punctuator";
}
function isOpeningBraceToken(token) {
	return token.value === "{" && token.type === "Punctuator";
}
function isClosingBraceToken(token) {
	return token.value === "}" && token.type === "Punctuator";
}
function isCommentToken(token) {
	return token.type === "Line" || token.type === "Block" || token.type === "Shebang";
}
function isKeywordToken(token) {
	return token.type === "Keyword";
}
function getOpeningParenOfParams(node, sourceCode) {
	return node.id ? sourceCode.getTokenAfter(node.id, isOpeningParenToken) : sourceCode.getFirstToken(node, isOpeningParenToken);
}
function createGlobalLinebreakMatcher() {
	return new RegExp(LINEBREAK_MATCHER.source, "g");
}
function equalTokens(left, right, sourceCode) {
	var tokensL = sourceCode.getTokens(left);
	var tokensR = sourceCode.getTokens(right);

	if (tokensL.length !== tokensR.length) {
		return false;
	}
	for (var i = 0; i < tokensL.length; ++i) {
		if (tokensL[i].type !== tokensR[i].type || tokensL[i].value !== tokensR[i].value) {
			return false;
		}
	}

	return true;
}
module.exports = {
	COMMENTS_IGNORE_PATTERN: COMMENTS_IGNORE_PATTERN,
	LINEBREAKS: LINEBREAKS,
	LINEBREAK_MATCHER: LINEBREAK_MATCHER,
	SHEBANG_MATCHER: SHEBANG_MATCHER,
	STATEMENT_LIST_PARENTS: STATEMENT_LIST_PARENTS,
	isTokenOnSameLine: function isTokenOnSameLine(left, right) {
		return left.loc.end.line === right.loc.start.line;
	},


	isNullOrUndefined: isNullOrUndefined,
	isCallee: isCallee,
	isES5Constructor: isES5Constructor,
	getUpperFunction: getUpperFunction,
	isFunction: isFunction,
	isLoop: isLoop,
	isInLoop: isInLoop,
	isArrayFromMethod: isArrayFromMethod,
	isParenthesised: isParenthesised,
	createGlobalLinebreakMatcher: createGlobalLinebreakMatcher,
	equalTokens: equalTokens,

	isArrowToken: isArrowToken,
	isClosingBraceToken: isClosingBraceToken,
	isClosingBracketToken: isClosingBracketToken,
	isClosingParenToken: isClosingParenToken,
	isColonToken: isColonToken,
	isCommaToken: isCommaToken,
	isCommentToken: isCommentToken,
	isKeywordToken: isKeywordToken,
	isNotClosingBraceToken: negate(isClosingBraceToken),
	isNotClosingBracketToken: negate(isClosingBracketToken),
	isNotClosingParenToken: negate(isClosingParenToken),
	isNotColonToken: negate(isColonToken),
	isNotCommaToken: negate(isCommaToken),
	isNotOpeningBraceToken: negate(isOpeningBraceToken),
	isNotOpeningBracketToken: negate(isOpeningBracketToken),
	isNotOpeningParenToken: negate(isOpeningParenToken),
	isNotSemicolonToken: negate(isSemicolonToken),
	isOpeningBraceToken: isOpeningBraceToken,
	isOpeningBracketToken: isOpeningBracketToken,
	isOpeningParenToken: isOpeningParenToken,
	isSemicolonToken: isSemicolonToken,
	isStringLiteral: function isStringLiteral(node) {
		return node.type === "Literal" && typeof node.value === "string" || node.type === "TemplateLiteral";
	},
	isBreakableStatement: function isBreakableStatement(node) {
		return breakableTypePattern.test(node.type);
	},
	getLabel: function getLabel(node) {
		if (node.parent.type === "LabeledStatement") {
			return node.parent.label.name;
		}
		return null;
	},
	getModifyingReferences: function getModifyingReferences(references) {
		return references.filter(isModifyingReference);
	},
	isSurroundedBy: function isSurroundedBy(val, character) {
		return val[0] === character && val[val.length - 1] === character;
	},
	isDirectiveComment: function isDirectiveComment(node) {
		var comment = node.value.trim();

		return node.type === "Line" && comment.indexOf("eslint-") === 0 || node.type === "Block" && (comment.indexOf("global ") === 0 || comment.indexOf("eslint ") === 0 || comment.indexOf("eslint-") === 0);
	},
	getTrailingStatement: esutils.ast.trailingStatement,
	getVariableByName: function getVariableByName(initScope, name) {
		var scope = initScope;

		while (scope) {
			var variable = scope.set.get(name);

			if (variable) {
				return variable;
			}

			scope = scope.upper;
		}

		return null;
	},
	isDefaultThisBinding: function isDefaultThisBinding(node, sourceCode) {
		if (isES5Constructor(node) || hasJSDocThisTag(node, sourceCode)) {
			return false;
		}
		var isAnonymous = node.id === null;

		while (node) {
			var parent = node.parent;

			switch (parent.type) {
				case "LogicalExpression":
				case "ConditionalExpression":
					node = parent;
					break;
				case "ReturnStatement":
					{
						var func = getUpperFunction(parent);

						if (func === null || !isCallee(func)) {
							return true;
						}
						node = func.parent;
						break;
					}
				case "ArrowFunctionExpression":
					if (node !== parent.body || !isCallee(parent)) {
						return true;
					}
					node = parent.parent;
					break;
				case "Property":
				case "MethodDefinition":
					return parent.value !== node;
				case "AssignmentExpression":
				case "AssignmentPattern":
					if (parent.left.type === "MemberExpression") {
						return false;
					}
					if (isAnonymous && parent.left.type === "Identifier" && startsWithUpperCase(parent.left.name)) {
						return false;
					}
					return true;
				case "VariableDeclarator":
					return !(isAnonymous && parent.init === node && parent.id.type === "Identifier" && startsWithUpperCase(parent.id.name));
				case "MemberExpression":
					return parent.object !== node || parent.property.type !== "Identifier" || !bindOrCallOrApplyPattern.test(parent.property.name) || !isCallee(parent) || parent.parent.arguments.length === 0 || isNullOrUndefined(parent.parent.arguments[0]);
				case "CallExpression":
					if (isReflectApply(parent.callee)) {
						return parent.arguments.length !== 3 || parent.arguments[0] !== node || isNullOrUndefined(parent.arguments[1]);
					}
					if (isArrayFromMethod(parent.callee)) {
						return parent.arguments.length !== 3 || parent.arguments[1] !== node || isNullOrUndefined(parent.arguments[2]);
					}
					if (isMethodWhichHasThisArg(parent.callee)) {
						return parent.arguments.length !== 2 || parent.arguments[0] !== node || isNullOrUndefined(parent.arguments[1]);
					}
					return true;
				default:
					return true;
			}
		}
		return true;
	},
	getPrecedence: function getPrecedence(node) {
		switch (node.type) {
			case "SequenceExpression":
				return 0;

			case "AssignmentExpression":
			case "ArrowFunctionExpression":
			case "YieldExpression":
				return 1;

			case "ConditionalExpression":
				return 3;

			case "LogicalExpression":
				switch (node.operator) {
					case "||":
						return 4;
					case "&&":
						return 5;
				}

			case "BinaryExpression":

				switch (node.operator) {
					case "|":
						return 6;
					case "^":
						return 7;
					case "&":
						return 8;
					case "==":
					case "!=":
					case "===":
					case "!==":
						return 9;
					case "<":
					case "<=":
					case ">":
					case ">=":
					case "in":
					case "instanceof":
						return 10;
					case "<<":
					case ">>":
					case ">>>":
						return 11;
					case "+":
					case "-":
						return 12;
					case "*":
					case "/":
					case "%":
						return 13;
					case "**":
						return 15;
				}

			case "UnaryExpression":
			case "AwaitExpression":
				return 16;

			case "UpdateExpression":
				return 17;

			case "CallExpression":
				return 18;

			case "NewExpression":
				return 19;

			default:
				return 20;
		}
	},
	isEmptyBlock: function isEmptyBlock(node) {
		return Boolean(node && node.type === "BlockStatement" && node.body.length === 0);
	},
	isEmptyFunction: function isEmptyFunction(node) {
		return isFunction(node) && module.exports.isEmptyBlock(node.body);
	},
	getStaticPropertyName: function getStaticPropertyName(node) {
		var prop = void 0;

		switch (node && node.type) {
			case "Property":
			case "MethodDefinition":
				prop = node.key;
				break;

			case "MemberExpression":
				prop = node.property;
				break;
		}

		switch (prop && prop.type) {
			case "Literal":
				return String(prop.value);

			case "TemplateLiteral":
				if (prop.expressions.length === 0 && prop.quasis.length === 1) {
					return prop.quasis[0].value.cooked;
				}
				break;

			case "Identifier":
				if (!node.computed) {
					return prop.name;
				}
				break;
		}

		return null;
	},
	getDirectivePrologue: function getDirectivePrologue(node) {
		var directives = [];
		if (node.type === "Program" || node.type === "FunctionDeclaration" || node.type === "FunctionExpression" ||
		node.type === "ArrowFunctionExpression" && node.body.type === "BlockStatement") {
			var statements = node.type === "Program" ? node.body : node.body.body;

			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = statements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var statement = _step.value;

					if (statement.type === "ExpressionStatement" && statement.expression.type === "Literal") {
						directives.push(statement);
					} else {
						break;
					}
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}
		}

		return directives;
	},
	isDecimalInteger: function isDecimalInteger(node) {
		return node.type === "Literal" && typeof node.value === "number" && /^(0|[1-9]\d*)$/.test(node.raw);
	},
	getFunctionNameWithKind: function getFunctionNameWithKind(node) {
		var parent = node.parent;
		var tokens = [];

		if (parent.type === "MethodDefinition" && parent.static) {
			tokens.push("static");
		}
		if (node.async) {
			tokens.push("async");
		}
		if (node.generator) {
			tokens.push("generator");
		}

		if (node.type === "ArrowFunctionExpression") {
			tokens.push("arrow", "function");
		} else if (parent.type === "Property" || parent.type === "MethodDefinition") {
			if (parent.kind === "constructor") {
				return "constructor";
			}
			if (parent.kind === "get") {
				tokens.push("getter");
			} else if (parent.kind === "set") {
				tokens.push("setter");
			} else {
				tokens.push("method");
			}
		} else {
			tokens.push("function");
		}

		if (node.id) {
			tokens.push("'" + node.id.name + "'");
		} else {
			var name = module.exports.getStaticPropertyName(parent);

			if (name) {
				tokens.push("'" + name + "'");
			}
		}

		return tokens.join(" ");
	},
	getFunctionHeadLoc: function getFunctionHeadLoc(node, sourceCode) {
		var parent = node.parent;
		var start = null;
		var end = null;

		if (node.type === "ArrowFunctionExpression") {
			var arrowToken = sourceCode.getTokenBefore(node.body, isArrowToken);

			start = arrowToken.loc.start;
			end = arrowToken.loc.end;
		} else if (parent.type === "Property" || parent.type === "MethodDefinition") {
			start = parent.loc.start;
			end = getOpeningParenOfParams(node, sourceCode).loc.start;
		} else {
			start = node.loc.start;
			end = getOpeningParenOfParams(node, sourceCode).loc.start;
		}

		return {
			start: Object.assign({}, start),
			end: Object.assign({}, end)
		};
	},
	getParenthesisedText: function getParenthesisedText(sourceCode, node) {
		var leftToken = sourceCode.getFirstToken(node);
		var rightToken = sourceCode.getLastToken(node);

		while (sourceCode.getTokenBefore(leftToken) && sourceCode.getTokenBefore(leftToken).type === "Punctuator" && sourceCode.getTokenBefore(leftToken).value === "(" && sourceCode.getTokenAfter(rightToken) && sourceCode.getTokenAfter(rightToken).type === "Punctuator" && sourceCode.getTokenAfter(rightToken).value === ")") {
			leftToken = sourceCode.getTokenBefore(leftToken);
			rightToken = sourceCode.getTokenAfter(rightToken);
		}

		return sourceCode.getText().slice(leftToken.range[0], rightToken.range[1]);
	},
	couldBeError: function couldBeError(node) {
		switch (node.type) {
			case "Identifier":
			case "CallExpression":
			case "NewExpression":
			case "MemberExpression":
			case "TaggedTemplateExpression":
			case "YieldExpression":
			case "AwaitExpression":
				return true; // possibly an error object.

			case "AssignmentExpression":
				return module.exports.couldBeError(node.right);

			case "SequenceExpression":
				{
					var exprs = node.expressions;

					return exprs.length !== 0 && module.exports.couldBeError(exprs[exprs.length - 1]);
				}

			case "LogicalExpression":
				return module.exports.couldBeError(node.left) || module.exports.couldBeError(node.right);

			case "ConditionalExpression":
				return module.exports.couldBeError(node.consequent) || module.exports.couldBeError(node.alternate);

			default:
				return false;
		}
	},
	isNullLiteral: function isNullLiteral(node) {
		return node.type === "Literal" && node.value === null && !node.regex;
	},
	canTokensBeAdjacent: function canTokensBeAdjacent(leftValue, rightValue) {
		var leftToken = void 0;

		if (typeof leftValue === "string") {
			var leftTokens = espree.tokenize(leftValue, { ecmaVersion: 2015 });

			leftToken = leftTokens[leftTokens.length - 1];
		} else {
			leftToken = leftValue;
		}

		var rightToken = typeof rightValue === "string" ? espree.tokenize(rightValue, { ecmaVersion: 2015 })[0] : rightValue;

		if (leftToken.type === "Punctuator" || rightToken.type === "Punctuator") {
			if (leftToken.type === "Punctuator" && rightToken.type === "Punctuator") {
				var PLUS_TOKENS = new Set(["+", "++"]);
				var MINUS_TOKENS = new Set(["-", "--"]);

				return !(PLUS_TOKENS.has(leftToken.value) && PLUS_TOKENS.has(rightToken.value) || MINUS_TOKENS.has(leftToken.value) && MINUS_TOKENS.has(rightToken.value));
			}
			return true;
		}

		if (leftToken.type === "String" || rightToken.type === "String" || leftToken.type === "Template" || rightToken.type === "Template") {
			return true;
		}

		if (leftToken.type !== "Numeric" && rightToken.type === "Numeric" && rightToken.value.startsWith(".")) {
			return true;
		}

		return false;
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(4);
var core = __webpack_require__(13);
var hide = __webpack_require__(17);
var redefine = __webpack_require__(15);
var ctx = __webpack_require__(22);
var PROTOTYPE = 'prototype';

var $export = function $export(type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
	own = !IS_FORCED && target && target[key] !== undefined;
	out = (own ? target : source)[key];
	exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	if (target) redefine(target, key, out, type & $export.U);
	if (exports[key] != out) hide(exports, key, exp);
	if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
$export.F = 1; // forced
$export.G = 2; // global
$export.S = 4; // static
$export.P = 8; // proto
$export.B = 16; // bind
$export.W = 32; // wrap
$export.U = 64; // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (exec) {
  try {
	return !!exec();
  } catch (e) {
	return true;
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = function (it) {
  return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) === 'object' ? it !== null : typeof it === 'function';
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self
: Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(3);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var store = __webpack_require__(74)('wks');
var uid = __webpack_require__(36);
var _Symbol = __webpack_require__(4).Symbol;
var USE_SYMBOL = typeof _Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : uid)('Symbol.' + name));
};

$exports.store = store;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(658);

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
var util = __webpack_require__(108);
var doctrine = __webpack_require__(164);
var variableUtil = __webpack_require__(27);
var pragmaUtil = __webpack_require__(71);

var usedPropTypesAreEquivalent = function usedPropTypesAreEquivalent(propA, propB) {
  if (propA.name === propB.name) {
	if (!propA.allNames && !propB.allNames) {
			return true;
	} else if (Array.isArray(propA.allNames) && Array.isArray(propB.allNames) && propA.allNames.join('') === propB.allNames.join('')) {
			return true;
	}
	return false;
  }
  return false;
};

var mergeUsedPropTypes = function mergeUsedPropTypes(propsList, newPropsList) {
  var propsToAdd = [];
  newPropsList.forEach(function (newProp) {
	var newPropisAlreadyInTheList = propsList.some(function (prop) {
			return usedPropTypesAreEquivalent(prop, newProp);
	});
	if (!newPropisAlreadyInTheList) {
			propsToAdd.push(newProp);
	}
  });
  return propsList.concat(propsToAdd);
};
function Components() {
  this._list = {};
  this._getId = function (node) {
	return node && node.range.join(':');
  };
}
Components.prototype.add = function (node, confidence) {
  var id = this._getId(node);
  if (this._list[id]) {
	if (confidence === 0 || this._list[id].confidence === 0) {
			this._list[id].confidence = 0;
	} else {
			this._list[id].confidence = Math.max(this._list[id].confidence, confidence);
	}
	return this._list[id];
  }
  this._list[id] = {
	node: node,
	confidence: confidence
  };
  return this._list[id];
};
Components.prototype.get = function (node) {
  var id = this._getId(node);
  return this._list[id];
};
Components.prototype.set = function (node, props) {
  while (node && !this._list[this._getId(node)]) {
	node = node.parent;
  }
  if (!node) {
	return;
  }
  var id = this._getId(node);
  var copyUsedPropTypes = void 0;
  if (this._list[id]) {
	copyUsedPropTypes = this._list[id].usedPropTypes && this._list[id].usedPropTypes.slice();
  }
  this._list[id] = util._extend(this._list[id], props);
  if (this._list[id] && props.usedPropTypes) {
	this._list[id].usedPropTypes = mergeUsedPropTypes(copyUsedPropTypes || [], props.usedPropTypes);
  }
};
Components.prototype.list = function () {
  var list = {};
  var usedPropTypes = {};
  for (var i in this._list) {
	if (!has(this._list, i) || this._list[i].confidence >= 2) {
			continue;
	}
	var component = null;
	var node = null;
	node = this._list[i].node;
	while (!component && node.parent) {
			node = node.parent;
			if (node.type === 'Decorator') {
		break;
			}
			component = this.get(node);
	}
	if (component) {
			var newUsedProps = (this._list[i].usedPropTypes || []).filter(function (propType) {
		return !propType.node || propType.node.kind !== 'init';
			});

			var componentId = this._getId(component.node);
			usedPropTypes[componentId] = (usedPropTypes[componentId] || []).concat(newUsedProps);
	}
  }
  for (var j in this._list) {
	if (!has(this._list, j) || this._list[j].confidence < 2) {
			continue;
	}
	var id = this._getId(this._list[j].node);
	list[j] = this._list[j];
	if (usedPropTypes[id]) {
			list[j].usedPropTypes = (list[j].usedPropTypes || []).concat(usedPropTypes[id]);
	}
  }
  return list;
};
Components.prototype.length = function () {
  var length = 0;
  for (var i in this._list) {
	if (!has(this._list, i) || this._list[i].confidence < 2) {
			continue;
	}
	length++;
  }
  return length;
};

function componentRule(rule, context) {
  var createClass = pragmaUtil.getCreateClassFromContext(context);
  var pragma = pragmaUtil.getFromContext(context);
  var sourceCode = context.getSourceCode();
  var components = new Components();
  var utils = {
	isES5Component: function isES5Component(node) {
			if (!node.parent) {
		return false;
			}
			return new RegExp('^(' + pragma + '\\.)?' + createClass + '$').test(sourceCode.getText(node.parent.callee));
	},
	isES6Component: function isES6Component(node) {
			if (utils.isExplicitComponent(node)) {
		return true;
			}

			if (!node.superClass) {
		return false;
			}
			return new RegExp('^(' + pragma + '\\.)?(Pure)?Component$').test(sourceCode.getText(node.superClass));
	},
	isExplicitComponent: function isExplicitComponent(node) {
			var comment = void 0;
			try {
		comment = sourceCode.getJSDocComment(node);
			} catch (e) {
		comment = null;
			}

			if (comment === null) {
		return false;
			}

			var commentAst = doctrine.parse(comment.value, {
		unwrap: true,
		tags: ['extends', 'augments']
			});

			var relevantTags = commentAst.tags.filter(function (tag) {
		return tag.name === 'React.Component' || tag.name === 'React.PureComponent';
			});

			return relevantTags.length > 0;
	},
	isPureComponent: function isPureComponent(node) {
			if (node.superClass) {
		return new RegExp('^(' + pragma + '\\.)?PureComponent$').test(sourceCode.getText(node.superClass));
			}
			return false;
	},
	hasDestructuredReactCreateElement: function hasDestructuredReactCreateElement() {
			var variables = variableUtil.variablesInScope(context);
			var variable = variableUtil.getVariable(variables, 'createElement');
			if (variable) {
		var map = variable.scope.set;
		if (map.has('React')) {
					return true;
		}
			}
			return false;
	},
	isReactCreateElement: function isReactCreateElement(node) {
			var calledOnReact = node && node.callee && node.callee.object && node.callee.object.name === 'React' && node.callee.property && node.callee.property.name === 'createElement';

			var calledDirectly = node && node.callee && node.callee.name === 'createElement';

			if (this.hasDestructuredReactCreateElement()) {
		return calledDirectly || calledOnReact;
			}
			return calledOnReact;
	},
	isReturningJSX: function isReturningJSX(ASTnode, strict) {
			var property = void 0;
			var node = ASTnode;
			switch (node.type) {
		case 'ReturnStatement':
					property = 'argument';
					break;
		case 'ArrowFunctionExpression':
					property = 'body';
					break;
		default:
					node = utils.findReturnStatement(node);
					if (!node) {
			return false;
					}
					property = 'argument';
			}

			var returnsConditionalJSXConsequent = node[property] && node[property].type === 'ConditionalExpression' && node[property].consequent.type === 'JSXElement';
			var returnsConditionalJSXAlternate = node[property] && node[property].type === 'ConditionalExpression' && node[property].alternate.type === 'JSXElement';
			var returnsConditionalJSX = strict ? returnsConditionalJSXConsequent && returnsConditionalJSXAlternate : returnsConditionalJSXConsequent || returnsConditionalJSXAlternate;

			var returnsJSX = node[property] && node[property].type === 'JSXElement';
			var returnsReactCreateElement = this.isReactCreateElement(node[property]);

			return Boolean(returnsConditionalJSX || returnsJSX || returnsReactCreateElement);
	},
	findReturnStatement: function findReturnStatement(node) {
			if ((!node.value || !node.value.body || !node.value.body.body) && (!node.body || !node.body.body)) {
		return false;
			}

			var bodyNodes = node.value ? node.value.body.body : node.body.body;

			var i = bodyNodes.length - 1;
			for (; i >= 0; i--) {
		if (bodyNodes[i].type === 'ReturnStatement') {
					return bodyNodes[i];
		}
			}
			return false;
	},
	getParentComponent: function getParentComponent() {
			return utils.getParentES6Component() || utils.getParentES5Component() || utils.getParentStatelessComponent();
	},
	getParentES5Component: function getParentES5Component() {
			var scope = context.getScope();
			while (scope) {
		var node = scope.block && scope.block.parent && scope.block.parent.parent;
		if (node && utils.isES5Component(node)) {
					return node;
		}
		scope = scope.upper;
			}
			return null;
	},
	getParentES6Component: function getParentES6Component() {
			var scope = context.getScope();
			while (scope && scope.type !== 'class') {
		scope = scope.upper;
			}
			var node = scope && scope.block;
			if (!node || !utils.isES6Component(node)) {
		return null;
			}
			return node;
	},
	getParentStatelessComponent: function getParentStatelessComponent() {
			var scope = context.getScope();
			while (scope) {
		var node = scope.block;
		var isClass = node.type === 'ClassExpression';
		var isFunction = /Function/.test(node.type); // Functions
		var isMethod = node.parent && node.parent.type === 'MethodDefinition'; // Classes methods
		var isArgument = node.parent && node.parent.type === 'CallExpression'; // Arguments (callback, etc.)
		var isJSXExpressionContainer = node.parent && node.parent.type === 'JSXExpressionContainer';
		if (isClass || isArgument) {
					return null;
		}
		if (isFunction && !isMethod && !isJSXExpressionContainer) {
					return node;
		}
		scope = scope.upper;
			}
			return null;
	},
	getRelatedComponent: function getRelatedComponent(node) {
			var i = void 0;
			var j = void 0;
			var k = void 0;
			var l = void 0;
			var componentNode = void 0;
			var componentPath = [];
			while (node) {
		if (node.property && node.property.type === 'Identifier') {
					componentPath.push(node.property.name);
		}
		if (node.object && node.object.type === 'Identifier') {
					componentPath.push(node.object.name);
		}
		node = node.object;
			}
			componentPath.reverse();
			var componentName = componentPath.slice(0, componentPath.length - 1).join('.');
			var variableName = componentPath.shift();
			if (!variableName) {
		return null;
			}
			var variableInScope = void 0;
			var variables = variableUtil.variablesInScope(context);
			for (i = 0, j = variables.length; i < j; i++) {
		if (variables[i].name === variableName) {
					variableInScope = variables[i];
					break;
		}
			}
			if (!variableInScope) {
		return null;
			}
			var refs = variableInScope.references;
			var refId = void 0;
			for (i = 0, j = refs.length; i < j; i++) {
		refId = refs[i].identifier;
		if (refId.parent && refId.parent.type === 'MemberExpression') {
					refId = refId.parent;
		}
		if (sourceCode.getText(refId) !== componentName) {
					continue;
		}
		if (refId.type === 'MemberExpression') {
					componentNode = refId.parent.right;
		} else if (refId.parent && refId.parent.type === 'VariableDeclarator') {
					componentNode = refId.parent.init;
		}
		break;
			}

			if (componentNode) {
		return components.add(componentNode, 1);
			}
			var defInScope = void 0;
			var defs = variableInScope.defs;
			for (i = 0, j = defs.length; i < j; i++) {
		if (defs[i].type === 'ClassName' || defs[i].type === 'FunctionName' || defs[i].type === 'Variable') {
					defInScope = defs[i];
					break;
		}
			}
			if (!defInScope || !defInScope.node) {
		return null;
			}
			componentNode = defInScope.node.init || defInScope.node;
			for (i = 0, j = componentPath.length; i < j; i++) {
		if (!componentNode.properties) {
					continue;
		}
		for (k = 0, l = componentNode.properties.length; k < l; k++) {
					if (componentNode.properties[k].key && componentNode.properties[k].key.name === componentPath[i]) {
			componentNode = componentNode.properties[k];
			break;
					}
		}
		if (!componentNode || !componentNode.value) {
					return null;
		}
		componentNode = componentNode.value;
			}
			return components.add(componentNode, 1);
	}
  };
  var detectionInstructions = {
	ClassExpression: function ClassExpression(node) {
			if (!utils.isES6Component(node)) {
		return;
			}
			components.add(node, 2);
	},

	ClassDeclaration: function ClassDeclaration(node) {
			if (!utils.isES6Component(node)) {
		return;
			}
			components.add(node, 2);
	},

	ClassProperty: function ClassProperty(node) {
			node = utils.getParentComponent();
			if (!node) {
		return;
			}
			components.add(node, 2);
	},

	ObjectExpression: function ObjectExpression(node) {
			if (!utils.isES5Component(node)) {
		return;
			}
			components.add(node, 2);
	},

	FunctionExpression: function FunctionExpression(node) {
			if (node.async) {
		components.add(node, 0);
		return;
			}
			var component = utils.getParentComponent();
			if (!component || component.parent && component.parent.type === 'JSXExpressionContainer') {
		components.add(node, 0);
		return;
			}
			components.add(component, 1);
	},

	FunctionDeclaration: function FunctionDeclaration(node) {
			if (node.async) {
		components.add(node, 0);
		return;
			}
			node = utils.getParentComponent();
			if (!node) {
		return;
			}
			components.add(node, 1);
	},

	ArrowFunctionExpression: function ArrowFunctionExpression(node) {
			if (node.async) {
		components.add(node, 0);
		return;
			}
			var component = utils.getParentComponent();
			if (!component || component.parent && component.parent.type === 'JSXExpressionContainer') {
		components.add(node, 0);
		return;
			}
			if (component.expression && utils.isReturningJSX(component)) {
		components.add(component, 2);
			} else {
		components.add(component, 1);
			}
	},

	ThisExpression: function ThisExpression(node) {
			var component = utils.getParentComponent();
			if (!component || !/Function/.test(component.type) || !node.parent.property) {
		return;
			}
			components.add(node, 0);
	},

	ReturnStatement: function ReturnStatement(node) {
			if (!utils.isReturningJSX(node)) {
		return;
			}
			node = utils.getParentComponent();
			if (!node) {
		var scope = context.getScope();
		components.add(scope.block, 1);
		return;
			}
			components.add(node, 2);
	}
  };
  var ruleInstructions = rule(context, components, utils);
  var updatedRuleInstructions = util._extend({}, ruleInstructions);
  Object.keys(detectionInstructions).forEach(function (instruction) {
	updatedRuleInstructions[instruction] = function (node) {
			detectionInstructions[instruction](node);
			return ruleInstructions[instruction] ? ruleInstructions[instruction](node) : void 0;
	};
  });
  return updatedRuleInstructions;
}

Components.detect = function (rule) {
  return componentRule.bind(this, rule);
};

module.exports = Components;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(5);
var IE8_DOM_DEFINE = __webpack_require__(116);
var toPrimitive = __webpack_require__(32);
var dP = Object.defineProperty;

exports.f = __webpack_require__(11) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
	return dP(O, P, Attributes);
  } catch (e) {/* empty */}
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function(global, module) {var __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
;(function () {
  var undefined;
  var VERSION = '4.17.4';
  var LARGE_ARRAY_SIZE = 200;
  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
			FUNC_ERROR_TEXT = 'Expected a function';
  var HASH_UNDEFINED = '__lodash_hash_undefined__';
  var MAX_MEMOIZE_SIZE = 500;
  var PLACEHOLDER = '__lodash_placeholder__';
  var CLONE_DEEP_FLAG = 1,
			CLONE_FLAT_FLAG = 2,
			CLONE_SYMBOLS_FLAG = 4;
  var COMPARE_PARTIAL_FLAG = 1,
			COMPARE_UNORDERED_FLAG = 2;
  var WRAP_BIND_FLAG = 1,
			WRAP_BIND_KEY_FLAG = 2,
			WRAP_CURRY_BOUND_FLAG = 4,
			WRAP_CURRY_FLAG = 8,
			WRAP_CURRY_RIGHT_FLAG = 16,
			WRAP_PARTIAL_FLAG = 32,
			WRAP_PARTIAL_RIGHT_FLAG = 64,
			WRAP_ARY_FLAG = 128,
			WRAP_REARG_FLAG = 256,
			WRAP_FLIP_FLAG = 512;
  var DEFAULT_TRUNC_LENGTH = 30,
			DEFAULT_TRUNC_OMISSION = '...';
  var HOT_COUNT = 800,
			HOT_SPAN = 16;
  var LAZY_FILTER_FLAG = 1,
			LAZY_MAP_FLAG = 2,
			LAZY_WHILE_FLAG = 3;
  var INFINITY = 1 / 0,
			MAX_SAFE_INTEGER = 9007199254740991,
			MAX_INTEGER = 1.7976931348623157e+308,
			NAN = 0 / 0;
  var MAX_ARRAY_LENGTH = 4294967295,
			MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
			HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
  var wrapFlags = [['ary', WRAP_ARY_FLAG], ['bind', WRAP_BIND_FLAG], ['bindKey', WRAP_BIND_KEY_FLAG], ['curry', WRAP_CURRY_FLAG], ['curryRight', WRAP_CURRY_RIGHT_FLAG], ['flip', WRAP_FLIP_FLAG], ['partial', WRAP_PARTIAL_FLAG], ['partialRight', WRAP_PARTIAL_RIGHT_FLAG], ['rearg', WRAP_REARG_FLAG]];
  var argsTag = '[object Arguments]',
			arrayTag = '[object Array]',
			asyncTag = '[object AsyncFunction]',
			boolTag = '[object Boolean]',
			dateTag = '[object Date]',
			domExcTag = '[object DOMException]',
			errorTag = '[object Error]',
			funcTag = '[object Function]',
			genTag = '[object GeneratorFunction]',
			mapTag = '[object Map]',
			numberTag = '[object Number]',
			nullTag = '[object Null]',
			objectTag = '[object Object]',
			promiseTag = '[object Promise]',
			proxyTag = '[object Proxy]',
			regexpTag = '[object RegExp]',
			setTag = '[object Set]',
			stringTag = '[object String]',
			symbolTag = '[object Symbol]',
			undefinedTag = '[object Undefined]',
			weakMapTag = '[object WeakMap]',
			weakSetTag = '[object WeakSet]';

  var arrayBufferTag = '[object ArrayBuffer]',
			dataViewTag = '[object DataView]',
			float32Tag = '[object Float32Array]',
			float64Tag = '[object Float64Array]',
			int8Tag = '[object Int8Array]',
			int16Tag = '[object Int16Array]',
			int32Tag = '[object Int32Array]',
			uint8Tag = '[object Uint8Array]',
			uint8ClampedTag = '[object Uint8ClampedArray]',
			uint16Tag = '[object Uint16Array]',
			uint32Tag = '[object Uint32Array]';
  var reEmptyStringLeading = /\b__p \+= '';/g,
			reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
			reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
			reUnescapedHtml = /[&<>"']/g,
			reHasEscapedHtml = RegExp(reEscapedHtml.source),
			reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
  var reEscape = /<%-([\s\S]+?)%>/g,
			reEvaluate = /<%([\s\S]+?)%>/g,
			reInterpolate = /<%=([\s\S]+?)%>/g;
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
			reIsPlainProp = /^\w*$/,
			reLeadingDot = /^\./,
			rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
			reHasRegExpChar = RegExp(reRegExpChar.source);
  var reTrim = /^\s+|\s+$/g,
			reTrimStart = /^\s+/,
			reTrimEnd = /\s+$/;
  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
			reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
			reSplitDetails = /,? & /;
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
  var reEscapeChar = /\\(\\)?/g;
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
  var reFlags = /\w*$/;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsOctal = /^0o[0-7]+$/i;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
  var reNoMatch = /($^)/;
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
  var rsAstralRange = '\\ud800-\\udfff',
			rsComboMarksRange = '\\u0300-\\u036f',
			reComboHalfMarksRange = '\\ufe20-\\ufe2f',
			rsComboSymbolsRange = '\\u20d0-\\u20ff',
			rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
			rsDingbatRange = '\\u2700-\\u27bf',
			rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
			rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
			rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
			rsPunctuationRange = '\\u2000-\\u206f',
			rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
			rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
			rsVarRange = '\\ufe0e\\ufe0f',
			rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
  var rsApos = '[\'\u2019]',
			rsAstral = '[' + rsAstralRange + ']',
			rsBreak = '[' + rsBreakRange + ']',
			rsCombo = '[' + rsComboRange + ']',
			rsDigits = '\\d+',
			rsDingbat = '[' + rsDingbatRange + ']',
			rsLower = '[' + rsLowerRange + ']',
			rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
			rsFitz = '\\ud83c[\\udffb-\\udfff]',
			rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
			rsNonAstral = '[^' + rsAstralRange + ']',
			rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
			rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
			rsUpper = '[' + rsUpperRange + ']',
			rsZWJ = '\\u200d';
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
			rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
			rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
			rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
			reOptMod = rsModifier + '?',
			rsOptVar = '[' + rsVarRange + ']?',
			rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
			rsOrdLower = '\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)',
			rsOrdUpper = '\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)',
			rsSeq = rsOptVar + reOptMod + rsOptJoin,
			rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
			rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
  var reApos = RegExp(rsApos, 'g');
  var reComboMark = RegExp(rsCombo, 'g');
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
  var reUnicodeWord = RegExp([rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')', rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')', rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower, rsUpper + '+' + rsOptContrUpper, rsOrdUpper, rsOrdLower, rsDigits, rsEmoji].join('|'), 'g');
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
  var contextProps = ['Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array', 'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object', 'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap', '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'];
  var templateCounter = -1;
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  var deburredLetters = {
	'\xc0': 'A', '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
	'\xe0': 'a', '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
	'\xc7': 'C', '\xe7': 'c',
	'\xd0': 'D', '\xf0': 'd',
	'\xc8': 'E', '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
	'\xe8': 'e', '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
	'\xcc': 'I', '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
	'\xec': 'i', '\xed': 'i', '\xee': 'i', '\xef': 'i',
	'\xd1': 'N', '\xf1': 'n',
	'\xd2': 'O', '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
	'\xf2': 'o', '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
	'\xd9': 'U', '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
	'\xf9': 'u', '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
	'\xdd': 'Y', '\xfd': 'y', '\xff': 'y',
	'\xc6': 'Ae', '\xe6': 'ae',
	'\xde': 'Th', '\xfe': 'th',
	'\xdf': 'ss',
	'\u0100': 'A', '\u0102': 'A', '\u0104': 'A',
	'\u0101': 'a', '\u0103': 'a', '\u0105': 'a',
	'\u0106': 'C', '\u0108': 'C', '\u010A': 'C', '\u010C': 'C',
	'\u0107': 'c', '\u0109': 'c', '\u010B': 'c', '\u010D': 'c',
	'\u010E': 'D', '\u0110': 'D', '\u010F': 'd', '\u0111': 'd',
	'\u0112': 'E', '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011A': 'E',
	'\u0113': 'e', '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011B': 'e',
	'\u011C': 'G', '\u011E': 'G', '\u0120': 'G', '\u0122': 'G',
	'\u011D': 'g', '\u011F': 'g', '\u0121': 'g', '\u0123': 'g',
	'\u0124': 'H', '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
	'\u0128': 'I', '\u012A': 'I', '\u012C': 'I', '\u012E': 'I', '\u0130': 'I',
	'\u0129': 'i', '\u012B': 'i', '\u012D': 'i', '\u012F': 'i', '\u0131': 'i',
	'\u0134': 'J', '\u0135': 'j',
	'\u0136': 'K', '\u0137': 'k', '\u0138': 'k',
	'\u0139': 'L', '\u013B': 'L', '\u013D': 'L', '\u013F': 'L', '\u0141': 'L',
	'\u013A': 'l', '\u013C': 'l', '\u013E': 'l', '\u0140': 'l', '\u0142': 'l',
	'\u0143': 'N', '\u0145': 'N', '\u0147': 'N', '\u014A': 'N',
	'\u0144': 'n', '\u0146': 'n', '\u0148': 'n', '\u014B': 'n',
	'\u014C': 'O', '\u014E': 'O', '\u0150': 'O',
	'\u014D': 'o', '\u014F': 'o', '\u0151': 'o',
	'\u0154': 'R', '\u0156': 'R', '\u0158': 'R',
	'\u0155': 'r', '\u0157': 'r', '\u0159': 'r',
	'\u015A': 'S', '\u015C': 'S', '\u015E': 'S', '\u0160': 'S',
	'\u015B': 's', '\u015D': 's', '\u015F': 's', '\u0161': 's',
	'\u0162': 'T', '\u0164': 'T', '\u0166': 'T',
	'\u0163': 't', '\u0165': 't', '\u0167': 't',
	'\u0168': 'U', '\u016A': 'U', '\u016C': 'U', '\u016E': 'U', '\u0170': 'U', '\u0172': 'U',
	'\u0169': 'u', '\u016B': 'u', '\u016D': 'u', '\u016F': 'u', '\u0171': 'u', '\u0173': 'u',
	'\u0174': 'W', '\u0175': 'w',
	'\u0176': 'Y', '\u0177': 'y', '\u0178': 'Y',
	'\u0179': 'Z', '\u017B': 'Z', '\u017D': 'Z',
	'\u017A': 'z', '\u017C': 'z', '\u017E': 'z',
	'\u0132': 'IJ', '\u0133': 'ij',
	'\u0152': 'Oe', '\u0153': 'oe',
	'\u0149': "'n", '\u017F': 's'
  };
  var htmlEscapes = {
	'&': '&amp;',
	'<': '&lt;',
	'>': '&gt;',
	'"': '&quot;',
	"'": '&#39;'
  };
  var htmlUnescapes = {
	'&amp;': '&',
	'&lt;': '<',
	'&gt;': '>',
	'&quot;': '"',
	'&#39;': "'"
  };
  var stringEscapes = {
	'\\': '\\',
	"'": "'",
	'\n': 'n',
	'\r': 'r',
	'\u2028': 'u2028',
	'\u2029': 'u2029'
  };
  var freeParseFloat = parseFloat,
			freeParseInt = parseInt;
  var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global && global.Object === Object && global;
  var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function('return this')();
  var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
  var freeModule = freeExports && ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal.process;
  var nodeUtil = function () {
	try {
			return freeProcess && freeProcess.binding && freeProcess.binding('util');
	} catch (e) {}
  }();
  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
			nodeIsDate = nodeUtil && nodeUtil.isDate,
			nodeIsMap = nodeUtil && nodeUtil.isMap,
			nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
			nodeIsSet = nodeUtil && nodeUtil.isSet,
			nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  function addMapEntry(map, pair) {
	map.set(pair[0], pair[1]);
	return map;
  }
  function addSetEntry(set, value) {
	set.add(value);
	return set;
  }
  function apply(func, thisArg, args) {
	switch (args.length) {
			case 0:
		return func.call(thisArg);
			case 1:
		return func.call(thisArg, args[0]);
			case 2:
		return func.call(thisArg, args[0], args[1]);
			case 3:
		return func.call(thisArg, args[0], args[1], args[2]);
	}
	return func.apply(thisArg, args);
  }
  function arrayAggregator(array, setter, iteratee, accumulator) {
	var index = -1,
		length = array == null ? 0 : array.length;

	while (++index < length) {
			var value = array[index];
			setter(accumulator, value, iteratee(value), array);
	}
	return accumulator;
  }
  function arrayEach(array, iteratee) {
	var index = -1,
		length = array == null ? 0 : array.length;

	while (++index < length) {
			if (iteratee(array[index], index, array) === false) {
		break;
			}
	}
	return array;
  }
  function arrayEachRight(array, iteratee) {
	var length = array == null ? 0 : array.length;

	while (length--) {
			if (iteratee(array[length], length, array) === false) {
		break;
			}
	}
	return array;
  }
  function arrayEvery(array, predicate) {
	var index = -1,
		length = array == null ? 0 : array.length;

	while (++index < length) {
			if (!predicate(array[index], index, array)) {
		return false;
			}
	}
	return true;
  }
  function arrayFilter(array, predicate) {
	var index = -1,
		length = array == null ? 0 : array.length,
		resIndex = 0,
		result = [];

	while (++index < length) {
			var value = array[index];
			if (predicate(value, index, array)) {
		result[resIndex++] = value;
			}
	}
	return result;
  }
  function arrayIncludes(array, value) {
	var length = array == null ? 0 : array.length;
	return !!length && baseIndexOf(array, value, 0) > -1;
  }
  function arrayIncludesWith(array, value, comparator) {
	var index = -1,
		length = array == null ? 0 : array.length;

	while (++index < length) {
			if (comparator(value, array[index])) {
		return true;
			}
	}
	return false;
  }
  function arrayMap(array, iteratee) {
	var index = -1,
		length = array == null ? 0 : array.length,
		result = Array(length);

	while (++index < length) {
			result[index] = iteratee(array[index], index, array);
	}
	return result;
  }
  function arrayPush(array, values) {
	var index = -1,
		length = values.length,
		offset = array.length;

	while (++index < length) {
			array[offset + index] = values[index];
	}
	return array;
  }
  function arrayReduce(array, iteratee, accumulator, initAccum) {
	var index = -1,
		length = array == null ? 0 : array.length;

	if (initAccum && length) {
			accumulator = array[++index];
	}
	while (++index < length) {
			accumulator = iteratee(accumulator, array[index], index, array);
	}
	return accumulator;
  }
  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
	var length = array == null ? 0 : array.length;
	if (initAccum && length) {
			accumulator = array[--length];
	}
	while (length--) {
			accumulator = iteratee(accumulator, array[length], length, array);
	}
	return accumulator;
  }
  function arraySome(array, predicate) {
	var index = -1,
		length = array == null ? 0 : array.length;

	while (++index < length) {
			if (predicate(array[index], index, array)) {
		return true;
			}
	}
	return false;
  }
  var asciiSize = baseProperty('length');
  function asciiToArray(string) {
	return string.split('');
  }
  function asciiWords(string) {
	return string.match(reAsciiWord) || [];
  }
  function baseFindKey(collection, predicate, eachFunc) {
	var result;
	eachFunc(collection, function (value, key, collection) {
			if (predicate(value, key, collection)) {
		result = key;
		return false;
			}
	});
	return result;
  }
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
	var length = array.length,
		index = fromIndex + (fromRight ? 1 : -1);

	while (fromRight ? index-- : ++index < length) {
			if (predicate(array[index], index, array)) {
		return index;
			}
	}
	return -1;
  }
  function baseIndexOf(array, value, fromIndex) {
	return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
  }
  function baseIndexOfWith(array, value, fromIndex, comparator) {
	var index = fromIndex - 1,
		length = array.length;

	while (++index < length) {
			if (comparator(array[index], value)) {
		return index;
			}
	}
	return -1;
  }
  function baseIsNaN(value) {
	return value !== value;
  }
  function baseMean(array, iteratee) {
	var length = array == null ? 0 : array.length;
	return length ? baseSum(array, iteratee) / length : NAN;
  }
  function baseProperty(key) {
	return function (object) {
			return object == null ? undefined : object[key];
	};
  }
  function basePropertyOf(object) {
	return function (key) {
			return object == null ? undefined : object[key];
	};
  }
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
	eachFunc(collection, function (value, index, collection) {
			accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);
	});
	return accumulator;
  }
  function baseSortBy(array, comparer) {
	var length = array.length;

	array.sort(comparer);
	while (length--) {
			array[length] = array[length].value;
	}
	return array;
  }
  function baseSum(array, iteratee) {
	var result,
		index = -1,
		length = array.length;

	while (++index < length) {
			var current = iteratee(array[index]);
			if (current !== undefined) {
		result = result === undefined ? current : result + current;
			}
	}
	return result;
  }
  function baseTimes(n, iteratee) {
	var index = -1,
		result = Array(n);

	while (++index < n) {
			result[index] = iteratee(index);
	}
	return result;
  }
  function baseToPairs(object, props) {
	return arrayMap(props, function (key) {
			return [key, object[key]];
	});
  }
  function baseUnary(func) {
	return function (value) {
			return func(value);
	};
  }
  function baseValues(object, props) {
	return arrayMap(props, function (key) {
			return object[key];
	});
  }
  function cacheHas(cache, key) {
	return cache.has(key);
  }
  function charsStartIndex(strSymbols, chrSymbols) {
	var index = -1,
		length = strSymbols.length;

	while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	return index;
  }
  function charsEndIndex(strSymbols, chrSymbols) {
	var index = strSymbols.length;

	while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	return index;
  }
  function countHolders(array, placeholder) {
	var length = array.length,
		result = 0;

	while (length--) {
			if (array[length] === placeholder) {
		++result;
			}
	}
	return result;
  }
  var deburrLetter = basePropertyOf(deburredLetters);
  var escapeHtmlChar = basePropertyOf(htmlEscapes);
  function escapeStringChar(chr) {
	return '\\' + stringEscapes[chr];
  }
  function getValue(object, key) {
	return object == null ? undefined : object[key];
  }
  function hasUnicode(string) {
	return reHasUnicode.test(string);
  }
  function hasUnicodeWord(string) {
	return reHasUnicodeWord.test(string);
  }
  function iteratorToArray(iterator) {
	var data,
		result = [];

	while (!(data = iterator.next()).done) {
			result.push(data.value);
	}
	return result;
  }
  function mapToArray(map) {
	var index = -1,
		result = Array(map.size);

	map.forEach(function (value, key) {
			result[++index] = [key, value];
	});
	return result;
  }
  function overArg(func, transform) {
	return function (arg) {
			return func(transform(arg));
	};
  }
  function replaceHolders(array, placeholder) {
	var index = -1,
		length = array.length,
		resIndex = 0,
		result = [];

	while (++index < length) {
			var value = array[index];
			if (value === placeholder || value === PLACEHOLDER) {
		array[index] = PLACEHOLDER;
		result[resIndex++] = index;
			}
	}
	return result;
  }
  function setToArray(set) {
	var index = -1,
		result = Array(set.size);

	set.forEach(function (value) {
			result[++index] = value;
	});
	return result;
  }
  function setToPairs(set) {
	var index = -1,
		result = Array(set.size);

	set.forEach(function (value) {
			result[++index] = [value, value];
	});
	return result;
  }
  function strictIndexOf(array, value, fromIndex) {
	var index = fromIndex - 1,
		length = array.length;

	while (++index < length) {
			if (array[index] === value) {
		return index;
			}
	}
	return -1;
  }
  function strictLastIndexOf(array, value, fromIndex) {
	var index = fromIndex + 1;
	while (index--) {
			if (array[index] === value) {
		return index;
			}
	}
	return index;
  }
  function stringSize(string) {
	return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
  }
  function stringToArray(string) {
	return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
  }
  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
  function unicodeSize(string) {
	var result = reUnicode.lastIndex = 0;
	while (reUnicode.test(string)) {
			++result;
	}
	return result;
  }
  function unicodeToArray(string) {
	return string.match(reUnicode) || [];
  }
  function unicodeWords(string) {
	return string.match(reUnicodeWord) || [];
  }
  var runInContext = function runInContext(context) {
	context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
	var Array = context.Array,
		Date = context.Date,
		Error = context.Error,
		Function = context.Function,
		Math = context.Math,
		Object = context.Object,
		RegExp = context.RegExp,
		String = context.String,
		TypeError = context.TypeError;
	var arrayProto = Array.prototype,
		funcProto = Function.prototype,
		objectProto = Object.prototype;
	var coreJsData = context['__core-js_shared__'];
	var funcToString = funcProto.toString;
	var hasOwnProperty = objectProto.hasOwnProperty;
	var idCounter = 0;
	var maskSrcKey = function () {
			var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
			return uid ? 'Symbol(src)_1.' + uid : '';
	}();
	var nativeObjectToString = objectProto.toString;
	var objectCtorString = funcToString.call(Object);
	var oldDash = root._;
	var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
	var Buffer = moduleExports ? context.Buffer : undefined,
		_Symbol = context.Symbol,
		Uint8Array = context.Uint8Array,
		allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
		getPrototype = overArg(Object.getPrototypeOf, Object),
		objectCreate = Object.create,
		propertyIsEnumerable = objectProto.propertyIsEnumerable,
		splice = arrayProto.splice,
		spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined,
		symIterator = _Symbol ? _Symbol.iterator : undefined,
		symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

	var defineProperty = function () {
			try {
		var func = getNative(Object, 'defineProperty');
		func({}, '', {});
		return func;
			} catch (e) {}
	}();
	var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
		ctxNow = Date && Date.now !== root.Date.now && Date.now,
		ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
	var nativeCeil = Math.ceil,
		nativeFloor = Math.floor,
		nativeGetSymbols = Object.getOwnPropertySymbols,
		nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
		nativeIsFinite = context.isFinite,
		nativeJoin = arrayProto.join,
		nativeKeys = overArg(Object.keys, Object),
		nativeMax = Math.max,
		nativeMin = Math.min,
		nativeNow = Date.now,
		nativeParseInt = context.parseInt,
		nativeRandom = Math.random,
		nativeReverse = arrayProto.reverse;
	var DataView = getNative(context, 'DataView'),
		Map = getNative(context, 'Map'),
		Promise = getNative(context, 'Promise'),
		Set = getNative(context, 'Set'),
		WeakMap = getNative(context, 'WeakMap'),
		nativeCreate = getNative(Object, 'create');
	var metaMap = WeakMap && new WeakMap();
	var realNames = {};
	var dataViewCtorString = toSource(DataView),
		mapCtorString = toSource(Map),
		promiseCtorString = toSource(Promise),
		setCtorString = toSource(Set),
		weakMapCtorString = toSource(WeakMap);
	var symbolProto = _Symbol ? _Symbol.prototype : undefined,
		symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
		symbolToString = symbolProto ? symbolProto.toString : undefined;
	function lodash(value) {
			if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
		if (value instanceof LodashWrapper) {
					return value;
		}
		if (hasOwnProperty.call(value, '__wrapped__')) {
					return wrapperClone(value);
		}
			}
			return new LodashWrapper(value);
	}
	var baseCreate = function () {
			function object() {}
			return function (proto) {
		if (!isObject(proto)) {
					return {};
		}
		if (objectCreate) {
					return objectCreate(proto);
		}
		object.prototype = proto;
		var result = new object();
		object.prototype = undefined;
		return result;
			};
	}();
	function baseLodash() {}
	function LodashWrapper(value, chainAll) {
			this.__wrapped__ = value;
			this.__actions__ = [];
			this.__chain__ = !!chainAll;
			this.__index__ = 0;
			this.__values__ = undefined;
	}
	lodash.templateSettings = {
			'escape': reEscape,
			'evaluate': reEvaluate,
			'interpolate': reInterpolate,
			'variable': '',
			'imports': {
		'_': lodash
			}
	};
	lodash.prototype = baseLodash.prototype;
	lodash.prototype.constructor = lodash;

	LodashWrapper.prototype = baseCreate(baseLodash.prototype);
	LodashWrapper.prototype.constructor = LodashWrapper;
	function LazyWrapper(value) {
			this.__wrapped__ = value;
			this.__actions__ = [];
			this.__dir__ = 1;
			this.__filtered__ = false;
			this.__iteratees__ = [];
			this.__takeCount__ = MAX_ARRAY_LENGTH;
			this.__views__ = [];
	}
	function lazyClone() {
			var result = new LazyWrapper(this.__wrapped__);
			result.__actions__ = copyArray(this.__actions__);
			result.__dir__ = this.__dir__;
			result.__filtered__ = this.__filtered__;
			result.__iteratees__ = copyArray(this.__iteratees__);
			result.__takeCount__ = this.__takeCount__;
			result.__views__ = copyArray(this.__views__);
			return result;
	}
	function lazyReverse() {
			if (this.__filtered__) {
		var result = new LazyWrapper(this);
		result.__dir__ = -1;
		result.__filtered__ = true;
			} else {
		result = this.clone();
		result.__dir__ *= -1;
			}
			return result;
	}
	function lazyValue() {
			var array = this.__wrapped__.value(),
					dir = this.__dir__,
					isArr = isArray(array),
					isRight = dir < 0,
					arrLength = isArr ? array.length : 0,
					view = getView(0, arrLength, this.__views__),
					start = view.start,
					end = view.end,
					length = end - start,
					index = isRight ? end : start - 1,
					iteratees = this.__iteratees__,
					iterLength = iteratees.length,
					resIndex = 0,
					takeCount = nativeMin(length, this.__takeCount__);

			if (!isArr || !isRight && arrLength == length && takeCount == length) {
		return baseWrapperValue(array, this.__actions__);
			}
			var result = [];

			outer: while (length-- && resIndex < takeCount) {
		index += dir;

		var iterIndex = -1,
			value = array[index];

		while (++iterIndex < iterLength) {
					var data = iteratees[iterIndex],
							iteratee = data.iteratee,
							type = data.type,
							computed = iteratee(value);

					if (type == LAZY_MAP_FLAG) {
			value = computed;
					} else if (!computed) {
			if (type == LAZY_FILTER_FLAG) {
							continue outer;
			} else {
							break outer;
			}
					}
		}
		result[resIndex++] = value;
			}
			return result;
	}
	LazyWrapper.prototype = baseCreate(baseLodash.prototype);
	LazyWrapper.prototype.constructor = LazyWrapper;
	function Hash(entries) {
			var index = -1,
					length = entries == null ? 0 : entries.length;

			this.clear();
			while (++index < length) {
		var entry = entries[index];
		this.set(entry[0], entry[1]);
			}
	}
	function hashClear() {
			this.__data__ = nativeCreate ? nativeCreate(null) : {};
			this.size = 0;
	}
	function hashDelete(key) {
			var result = this.has(key) && delete this.__data__[key];
			this.size -= result ? 1 : 0;
			return result;
	}
	function hashGet(key) {
			var data = this.__data__;
			if (nativeCreate) {
		var result = data[key];
		return result === HASH_UNDEFINED ? undefined : result;
			}
			return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}
	function hashHas(key) {
			var data = this.__data__;
			return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
	}
	function hashSet(key, value) {
			var data = this.__data__;
			this.size += this.has(key) ? 0 : 1;
			data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
			return this;
	}
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;
	function ListCache(entries) {
			var index = -1,
					length = entries == null ? 0 : entries.length;

			this.clear();
			while (++index < length) {
		var entry = entries[index];
		this.set(entry[0], entry[1]);
			}
	}
	function listCacheClear() {
			this.__data__ = [];
			this.size = 0;
	}
	function listCacheDelete(key) {
			var data = this.__data__,
					index = assocIndexOf(data, key);

			if (index < 0) {
		return false;
			}
			var lastIndex = data.length - 1;
			if (index == lastIndex) {
		data.pop();
			} else {
		splice.call(data, index, 1);
			}
			--this.size;
			return true;
	}
	function listCacheGet(key) {
			var data = this.__data__,
					index = assocIndexOf(data, key);

			return index < 0 ? undefined : data[index][1];
	}
	function listCacheHas(key) {
			return assocIndexOf(this.__data__, key) > -1;
	}
	function listCacheSet(key, value) {
			var data = this.__data__,
					index = assocIndexOf(data, key);

			if (index < 0) {
		++this.size;
		data.push([key, value]);
			} else {
		data[index][1] = value;
			}
			return this;
	}
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;
	function MapCache(entries) {
			var index = -1,
					length = entries == null ? 0 : entries.length;

			this.clear();
			while (++index < length) {
		var entry = entries[index];
		this.set(entry[0], entry[1]);
			}
	}
	function mapCacheClear() {
			this.size = 0;
			this.__data__ = {
		'hash': new Hash(),
		'map': new (Map || ListCache)(),
		'string': new Hash()
			};
	}
	function mapCacheDelete(key) {
			var result = getMapData(this, key)['delete'](key);
			this.size -= result ? 1 : 0;
			return result;
	}
	function mapCacheGet(key) {
			return getMapData(this, key).get(key);
	}
	function mapCacheHas(key) {
			return getMapData(this, key).has(key);
	}
	function mapCacheSet(key, value) {
			var data = getMapData(this, key),
					size = data.size;

			data.set(key, value);
			this.size += data.size == size ? 0 : 1;
			return this;
	}
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;
	function SetCache(values) {
			var index = -1,
					length = values == null ? 0 : values.length;

			this.__data__ = new MapCache();
			while (++index < length) {
		this.add(values[index]);
			}
	}
	function setCacheAdd(value) {
			this.__data__.set(value, HASH_UNDEFINED);
			return this;
	}
	function setCacheHas(value) {
			return this.__data__.has(value);
	}
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;
	function Stack(entries) {
			var data = this.__data__ = new ListCache(entries);
			this.size = data.size;
	}
	function stackClear() {
			this.__data__ = new ListCache();
			this.size = 0;
	}
	function stackDelete(key) {
			var data = this.__data__,
					result = data['delete'](key);

			this.size = data.size;
			return result;
	}
	function stackGet(key) {
			return this.__data__.get(key);
	}
	function stackHas(key) {
			return this.__data__.has(key);
	}
	function stackSet(key, value) {
			var data = this.__data__;
			if (data instanceof ListCache) {
		var pairs = data.__data__;
		if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
					pairs.push([key, value]);
					this.size = ++data.size;
					return this;
		}
		data = this.__data__ = new MapCache(pairs);
			}
			data.set(key, value);
			this.size = data.size;
			return this;
	}
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;
	function arrayLikeKeys(value, inherited) {
			var isArr = isArray(value),
					isArg = !isArr && isArguments(value),
					isBuff = !isArr && !isArg && isBuffer(value),
					isType = !isArr && !isArg && !isBuff && isTypedArray(value),
					skipIndexes = isArr || isArg || isBuff || isType,
					result = skipIndexes ? baseTimes(value.length, String) : [],
					length = result.length;

			for (var key in value) {
		if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (
		key == 'length' ||
		isBuff && (key == 'offset' || key == 'parent') ||
		isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
		isIndex(key, length)))) {
					result.push(key);
		}
			}
			return result;
	}
	function arraySample(array) {
			var length = array.length;
			return length ? array[baseRandom(0, length - 1)] : undefined;
	}
	function arraySampleSize(array, n) {
			return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
	}
	function arrayShuffle(array) {
			return shuffleSelf(copyArray(array));
	}
	function assignMergeValue(object, key, value) {
			if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
		baseAssignValue(object, key, value);
			}
	}
	function assignValue(object, key, value) {
			var objValue = object[key];
			if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
		baseAssignValue(object, key, value);
			}
	}
	function assocIndexOf(array, key) {
			var length = array.length;
			while (length--) {
		if (eq(array[length][0], key)) {
					return length;
		}
			}
			return -1;
	}
	function baseAggregator(collection, setter, iteratee, accumulator) {
			baseEach(collection, function (value, key, collection) {
		setter(accumulator, value, iteratee(value), collection);
			});
			return accumulator;
	}
	function baseAssign(object, source) {
			return object && copyObject(source, keys(source), object);
	}
	function baseAssignIn(object, source) {
			return object && copyObject(source, keysIn(source), object);
	}
	function baseAssignValue(object, key, value) {
			if (key == '__proto__' && defineProperty) {
		defineProperty(object, key, {
					'configurable': true,
					'enumerable': true,
					'value': value,
					'writable': true
		});
			} else {
		object[key] = value;
			}
	}
	function baseAt(object, paths) {
			var index = -1,
					length = paths.length,
					result = Array(length),
					skip = object == null;

			while (++index < length) {
		result[index] = skip ? undefined : get(object, paths[index]);
			}
			return result;
	}
	function baseClamp(number, lower, upper) {
			if (number === number) {
		if (upper !== undefined) {
					number = number <= upper ? number : upper;
		}
		if (lower !== undefined) {
					number = number >= lower ? number : lower;
		}
			}
			return number;
	}
	function baseClone(value, bitmask, customizer, key, object, stack) {
			var result,
					isDeep = bitmask & CLONE_DEEP_FLAG,
					isFlat = bitmask & CLONE_FLAT_FLAG,
					isFull = bitmask & CLONE_SYMBOLS_FLAG;

			if (customizer) {
		result = object ? customizer(value, key, object, stack) : customizer(value);
			}
			if (result !== undefined) {
		return result;
			}
			if (!isObject(value)) {
		return value;
			}
			var isArr = isArray(value);
			if (isArr) {
		result = initCloneArray(value);
		if (!isDeep) {
					return copyArray(value, result);
		}
			} else {
		var tag = getTag(value),
			isFunc = tag == funcTag || tag == genTag;

		if (isBuffer(value)) {
					return cloneBuffer(value, isDeep);
		}
		if (tag == objectTag || tag == argsTag || isFunc && !object) {
					result = isFlat || isFunc ? {} : initCloneObject(value);
					if (!isDeep) {
			return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
					}
		} else {
					if (!cloneableTags[tag]) {
			return object ? value : {};
					}
					result = initCloneByTag(value, tag, baseClone, isDeep);
		}
			}
			stack || (stack = new Stack());
			var stacked = stack.get(value);
			if (stacked) {
		return stacked;
			}
			stack.set(value, result);

			var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;

			var props = isArr ? undefined : keysFunc(value);
			arrayEach(props || value, function (subValue, key) {
		if (props) {
					key = subValue;
					subValue = value[key];
		}
		assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
			});
			return result;
	}
	function baseConforms(source) {
			var props = keys(source);
			return function (object) {
		return baseConformsTo(object, source, props);
			};
	}
	function baseConformsTo(object, source, props) {
			var length = props.length;
			if (object == null) {
		return !length;
			}
			object = Object(object);
			while (length--) {
		var key = props[length],
			predicate = source[key],
			value = object[key];

		if (value === undefined && !(key in object) || !predicate(value)) {
					return false;
		}
			}
			return true;
	}
	function baseDelay(func, wait, args) {
			if (typeof func != 'function') {
		throw new TypeError(FUNC_ERROR_TEXT);
			}
			return setTimeout(function () {
		func.apply(undefined, args);
			}, wait);
	}
	function baseDifference(array, values, iteratee, comparator) {
			var index = -1,
					includes = arrayIncludes,
					isCommon = true,
					length = array.length,
					result = [],
					valuesLength = values.length;

			if (!length) {
		return result;
			}
			if (iteratee) {
		values = arrayMap(values, baseUnary(iteratee));
			}
			if (comparator) {
		includes = arrayIncludesWith;
		isCommon = false;
			} else if (values.length >= LARGE_ARRAY_SIZE) {
		includes = cacheHas;
		isCommon = false;
		values = new SetCache(values);
			}
			outer: while (++index < length) {
		var value = array[index],
			computed = iteratee == null ? value : iteratee(value);

		value = comparator || value !== 0 ? value : 0;
		if (isCommon && computed === computed) {
					var valuesIndex = valuesLength;
					while (valuesIndex--) {
			if (values[valuesIndex] === computed) {
							continue outer;
			}
					}
					result.push(value);
		} else if (!includes(values, computed, comparator)) {
					result.push(value);
		}
			}
			return result;
	}
	var baseEach = createBaseEach(baseForOwn);
	var baseEachRight = createBaseEach(baseForOwnRight, true);
	function baseEvery(collection, predicate) {
			var result = true;
			baseEach(collection, function (value, index, collection) {
		result = !!predicate(value, index, collection);
		return result;
			});
			return result;
	}
	function baseExtremum(array, iteratee, comparator) {
			var index = -1,
					length = array.length;

			while (++index < length) {
		var value = array[index],
			current = iteratee(value);

		if (current != null && (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed))) {
					var computed = current,
							result = value;
		}
			}
			return result;
	}
	function baseFill(array, value, start, end) {
			var length = array.length;

			start = toInteger(start);
			if (start < 0) {
		start = -start > length ? 0 : length + start;
			}
			end = end === undefined || end > length ? length : toInteger(end);
			if (end < 0) {
		end += length;
			}
			end = start > end ? 0 : toLength(end);
			while (start < end) {
		array[start++] = value;
			}
			return array;
	}
	function baseFilter(collection, predicate) {
			var result = [];
			baseEach(collection, function (value, index, collection) {
		if (predicate(value, index, collection)) {
					result.push(value);
		}
			});
			return result;
	}
	function baseFlatten(array, depth, predicate, isStrict, result) {
			var index = -1,
					length = array.length;

			predicate || (predicate = isFlattenable);
			result || (result = []);

			while (++index < length) {
		var value = array[index];
		if (depth > 0 && predicate(value)) {
					if (depth > 1) {
			baseFlatten(value, depth - 1, predicate, isStrict, result);
					} else {
			arrayPush(result, value);
					}
		} else if (!isStrict) {
					result[result.length] = value;
		}
			}
			return result;
	}
	var baseFor = createBaseFor();
	var baseForRight = createBaseFor(true);
	function baseForOwn(object, iteratee) {
			return object && baseFor(object, iteratee, keys);
	}
	function baseForOwnRight(object, iteratee) {
			return object && baseForRight(object, iteratee, keys);
	}
	function baseFunctions(object, props) {
			return arrayFilter(props, function (key) {
		return isFunction(object[key]);
			});
	}
	function baseGet(object, path) {
			path = castPath(path, object);

			var index = 0,
					length = path.length;

			while (object != null && index < length) {
		object = object[toKey(path[index++])];
			}
			return index && index == length ? object : undefined;
	}
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
			var result = keysFunc(object);
			return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	}
	function baseGetTag(value) {
			if (value == null) {
		return value === undefined ? undefinedTag : nullTag;
			}
			return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
	}
	function baseGt(value, other) {
			return value > other;
	}
	function baseHas(object, key) {
			return object != null && hasOwnProperty.call(object, key);
	}
	function baseHasIn(object, key) {
			return object != null && key in Object(object);
	}
	function baseInRange(number, start, end) {
			return number >= nativeMin(start, end) && number < nativeMax(start, end);
	}
	function baseIntersection(arrays, iteratee, comparator) {
			var includes = comparator ? arrayIncludesWith : arrayIncludes,
					length = arrays[0].length,
					othLength = arrays.length,
					othIndex = othLength,
					caches = Array(othLength),
					maxLength = Infinity,
					result = [];

			while (othIndex--) {
		var array = arrays[othIndex];
		if (othIndex && iteratee) {
					array = arrayMap(array, baseUnary(iteratee));
		}
		maxLength = nativeMin(array.length, maxLength);
		caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined;
			}
			array = arrays[0];

			var index = -1,
					seen = caches[0];

			outer: while (++index < length && result.length < maxLength) {
		var value = array[index],
			computed = iteratee ? iteratee(value) : value;

		value = comparator || value !== 0 ? value : 0;
		if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
					othIndex = othLength;
					while (--othIndex) {
			var cache = caches[othIndex];
			if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
							continue outer;
			}
					}
					if (seen) {
			seen.push(computed);
					}
					result.push(value);
		}
			}
			return result;
	}
	function baseInverter(object, setter, iteratee, accumulator) {
			baseForOwn(object, function (value, key, object) {
		setter(accumulator, iteratee(value), key, object);
			});
			return accumulator;
	}
	function baseInvoke(object, path, args) {
			path = castPath(path, object);
			object = parent(object, path);
			var func = object == null ? object : object[toKey(last(path))];
			return func == null ? undefined : apply(func, object, args);
	}
	function baseIsArguments(value) {
			return isObjectLike(value) && baseGetTag(value) == argsTag;
	}
	function baseIsArrayBuffer(value) {
			return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
	}
	function baseIsDate(value) {
			return isObjectLike(value) && baseGetTag(value) == dateTag;
	}
	function baseIsEqual(value, other, bitmask, customizer, stack) {
			if (value === other) {
		return true;
			}
			if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
		return value !== value && other !== other;
			}
			return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	}
	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
			var objIsArr = isArray(object),
					othIsArr = isArray(other),
					objTag = objIsArr ? arrayTag : getTag(object),
					othTag = othIsArr ? arrayTag : getTag(other);

			objTag = objTag == argsTag ? objectTag : objTag;
			othTag = othTag == argsTag ? objectTag : othTag;

			var objIsObj = objTag == objectTag,
					othIsObj = othTag == objectTag,
					isSameTag = objTag == othTag;

			if (isSameTag && isBuffer(object)) {
		if (!isBuffer(other)) {
					return false;
		}
		objIsArr = true;
		objIsObj = false;
			}
			if (isSameTag && !objIsObj) {
		stack || (stack = new Stack());
		return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
			}
			if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
		var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
			othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

		if (objIsWrapped || othIsWrapped) {
					var objUnwrapped = objIsWrapped ? object.value() : object,
							othUnwrapped = othIsWrapped ? other.value() : other;

					stack || (stack = new Stack());
					return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
		}
			}
			if (!isSameTag) {
		return false;
			}
			stack || (stack = new Stack());
			return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}
	function baseIsMap(value) {
			return isObjectLike(value) && getTag(value) == mapTag;
	}
	function baseIsMatch(object, source, matchData, customizer) {
			var index = matchData.length,
					length = index,
					noCustomizer = !customizer;

			if (object == null) {
		return !length;
			}
			object = Object(object);
			while (index--) {
		var data = matchData[index];
		if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
					return false;
		}
			}
			while (++index < length) {
		data = matchData[index];
		var key = data[0],
			objValue = object[key],
			srcValue = data[1];

		if (noCustomizer && data[2]) {
					if (objValue === undefined && !(key in object)) {
			return false;
					}
		} else {
					var stack = new Stack();
					if (customizer) {
			var result = customizer(objValue, srcValue, key, object, source, stack);
					}
					if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
			return false;
					}
		}
			}
			return true;
	}
	function baseIsNative(value) {
			if (!isObject(value) || isMasked(value)) {
		return false;
			}
			var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
			return pattern.test(toSource(value));
	}
	function baseIsRegExp(value) {
			return isObjectLike(value) && baseGetTag(value) == regexpTag;
	}
	function baseIsSet(value) {
			return isObjectLike(value) && getTag(value) == setTag;
	}
	function baseIsTypedArray(value) {
			return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}
	function baseIteratee(value) {
			if (typeof value == 'function') {
		return value;
			}
			if (value == null) {
		return identity;
			}
			if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {
		return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
			}
			return property(value);
	}
	function baseKeys(object) {
			if (!isPrototype(object)) {
		return nativeKeys(object);
			}
			var result = [];
			for (var key in Object(object)) {
		if (hasOwnProperty.call(object, key) && key != 'constructor') {
					result.push(key);
		}
			}
			return result;
	}
	function baseKeysIn(object) {
			if (!isObject(object)) {
		return nativeKeysIn(object);
			}
			var isProto = isPrototype(object),
					result = [];

			for (var key in object) {
		if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
					result.push(key);
		}
			}
			return result;
	}
	function baseLt(value, other) {
			return value < other;
	}
	function baseMap(collection, iteratee) {
			var index = -1,
					result = isArrayLike(collection) ? Array(collection.length) : [];

			baseEach(collection, function (value, key, collection) {
		result[++index] = iteratee(value, key, collection);
			});
			return result;
	}
	function baseMatches(source) {
			var matchData = getMatchData(source);
			if (matchData.length == 1 && matchData[0][2]) {
		return matchesStrictComparable(matchData[0][0], matchData[0][1]);
			}
			return function (object) {
		return object === source || baseIsMatch(object, source, matchData);
			};
	}
	function baseMatchesProperty(path, srcValue) {
			if (isKey(path) && isStrictComparable(srcValue)) {
		return matchesStrictComparable(toKey(path), srcValue);
			}
			return function (object) {
		var objValue = get(object, path);
		return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
			};
	}
	function baseMerge(object, source, srcIndex, customizer, stack) {
			if (object === source) {
		return;
			}
			baseFor(source, function (srcValue, key) {
		if (isObject(srcValue)) {
					stack || (stack = new Stack());
					baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
		} else {
					var newValue = customizer ? customizer(object[key], srcValue, key + '', object, source, stack) : undefined;

					if (newValue === undefined) {
			newValue = srcValue;
					}
					assignMergeValue(object, key, newValue);
		}
			}, keysIn);
	}
	function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
			var objValue = object[key],
					srcValue = source[key],
					stacked = stack.get(srcValue);

			if (stacked) {
		assignMergeValue(object, key, stacked);
		return;
			}
			var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;

			var isCommon = newValue === undefined;

			if (isCommon) {
		var isArr = isArray(srcValue),
			isBuff = !isArr && isBuffer(srcValue),
			isTyped = !isArr && !isBuff && isTypedArray(srcValue);

		newValue = srcValue;
		if (isArr || isBuff || isTyped) {
					if (isArray(objValue)) {
			newValue = objValue;
					} else if (isArrayLikeObject(objValue)) {
			newValue = copyArray(objValue);
					} else if (isBuff) {
			isCommon = false;
			newValue = cloneBuffer(srcValue, true);
					} else if (isTyped) {
			isCommon = false;
			newValue = cloneTypedArray(srcValue, true);
					} else {
			newValue = [];
					}
		} else if (isPlainObject(srcValue) || isArguments(srcValue)) {
					newValue = objValue;
					if (isArguments(objValue)) {
			newValue = toPlainObject(objValue);
					} else if (!isObject(objValue) || srcIndex && isFunction(objValue)) {
			newValue = initCloneObject(srcValue);
					}
		} else {
					isCommon = false;
		}
			}
			if (isCommon) {
		stack.set(srcValue, newValue);
		mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
		stack['delete'](srcValue);
			}
			assignMergeValue(object, key, newValue);
	}
	function baseNth(array, n) {
			var length = array.length;
			if (!length) {
		return;
			}
			n += n < 0 ? length : 0;
			return isIndex(n, length) ? array[n] : undefined;
	}
	function baseOrderBy(collection, iteratees, orders) {
			var index = -1;
			iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));

			var result = baseMap(collection, function (value, key, collection) {
		var criteria = arrayMap(iteratees, function (iteratee) {
					return iteratee(value);
		});
		return { 'criteria': criteria, 'index': ++index, 'value': value };
			});

			return baseSortBy(result, function (object, other) {
		return compareMultiple(object, other, orders);
			});
	}
	function basePick(object, paths) {
			return basePickBy(object, paths, function (value, path) {
		return hasIn(object, path);
			});
	}
	function basePickBy(object, paths, predicate) {
			var index = -1,
					length = paths.length,
					result = {};

			while (++index < length) {
		var path = paths[index],
			value = baseGet(object, path);

		if (predicate(value, path)) {
					baseSet(result, castPath(path, object), value);
		}
			}
			return result;
	}
	function basePropertyDeep(path) {
			return function (object) {
		return baseGet(object, path);
			};
	}
	function basePullAll(array, values, iteratee, comparator) {
			var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
					index = -1,
					length = values.length,
					seen = array;

			if (array === values) {
		values = copyArray(values);
			}
			if (iteratee) {
		seen = arrayMap(array, baseUnary(iteratee));
			}
			while (++index < length) {
		var fromIndex = 0,
			value = values[index],
			computed = iteratee ? iteratee(value) : value;

		while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
					if (seen !== array) {
			splice.call(seen, fromIndex, 1);
					}
					splice.call(array, fromIndex, 1);
		}
			}
			return array;
	}
	function basePullAt(array, indexes) {
			var length = array ? indexes.length : 0,
					lastIndex = length - 1;

			while (length--) {
		var index = indexes[length];
		if (length == lastIndex || index !== previous) {
					var previous = index;
					if (isIndex(index)) {
			splice.call(array, index, 1);
					} else {
			baseUnset(array, index);
					}
		}
			}
			return array;
	}
	function baseRandom(lower, upper) {
			return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
	}
	function baseRange(start, end, step, fromRight) {
			var index = -1,
					length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
					result = Array(length);

			while (length--) {
		result[fromRight ? length : ++index] = start;
		start += step;
			}
			return result;
	}
	function baseRepeat(string, n) {
			var result = '';
			if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
		return result;
			}
			do {
		if (n % 2) {
					result += string;
		}
		n = nativeFloor(n / 2);
		if (n) {
					string += string;
		}
			} while (n);

			return result;
	}
	function baseRest(func, start) {
			return setToString(overRest(func, start, identity), func + '');
	}
	function baseSample(collection) {
			return arraySample(values(collection));
	}
	function baseSampleSize(collection, n) {
			var array = values(collection);
			return shuffleSelf(array, baseClamp(n, 0, array.length));
	}
	function baseSet(object, path, value, customizer) {
			if (!isObject(object)) {
		return object;
			}
			path = castPath(path, object);

			var index = -1,
					length = path.length,
					lastIndex = length - 1,
					nested = object;

			while (nested != null && ++index < length) {
		var key = toKey(path[index]),
			newValue = value;

		if (index != lastIndex) {
					var objValue = nested[key];
					newValue = customizer ? customizer(objValue, key, nested) : undefined;
					if (newValue === undefined) {
			newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
					}
		}
		assignValue(nested, key, newValue);
		nested = nested[key];
			}
			return object;
	}
	var baseSetData = !metaMap ? identity : function (func, data) {
			metaMap.set(func, data);
			return func;
	};
	var baseSetToString = !defineProperty ? identity : function (func, string) {
			return defineProperty(func, 'toString', {
		'configurable': true,
		'enumerable': false,
		'value': constant(string),
		'writable': true
			});
	};
	function baseShuffle(collection) {
			return shuffleSelf(values(collection));
	}
	function baseSlice(array, start, end) {
			var index = -1,
					length = array.length;

			if (start < 0) {
		start = -start > length ? 0 : length + start;
			}
			end = end > length ? length : end;
			if (end < 0) {
		end += length;
			}
			length = start > end ? 0 : end - start >>> 0;
			start >>>= 0;

			var result = Array(length);
			while (++index < length) {
		result[index] = array[index + start];
			}
			return result;
	}
	function baseSome(collection, predicate) {
			var result;

			baseEach(collection, function (value, index, collection) {
		result = predicate(value, index, collection);
		return !result;
			});
			return !!result;
	}
	function baseSortedIndex(array, value, retHighest) {
			var low = 0,
					high = array == null ? low : array.length;

			if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
		while (low < high) {
					var mid = low + high >>> 1,
							computed = array[mid];

					if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
			low = mid + 1;
					} else {
			high = mid;
					}
		}
		return high;
			}
			return baseSortedIndexBy(array, value, identity, retHighest);
	}
	function baseSortedIndexBy(array, value, iteratee, retHighest) {
			value = iteratee(value);

			var low = 0,
					high = array == null ? 0 : array.length,
					valIsNaN = value !== value,
					valIsNull = value === null,
					valIsSymbol = isSymbol(value),
					valIsUndefined = value === undefined;

			while (low < high) {
		var mid = nativeFloor((low + high) / 2),
			computed = iteratee(array[mid]),
			othIsDefined = computed !== undefined,
			othIsNull = computed === null,
			othIsReflexive = computed === computed,
			othIsSymbol = isSymbol(computed);

		if (valIsNaN) {
					var setLow = retHighest || othIsReflexive;
		} else if (valIsUndefined) {
					setLow = othIsReflexive && (retHighest || othIsDefined);
		} else if (valIsNull) {
					setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
		} else if (valIsSymbol) {
					setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
		} else if (othIsNull || othIsSymbol) {
					setLow = false;
		} else {
					setLow = retHighest ? computed <= value : computed < value;
		}
		if (setLow) {
					low = mid + 1;
		} else {
					high = mid;
		}
			}
			return nativeMin(high, MAX_ARRAY_INDEX);
	}
	function baseSortedUniq(array, iteratee) {
			var index = -1,
					length = array.length,
					resIndex = 0,
					result = [];

			while (++index < length) {
		var value = array[index],
			computed = iteratee ? iteratee(value) : value;

		if (!index || !eq(computed, seen)) {
					var seen = computed;
					result[resIndex++] = value === 0 ? 0 : value;
		}
			}
			return result;
	}
	function baseToNumber(value) {
			if (typeof value == 'number') {
		return value;
			}
			if (isSymbol(value)) {
		return NAN;
			}
			return +value;
	}
	function baseToString(value) {
			if (typeof value == 'string') {
		return value;
			}
			if (isArray(value)) {
		return arrayMap(value, baseToString) + '';
			}
			if (isSymbol(value)) {
		return symbolToString ? symbolToString.call(value) : '';
			}
			var result = value + '';
			return result == '0' && 1 / value == -INFINITY ? '-0' : result;
	}
	function baseUniq(array, iteratee, comparator) {
			var index = -1,
					includes = arrayIncludes,
					length = array.length,
					isCommon = true,
					result = [],
					seen = result;

			if (comparator) {
		isCommon = false;
		includes = arrayIncludesWith;
			} else if (length >= LARGE_ARRAY_SIZE) {
		var set = iteratee ? null : createSet(array);
		if (set) {
					return setToArray(set);
		}
		isCommon = false;
		includes = cacheHas;
		seen = new SetCache();
			} else {
		seen = iteratee ? [] : result;
			}
			outer: while (++index < length) {
		var value = array[index],
			computed = iteratee ? iteratee(value) : value;

		value = comparator || value !== 0 ? value : 0;
		if (isCommon && computed === computed) {
					var seenIndex = seen.length;
					while (seenIndex--) {
			if (seen[seenIndex] === computed) {
							continue outer;
			}
					}
					if (iteratee) {
			seen.push(computed);
					}
					result.push(value);
		} else if (!includes(seen, computed, comparator)) {
					if (seen !== result) {
			seen.push(computed);
					}
					result.push(value);
		}
			}
			return result;
	}
	function baseUnset(object, path) {
			path = castPath(path, object);
			object = parent(object, path);
			return object == null || delete object[toKey(last(path))];
	}
	function baseUpdate(object, path, updater, customizer) {
			return baseSet(object, path, updater(baseGet(object, path)), customizer);
	}
	function baseWhile(array, predicate, isDrop, fromRight) {
			var length = array.length,
					index = fromRight ? length : -1;

			while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}

			return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
	}
	function baseWrapperValue(value, actions) {
			var result = value;
			if (result instanceof LazyWrapper) {
		result = result.value();
			}
			return arrayReduce(actions, function (result, action) {
		return action.func.apply(action.thisArg, arrayPush([result], action.args));
			}, result);
	}
	function baseXor(arrays, iteratee, comparator) {
			var length = arrays.length;
			if (length < 2) {
		return length ? baseUniq(arrays[0]) : [];
			}
			var index = -1,
					result = Array(length);

			while (++index < length) {
		var array = arrays[index],
			othIndex = -1;

		while (++othIndex < length) {
					if (othIndex != index) {
			result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
					}
		}
			}
			return baseUniq(baseFlatten(result, 1), iteratee, comparator);
	}
	function baseZipObject(props, values, assignFunc) {
			var index = -1,
					length = props.length,
					valsLength = values.length,
					result = {};

			while (++index < length) {
		var value = index < valsLength ? values[index] : undefined;
		assignFunc(result, props[index], value);
			}
			return result;
	}
	function castArrayLikeObject(value) {
			return isArrayLikeObject(value) ? value : [];
	}
	function castFunction(value) {
			return typeof value == 'function' ? value : identity;
	}
	function castPath(value, object) {
			if (isArray(value)) {
		return value;
			}
			return isKey(value, object) ? [value] : stringToPath(toString(value));
	}
	var castRest = baseRest;
	function castSlice(array, start, end) {
			var length = array.length;
			end = end === undefined ? length : end;
			return !start && end >= length ? array : baseSlice(array, start, end);
	}
	var clearTimeout = ctxClearTimeout || function (id) {
			return root.clearTimeout(id);
	};
	function cloneBuffer(buffer, isDeep) {
			if (isDeep) {
		return buffer.slice();
			}
			var length = buffer.length,
					result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

			buffer.copy(result);
			return result;
	}
	function cloneArrayBuffer(arrayBuffer) {
			var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
			new Uint8Array(result).set(new Uint8Array(arrayBuffer));
			return result;
	}
	function cloneDataView(dataView, isDeep) {
			var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
			return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	}
	function cloneMap(map, isDeep, cloneFunc) {
			var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);
			return arrayReduce(array, addMapEntry, new map.constructor());
	}
	function cloneRegExp(regexp) {
			var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
			result.lastIndex = regexp.lastIndex;
			return result;
	}
	function cloneSet(set, isDeep, cloneFunc) {
			var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);
			return arrayReduce(array, addSetEntry, new set.constructor());
	}
	function cloneSymbol(symbol) {
			return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
	}
	function cloneTypedArray(typedArray, isDeep) {
			var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
			return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}
	function compareAscending(value, other) {
			if (value !== other) {
		var valIsDefined = value !== undefined,
			valIsNull = value === null,
			valIsReflexive = value === value,
			valIsSymbol = isSymbol(value);

		var othIsDefined = other !== undefined,
			othIsNull = other === null,
			othIsReflexive = other === other,
			othIsSymbol = isSymbol(other);

		if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
					return 1;
		}
		if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
					return -1;
		}
			}
			return 0;
	}
	function compareMultiple(object, other, orders) {
			var index = -1,
					objCriteria = object.criteria,
					othCriteria = other.criteria,
					length = objCriteria.length,
					ordersLength = orders.length;

			while (++index < length) {
		var result = compareAscending(objCriteria[index], othCriteria[index]);
		if (result) {
					if (index >= ordersLength) {
			return result;
					}
					var order = orders[index];
					return result * (order == 'desc' ? -1 : 1);
		}
			}
			//
			return object.index - other.index;
	}
	function composeArgs(args, partials, holders, isCurried) {
			var argsIndex = -1,
					argsLength = args.length,
					holdersLength = holders.length,
					leftIndex = -1,
					leftLength = partials.length,
					rangeLength = nativeMax(argsLength - holdersLength, 0),
					result = Array(leftLength + rangeLength),
					isUncurried = !isCurried;

			while (++leftIndex < leftLength) {
		result[leftIndex] = partials[leftIndex];
			}
			while (++argsIndex < holdersLength) {
		if (isUncurried || argsIndex < argsLength) {
					result[holders[argsIndex]] = args[argsIndex];
		}
			}
			while (rangeLength--) {
		result[leftIndex++] = args[argsIndex++];
			}
			return result;
	}
	function composeArgsRight(args, partials, holders, isCurried) {
			var argsIndex = -1,
					argsLength = args.length,
					holdersIndex = -1,
					holdersLength = holders.length,
					rightIndex = -1,
					rightLength = partials.length,
					rangeLength = nativeMax(argsLength - holdersLength, 0),
					result = Array(rangeLength + rightLength),
					isUncurried = !isCurried;

			while (++argsIndex < rangeLength) {
		result[argsIndex] = args[argsIndex];
			}
			var offset = argsIndex;
			while (++rightIndex < rightLength) {
		result[offset + rightIndex] = partials[rightIndex];
			}
			while (++holdersIndex < holdersLength) {
		if (isUncurried || argsIndex < argsLength) {
					result[offset + holders[holdersIndex]] = args[argsIndex++];
		}
			}
			return result;
	}
	function copyArray(source, array) {
			var index = -1,
					length = source.length;

			array || (array = Array(length));
			while (++index < length) {
		array[index] = source[index];
			}
			return array;
	}
	function copyObject(source, props, object, customizer) {
			var isNew = !object;
			object || (object = {});

			var index = -1,
					length = props.length;

			while (++index < length) {
		var key = props[index];

		var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

		if (newValue === undefined) {
					newValue = source[key];
		}
		if (isNew) {
					baseAssignValue(object, key, newValue);
		} else {
					assignValue(object, key, newValue);
		}
			}
			return object;
	}
	function copySymbols(source, object) {
			return copyObject(source, getSymbols(source), object);
	}
	function copySymbolsIn(source, object) {
			return copyObject(source, getSymbolsIn(source), object);
	}
	function createAggregator(setter, initializer) {
			return function (collection, iteratee) {
		var func = isArray(collection) ? arrayAggregator : baseAggregator,
			accumulator = initializer ? initializer() : {};

		return func(collection, setter, getIteratee(iteratee, 2), accumulator);
			};
	}
	function createAssigner(assigner) {
			return baseRest(function (object, sources) {
		var index = -1,
			length = sources.length,
			customizer = length > 1 ? sources[length - 1] : undefined,
			guard = length > 2 ? sources[2] : undefined;

		customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

		if (guard && isIterateeCall(sources[0], sources[1], guard)) {
					customizer = length < 3 ? undefined : customizer;
					length = 1;
		}
		object = Object(object);
		while (++index < length) {
					var source = sources[index];
					if (source) {
			assigner(object, source, index, customizer);
					}
		}
		return object;
			});
	}
	function createBaseEach(eachFunc, fromRight) {
			return function (collection, iteratee) {
		if (collection == null) {
					return collection;
		}
		if (!isArrayLike(collection)) {
					return eachFunc(collection, iteratee);
		}
		var length = collection.length,
			index = fromRight ? length : -1,
			iterable = Object(collection);

		while (fromRight ? index-- : ++index < length) {
					if (iteratee(iterable[index], index, iterable) === false) {
			break;
					}
		}
		return collection;
			};
	}
	function createBaseFor(fromRight) {
			return function (object, iteratee, keysFunc) {
		var index = -1,
			iterable = Object(object),
			props = keysFunc(object),
			length = props.length;

		while (length--) {
					var key = props[fromRight ? length : ++index];
					if (iteratee(iterable[key], key, iterable) === false) {
			break;
					}
		}
		return object;
			};
	}
	function createBind(func, bitmask, thisArg) {
			var isBind = bitmask & WRAP_BIND_FLAG,
					Ctor = createCtor(func);

			function wrapper() {
		var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
		return fn.apply(isBind ? thisArg : this, arguments);
			}
			return wrapper;
	}
	function createCaseFirst(methodName) {
			return function (string) {
		string = toString(string);

		var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;

		var chr = strSymbols ? strSymbols[0] : string.charAt(0);

		var trailing = strSymbols ? castSlice(strSymbols, 1).join('') : string.slice(1);

		return chr[methodName]() + trailing;
			};
	}
	function createCompounder(callback) {
			return function (string) {
		return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
			};
	}
	function createCtor(Ctor) {
			return function () {
		var args = arguments;
		switch (args.length) {
					case 0:
			return new Ctor();
					case 1:
			return new Ctor(args[0]);
					case 2:
			return new Ctor(args[0], args[1]);
					case 3:
			return new Ctor(args[0], args[1], args[2]);
					case 4:
			return new Ctor(args[0], args[1], args[2], args[3]);
					case 5:
			return new Ctor(args[0], args[1], args[2], args[3], args[4]);
					case 6:
			return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
					case 7:
			return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
		}
		var thisBinding = baseCreate(Ctor.prototype),
			result = Ctor.apply(thisBinding, args);
		return isObject(result) ? result : thisBinding;
			};
	}
	function createCurry(func, bitmask, arity) {
			var Ctor = createCtor(func);

			function wrapper() {
		var length = arguments.length,
			args = Array(length),
			index = length,
			placeholder = getHolder(wrapper);

		while (index--) {
					args[index] = arguments[index];
		}
		var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);

		length -= holders.length;
		if (length < arity) {
					return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length);
		}
		var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
		return apply(fn, this, args);
			}
			return wrapper;
	}
	function createFind(findIndexFunc) {
			return function (collection, predicate, fromIndex) {
		var iterable = Object(collection);
		if (!isArrayLike(collection)) {
					var iteratee = getIteratee(predicate, 3);
					collection = keys(collection);
					predicate = function predicate(key) {
			return iteratee(iterable[key], key, iterable);
					};
		}
		var index = findIndexFunc(collection, predicate, fromIndex);
		return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
			};
	}
	function createFlow(fromRight) {
			return flatRest(function (funcs) {
		var length = funcs.length,
			index = length,
			prereq = LodashWrapper.prototype.thru;

		if (fromRight) {
					funcs.reverse();
		}
		while (index--) {
					var func = funcs[index];
					if (typeof func != 'function') {
			throw new TypeError(FUNC_ERROR_TEXT);
					}
					if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
			var wrapper = new LodashWrapper([], true);
					}
		}
		index = wrapper ? index : length;
		while (++index < length) {
					func = funcs[index];

					var funcName = getFuncName(func),
							data = funcName == 'wrapper' ? getData(func) : undefined;

					if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
			wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
					} else {
			wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
					}
		}
		return function () {
					var args = arguments,
							value = args[0];

					if (wrapper && args.length == 1 && isArray(value)) {
			return wrapper.plant(value).value();
					}
					var index = 0,
							result = length ? funcs[index].apply(this, args) : value;

					while (++index < length) {
			result = funcs[index].call(this, result);
					}
					return result;
		};
			});
	}
	function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
			var isAry = bitmask & WRAP_ARY_FLAG,
					isBind = bitmask & WRAP_BIND_FLAG,
					isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
					isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
					isFlip = bitmask & WRAP_FLIP_FLAG,
					Ctor = isBindKey ? undefined : createCtor(func);

			function wrapper() {
		var length = arguments.length,
			args = Array(length),
			index = length;

		while (index--) {
					args[index] = arguments[index];
		}
		if (isCurried) {
					var placeholder = getHolder(wrapper),
							holdersCount = countHolders(args, placeholder);
		}
		if (partials) {
					args = composeArgs(args, partials, holders, isCurried);
		}
		if (partialsRight) {
					args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
		}
		length -= holdersCount;
		if (isCurried && length < arity) {
					var newHolders = replaceHolders(args, placeholder);
					return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);
		}
		var thisBinding = isBind ? thisArg : this,
			fn = isBindKey ? thisBinding[func] : func;

		length = args.length;
		if (argPos) {
					args = reorder(args, argPos);
		} else if (isFlip && length > 1) {
					args.reverse();
		}
		if (isAry && ary < length) {
					args.length = ary;
		}
		if (this && this !== root && this instanceof wrapper) {
					fn = Ctor || createCtor(fn);
		}
		return fn.apply(thisBinding, args);
			}
			return wrapper;
	}
	function createInverter(setter, toIteratee) {
			return function (object, iteratee) {
		return baseInverter(object, setter, toIteratee(iteratee), {});
			};
	}
	function createMathOperation(operator, defaultValue) {
			return function (value, other) {
		var result;
		if (value === undefined && other === undefined) {
					return defaultValue;
		}
		if (value !== undefined) {
					result = value;
		}
		if (other !== undefined) {
					if (result === undefined) {
			return other;
					}
					if (typeof value == 'string' || typeof other == 'string') {
			value = baseToString(value);
			other = baseToString(other);
					} else {
			value = baseToNumber(value);
			other = baseToNumber(other);
					}
					result = operator(value, other);
		}
		return result;
			};
	}
	function createOver(arrayFunc) {
			return flatRest(function (iteratees) {
		iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
		return baseRest(function (args) {
					var thisArg = this;
					return arrayFunc(iteratees, function (iteratee) {
			return apply(iteratee, thisArg, args);
					});
		});
			});
	}
	function createPadding(length, chars) {
			chars = chars === undefined ? ' ' : baseToString(chars);

			var charsLength = chars.length;
			if (charsLength < 2) {
		return charsLength ? baseRepeat(chars, length) : chars;
			}
			var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
			return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join('') : result.slice(0, length);
	}
	function createPartial(func, bitmask, thisArg, partials) {
			var isBind = bitmask & WRAP_BIND_FLAG,
					Ctor = createCtor(func);

			function wrapper() {
		var argsIndex = -1,
			argsLength = arguments.length,
			leftIndex = -1,
			leftLength = partials.length,
			args = Array(leftLength + argsLength),
			fn = this && this !== root && this instanceof wrapper ? Ctor : func;

		while (++leftIndex < leftLength) {
					args[leftIndex] = partials[leftIndex];
		}
		while (argsLength--) {
					args[leftIndex++] = arguments[++argsIndex];
		}
		return apply(fn, isBind ? thisArg : this, args);
			}
			return wrapper;
	}
	function createRange(fromRight) {
			return function (start, end, step) {
		if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
					end = step = undefined;
		}
		start = toFinite(start);
		if (end === undefined) {
					end = start;
					start = 0;
		} else {
					end = toFinite(end);
		}
		step = step === undefined ? start < end ? 1 : -1 : toFinite(step);
		return baseRange(start, end, step, fromRight);
			};
	}
	function createRelationalOperation(operator) {
			return function (value, other) {
		if (!(typeof value == 'string' && typeof other == 'string')) {
					value = toNumber(value);
					other = toNumber(other);
		}
		return operator(value, other);
			};
	}
	function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
			var isCurry = bitmask & WRAP_CURRY_FLAG,
					newHolders = isCurry ? holders : undefined,
					newHoldersRight = isCurry ? undefined : holders,
					newPartials = isCurry ? partials : undefined,
					newPartialsRight = isCurry ? undefined : partials;

			bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
			bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

			if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
		bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
			}
			var newData = [func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity];

			var result = wrapFunc.apply(undefined, newData);
			if (isLaziable(func)) {
		setData(result, newData);
			}
			result.placeholder = placeholder;
			return setWrapToString(result, func, bitmask);
	}
	function createRound(methodName) {
			var func = Math[methodName];
			return function (number, precision) {
		number = toNumber(number);
		precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
		if (precision) {
					var pair = (toString(number) + 'e').split('e'),
							value = func(pair[0] + 'e' + (+pair[1] + precision));

					pair = (toString(value) + 'e').split('e');
					return +(pair[0] + 'e' + (+pair[1] - precision));
		}
		return func(number);
			};
	}
	var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function (values) {
			return new Set(values);
	};
	function createToPairs(keysFunc) {
			return function (object) {
		var tag = getTag(object);
		if (tag == mapTag) {
					return mapToArray(object);
		}
		if (tag == setTag) {
					return setToPairs(object);
		}
		return baseToPairs(object, keysFunc(object));
			};
	}
	function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
			var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
			if (!isBindKey && typeof func != 'function') {
		throw new TypeError(FUNC_ERROR_TEXT);
			}
			var length = partials ? partials.length : 0;
			if (!length) {
		bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
		partials = holders = undefined;
			}
			ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
			arity = arity === undefined ? arity : toInteger(arity);
			length -= holders ? holders.length : 0;

			if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
		var partialsRight = partials,
			holdersRight = holders;

		partials = holders = undefined;
			}
			var data = isBindKey ? undefined : getData(func);

			var newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

			if (data) {
		mergeData(newData, data);
			}
			func = newData[0];
			bitmask = newData[1];
			thisArg = newData[2];
			partials = newData[3];
			holders = newData[4];
			arity = newData[9] = newData[9] === undefined ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);

			if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
		bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
			}
			if (!bitmask || bitmask == WRAP_BIND_FLAG) {
		var result = createBind(func, bitmask, thisArg);
			} else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
		result = createCurry(func, bitmask, arity);
			} else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
		result = createPartial(func, bitmask, thisArg, partials);
			} else {
		result = createHybrid.apply(undefined, newData);
			}
			var setter = data ? baseSetData : setData;
			return setWrapToString(setter(result, newData), func, bitmask);
	}
	function customDefaultsAssignIn(objValue, srcValue, key, object) {
			if (objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
		return srcValue;
			}
			return objValue;
	}
	function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
			if (isObject(objValue) && isObject(srcValue)) {
		stack.set(srcValue, objValue);
		baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
		stack['delete'](srcValue);
			}
			return objValue;
	}
	function customOmitClone(value) {
			return isPlainObject(value) ? undefined : value;
	}
	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
			var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
					arrLength = array.length,
					othLength = other.length;

			if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
		return false;
			}
			var stacked = stack.get(array);
			if (stacked && stack.get(other)) {
		return stacked == other;
			}
			var index = -1,
					result = true,
					seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;

			stack.set(array, other);
			stack.set(other, array);
			while (++index < arrLength) {
		var arrValue = array[index],
			othValue = other[index];

		if (customizer) {
					var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
		}
		if (compared !== undefined) {
					if (compared) {
			continue;
					}
					result = false;
					break;
		}
		if (seen) {
					if (!arraySome(other, function (othValue, othIndex) {
			if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
							return seen.push(othIndex);
			}
					})) {
			result = false;
			break;
					}
		} else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
					result = false;
					break;
		}
			}
			stack['delete'](array);
			stack['delete'](other);
			return result;
	}
	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
			switch (tag) {
		case dataViewTag:
					if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
			return false;
					}
					object = object.buffer;
					other = other.buffer;

		case arrayBufferTag:
					if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
			return false;
					}
					return true;

		case boolTag:
		case dateTag:
		case numberTag:
					return eq(+object, +other);

		case errorTag:
					return object.name == other.name && object.message == other.message;

		case regexpTag:
		case stringTag:
					return object == other + '';

		case mapTag:
					var convert = mapToArray;

		case setTag:
					var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
					convert || (convert = setToArray);

					if (object.size != other.size && !isPartial) {
			return false;
					}
					var stacked = stack.get(object);
					if (stacked) {
			return stacked == other;
					}
					bitmask |= COMPARE_UNORDERED_FLAG;
					stack.set(object, other);
					var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
					stack['delete'](object);
					return result;

		case symbolTag:
					if (symbolValueOf) {
			return symbolValueOf.call(object) == symbolValueOf.call(other);
					}
			}
			return false;
	}
	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
			var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
					objProps = getAllKeys(object),
					objLength = objProps.length,
					othProps = getAllKeys(other),
					othLength = othProps.length;

			if (objLength != othLength && !isPartial) {
		return false;
			}
			var index = objLength;
			while (index--) {
		var key = objProps[index];
		if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
					return false;
		}
			}
			var stacked = stack.get(object);
			if (stacked && stack.get(other)) {
		return stacked == other;
			}
			var result = true;
			stack.set(object, other);
			stack.set(other, object);

			var skipCtor = isPartial;
			while (++index < objLength) {
		key = objProps[index];
		var objValue = object[key],
			othValue = other[key];

		if (customizer) {
					var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
		}
		if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
					result = false;
					break;
		}
		skipCtor || (skipCtor = key == 'constructor');
			}
			if (result && !skipCtor) {
		var objCtor = object.constructor,
			othCtor = other.constructor;
		if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
					result = false;
		}
			}
			stack['delete'](object);
			stack['delete'](other);
			return result;
	}
	function flatRest(func) {
			return setToString(overRest(func, undefined, flatten), func + '');
	}
	function getAllKeys(object) {
			return baseGetAllKeys(object, keys, getSymbols);
	}
	function getAllKeysIn(object) {
			return baseGetAllKeys(object, keysIn, getSymbolsIn);
	}
	var getData = !metaMap ? noop : function (func) {
			return metaMap.get(func);
	};
	function getFuncName(func) {
			var result = func.name + '',
					array = realNames[result],
					length = hasOwnProperty.call(realNames, result) ? array.length : 0;

			while (length--) {
		var data = array[length],
			otherFunc = data.func;
		if (otherFunc == null || otherFunc == func) {
					return data.name;
		}
			}
			return result;
	}
	function getHolder(func) {
			var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
			return object.placeholder;
	}
	function getIteratee() {
			var result = lodash.iteratee || iteratee;
			result = result === iteratee ? baseIteratee : result;
			return arguments.length ? result(arguments[0], arguments[1]) : result;
	}
	function getMapData(map, key) {
			var data = map.__data__;
			return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
	}
	function getMatchData(object) {
			var result = keys(object),
					length = result.length;

			while (length--) {
		var key = result[length],
			value = object[key];

		result[length] = [key, value, isStrictComparable(value)];
			}
			return result;
	}
	function getNative(object, key) {
			var value = getValue(object, key);
			return baseIsNative(value) ? value : undefined;
	}
	function getRawTag(value) {
			var isOwn = hasOwnProperty.call(value, symToStringTag),
					tag = value[symToStringTag];

			try {
		value[symToStringTag] = undefined;
		var unmasked = true;
			} catch (e) {}

			var result = nativeObjectToString.call(value);
			if (unmasked) {
		if (isOwn) {
					value[symToStringTag] = tag;
		} else {
					delete value[symToStringTag];
		}
			}
			return result;
	}
	var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
			if (object == null) {
		return [];
			}
			object = Object(object);
			return arrayFilter(nativeGetSymbols(object), function (symbol) {
		return propertyIsEnumerable.call(object, symbol);
			});
	};
	var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
			var result = [];
			while (object) {
		arrayPush(result, getSymbols(object));
		object = getPrototype(object);
			}
			return result;
	};
	var getTag = baseGetTag;
	if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
			getTag = function getTag(value) {
		var result = baseGetTag(value),
			Ctor = result == objectTag ? value.constructor : undefined,
			ctorString = Ctor ? toSource(Ctor) : '';

		if (ctorString) {
					switch (ctorString) {
			case dataViewCtorString:
							return dataViewTag;
			case mapCtorString:
							return mapTag;
			case promiseCtorString:
							return promiseTag;
			case setCtorString:
							return setTag;
			case weakMapCtorString:
							return weakMapTag;
					}
		}
		return result;
			};
	}
	function getView(start, end, transforms) {
			var index = -1,
					length = transforms.length;

			while (++index < length) {
		var data = transforms[index],
			size = data.size;

		switch (data.type) {
					case 'drop':
			start += size;break;
					case 'dropRight':
			end -= size;break;
					case 'take':
			end = nativeMin(end, start + size);break;
					case 'takeRight':
			start = nativeMax(start, end - size);break;
		}
			}
			return { 'start': start, 'end': end };
	}
	function getWrapDetails(source) {
			var match = source.match(reWrapDetails);
			return match ? match[1].split(reSplitDetails) : [];
	}
	function hasPath(object, path, hasFunc) {
			path = castPath(path, object);

			var index = -1,
					length = path.length,
					result = false;

			while (++index < length) {
		var key = toKey(path[index]);
		if (!(result = object != null && hasFunc(object, key))) {
					break;
		}
		object = object[key];
			}
			if (result || ++index != length) {
		return result;
			}
			length = object == null ? 0 : object.length;
			return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
	}
	function initCloneArray(array) {
			var length = array.length,
					result = array.constructor(length);
			if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
		result.index = array.index;
		result.input = array.input;
			}
			return result;
	}
	function initCloneObject(object) {
			return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
	}
	function initCloneByTag(object, tag, cloneFunc, isDeep) {
			var Ctor = object.constructor;
			switch (tag) {
		case arrayBufferTag:
					return cloneArrayBuffer(object);

		case boolTag:
		case dateTag:
					return new Ctor(+object);

		case dataViewTag:
					return cloneDataView(object, isDeep);

		case float32Tag:case float64Tag:
		case int8Tag:case int16Tag:case int32Tag:
		case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:
					return cloneTypedArray(object, isDeep);

		case mapTag:
					return cloneMap(object, isDeep, cloneFunc);

		case numberTag:
		case stringTag:
					return new Ctor(object);

		case regexpTag:
					return cloneRegExp(object);

		case setTag:
					return cloneSet(object, isDeep, cloneFunc);

		case symbolTag:
					return cloneSymbol(object);
			}
	}
	function insertWrapDetails(source, details) {
			var length = details.length;
			if (!length) {
		return source;
			}
			var lastIndex = length - 1;
			details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
			details = details.join(length > 2 ? ', ' : ' ');
			return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
	}
	function isFlattenable(value) {
			return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
	}
	function isIndex(value, length) {
			length = length == null ? MAX_SAFE_INTEGER : length;
			return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
	}
	function isIterateeCall(value, index, object) {
			if (!isObject(object)) {
		return false;
			}
			var type = typeof index === 'undefined' ? 'undefined' : _typeof(index);
			if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
		return eq(object[index], value);
			}
			return false;
	}
	function isKey(value, object) {
			if (isArray(value)) {
		return false;
			}
			var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
			if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
		return true;
			}
			return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
	}
	function isKeyable(value) {
			var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
			return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
	}
	function isLaziable(func) {
			var funcName = getFuncName(func),
					other = lodash[funcName];

			if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
		return false;
			}
			if (func === other) {
		return true;
			}
			var data = getData(other);
			return !!data && func === data[0];
	}
	function isMasked(func) {
			return !!maskSrcKey && maskSrcKey in func;
	}
	var isMaskable = coreJsData ? isFunction : stubFalse;
	function isPrototype(value) {
			var Ctor = value && value.constructor,
					proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;

			return value === proto;
	}
	function isStrictComparable(value) {
			return value === value && !isObject(value);
	}
	function matchesStrictComparable(key, srcValue) {
			return function (object) {
		if (object == null) {
					return false;
		}
		return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
			};
	}
	function memoizeCapped(func) {
			var result = memoize(func, function (key) {
		if (cache.size === MAX_MEMOIZE_SIZE) {
					cache.clear();
		}
		return key;
			});

			var cache = result.cache;
			return result;
	}
	function mergeData(data, source) {
			var bitmask = data[1],
					srcBitmask = source[1],
					newBitmask = bitmask | srcBitmask,
					isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

			var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
			if (!(isCommon || isCombo)) {
		return data;
			}
			if (srcBitmask & WRAP_BIND_FLAG) {
		data[2] = source[2];
		newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
			}
			var value = source[3];
			if (value) {
		var partials = data[3];
		data[3] = partials ? composeArgs(partials, value, source[4]) : value;
		data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
			}
			value = source[5];
			if (value) {
		partials = data[5];
		data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
		data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
			}
			value = source[7];
			if (value) {
		data[7] = value;
			}
			if (srcBitmask & WRAP_ARY_FLAG) {
		data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
			}
			if (data[9] == null) {
		data[9] = source[9];
			}
			data[0] = source[0];
			data[1] = newBitmask;

			return data;
	}
	function nativeKeysIn(object) {
			var result = [];
			if (object != null) {
		for (var key in Object(object)) {
					result.push(key);
		}
			}
			return result;
	}
	function objectToString(value) {
			return nativeObjectToString.call(value);
	}
	function overRest(func, start, transform) {
			start = nativeMax(start === undefined ? func.length - 1 : start, 0);
			return function () {
		var args = arguments,
			index = -1,
			length = nativeMax(args.length - start, 0),
			array = Array(length);

		while (++index < length) {
					array[index] = args[start + index];
		}
		index = -1;
		var otherArgs = Array(start + 1);
		while (++index < start) {
					otherArgs[index] = args[index];
		}
		otherArgs[start] = transform(array);
		return apply(func, this, otherArgs);
			};
	}
	function parent(object, path) {
			return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
	}
	function reorder(array, indexes) {
			var arrLength = array.length,
					length = nativeMin(indexes.length, arrLength),
					oldArray = copyArray(array);

			while (length--) {
		var index = indexes[length];
		array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
			}
			return array;
	}
	var setData = shortOut(baseSetData);
	var setTimeout = ctxSetTimeout || function (func, wait) {
			return root.setTimeout(func, wait);
	};
	var setToString = shortOut(baseSetToString);
	function setWrapToString(wrapper, reference, bitmask) {
			var source = reference + '';
			return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
	}
	function shortOut(func) {
			var count = 0,
					lastCalled = 0;

			return function () {
		var stamp = nativeNow(),
			remaining = HOT_SPAN - (stamp - lastCalled);

		lastCalled = stamp;
		if (remaining > 0) {
					if (++count >= HOT_COUNT) {
			return arguments[0];
					}
		} else {
					count = 0;
		}
		return func.apply(undefined, arguments);
			};
	}
	function shuffleSelf(array, size) {
			var index = -1,
					length = array.length,
					lastIndex = length - 1;

			size = size === undefined ? length : size;
			while (++index < size) {
		var rand = baseRandom(index, lastIndex),
			value = array[rand];

		array[rand] = array[index];
		array[index] = value;
			}
			array.length = size;
			return array;
	}
	var stringToPath = memoizeCapped(function (string) {
			var result = [];
			if (reLeadingDot.test(string)) {
		result.push('');
			}
			string.replace(rePropName, function (match, number, quote, string) {
		result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
			});
			return result;
	});
	function toKey(value) {
			if (typeof value == 'string' || isSymbol(value)) {
		return value;
			}
			var result = value + '';
			return result == '0' && 1 / value == -INFINITY ? '-0' : result;
	}
	function toSource(func) {
			if (func != null) {
		try {
					return funcToString.call(func);
		} catch (e) {}
		try {
					return func + '';
		} catch (e) {}
			}
			return '';
	}
	function updateWrapDetails(details, bitmask) {
			arrayEach(wrapFlags, function (pair) {
		var value = '_.' + pair[0];
		if (bitmask & pair[1] && !arrayIncludes(details, value)) {
					details.push(value);
		}
			});
			return details.sort();
	}
	function wrapperClone(wrapper) {
			if (wrapper instanceof LazyWrapper) {
		return wrapper.clone();
			}
			var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
			result.__actions__ = copyArray(wrapper.__actions__);
			result.__index__ = wrapper.__index__;
			result.__values__ = wrapper.__values__;
			return result;
	}
	function chunk(array, size, guard) {
			if (guard ? isIterateeCall(array, size, guard) : size === undefined) {
		size = 1;
			} else {
		size = nativeMax(toInteger(size), 0);
			}
			var length = array == null ? 0 : array.length;
			if (!length || size < 1) {
		return [];
			}
			var index = 0,
					resIndex = 0,
					result = Array(nativeCeil(length / size));

			while (index < length) {
		result[resIndex++] = baseSlice(array, index, index += size);
			}
			return result;
	}
	function compact(array) {
			var index = -1,
					length = array == null ? 0 : array.length,
					resIndex = 0,
					result = [];

			while (++index < length) {
		var value = array[index];
		if (value) {
					result[resIndex++] = value;
		}
			}
			return result;
	}
	function concat() {
			var length = arguments.length;
			if (!length) {
		return [];
			}
			var args = Array(length - 1),
					array = arguments[0],
					index = length;

			while (index--) {
		args[index - 1] = arguments[index];
			}
			return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
	}
	var difference = baseRest(function (array, values) {
			return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
	});
	var differenceBy = baseRest(function (array, values) {
			var iteratee = last(values);
			if (isArrayLikeObject(iteratee)) {
		iteratee = undefined;
			}
			return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2)) : [];
	});
	var differenceWith = baseRest(function (array, values) {
			var comparator = last(values);
			if (isArrayLikeObject(comparator)) {
		comparator = undefined;
			}
			return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator) : [];
	});
	function drop(array, n, guard) {
			var length = array == null ? 0 : array.length;
			if (!length) {
		return [];
			}
			n = guard || n === undefined ? 1 : toInteger(n);
			return baseSlice(array, n < 0 ? 0 : n, length);
	}
	function dropRight(array, n, guard) {
			var length = array == null ? 0 : array.length;
			if (!length) {
		return [];
			}
			n = guard || n === undefined ? 1 : toInteger(n);
			n = length - n;
			return baseSlice(array, 0, n < 0 ? 0 : n);
	}
	function dropRightWhile(array, predicate) {
			return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
	}
	function dropWhile(array, predicate) {
			return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
	}
	function fill(array, value, start, end) {
			var length = array == null ? 0 : array.length;
			if (!length) {
		return [];
			}
			if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
		start = 0;
		end = length;
			}
			return baseFill(array, value, start, end);
	}
	function findIndex(array, predicate, fromIndex) {
			var length = array == null ? 0 : array.length;
			if (!length) {
		return -1;
			}
			var index = fromIndex == null ? 0 : toInteger(fromIndex);
			if (index < 0) {
		index = nativeMax(length + index, 0);
			}
			return baseFindIndex(array, getIteratee(predicate, 3), index);
	}
	function findLastIndex(array, predicate, fromIndex) {
			var length = array == null ? 0 : array.length;
			if (!length) {
		return -1;
			}
			var index = length - 1;
			if (fromIndex !== undefined) {
		index = toInteger(fromIndex);
		index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
			}
			return baseFindIndex(array, getIteratee(predicate, 3), index, true);
	}
	function flatten(array) {
			var length = array == null ? 0 : array.length;
			return length ? baseFlatten(array, 1) : [];
	}
	function flattenDeep(array) {
			var length = array == null ? 0 : array.length;
			return length ? baseFlatten(array, INFINITY) : [];
	}
	function flattenDepth(array, depth) {
			var length = array == null ? 0 : array.length;
			if (!length) {
		return [];
			}
			depth = depth === undefined ? 1 : toInteger(depth);
			return baseFlatten(array, depth);
	}
	function fromPairs(pairs) {
			var index = -1,
					length = pairs == null ? 0 : pairs.length,
					result = {};

			while (++index < length) {
		var pair = pairs[index];
		result[pair[0]] = pair[1];
			}
			return result;
	}
	function head(array) {
			return array && array.length ? array[0] : undefined;
	}
	function indexOf(array, value, fromIndex) {
			var length = array == null ? 0 : array.length;
			if (!length) {
		return -1;
			}
			var index = fromIndex == null ? 0 : toInteger(fromIndex);
			if (index < 0) {
		index = nativeMax(length + index, 0);
			}
			return baseIndexOf(array, value, index);
	}
	function initial(array) {
			var length = array == null ? 0 : array.length;
			return length ? baseSlice(array, 0, -1) : [];
	}
	var intersection = baseRest(function (arrays) {
			var mapped = arrayMap(arrays, castArrayLikeObject);
			return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
	});
	var intersectionBy = baseRest(function (arrays) {
			var iteratee = last(arrays),
					mapped = arrayMap(arrays, castArrayLikeObject);

			if (iteratee === last(mapped)) {
		iteratee = undefined;
			} else {
		mapped.pop();
			}
			return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee, 2)) : [];
	});
	var intersectionWith = baseRest(function (arrays) {
			var comparator = last(arrays),
					mapped = arrayMap(arrays, castArrayLikeObject);

			comparator = typeof comparator == 'function' ? comparator : undefined;
			if (comparator) {
		mapped.pop();
			}
			return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined, comparator) : [];
	});
	function join(array, separator) {
			return array == null ? '' : nativeJoin.call(array, separator);
	}
	function last(array) {
			var length = array == null ? 0 : array.length;
			return length ? array[length - 1] : undefined;
	}
	function lastIndexOf(array, value, fromIndex) {
			var length = array == null ? 0 : array.length;
			if (!length) {
		return -1;
			}
			var index = length;
			if (fromIndex !== undefined) {
		index = toInteger(fromIndex);
		index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
			}
			return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
	}
	function nth(array, n) {
			return array && array.length ? baseNth(array, toInteger(n)) : undefined;
	}
	var pull = baseRest(pullAll);
	function pullAll(array, values) {
			return array && array.length && values && values.length ? basePullAll(array, values) : array;
	}
	function pullAllBy(array, values, iteratee) {
			return array && array.length && values && values.length ? basePullAll(array, values, getIteratee(iteratee, 2)) : array;
	}
	function pullAllWith(array, values, comparator) {
			return array && array.length && values && values.length ? basePullAll(array, values, undefined, comparator) : array;
	}
	var pullAt = flatRest(function (array, indexes) {
			var length = array == null ? 0 : array.length,
					result = baseAt(array, indexes);

			basePullAt(array, arrayMap(indexes, function (index) {
		return isIndex(index, length) ? +index : index;
			}).sort(compareAscending));

			return result;
	});
	function remove(array, predicate) {
			var result = [];
			if (!(array && array.length)) {
		return result;
			}
			var index = -1,
					indexes = [],
					length = array.length;

			predicate = getIteratee(predicate, 3);
			while (++index < length) {
		var value = array[index];
		if (predicate(value, index, array)) {
					result.push(value);
					indexes.push(index);
		}
			}
			basePullAt(array, indexes);
			return result;
	}
	function reverse(array) {
			return array == null ? array : nativeReverse.call(array);
	}
	function slice(array, start, end) {
			var length = array == null ? 0 : array.length;
			if (!length) {
		return [];
			}
			if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
		start = 0;
		end = length;
			} else {
		start = start == null ? 0 : toInteger(start);
		end = end === undefined ? length : toInteger(end);
			}
			return baseSlice(array, start, end);
	}
	function sortedIndex(array, value) {
			return baseSortedIndex(array, value);
	}
	function sortedIndexBy(array, value, iteratee) {
			return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
	}
	function sortedIndexOf(array, value) {
			var length = array == null ? 0 : array.length;
			if (length) {
		var index = baseSortedIndex(array, value);
		if (index < length && eq(array[index], value)) {
					return index;
		}
			}
			return -1;
	}
	function sortedLastIndex(array, value) {
			return baseSortedIndex(array, value, true);
	}
	function sortedLastIndexBy(array, value, iteratee) {
			return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
	}
	function sortedLastIndexOf(array, value) {
			var length = array == null ? 0 : array.length;
			if (length) {
		var index = baseSortedIndex(array, value, true) - 1;
		if (eq(array[index], value)) {
					return index;
		}
			}
			return -1;
	}
	function sortedUniq(array) {
			return array && array.length ? baseSortedUniq(array) : [];
	}
	function sortedUniqBy(array, iteratee) {
			return array && array.length ? baseSortedUniq(array, getIteratee(iteratee, 2)) : [];
	}
	function tail(array) {
			var length = array == null ? 0 : array.length;
			return length ? baseSlice(array, 1, length) : [];
	}
	function take(array, n, guard) {
			if (!(array && array.length)) {
		return [];
			}
			n = guard || n === undefined ? 1 : toInteger(n);
			return baseSlice(array, 0, n < 0 ? 0 : n);
	}
	function takeRight(array, n, guard) {
			var length = array == null ? 0 : array.length;
			if (!length) {
		return [];
			}
			n = guard || n === undefined ? 1 : toInteger(n);
			n = length - n;
			return baseSlice(array, n < 0 ? 0 : n, length);
	}
	function takeRightWhile(array, predicate) {
			return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
	}
	function takeWhile(array, predicate) {
			return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
	}
	var union = baseRest(function (arrays) {
			return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
	});
	var unionBy = baseRest(function (arrays) {
			var iteratee = last(arrays);
			if (isArrayLikeObject(iteratee)) {
		iteratee = undefined;
			}
			return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
	});
	var unionWith = baseRest(function (arrays) {
			var comparator = last(arrays);
			comparator = typeof comparator == 'function' ? comparator : undefined;
			return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
	});
	function uniq(array) {
			return array && array.length ? baseUniq(array) : [];
	}
	function uniqBy(array, iteratee) {
			return array && array.length ? baseUniq(array, getIteratee(iteratee, 2)) : [];
	}
	function uniqWith(array, comparator) {
			comparator = typeof comparator == 'function' ? comparator : undefined;
			return array && array.length ? baseUniq(array, undefined, comparator) : [];
	}
	function unzip(array) {
			if (!(array && array.length)) {
		return [];
			}
			var length = 0;
			array = arrayFilter(array, function (group) {
		if (isArrayLikeObject(group)) {
					length = nativeMax(group.length, length);
					return true;
		}
			});
			return baseTimes(length, function (index) {
		return arrayMap(array, baseProperty(index));
			});
	}
	function unzipWith(array, iteratee) {
			if (!(array && array.length)) {
		return [];
			}
			var result = unzip(array);
			if (iteratee == null) {
		return result;
			}
			return arrayMap(result, function (group) {
		return apply(iteratee, undefined, group);
			});
	}
	var without = baseRest(function (array, values) {
			return isArrayLikeObject(array) ? baseDifference(array, values) : [];
	});
	var xor = baseRest(function (arrays) {
			return baseXor(arrayFilter(arrays, isArrayLikeObject));
	});
	var xorBy = baseRest(function (arrays) {
			var iteratee = last(arrays);
			if (isArrayLikeObject(iteratee)) {
		iteratee = undefined;
			}
			return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
	});
	var xorWith = baseRest(function (arrays) {
			var comparator = last(arrays);
			comparator = typeof comparator == 'function' ? comparator : undefined;
			return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
	});
	var zip = baseRest(unzip);
	function zipObject(props, values) {
			return baseZipObject(props || [], values || [], assignValue);
	}
	function zipObjectDeep(props, values) {
			return baseZipObject(props || [], values || [], baseSet);
	}
	var zipWith = baseRest(function (arrays) {
			var length = arrays.length,
					iteratee = length > 1 ? arrays[length - 1] : undefined;

			iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
			return unzipWith(arrays, iteratee);
	});
	function chain(value) {
			var result = lodash(value);
			result.__chain__ = true;
			return result;
	}
	function tap(value, interceptor) {
			interceptor(value);
			return value;
	}
	function thru(value, interceptor) {
			return interceptor(value);
	}
	var wrapperAt = flatRest(function (paths) {
			var length = paths.length,
					start = length ? paths[0] : 0,
					value = this.__wrapped__,
					interceptor = function interceptor(object) {
		return baseAt(object, paths);
			};

			if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
		return this.thru(interceptor);
			}
			value = value.slice(start, +start + (length ? 1 : 0));
			value.__actions__.push({
		'func': thru,
		'args': [interceptor],
		'thisArg': undefined
			});
			return new LodashWrapper(value, this.__chain__).thru(function (array) {
		if (length && !array.length) {
					array.push(undefined);
		}
		return array;
			});
	});
	function wrapperChain() {
			return chain(this);
	}
	function wrapperCommit() {
			return new LodashWrapper(this.value(), this.__chain__);
	}
	function wrapperNext() {
			if (this.__values__ === undefined) {
		this.__values__ = toArray(this.value());
			}
			var done = this.__index__ >= this.__values__.length,
					value = done ? undefined : this.__values__[this.__index__++];

			return { 'done': done, 'value': value };
	}
	function wrapperToIterator() {
			return this;
	}
	function wrapperPlant(value) {
			var result,
					parent = this;

			while (parent instanceof baseLodash) {
		var clone = wrapperClone(parent);
		clone.__index__ = 0;
		clone.__values__ = undefined;
		if (result) {
					previous.__wrapped__ = clone;
		} else {
					result = clone;
		}
		var previous = clone;
		parent = parent.__wrapped__;
			}
			previous.__wrapped__ = value;
			return result;
	}
	function wrapperReverse() {
			var value = this.__wrapped__;
			if (value instanceof LazyWrapper) {
		var wrapped = value;
		if (this.__actions__.length) {
					wrapped = new LazyWrapper(this);
		}
		wrapped = wrapped.reverse();
		wrapped.__actions__.push({
					'func': thru,
					'args': [reverse],
					'thisArg': undefined
		});
		return new LodashWrapper(wrapped, this.__chain__);
			}
			return this.thru(reverse);
	}
	function wrapperValue() {
			return baseWrapperValue(this.__wrapped__, this.__actions__);
	}
	var countBy = createAggregator(function (result, value, key) {
			if (hasOwnProperty.call(result, key)) {
		++result[key];
			} else {
		baseAssignValue(result, key, 1);
			}
	});
	function every(collection, predicate, guard) {
			var func = isArray(collection) ? arrayEvery : baseEvery;
			if (guard && isIterateeCall(collection, predicate, guard)) {
		predicate = undefined;
			}
			return func(collection, getIteratee(predicate, 3));
	}
	function filter(collection, predicate) {
			var func = isArray(collection) ? arrayFilter : baseFilter;
			return func(collection, getIteratee(predicate, 3));
	}
	var find = createFind(findIndex);
	var findLast = createFind(findLastIndex);
	function flatMap(collection, iteratee) {
			return baseFlatten(map(collection, iteratee), 1);
	}
	function flatMapDeep(collection, iteratee) {
			return baseFlatten(map(collection, iteratee), INFINITY);
	}
	function flatMapDepth(collection, iteratee, depth) {
			depth = depth === undefined ? 1 : toInteger(depth);
			return baseFlatten(map(collection, iteratee), depth);
	}
	function forEach(collection, iteratee) {
			var func = isArray(collection) ? arrayEach : baseEach;
			return func(collection, getIteratee(iteratee, 3));
	}
	function forEachRight(collection, iteratee) {
			var func = isArray(collection) ? arrayEachRight : baseEachRight;
			return func(collection, getIteratee(iteratee, 3));
	}
	var groupBy = createAggregator(function (result, value, key) {
			if (hasOwnProperty.call(result, key)) {
		result[key].push(value);
			} else {
		baseAssignValue(result, key, [value]);
			}
	});
	function includes(collection, value, fromIndex, guard) {
			collection = isArrayLike(collection) ? collection : values(collection);
			fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;

			var length = collection.length;
			if (fromIndex < 0) {
		fromIndex = nativeMax(length + fromIndex, 0);
			}
			return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
	}
	var invokeMap = baseRest(function (collection, path, args) {
			var index = -1,
					isFunc = typeof path == 'function',
					result = isArrayLike(collection) ? Array(collection.length) : [];

			baseEach(collection, function (value) {
		result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
			});
			return result;
	});
	var keyBy = createAggregator(function (result, value, key) {
			baseAssignValue(result, key, value);
	});
	function map(collection, iteratee) {
			var func = isArray(collection) ? arrayMap : baseMap;
			return func(collection, getIteratee(iteratee, 3));
	}
	function orderBy(collection, iteratees, orders, guard) {
			if (collection == null) {
		return [];
			}
			if (!isArray(iteratees)) {
		iteratees = iteratees == null ? [] : [iteratees];
			}
			orders = guard ? undefined : orders;
			if (!isArray(orders)) {
		orders = orders == null ? [] : [orders];
			}
			return baseOrderBy(collection, iteratees, orders);
	}
	var partition = createAggregator(function (result, value, key) {
			result[key ? 0 : 1].push(value);
	}, function () {
			return [[], []];
	});
	function reduce(collection, iteratee, accumulator) {
			var func = isArray(collection) ? arrayReduce : baseReduce,
					initAccum = arguments.length < 3;

			return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
	}
	function reduceRight(collection, iteratee, accumulator) {
			var func = isArray(collection) ? arrayReduceRight : baseReduce,
					initAccum = arguments.length < 3;

			return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
	}
	function reject(collection, predicate) {
			var func = isArray(collection) ? arrayFilter : baseFilter;
			return func(collection, negate(getIteratee(predicate, 3)));
	}
	function sample(collection) {
			var func = isArray(collection) ? arraySample : baseSample;
			return func(collection);
	}
	function sampleSize(collection, n, guard) {
			if (guard ? isIterateeCall(collection, n, guard) : n === undefined) {
		n = 1;
			} else {
		n = toInteger(n);
			}
			var func = isArray(collection) ? arraySampleSize : baseSampleSize;
			return func(collection, n);
	}
	function shuffle(collection) {
			var func = isArray(collection) ? arrayShuffle : baseShuffle;
			return func(collection);
	}
	function size(collection) {
			if (collection == null) {
		return 0;
			}
			if (isArrayLike(collection)) {
		return isString(collection) ? stringSize(collection) : collection.length;
			}
			var tag = getTag(collection);
			if (tag == mapTag || tag == setTag) {
		return collection.size;
			}
			return baseKeys(collection).length;
	}
	function some(collection, predicate, guard) {
			var func = isArray(collection) ? arraySome : baseSome;
			if (guard && isIterateeCall(collection, predicate, guard)) {
		predicate = undefined;
			}
			return func(collection, getIteratee(predicate, 3));
	}
	var sortBy = baseRest(function (collection, iteratees) {
			if (collection == null) {
		return [];
			}
			var length = iteratees.length;
			if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
		iteratees = [];
			} else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
		iteratees = [iteratees[0]];
			}
			return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
	});
	var now = ctxNow || function () {
			return root.Date.now();
	};
	function after(n, func) {
			if (typeof func != 'function') {
		throw new TypeError(FUNC_ERROR_TEXT);
			}
			n = toInteger(n);
			return function () {
		if (--n < 1) {
					return func.apply(this, arguments);
		}
			};
	}
	function ary(func, n, guard) {
			n = guard ? undefined : n;
			n = func && n == null ? func.length : n;
			return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
	}
	function before(n, func) {
			var result;
			if (typeof func != 'function') {
		throw new TypeError(FUNC_ERROR_TEXT);
			}
			n = toInteger(n);
			return function () {
		if (--n > 0) {
					result = func.apply(this, arguments);
		}
		if (n <= 1) {
					func = undefined;
		}
		return result;
			};
	}
	var bind = baseRest(function (func, thisArg, partials) {
			var bitmask = WRAP_BIND_FLAG;
			if (partials.length) {
		var holders = replaceHolders(partials, getHolder(bind));
		bitmask |= WRAP_PARTIAL_FLAG;
			}
			return createWrap(func, bitmask, thisArg, partials, holders);
	});
	var bindKey = baseRest(function (object, key, partials) {
			var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
			if (partials.length) {
		var holders = replaceHolders(partials, getHolder(bindKey));
		bitmask |= WRAP_PARTIAL_FLAG;
			}
			return createWrap(key, bitmask, object, partials, holders);
	});
	function curry(func, arity, guard) {
			arity = guard ? undefined : arity;
			var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
			result.placeholder = curry.placeholder;
			return result;
	}
	function curryRight(func, arity, guard) {
			arity = guard ? undefined : arity;
			var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
			result.placeholder = curryRight.placeholder;
			return result;
	}
	function debounce(func, wait, options) {
			var lastArgs,
					lastThis,
					maxWait,
					result,
					timerId,
					lastCallTime,
					lastInvokeTime = 0,
					leading = false,
					maxing = false,
					trailing = true;

			if (typeof func != 'function') {
		throw new TypeError(FUNC_ERROR_TEXT);
			}
			wait = toNumber(wait) || 0;
			if (isObject(options)) {
		leading = !!options.leading;
		maxing = 'maxWait' in options;
		maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
		trailing = 'trailing' in options ? !!options.trailing : trailing;
			}

			function invokeFunc(time) {
		var args = lastArgs,
			thisArg = lastThis;

		lastArgs = lastThis = undefined;
		lastInvokeTime = time;
		result = func.apply(thisArg, args);
		return result;
			}

			function leadingEdge(time) {
		lastInvokeTime = time;
		timerId = setTimeout(timerExpired, wait);
		return leading ? invokeFunc(time) : result;
			}

			function remainingWait(time) {
		var timeSinceLastCall = time - lastCallTime,
			timeSinceLastInvoke = time - lastInvokeTime,
			result = wait - timeSinceLastCall;

		return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
			}

			function shouldInvoke(time) {
		var timeSinceLastCall = time - lastCallTime,
			timeSinceLastInvoke = time - lastInvokeTime;
		return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
			}

			function timerExpired() {
		var time = now();
		if (shouldInvoke(time)) {
					return trailingEdge(time);
		}
		timerId = setTimeout(timerExpired, remainingWait(time));
			}

			function trailingEdge(time) {
		timerId = undefined;
		if (trailing && lastArgs) {
					return invokeFunc(time);
		}
		lastArgs = lastThis = undefined;
		return result;
			}

			function cancel() {
		if (timerId !== undefined) {
					clearTimeout(timerId);
		}
		lastInvokeTime = 0;
		lastArgs = lastCallTime = lastThis = timerId = undefined;
			}

			function flush() {
		return timerId === undefined ? result : trailingEdge(now());
			}

			function debounced() {
		var time = now(),
			isInvoking = shouldInvoke(time);

		lastArgs = arguments;
		lastThis = this;
		lastCallTime = time;

		if (isInvoking) {
					if (timerId === undefined) {
			return leadingEdge(lastCallTime);
					}
					if (maxing) {
			timerId = setTimeout(timerExpired, wait);
			return invokeFunc(lastCallTime);
					}
		}
		if (timerId === undefined) {
					timerId = setTimeout(timerExpired, wait);
		}
		return result;
			}
			debounced.cancel = cancel;
			debounced.flush = flush;
			return debounced;
	}
	var defer = baseRest(function (func, args) {
			return baseDelay(func, 1, args);
	});
	var delay = baseRest(function (func, wait, args) {
			return baseDelay(func, toNumber(wait) || 0, args);
	});
	function flip(func) {
			return createWrap(func, WRAP_FLIP_FLAG);
	}
	function memoize(func, resolver) {
			if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
		throw new TypeError(FUNC_ERROR_TEXT);
			}
			var memoized = function memoized() {
		var args = arguments,
			key = resolver ? resolver.apply(this, args) : args[0],
			cache = memoized.cache;

		if (cache.has(key)) {
					return cache.get(key);
		}
		var result = func.apply(this, args);
		memoized.cache = cache.set(key, result) || cache;
		return result;
			};
			memoized.cache = new (memoize.Cache || MapCache)();
			return memoized;
	}
	memoize.Cache = MapCache;
	function negate(predicate) {
			if (typeof predicate != 'function') {
		throw new TypeError(FUNC_ERROR_TEXT);
			}
			return function () {
		var args = arguments;
		switch (args.length) {
					case 0:
			return !predicate.call(this);
					case 1:
			return !predicate.call(this, args[0]);
					case 2:
			return !predicate.call(this, args[0], args[1]);
					case 3:
			return !predicate.call(this, args[0], args[1], args[2]);
		}
		return !predicate.apply(this, args);
			};
	}
	function once(func) {
			return before(2, func);
	}
	var overArgs = castRest(function (func, transforms) {
			transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

			var funcsLength = transforms.length;
			return baseRest(function (args) {
		var index = -1,
			length = nativeMin(args.length, funcsLength);

		while (++index < length) {
					args[index] = transforms[index].call(this, args[index]);
		}
		return apply(func, this, args);
			});
	});
	var partial = baseRest(function (func, partials) {
			var holders = replaceHolders(partials, getHolder(partial));
			return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
	});
	var partialRight = baseRest(function (func, partials) {
			var holders = replaceHolders(partials, getHolder(partialRight));
			return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
	});
	var rearg = flatRest(function (func, indexes) {
			return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
	});
	function rest(func, start) {
			if (typeof func != 'function') {
		throw new TypeError(FUNC_ERROR_TEXT);
			}
			start = start === undefined ? start : toInteger(start);
			return baseRest(func, start);
	}
	function spread(func, start) {
			if (typeof func != 'function') {
		throw new TypeError(FUNC_ERROR_TEXT);
			}
			start = start == null ? 0 : nativeMax(toInteger(start), 0);
			return baseRest(function (args) {
		var array = args[start],
			otherArgs = castSlice(args, 0, start);

		if (array) {
					arrayPush(otherArgs, array);
		}
		return apply(func, this, otherArgs);
			});
	}
	function throttle(func, wait, options) {
			var leading = true,
					trailing = true;

			if (typeof func != 'function') {
		throw new TypeError(FUNC_ERROR_TEXT);
			}
			if (isObject(options)) {
		leading = 'leading' in options ? !!options.leading : leading;
		trailing = 'trailing' in options ? !!options.trailing : trailing;
			}
			return debounce(func, wait, {
		'leading': leading,
		'maxWait': wait,
		'trailing': trailing
			});
	}
	function unary(func) {
			return ary(func, 1);
	}
	function wrap(value, wrapper) {
			return partial(castFunction(wrapper), value);
	}
	function castArray() {
			if (!arguments.length) {
		return [];
			}
			var value = arguments[0];
			return isArray(value) ? value : [value];
	}
	function clone(value) {
			return baseClone(value, CLONE_SYMBOLS_FLAG);
	}
	function cloneWith(value, customizer) {
			customizer = typeof customizer == 'function' ? customizer : undefined;
			return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
	}
	function cloneDeep(value) {
			return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
	}
	function cloneDeepWith(value, customizer) {
			customizer = typeof customizer == 'function' ? customizer : undefined;
			return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
	}
	function conformsTo(object, source) {
			return source == null || baseConformsTo(object, source, keys(source));
	}
	function eq(value, other) {
			return value === other || value !== value && other !== other;
	}
	var gt = createRelationalOperation(baseGt);
	var gte = createRelationalOperation(function (value, other) {
			return value >= other;
	});
	var isArguments = baseIsArguments(function () {
			return arguments;
	}()) ? baseIsArguments : function (value) {
			return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
	};
	var isArray = Array.isArray;
	var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
	function isArrayLike(value) {
			return value != null && isLength(value.length) && !isFunction(value);
	}
	function isArrayLikeObject(value) {
			return isObjectLike(value) && isArrayLike(value);
	}
	function isBoolean(value) {
			return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
	}
	var isBuffer = nativeIsBuffer || stubFalse;
	var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
	function isElement(value) {
			return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
	}
	function isEmpty(value) {
			if (value == null) {
		return true;
			}
			if (isArrayLike(value) && (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
		return !value.length;
			}
			var tag = getTag(value);
			if (tag == mapTag || tag == setTag) {
		return !value.size;
			}
			if (isPrototype(value)) {
		return !baseKeys(value).length;
			}
			for (var key in value) {
		if (hasOwnProperty.call(value, key)) {
					return false;
		}
			}
			return true;
	}
	function isEqual(value, other) {
			return baseIsEqual(value, other);
	}
	function isEqualWith(value, other, customizer) {
			customizer = typeof customizer == 'function' ? customizer : undefined;
			var result = customizer ? customizer(value, other) : undefined;
			return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
	}
	function isError(value) {
			if (!isObjectLike(value)) {
		return false;
			}
			var tag = baseGetTag(value);
			return tag == errorTag || tag == domExcTag || typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value);
	}
	function isFinite(value) {
			return typeof value == 'number' && nativeIsFinite(value);
	}
	function isFunction(value) {
			if (!isObject(value)) {
		return false;
			}
			var tag = baseGetTag(value);
			return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}
	function isInteger(value) {
			return typeof value == 'number' && value == toInteger(value);
	}
	function isLength(value) {
			return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	function isObject(value) {
			var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
			return value != null && (type == 'object' || type == 'function');
	}
	function isObjectLike(value) {
			return value != null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
	}
	var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
	function isMatch(object, source) {
			return object === source || baseIsMatch(object, source, getMatchData(source));
	}
	function isMatchWith(object, source, customizer) {
			customizer = typeof customizer == 'function' ? customizer : undefined;
			return baseIsMatch(object, source, getMatchData(source), customizer);
	}
	function isNaN(value) {
			return isNumber(value) && value != +value;
	}
	function isNative(value) {
			if (isMaskable(value)) {
		throw new Error(CORE_ERROR_TEXT);
			}
			return baseIsNative(value);
	}
	function isNull(value) {
			return value === null;
	}
	function isNil(value) {
			return value == null;
	}
	function isNumber(value) {
			return typeof value == 'number' || isObjectLike(value) && baseGetTag(value) == numberTag;
	}
	function isPlainObject(value) {
			if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
		return false;
			}
			var proto = getPrototype(value);
			if (proto === null) {
		return true;
			}
			var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
			return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
	}
	var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
	function isSafeInteger(value) {
			return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
	}
	var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
	function isString(value) {
			return typeof value == 'string' || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
	}
	function isSymbol(value) {
			return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
	}
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
	function isUndefined(value) {
			return value === undefined;
	}
	function isWeakMap(value) {
			return isObjectLike(value) && getTag(value) == weakMapTag;
	}
	function isWeakSet(value) {
			return isObjectLike(value) && baseGetTag(value) == weakSetTag;
	}
	var lt = createRelationalOperation(baseLt);
	var lte = createRelationalOperation(function (value, other) {
			return value <= other;
	});
	function toArray(value) {
			if (!value) {
		return [];
			}
			if (isArrayLike(value)) {
		return isString(value) ? stringToArray(value) : copyArray(value);
			}
			if (symIterator && value[symIterator]) {
		return iteratorToArray(value[symIterator]());
			}
			var tag = getTag(value),
					func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;

			return func(value);
	}
	function toFinite(value) {
			if (!value) {
		return value === 0 ? value : 0;
			}
			value = toNumber(value);
			if (value === INFINITY || value === -INFINITY) {
		var sign = value < 0 ? -1 : 1;
		return sign * MAX_INTEGER;
			}
			return value === value ? value : 0;
	}
	function toInteger(value) {
			var result = toFinite(value),
					remainder = result % 1;

			return result === result ? remainder ? result - remainder : result : 0;
	}
	function toLength(value) {
			return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
	}
	function toNumber(value) {
			if (typeof value == 'number') {
		return value;
			}
			if (isSymbol(value)) {
		return NAN;
			}
			if (isObject(value)) {
		var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
		value = isObject(other) ? other + '' : other;
			}
			if (typeof value != 'string') {
		return value === 0 ? value : +value;
			}
			value = value.replace(reTrim, '');
			var isBinary = reIsBinary.test(value);
			return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
	}
	function toPlainObject(value) {
			return copyObject(value, keysIn(value));
	}
	function toSafeInteger(value) {
			return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
	}
	function toString(value) {
			return value == null ? '' : baseToString(value);
	}
	var assign = createAssigner(function (object, source) {
			if (isPrototype(source) || isArrayLike(source)) {
		copyObject(source, keys(source), object);
		return;
			}
			for (var key in source) {
		if (hasOwnProperty.call(source, key)) {
					assignValue(object, key, source[key]);
		}
			}
	});
	var assignIn = createAssigner(function (object, source) {
			copyObject(source, keysIn(source), object);
	});
	var assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
			copyObject(source, keysIn(source), object, customizer);
	});
	var assignWith = createAssigner(function (object, source, srcIndex, customizer) {
			copyObject(source, keys(source), object, customizer);
	});
	var at = flatRest(baseAt);
	function create(prototype, properties) {
			var result = baseCreate(prototype);
			return properties == null ? result : baseAssign(result, properties);
	}
	var defaults = baseRest(function (args) {
			args.push(undefined, customDefaultsAssignIn);
			return apply(assignInWith, undefined, args);
	});
	var defaultsDeep = baseRest(function (args) {
			args.push(undefined, customDefaultsMerge);
			return apply(mergeWith, undefined, args);
	});
	function findKey(object, predicate) {
			return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
	}
	function findLastKey(object, predicate) {
			return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
	}
	function forIn(object, iteratee) {
			return object == null ? object : baseFor(object, getIteratee(iteratee, 3), keysIn);
	}
	function forInRight(object, iteratee) {
			return object == null ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn);
	}
	function forOwn(object, iteratee) {
			return object && baseForOwn(object, getIteratee(iteratee, 3));
	}
	function forOwnRight(object, iteratee) {
			return object && baseForOwnRight(object, getIteratee(iteratee, 3));
	}
	function functions(object) {
			return object == null ? [] : baseFunctions(object, keys(object));
	}
	function functionsIn(object) {
			return object == null ? [] : baseFunctions(object, keysIn(object));
	}
	function get(object, path, defaultValue) {
			var result = object == null ? undefined : baseGet(object, path);
			return result === undefined ? defaultValue : result;
	}
	function has(object, path) {
			return object != null && hasPath(object, path, baseHas);
	}
	function hasIn(object, path) {
			return object != null && hasPath(object, path, baseHasIn);
	}
	var invert = createInverter(function (result, value, key) {
			result[value] = key;
	}, constant(identity));
	var invertBy = createInverter(function (result, value, key) {
			if (hasOwnProperty.call(result, value)) {
		result[value].push(key);
			} else {
		result[value] = [key];
			}
	}, getIteratee);
	var invoke = baseRest(baseInvoke);
	function keys(object) {
			return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}
	function keysIn(object) {
			return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	}
	function mapKeys(object, iteratee) {
			var result = {};
			iteratee = getIteratee(iteratee, 3);

			baseForOwn(object, function (value, key, object) {
		baseAssignValue(result, iteratee(value, key, object), value);
			});
			return result;
	}
	function mapValues(object, iteratee) {
			var result = {};
			iteratee = getIteratee(iteratee, 3);

			baseForOwn(object, function (value, key, object) {
		baseAssignValue(result, key, iteratee(value, key, object));
			});
			return result;
	}
	var merge = createAssigner(function (object, source, srcIndex) {
			baseMerge(object, source, srcIndex);
	});
	var mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
			baseMerge(object, source, srcIndex, customizer);
	});
	var omit = flatRest(function (object, paths) {
			var result = {};
			if (object == null) {
		return result;
			}
			var isDeep = false;
			paths = arrayMap(paths, function (path) {
		path = castPath(path, object);
		isDeep || (isDeep = path.length > 1);
		return path;
			});
			copyObject(object, getAllKeysIn(object), result);
			if (isDeep) {
		result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
			}
			var length = paths.length;
			while (length--) {
		baseUnset(result, paths[length]);
			}
			return result;
	});
	function omitBy(object, predicate) {
			return pickBy(object, negate(getIteratee(predicate)));
	}
	var pick = flatRest(function (object, paths) {
			return object == null ? {} : basePick(object, paths);
	});
	function pickBy(object, predicate) {
			if (object == null) {
		return {};
			}
			var props = arrayMap(getAllKeysIn(object), function (prop) {
		return [prop];
			});
			predicate = getIteratee(predicate);
			return basePickBy(object, props, function (value, path) {
		return predicate(value, path[0]);
			});
	}
	function result(object, path, defaultValue) {
			path = castPath(path, object);

			var index = -1,
					length = path.length;
			if (!length) {
		length = 1;
		object = undefined;
			}
			while (++index < length) {
		var value = object == null ? undefined : object[toKey(path[index])];
		if (value === undefined) {
					index = length;
					value = defaultValue;
		}
		object = isFunction(value) ? value.call(object) : value;
			}
			return object;
	}
	function set(object, path, value) {
			return object == null ? object : baseSet(object, path, value);
	}
	function setWith(object, path, value, customizer) {
			customizer = typeof customizer == 'function' ? customizer : undefined;
			return object == null ? object : baseSet(object, path, value, customizer);
	}
	var toPairs = createToPairs(keys);
	var toPairsIn = createToPairs(keysIn);
	function transform(object, iteratee, accumulator) {
			var isArr = isArray(object),
					isArrLike = isArr || isBuffer(object) || isTypedArray(object);

			iteratee = getIteratee(iteratee, 4);
			if (accumulator == null) {
		var Ctor = object && object.constructor;
		if (isArrLike) {
					accumulator = isArr ? new Ctor() : [];
		} else if (isObject(object)) {
					accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
		} else {
					accumulator = {};
		}
			}
			(isArrLike ? arrayEach : baseForOwn)(object, function (value, index, object) {
		return iteratee(accumulator, value, index, object);
			});
			return accumulator;
	}
	function unset(object, path) {
			return object == null ? true : baseUnset(object, path);
	}
	function update(object, path, updater) {
			return object == null ? object : baseUpdate(object, path, castFunction(updater));
	}
	function updateWith(object, path, updater, customizer) {
			customizer = typeof customizer == 'function' ? customizer : undefined;
			return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
	}
	function values(object) {
			return object == null ? [] : baseValues(object, keys(object));
	}
	function valuesIn(object) {
			return object == null ? [] : baseValues(object, keysIn(object));
	}
	function clamp(number, lower, upper) {
			if (upper === undefined) {
		upper = lower;
		lower = undefined;
			}
			if (upper !== undefined) {
		upper = toNumber(upper);
		upper = upper === upper ? upper : 0;
			}
			if (lower !== undefined) {
		lower = toNumber(lower);
		lower = lower === lower ? lower : 0;
			}
			return baseClamp(toNumber(number), lower, upper);
	}
	function inRange(number, start, end) {
			start = toFinite(start);
			if (end === undefined) {
		end = start;
		start = 0;
			} else {
		end = toFinite(end);
			}
			number = toNumber(number);
			return baseInRange(number, start, end);
	}
	function random(lower, upper, floating) {
			if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
		upper = floating = undefined;
			}
			if (floating === undefined) {
		if (typeof upper == 'boolean') {
					floating = upper;
					upper = undefined;
		} else if (typeof lower == 'boolean') {
					floating = lower;
					lower = undefined;
		}
			}
			if (lower === undefined && upper === undefined) {
		lower = 0;
		upper = 1;
			} else {
		lower = toFinite(lower);
		if (upper === undefined) {
					upper = lower;
					lower = 0;
		} else {
					upper = toFinite(upper);
		}
			}
			if (lower > upper) {
		var temp = lower;
		lower = upper;
		upper = temp;
			}
			if (floating || lower % 1 || upper % 1) {
		var rand = nativeRandom();
		return nativeMin(lower + rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1))), upper);
			}
			return baseRandom(lower, upper);
	}
	var camelCase = createCompounder(function (result, word, index) {
			word = word.toLowerCase();
			return result + (index ? capitalize(word) : word);
	});
	function capitalize(string) {
			return upperFirst(toString(string).toLowerCase());
	}
	function deburr(string) {
			string = toString(string);
			return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
	}
	function endsWith(string, target, position) {
			string = toString(string);
			target = baseToString(target);

			var length = string.length;
			position = position === undefined ? length : baseClamp(toInteger(position), 0, length);

			var end = position;
			position -= target.length;
			return position >= 0 && string.slice(position, end) == target;
	}
	function escape(string) {
			string = toString(string);
			return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
	}
	function escapeRegExp(string) {
			string = toString(string);
			return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, '\\$&') : string;
	}
	var kebabCase = createCompounder(function (result, word, index) {
			return result + (index ? '-' : '') + word.toLowerCase();
	});
	var lowerCase = createCompounder(function (result, word, index) {
			return result + (index ? ' ' : '') + word.toLowerCase();
	});
	var lowerFirst = createCaseFirst('toLowerCase');
	function pad(string, length, chars) {
			string = toString(string);
			length = toInteger(length);

			var strLength = length ? stringSize(string) : 0;
			if (!length || strLength >= length) {
		return string;
			}
			var mid = (length - strLength) / 2;
			return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
	}
	function padEnd(string, length, chars) {
			string = toString(string);
			length = toInteger(length);

			var strLength = length ? stringSize(string) : 0;
			return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
	}
	function padStart(string, length, chars) {
			string = toString(string);
			length = toInteger(length);

			var strLength = length ? stringSize(string) : 0;
			return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
	}
	function parseInt(string, radix, guard) {
			if (guard || radix == null) {
		radix = 0;
			} else if (radix) {
		radix = +radix;
			}
			return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
	}
	function repeat(string, n, guard) {
			if (guard ? isIterateeCall(string, n, guard) : n === undefined) {
		n = 1;
			} else {
		n = toInteger(n);
			}
			return baseRepeat(toString(string), n);
	}
	function replace() {
			var args = arguments,
					string = toString(args[0]);

			return args.length < 3 ? string : string.replace(args[1], args[2]);
	}
	var snakeCase = createCompounder(function (result, word, index) {
			return result + (index ? '_' : '') + word.toLowerCase();
	});
	function split(string, separator, limit) {
			if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
		separator = limit = undefined;
			}
			limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
			if (!limit) {
		return [];
			}
			string = toString(string);
			if (string && (typeof separator == 'string' || separator != null && !isRegExp(separator))) {
		separator = baseToString(separator);
		if (!separator && hasUnicode(string)) {
					return castSlice(stringToArray(string), 0, limit);
		}
			}
			return string.split(separator, limit);
	}
	var startCase = createCompounder(function (result, word, index) {
			return result + (index ? ' ' : '') + upperFirst(word);
	});
	function startsWith(string, target, position) {
			string = toString(string);
			position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);

			target = baseToString(target);
			return string.slice(position, position + target.length) == target;
	}
	function template(string, options, guard) {
			var settings = lodash.templateSettings;

			if (guard && isIterateeCall(string, options, guard)) {
		options = undefined;
			}
			string = toString(string);
			options = assignInWith({}, options, settings, customDefaultsAssignIn);

			var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
					importsKeys = keys(imports),
					importsValues = baseValues(imports, importsKeys);

			var isEscaping,
					isEvaluating,
					index = 0,
					interpolate = options.interpolate || reNoMatch,
					source = "__p += '";
			var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
			var sourceURL = '//# sourceURL=' + ('sourceURL' in options ? options.sourceURL : 'lodash.templateSources[' + ++templateCounter + ']') + '\n';

			string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
		interpolateValue || (interpolateValue = esTemplateValue);
		source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
		if (escapeValue) {
					isEscaping = true;
					source += "' +\n__e(" + escapeValue + ") +\n'";
		}
		if (evaluateValue) {
					isEvaluating = true;
					source += "';\n" + evaluateValue + ";\n__p += '";
		}
		if (interpolateValue) {
					source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
		}
		index = offset + match.length;
		return match;
			});

			source += "';\n";
			var variable = options.variable;
			if (!variable) {
		source = 'with (obj) {\n' + source + '\n}\n';
			}
			source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
			source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';

			var result = attempt(function () {
		return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
			});
			result.source = source;
			if (isError(result)) {
		throw result;
			}
			return result;
	}
	function toLower(value) {
			return toString(value).toLowerCase();
	}
	function toUpper(value) {
			return toString(value).toUpperCase();
	}
	function trim(string, chars, guard) {
			string = toString(string);
			if (string && (guard || chars === undefined)) {
		return string.replace(reTrim, '');
			}
			if (!string || !(chars = baseToString(chars))) {
		return string;
			}
			var strSymbols = stringToArray(string),
					chrSymbols = stringToArray(chars),
					start = charsStartIndex(strSymbols, chrSymbols),
					end = charsEndIndex(strSymbols, chrSymbols) + 1;

			return castSlice(strSymbols, start, end).join('');
	}
	function trimEnd(string, chars, guard) {
			string = toString(string);
			if (string && (guard || chars === undefined)) {
		return string.replace(reTrimEnd, '');
			}
			if (!string || !(chars = baseToString(chars))) {
		return string;
			}
			var strSymbols = stringToArray(string),
					end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

			return castSlice(strSymbols, 0, end).join('');
	}
	function trimStart(string, chars, guard) {
			string = toString(string);
			if (string && (guard || chars === undefined)) {
		return string.replace(reTrimStart, '');
			}
			if (!string || !(chars = baseToString(chars))) {
		return string;
			}
			var strSymbols = stringToArray(string),
					start = charsStartIndex(strSymbols, stringToArray(chars));

			return castSlice(strSymbols, start).join('');
	}
	function truncate(string, options) {
			var length = DEFAULT_TRUNC_LENGTH,
					omission = DEFAULT_TRUNC_OMISSION;

			if (isObject(options)) {
		var separator = 'separator' in options ? options.separator : separator;
		length = 'length' in options ? toInteger(options.length) : length;
		omission = 'omission' in options ? baseToString(options.omission) : omission;
			}
			string = toString(string);

			var strLength = string.length;
			if (hasUnicode(string)) {
		var strSymbols = stringToArray(string);
		strLength = strSymbols.length;
			}
			if (length >= strLength) {
		return string;
			}
			var end = length - stringSize(omission);
			if (end < 1) {
		return omission;
			}
			var result = strSymbols ? castSlice(strSymbols, 0, end).join('') : string.slice(0, end);

			if (separator === undefined) {
		return result + omission;
			}
			if (strSymbols) {
		end += result.length - end;
			}
			if (isRegExp(separator)) {
		if (string.slice(end).search(separator)) {
					var match,
							substring = result;

					if (!separator.global) {
			separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
					}
					separator.lastIndex = 0;
					while (match = separator.exec(substring)) {
			var newEnd = match.index;
					}
					result = result.slice(0, newEnd === undefined ? end : newEnd);
		}
			} else if (string.indexOf(baseToString(separator), end) != end) {
		var index = result.lastIndexOf(separator);
		if (index > -1) {
					result = result.slice(0, index);
		}
			}
			return result + omission;
	}
	function unescape(string) {
			string = toString(string);
			return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
	}
	var upperCase = createCompounder(function (result, word, index) {
			return result + (index ? ' ' : '') + word.toUpperCase();
	});
	var upperFirst = createCaseFirst('toUpperCase');
	function words(string, pattern, guard) {
			string = toString(string);
			pattern = guard ? undefined : pattern;

			if (pattern === undefined) {
		return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
			}
			return string.match(pattern) || [];
	}
	var attempt = baseRest(function (func, args) {
			try {
		return apply(func, undefined, args);
			} catch (e) {
		return isError(e) ? e : new Error(e);
			}
	});
	var bindAll = flatRest(function (object, methodNames) {
			arrayEach(methodNames, function (key) {
		key = toKey(key);
		baseAssignValue(object, key, bind(object[key], object));
			});
			return object;
	});
	function cond(pairs) {
			var length = pairs == null ? 0 : pairs.length,
					toIteratee = getIteratee();

			pairs = !length ? [] : arrayMap(pairs, function (pair) {
		if (typeof pair[1] != 'function') {
					throw new TypeError(FUNC_ERROR_TEXT);
		}
		return [toIteratee(pair[0]), pair[1]];
			});

			return baseRest(function (args) {
		var index = -1;
		while (++index < length) {
					var pair = pairs[index];
					if (apply(pair[0], this, args)) {
			return apply(pair[1], this, args);
					}
		}
			});
	}
	function conforms(source) {
			return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
	}
	function constant(value) {
			return function () {
		return value;
			};
	}
	function defaultTo(value, defaultValue) {
			return value == null || value !== value ? defaultValue : value;
	}
	var flow = createFlow();
	var flowRight = createFlow(true);
	function identity(value) {
			return value;
	}
	function iteratee(func) {
			return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
	}
	function matches(source) {
			return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
	}
	function matchesProperty(path, srcValue) {
			return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
	}
	var method = baseRest(function (path, args) {
			return function (object) {
		return baseInvoke(object, path, args);
			};
	});
	var methodOf = baseRest(function (object, args) {
			return function (path) {
		return baseInvoke(object, path, args);
			};
	});
	function mixin(object, source, options) {
			var props = keys(source),
					methodNames = baseFunctions(source, props);

			if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
		options = source;
		source = object;
		object = this;
		methodNames = baseFunctions(source, keys(source));
			}
			var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
					isFunc = isFunction(object);

			arrayEach(methodNames, function (methodName) {
		var func = source[methodName];
		object[methodName] = func;
		if (isFunc) {
					object.prototype[methodName] = function () {
			var chainAll = this.__chain__;
			if (chain || chainAll) {
							var result = object(this.__wrapped__),
									actions = result.__actions__ = copyArray(this.__actions__);

							actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
							result.__chain__ = chainAll;
							return result;
			}
			return func.apply(object, arrayPush([this.value()], arguments));
					};
		}
			});

			return object;
	}
	function noConflict() {
			if (root._ === this) {
		root._ = oldDash;
			}
			return this;
	}
	function noop() {}
	function nthArg(n) {
			n = toInteger(n);
			return baseRest(function (args) {
		return baseNth(args, n);
			});
	}
	var over = createOver(arrayMap);
	var overEvery = createOver(arrayEvery);
	var overSome = createOver(arraySome);
	function property(path) {
			return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	}
	function propertyOf(object) {
			return function (path) {
		return object == null ? undefined : baseGet(object, path);
			};
	}
	var range = createRange();
	var rangeRight = createRange(true);
	function stubArray() {
			return [];
	}
	function stubFalse() {
			return false;
	}
	function stubObject() {
			return {};
	}
	function stubString() {
			return '';
	}
	function stubTrue() {
			return true;
	}
	function times(n, iteratee) {
			n = toInteger(n);
			if (n < 1 || n > MAX_SAFE_INTEGER) {
		return [];
			}
			var index = MAX_ARRAY_LENGTH,
					length = nativeMin(n, MAX_ARRAY_LENGTH);

			iteratee = getIteratee(iteratee);
			n -= MAX_ARRAY_LENGTH;

			var result = baseTimes(length, iteratee);
			while (++index < n) {
		iteratee(index);
			}
			return result;
	}
	function toPath(value) {
			if (isArray(value)) {
		return arrayMap(value, toKey);
			}
			return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
	}
	function uniqueId(prefix) {
			var id = ++idCounter;
			return toString(prefix) + id;
	}
	var add = createMathOperation(function (augend, addend) {
			return augend + addend;
	}, 0);
	var ceil = createRound('ceil');
	var divide = createMathOperation(function (dividend, divisor) {
			return dividend / divisor;
	}, 1);
	var floor = createRound('floor');
	function max(array) {
			return array && array.length ? baseExtremum(array, identity, baseGt) : undefined;
	}
	function maxBy(array, iteratee) {
			return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined;
	}
	function mean(array) {
			return baseMean(array, identity);
	}
	function meanBy(array, iteratee) {
			return baseMean(array, getIteratee(iteratee, 2));
	}
	function min(array) {
			return array && array.length ? baseExtremum(array, identity, baseLt) : undefined;
	}
	function minBy(array, iteratee) {
			return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined;
	}
	var multiply = createMathOperation(function (multiplier, multiplicand) {
			return multiplier * multiplicand;
	}, 1);
	var round = createRound('round');
	var subtract = createMathOperation(function (minuend, subtrahend) {
			return minuend - subtrahend;
	}, 0);
	function sum(array) {
			return array && array.length ? baseSum(array, identity) : 0;
	}
	function sumBy(array, iteratee) {
			return array && array.length ? baseSum(array, getIteratee(iteratee, 2)) : 0;
	}
	lodash.after = after;
	lodash.ary = ary;
	lodash.assign = assign;
	lodash.assignIn = assignIn;
	lodash.assignInWith = assignInWith;
	lodash.assignWith = assignWith;
	lodash.at = at;
	lodash.before = before;
	lodash.bind = bind;
	lodash.bindAll = bindAll;
	lodash.bindKey = bindKey;
	lodash.castArray = castArray;
	lodash.chain = chain;
	lodash.chunk = chunk;
	lodash.compact = compact;
	lodash.concat = concat;
	lodash.cond = cond;
	lodash.conforms = conforms;
	lodash.constant = constant;
	lodash.countBy = countBy;
	lodash.create = create;
	lodash.curry = curry;
	lodash.curryRight = curryRight;
	lodash.debounce = debounce;
	lodash.defaults = defaults;
	lodash.defaultsDeep = defaultsDeep;
	lodash.defer = defer;
	lodash.delay = delay;
	lodash.difference = difference;
	lodash.differenceBy = differenceBy;
	lodash.differenceWith = differenceWith;
	lodash.drop = drop;
	lodash.dropRight = dropRight;
	lodash.dropRightWhile = dropRightWhile;
	lodash.dropWhile = dropWhile;
	lodash.fill = fill;
	lodash.filter = filter;
	lodash.flatMap = flatMap;
	lodash.flatMapDeep = flatMapDeep;
	lodash.flatMapDepth = flatMapDepth;
	lodash.flatten = flatten;
	lodash.flattenDeep = flattenDeep;
	lodash.flattenDepth = flattenDepth;
	lodash.flip = flip;
	lodash.flow = flow;
	lodash.flowRight = flowRight;
	lodash.fromPairs = fromPairs;
	lodash.functions = functions;
	lodash.functionsIn = functionsIn;
	lodash.groupBy = groupBy;
	lodash.initial = initial;
	lodash.intersection = intersection;
	lodash.intersectionBy = intersectionBy;
	lodash.intersectionWith = intersectionWith;
	lodash.invert = invert;
	lodash.invertBy = invertBy;
	lodash.invokeMap = invokeMap;
	lodash.iteratee = iteratee;
	lodash.keyBy = keyBy;
	lodash.keys = keys;
	lodash.keysIn = keysIn;
	lodash.map = map;
	lodash.mapKeys = mapKeys;
	lodash.mapValues = mapValues;
	lodash.matches = matches;
	lodash.matchesProperty = matchesProperty;
	lodash.memoize = memoize;
	lodash.merge = merge;
	lodash.mergeWith = mergeWith;
	lodash.method = method;
	lodash.methodOf = methodOf;
	lodash.mixin = mixin;
	lodash.negate = negate;
	lodash.nthArg = nthArg;
	lodash.omit = omit;
	lodash.omitBy = omitBy;
	lodash.once = once;
	lodash.orderBy = orderBy;
	lodash.over = over;
	lodash.overArgs = overArgs;
	lodash.overEvery = overEvery;
	lodash.overSome = overSome;
	lodash.partial = partial;
	lodash.partialRight = partialRight;
	lodash.partition = partition;
	lodash.pick = pick;
	lodash.pickBy = pickBy;
	lodash.property = property;
	lodash.propertyOf = propertyOf;
	lodash.pull = pull;
	lodash.pullAll = pullAll;
	lodash.pullAllBy = pullAllBy;
	lodash.pullAllWith = pullAllWith;
	lodash.pullAt = pullAt;
	lodash.range = range;
	lodash.rangeRight = rangeRight;
	lodash.rearg = rearg;
	lodash.reject = reject;
	lodash.remove = remove;
	lodash.rest = rest;
	lodash.reverse = reverse;
	lodash.sampleSize = sampleSize;
	lodash.set = set;
	lodash.setWith = setWith;
	lodash.shuffle = shuffle;
	lodash.slice = slice;
	lodash.sortBy = sortBy;
	lodash.sortedUniq = sortedUniq;
	lodash.sortedUniqBy = sortedUniqBy;
	lodash.split = split;
	lodash.spread = spread;
	lodash.tail = tail;
	lodash.take = take;
	lodash.takeRight = takeRight;
	lodash.takeRightWhile = takeRightWhile;
	lodash.takeWhile = takeWhile;
	lodash.tap = tap;
	lodash.throttle = throttle;
	lodash.thru = thru;
	lodash.toArray = toArray;
	lodash.toPairs = toPairs;
	lodash.toPairsIn = toPairsIn;
	lodash.toPath = toPath;
	lodash.toPlainObject = toPlainObject;
	lodash.transform = transform;
	lodash.unary = unary;
	lodash.union = union;
	lodash.unionBy = unionBy;
	lodash.unionWith = unionWith;
	lodash.uniq = uniq;
	lodash.uniqBy = uniqBy;
	lodash.uniqWith = uniqWith;
	lodash.unset = unset;
	lodash.unzip = unzip;
	lodash.unzipWith = unzipWith;
	lodash.update = update;
	lodash.updateWith = updateWith;
	lodash.values = values;
	lodash.valuesIn = valuesIn;
	lodash.without = without;
	lodash.words = words;
	lodash.wrap = wrap;
	lodash.xor = xor;
	lodash.xorBy = xorBy;
	lodash.xorWith = xorWith;
	lodash.zip = zip;
	lodash.zipObject = zipObject;
	lodash.zipObjectDeep = zipObjectDeep;
	lodash.zipWith = zipWith;
	lodash.entries = toPairs;
	lodash.entriesIn = toPairsIn;
	lodash.extend = assignIn;
	lodash.extendWith = assignInWith;
	mixin(lodash, lodash);
	lodash.add = add;
	lodash.attempt = attempt;
	lodash.camelCase = camelCase;
	lodash.capitalize = capitalize;
	lodash.ceil = ceil;
	lodash.clamp = clamp;
	lodash.clone = clone;
	lodash.cloneDeep = cloneDeep;
	lodash.cloneDeepWith = cloneDeepWith;
	lodash.cloneWith = cloneWith;
	lodash.conformsTo = conformsTo;
	lodash.deburr = deburr;
	lodash.defaultTo = defaultTo;
	lodash.divide = divide;
	lodash.endsWith = endsWith;
	lodash.eq = eq;
	lodash.escape = escape;
	lodash.escapeRegExp = escapeRegExp;
	lodash.every = every;
	lodash.find = find;
	lodash.findIndex = findIndex;
	lodash.findKey = findKey;
	lodash.findLast = findLast;
	lodash.findLastIndex = findLastIndex;
	lodash.findLastKey = findLastKey;
	lodash.floor = floor;
	lodash.forEach = forEach;
	lodash.forEachRight = forEachRight;
	lodash.forIn = forIn;
	lodash.forInRight = forInRight;
	lodash.forOwn = forOwn;
	lodash.forOwnRight = forOwnRight;
	lodash.get = get;
	lodash.gt = gt;
	lodash.gte = gte;
	lodash.has = has;
	lodash.hasIn = hasIn;
	lodash.head = head;
	lodash.identity = identity;
	lodash.includes = includes;
	lodash.indexOf = indexOf;
	lodash.inRange = inRange;
	lodash.invoke = invoke;
	lodash.isArguments = isArguments;
	lodash.isArray = isArray;
	lodash.isArrayBuffer = isArrayBuffer;
	lodash.isArrayLike = isArrayLike;
	lodash.isArrayLikeObject = isArrayLikeObject;
	lodash.isBoolean = isBoolean;
	lodash.isBuffer = isBuffer;
	lodash.isDate = isDate;
	lodash.isElement = isElement;
	lodash.isEmpty = isEmpty;
	lodash.isEqual = isEqual;
	lodash.isEqualWith = isEqualWith;
	lodash.isError = isError;
	lodash.isFinite = isFinite;
	lodash.isFunction = isFunction;
	lodash.isInteger = isInteger;
	lodash.isLength = isLength;
	lodash.isMap = isMap;
	lodash.isMatch = isMatch;
	lodash.isMatchWith = isMatchWith;
	lodash.isNaN = isNaN;
	lodash.isNative = isNative;
	lodash.isNil = isNil;
	lodash.isNull = isNull;
	lodash.isNumber = isNumber;
	lodash.isObject = isObject;
	lodash.isObjectLike = isObjectLike;
	lodash.isPlainObject = isPlainObject;
	lodash.isRegExp = isRegExp;
	lodash.isSafeInteger = isSafeInteger;
	lodash.isSet = isSet;
	lodash.isString = isString;
	lodash.isSymbol = isSymbol;
	lodash.isTypedArray = isTypedArray;
	lodash.isUndefined = isUndefined;
	lodash.isWeakMap = isWeakMap;
	lodash.isWeakSet = isWeakSet;
	lodash.join = join;
	lodash.kebabCase = kebabCase;
	lodash.last = last;
	lodash.lastIndexOf = lastIndexOf;
	lodash.lowerCase = lowerCase;
	lodash.lowerFirst = lowerFirst;
	lodash.lt = lt;
	lodash.lte = lte;
	lodash.max = max;
	lodash.maxBy = maxBy;
	lodash.mean = mean;
	lodash.meanBy = meanBy;
	lodash.min = min;
	lodash.minBy = minBy;
	lodash.stubArray = stubArray;
	lodash.stubFalse = stubFalse;
	lodash.stubObject = stubObject;
	lodash.stubString = stubString;
	lodash.stubTrue = stubTrue;
	lodash.multiply = multiply;
	lodash.nth = nth;
	lodash.noConflict = noConflict;
	lodash.noop = noop;
	lodash.now = now;
	lodash.pad = pad;
	lodash.padEnd = padEnd;
	lodash.padStart = padStart;
	lodash.parseInt = parseInt;
	lodash.random = random;
	lodash.reduce = reduce;
	lodash.reduceRight = reduceRight;
	lodash.repeat = repeat;
	lodash.replace = replace;
	lodash.result = result;
	lodash.round = round;
	lodash.runInContext = runInContext;
	lodash.sample = sample;
	lodash.size = size;
	lodash.snakeCase = snakeCase;
	lodash.some = some;
	lodash.sortedIndex = sortedIndex;
	lodash.sortedIndexBy = sortedIndexBy;
	lodash.sortedIndexOf = sortedIndexOf;
	lodash.sortedLastIndex = sortedLastIndex;
	lodash.sortedLastIndexBy = sortedLastIndexBy;
	lodash.sortedLastIndexOf = sortedLastIndexOf;
	lodash.startCase = startCase;
	lodash.startsWith = startsWith;
	lodash.subtract = subtract;
	lodash.sum = sum;
	lodash.sumBy = sumBy;
	lodash.template = template;
	lodash.times = times;
	lodash.toFinite = toFinite;
	lodash.toInteger = toInteger;
	lodash.toLength = toLength;
	lodash.toLower = toLower;
	lodash.toNumber = toNumber;
	lodash.toSafeInteger = toSafeInteger;
	lodash.toString = toString;
	lodash.toUpper = toUpper;
	lodash.trim = trim;
	lodash.trimEnd = trimEnd;
	lodash.trimStart = trimStart;
	lodash.truncate = truncate;
	lodash.unescape = unescape;
	lodash.uniqueId = uniqueId;
	lodash.upperCase = upperCase;
	lodash.upperFirst = upperFirst;
	lodash.each = forEach;
	lodash.eachRight = forEachRight;
	lodash.first = head;

	mixin(lodash, function () {
			var source = {};
			baseForOwn(lodash, function (func, methodName) {
		if (!hasOwnProperty.call(lodash.prototype, methodName)) {
					source[methodName] = func;
		}
			});
			return source;
	}(), { 'chain': false });
	lodash.VERSION = VERSION;
	arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function (methodName) {
			lodash[methodName].placeholder = lodash;
	});
	arrayEach(['drop', 'take'], function (methodName, index) {
			LazyWrapper.prototype[methodName] = function (n) {
		n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

		var result = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();

		if (result.__filtered__) {
					result.__takeCount__ = nativeMin(n, result.__takeCount__);
		} else {
					result.__views__.push({
			'size': nativeMin(n, MAX_ARRAY_LENGTH),
			'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
					});
		}
		return result;
			};

			LazyWrapper.prototype[methodName + 'Right'] = function (n) {
		return this.reverse()[methodName](n).reverse();
			};
	});
	arrayEach(['filter', 'map', 'takeWhile'], function (methodName, index) {
			var type = index + 1,
					isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

			LazyWrapper.prototype[methodName] = function (iteratee) {
		var result = this.clone();
		result.__iteratees__.push({
					'iteratee': getIteratee(iteratee, 3),
					'type': type
		});
		result.__filtered__ = result.__filtered__ || isFilter;
		return result;
			};
	});
	arrayEach(['head', 'last'], function (methodName, index) {
			var takeName = 'take' + (index ? 'Right' : '');

			LazyWrapper.prototype[methodName] = function () {
		return this[takeName](1).value()[0];
			};
	});
	arrayEach(['initial', 'tail'], function (methodName, index) {
			var dropName = 'drop' + (index ? '' : 'Right');

			LazyWrapper.prototype[methodName] = function () {
		return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
			};
	});

	LazyWrapper.prototype.compact = function () {
			return this.filter(identity);
	};

	LazyWrapper.prototype.find = function (predicate) {
			return this.filter(predicate).head();
	};

	LazyWrapper.prototype.findLast = function (predicate) {
			return this.reverse().find(predicate);
	};

	LazyWrapper.prototype.invokeMap = baseRest(function (path, args) {
			if (typeof path == 'function') {
		return new LazyWrapper(this);
			}
			return this.map(function (value) {
		return baseInvoke(value, path, args);
			});
	});

	LazyWrapper.prototype.reject = function (predicate) {
			return this.filter(negate(getIteratee(predicate)));
	};

	LazyWrapper.prototype.slice = function (start, end) {
			start = toInteger(start);

			var result = this;
			if (result.__filtered__ && (start > 0 || end < 0)) {
		return new LazyWrapper(result);
			}
			if (start < 0) {
		result = result.takeRight(-start);
			} else if (start) {
		result = result.drop(start);
			}
			if (end !== undefined) {
		end = toInteger(end);
		result = end < 0 ? result.dropRight(-end) : result.take(end - start);
			}
			return result;
	};

	LazyWrapper.prototype.takeRightWhile = function (predicate) {
			return this.reverse().takeWhile(predicate).reverse();
	};

	LazyWrapper.prototype.toArray = function () {
			return this.take(MAX_ARRAY_LENGTH);
	};
	baseForOwn(LazyWrapper.prototype, function (func, methodName) {
			var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
					isTaker = /^(?:head|last)$/.test(methodName),
					lodashFunc = lodash[isTaker ? 'take' + (methodName == 'last' ? 'Right' : '') : methodName],
					retUnwrapped = isTaker || /^find/.test(methodName);

			if (!lodashFunc) {
		return;
			}
			lodash.prototype[methodName] = function () {
		var value = this.__wrapped__,
			args = isTaker ? [1] : arguments,
			isLazy = value instanceof LazyWrapper,
			iteratee = args[0],
			useLazy = isLazy || isArray(value);

		var interceptor = function interceptor(value) {
					var result = lodashFunc.apply(lodash, arrayPush([value], args));
					return isTaker && chainAll ? result[0] : result;
		};

		if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
					isLazy = useLazy = false;
		}
		var chainAll = this.__chain__,
			isHybrid = !!this.__actions__.length,
			isUnwrapped = retUnwrapped && !chainAll,
			onlyLazy = isLazy && !isHybrid;

		if (!retUnwrapped && useLazy) {
					value = onlyLazy ? value : new LazyWrapper(this);
					var result = func.apply(value, args);
					result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
					return new LodashWrapper(result, chainAll);
		}
		if (isUnwrapped && onlyLazy) {
					return func.apply(this, args);
		}
		result = this.thru(interceptor);
		return isUnwrapped ? isTaker ? result.value()[0] : result.value() : result;
			};
	});
	arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function (methodName) {
			var func = arrayProto[methodName],
					chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
					retUnwrapped = /^(?:pop|shift)$/.test(methodName);

			lodash.prototype[methodName] = function () {
		var args = arguments;
		if (retUnwrapped && !this.__chain__) {
					var value = this.value();
					return func.apply(isArray(value) ? value : [], args);
		}
		return this[chainName](function (value) {
					return func.apply(isArray(value) ? value : [], args);
		});
			};
	});
	baseForOwn(LazyWrapper.prototype, function (func, methodName) {
			var lodashFunc = lodash[methodName];
			if (lodashFunc) {
		var key = lodashFunc.name + '',
			names = realNames[key] || (realNames[key] = []);

		names.push({ 'name': methodName, 'func': lodashFunc });
			}
	});

	realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
			'name': 'wrapper',
			'func': undefined
	}];
	LazyWrapper.prototype.clone = lazyClone;
	LazyWrapper.prototype.reverse = lazyReverse;
	LazyWrapper.prototype.value = lazyValue;
	lodash.prototype.at = wrapperAt;
	lodash.prototype.chain = wrapperChain;
	lodash.prototype.commit = wrapperCommit;
	lodash.prototype.next = wrapperNext;
	lodash.prototype.plant = wrapperPlant;
	lodash.prototype.reverse = wrapperReverse;
	lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
	lodash.prototype.first = lodash.prototype.head;

	if (symIterator) {
			lodash.prototype[symIterator] = wrapperToIterator;
	}
	return lodash;
  };
  var _ = runInContext();
  if ("function" == 'function' && _typeof(__webpack_require__(157)) == 'object' && __webpack_require__(157)) {
	root._ = _;
	!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return _;
	}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
  else if (freeModule) {
			(freeModule.exports = _)._ = _;
			freeExports._ = _;
	} else {
			root._ = _;
	}
}).call(undefined);
}.call(exports, __webpack_require__(101), __webpack_require__(150)(module)))
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = !__webpack_require__(2)(function () {
  return Object.defineProperty({}, 'a', { get: function get() {
			return 7;
	} }).a != 7;
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var toInteger = __webpack_require__(29);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var core = module.exports = { version: '2.5.3' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(4);
var hide = __webpack_require__(17);
var has = __webpack_require__(14);
var SRC = __webpack_require__(36)('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__(13).inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
	O[key] = val;
  } else if (!safe) {
	delete O[key];
	hide(O, key, val);
  } else if (O[key]) {
	O[key] = val;
  } else {
	hide(O, key, val);
  }
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var fails = __webpack_require__(2);
var defined = __webpack_require__(34);
var quot = /"/g;
var createHTML = function createHTML(string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
	var test = ''[NAME]('"');
	return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var dP = __webpack_require__(9);
var createDesc = __webpack_require__(35);
module.exports = __webpack_require__(11) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var defined = __webpack_require__(34);
module.exports = function (it) {
  return Object(defined(it));
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var fails = __webpack_require__(2);

module.exports = function (method, arg) {
  return !!method && fails(function () {
	arg ? method.call(null, function () {/* empty */}, 1) : method.call(null);
  });
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var process = module.exports = {};
var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
	throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
	throw new Error('clearTimeout has not been defined');
}
(function () {
	try {
		if (typeof setTimeout === 'function') {
			cachedSetTimeout = setTimeout;
		} else {
			cachedSetTimeout = defaultSetTimout;
		}
	} catch (e) {
		cachedSetTimeout = defaultSetTimout;
	}
	try {
		if (typeof clearTimeout === 'function') {
			cachedClearTimeout = clearTimeout;
		} else {
			cachedClearTimeout = defaultClearTimeout;
		}
	} catch (e) {
		cachedClearTimeout = defaultClearTimeout;
	}
})();
function runTimeout(fun) {
	if (cachedSetTimeout === setTimeout) {
		return setTimeout(fun, 0);
	}
	if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
		cachedSetTimeout = setTimeout;
		return setTimeout(fun, 0);
	}
	try {
		return cachedSetTimeout(fun, 0);
	} catch (e) {
		try {
			return cachedSetTimeout.call(null, fun, 0);
		} catch (e) {
			return cachedSetTimeout.call(this, fun, 0);
		}
	}
}
function runClearTimeout(marker) {
	if (cachedClearTimeout === clearTimeout) {
		return clearTimeout(marker);
	}
	if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
		cachedClearTimeout = clearTimeout;
		return clearTimeout(marker);
	}
	try {
		return cachedClearTimeout(marker);
	} catch (e) {
		try {
			return cachedClearTimeout.call(null, marker);
		} catch (e) {
			return cachedClearTimeout.call(this, marker);
		}
	}
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
	if (!draining || !currentQueue) {
		return;
	}
	draining = false;
	if (currentQueue.length) {
		queue = currentQueue.concat(queue);
	} else {
		queueIndex = -1;
	}
	if (queue.length) {
		drainQueue();
	}
}

function drainQueue() {
	if (draining) {
		return;
	}
	var timeout = runTimeout(cleanUpNextTick);
	draining = true;

	var len = queue.length;
	while (len) {
		currentQueue = queue;
		queue = [];
		while (++queueIndex < len) {
			if (currentQueue) {
				currentQueue[queueIndex].run();
			}
		}
		queueIndex = -1;
		len = queue.length;
	}
	currentQueue = null;
	draining = false;
	runClearTimeout(timeout);
}

process.nextTick = function (fun) {
	var args = new Array(arguments.length - 1);
	if (arguments.length > 1) {
		for (var i = 1; i < arguments.length; i++) {
			args[i - 1] = arguments[i];
		}
	}
	queue.push(new Item(fun, args));
	if (queue.length === 1 && !draining) {
		runTimeout(drainQueue);
	}
};
function Item(fun, array) {
	this.fun = fun;
	this.array = array;
}
Item.prototype.run = function () {
	this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
	return [];
};

process.binding = function (name) {
	throw new Error('process.binding is not supported');
};

process.cwd = function () {
	return '/';
};
process.chdir = function (dir) {
	throw new Error('process.chdir is not supported');
};
process.umask = function () {
	return 0;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extract;
exports.extractLiteral = extractLiteral;

var _Literal = __webpack_require__(166);

var _Literal2 = _interopRequireDefault(_Literal);

var _JSXElement = __webpack_require__(167);

var _JSXElement2 = _interopRequireDefault(_JSXElement);

var _Identifier = __webpack_require__(685);

var _Identifier2 = _interopRequireDefault(_Identifier);

var _TaggedTemplateExpression = __webpack_require__(686);

var _TaggedTemplateExpression2 = _interopRequireDefault(_TaggedTemplateExpression);

var _TemplateLiteral = __webpack_require__(168);

var _TemplateLiteral2 = _interopRequireDefault(_TemplateLiteral);

var _FunctionExpression = __webpack_require__(687);

var _FunctionExpression2 = _interopRequireDefault(_FunctionExpression);

var _LogicalExpression = __webpack_require__(688);

var _LogicalExpression2 = _interopRequireDefault(_LogicalExpression);

var _MemberExpression = __webpack_require__(689);

var _MemberExpression2 = _interopRequireDefault(_MemberExpression);

var _CallExpression = __webpack_require__(690);

var _CallExpression2 = _interopRequireDefault(_CallExpression);

var _UnaryExpression = __webpack_require__(691);

var _UnaryExpression2 = _interopRequireDefault(_UnaryExpression);

var _ThisExpression = __webpack_require__(692);

var _ThisExpression2 = _interopRequireDefault(_ThisExpression);

var _ConditionalExpression = __webpack_require__(693);

var _ConditionalExpression2 = _interopRequireDefault(_ConditionalExpression);

var _BinaryExpression = __webpack_require__(694);

var _BinaryExpression2 = _interopRequireDefault(_BinaryExpression);

var _ObjectExpression = __webpack_require__(695);

var _ObjectExpression2 = _interopRequireDefault(_ObjectExpression);

var _NewExpression = __webpack_require__(696);

var _NewExpression2 = _interopRequireDefault(_NewExpression);

var _UpdateExpression = __webpack_require__(697);

var _UpdateExpression2 = _interopRequireDefault(_UpdateExpression);

var _ArrayExpression = __webpack_require__(698);

var _ArrayExpression2 = _interopRequireDefault(_ArrayExpression);

var _BindExpression = __webpack_require__(699);

var _BindExpression2 = _interopRequireDefault(_BindExpression);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var TYPES = {
  Identifier: _Identifier2.default,
  Literal: _Literal2.default,
  JSXElement: _JSXElement2.default,
  TaggedTemplateExpression: _TaggedTemplateExpression2.default,
  TemplateLiteral: _TemplateLiteral2.default,
  ArrowFunctionExpression: _FunctionExpression2.default,
  FunctionExpression: _FunctionExpression2.default,
  LogicalExpression: _LogicalExpression2.default,
  MemberExpression: _MemberExpression2.default,
  CallExpression: _CallExpression2.default,
  UnaryExpression: _UnaryExpression2.default,
  ThisExpression: _ThisExpression2.default,
  ConditionalExpression: _ConditionalExpression2.default,
  BinaryExpression: _BinaryExpression2.default,
  ObjectExpression: _ObjectExpression2.default,
  NewExpression: _NewExpression2.default,
  UpdateExpression: _UpdateExpression2.default,
  ArrayExpression: _ArrayExpression2.default,
  BindExpression: _BindExpression2.default
};

var noop = function noop() {
  return null;
};
var LITERAL_TYPES = Object.assign({}, TYPES, {
  Literal: function Literal(value) {
	var extractedVal = TYPES.Literal.call(undefined, value);
	var isNull = extractedVal === null;
	return isNull ? 'null' : extractedVal;
  },
  Identifier: function Identifier(value) {
	var isUndefined = TYPES.Identifier.call(undefined, value) === undefined;
	return isUndefined ? undefined : null;
  },
  JSXElement: noop,
  ArrowFunctionExpression: noop,
  FunctionExpression: noop,
  LogicalExpression: noop,
  MemberExpression: noop,
  CallExpression: noop,
  UnaryExpression: function UnaryExpression(value) {
	var extractedVal = TYPES.UnaryExpression.call(undefined, value);
	return extractedVal === undefined ? null : extractedVal;
  },
  UpdateExpression: function UpdateExpression(value) {
	var extractedVal = TYPES.UpdateExpression.call(undefined, value);
	return extractedVal === undefined ? null : extractedVal;
  },
  ThisExpression: noop,
  ConditionalExpression: noop,
  BinaryExpression: noop,
  ObjectExpression: noop,
  NewExpression: noop,
  ArrayExpression: function ArrayExpression(value) {
	var extractedVal = TYPES.ArrayExpression.call(undefined, value);
	return extractedVal.filter(function (val) {
			return val !== null;
	});
  },
  BindExpression: noop
});

var errorMessage = function errorMessage(expression) {
  return 'The prop value with an expression type of ' + expression + ' could not be resolved.\n  Please file issue to get this fixed immediately.';
};
function extract(value) {
  var expression = void 0;
  if (typeof value.expression !== 'boolean' && value.expression) {
	expression = value.expression;
  } else {
	expression = value;
  }
  var _expression = expression,
			type = _expression.type;

  if (TYPES[type] === undefined) {
	throw new Error(errorMessage(type));
  }

  return TYPES[type](expression);
}
function extractLiteral(value) {
  var expression = value.expression || value;
  var type = expression.type;

  if (LITERAL_TYPES[type] === undefined) {
	throw new Error(errorMessage(type));
  }

  return LITERAL_TYPES[type](expression);
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var aFunction = __webpack_require__(23);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
	case 1:
			return function (a) {
		return fn.call(that, a);
			};
	case 2:
			return function (a, b) {
		return fn.call(that, a, b);
			};
	case 3:
			return function (a, b, c) {
		return fn.call(that, a, b, c);
			};
  }
  return function () /* ...args */{
	return fn.apply(that, arguments);
  };
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var IObject = __webpack_require__(51);
var defined = __webpack_require__(34);
module.exports = function (it) {
  return IObject(defined(it));
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var core = __webpack_require__(13);
var fails = __webpack_require__(2);
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () {
	fn(1);
  }), 'Object', exp);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var ctx = __webpack_require__(22);
var IObject = __webpack_require__(51);
var toObject = __webpack_require__(18);
var toLength = __webpack_require__(12);
var asc = __webpack_require__(261);
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
	var O = toObject($this);
	var self = IObject(O);
	var f = ctx(callbackfn, that, 3);
	var length = toLength(self.length);
	var index = 0;
	var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
	var val, res;
	for (; length > index; index++) {
			if (NO_HOLES || index in self) {
		val = self[index];
		res = f(val, index, O);
		if (TYPE) {
					if (IS_MAP) result[index] = res; // map
					else if (res) switch (TYPE) {
							case 3:
				return true; // some
							case 5:
				return val; // find
							case 6:
				return index; // findIndex
							case 2:
				result.push(val); // filter
			} else if (IS_EVERY) return false; // every
		}
			}
	}return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function findVariable(variables, name) {
  return variables.some(function (variable) {
	return variable.name === name;
  });
}
function getVariable(variables, name) {
  return variables.find(function (variable) {
	return variable.name === name;
  });
}
function variablesInScope(context) {
  var scope = context.getScope();
  var variables = scope.variables;

  while (scope.type !== 'global') {
	scope = scope.upper;
	variables = scope.variables.concat(variables);
  }
  if (scope.childScopes.length) {
	variables = scope.childScopes[0].variables.concat(variables);
	if (scope.childScopes[0].childScopes.length) {
			variables = scope.childScopes[0].childScopes[0].variables.concat(variables);
	}
  }
  variables.reverse();

  return variables;
}

module.exports = {
  findVariable: findVariable,
  getVariable: getVariable,
  variablesInScope: variablesInScope
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var pIE = __webpack_require__(59);
var createDesc = __webpack_require__(35);
var toIObject = __webpack_require__(24);
var toPrimitive = __webpack_require__(32);
var has = __webpack_require__(14);
var IE8_DOM_DEFINE = __webpack_require__(116);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(11) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
	return gOPD(O, P);
  } catch (e) {/* empty */}
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (__webpack_require__(11)) {
  var LIBRARY = __webpack_require__(42);
  var global = __webpack_require__(4);
  var fails = __webpack_require__(2);
  var $export = __webpack_require__(1);
  var $typed = __webpack_require__(65);
  var $buffer = __webpack_require__(96);
  var ctx = __webpack_require__(22);
  var anInstance = __webpack_require__(46);
  var propertyDesc = __webpack_require__(35);
  var hide = __webpack_require__(17);
  var redefineAll = __webpack_require__(48);
  var toInteger = __webpack_require__(29);
  var toLength = __webpack_require__(12);
  var toIndex = __webpack_require__(148);
  var toAbsoluteIndex = __webpack_require__(37);
  var toPrimitive = __webpack_require__(32);
  var has = __webpack_require__(14);
  var classof = __webpack_require__(53);
  var isObject = __webpack_require__(3);
  var toObject = __webpack_require__(18);
  var isArrayIter = __webpack_require__(90);
  var create = __webpack_require__(38);
  var getPrototypeOf = __webpack_require__(40);
  var gOPN = __webpack_require__(39).f;
  var getIterFn = __webpack_require__(91);
  var uid = __webpack_require__(36);
  var wks = __webpack_require__(6);
  var createArrayMethod = __webpack_require__(26);
  var createArrayIncludes = __webpack_require__(76);
  var speciesConstructor = __webpack_require__(95);
  var ArrayIterators = __webpack_require__(93);
  var Iterators = __webpack_require__(44);
  var $iterDetect = __webpack_require__(62);
  var setSpecies = __webpack_require__(45);
  var arrayFill = __webpack_require__(92);
  var arrayCopyWithin = __webpack_require__(137);
  var $DP = __webpack_require__(9);
  var $GOPD = __webpack_require__(30);
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
	return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
	return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
	new Uint8Array(1).set({});
  });

  var toOffset = function toOffset(it, BYTES) {
	var offset = toInteger(it);
	if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
	return offset;
  };

  var validate = function validate(it) {
	if (isObject(it) && TYPED_ARRAY in it) return it;
	throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function allocate(C, length) {
	if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
			throw TypeError('It is not a typed array constructor!');
	}return new C(length);
  };

  var speciesFromList = function speciesFromList(O, list) {
	return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function fromList(C, list) {
	var index = 0;
	var length = list.length;
	var result = allocate(C, length);
	while (length > index) {
			result[index] = list[index++];
	}return result;
  };

  var addGetter = function addGetter(it, key, internal) {
	dP(it, key, { get: function get() {
		return this._d[internal];
			} });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
	var O = toObject(source);
	var aLen = arguments.length;
	var mapfn = aLen > 1 ? arguments[1] : undefined;
	var mapping = mapfn !== undefined;
	var iterFn = getIterFn(O);
	var i, length, values, result, step, iterator;
	if (iterFn != undefined && !isArrayIter(iterFn)) {
			for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
		values.push(step.value);
			}O = values;
	}
	if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
	for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
			result[i] = mapping ? mapfn(O[i], i) : O[i];
	}
	return result;
  };

  var $of = function of() /* ...items */{
	var index = 0;
	var length = arguments.length;
	var result = allocate(this, length);
	while (length > index) {
			result[index] = arguments[index++];
	}return result;
  };
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () {
	arrayToLocaleString.call(new Uint8Array(1));
  });

  var $toLocaleString = function toLocaleString() {
	return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
	copyWithin: function copyWithin(target, start /* , end */) {
			return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
	},
	every: function every(callbackfn /* , thisArg */) {
			return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	},
	fill: function fill(value /* , start, end */) {
			return arrayFill.apply(validate(this), arguments);
	},
	filter: function filter(callbackfn /* , thisArg */) {
			return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined));
	},
	find: function find(predicate /* , thisArg */) {
			return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	},
	findIndex: function findIndex(predicate /* , thisArg */) {
			return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	},
	forEach: function forEach(callbackfn /* , thisArg */) {
			arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	},
	indexOf: function indexOf(searchElement /* , fromIndex */) {
			return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	},
	includes: function includes(searchElement /* , fromIndex */) {
			return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	},
	join: function join(separator) {
			return arrayJoin.apply(validate(this), arguments);
	},
	lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) {
			return arrayLastIndexOf.apply(validate(this), arguments);
	},
	map: function map(mapfn /* , thisArg */) {
			return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
	},
	reduce: function reduce(callbackfn /* , initialValue */) {
			return arrayReduce.apply(validate(this), arguments);
	},
	reduceRight: function reduceRight(callbackfn /* , initialValue */) {
			return arrayReduceRight.apply(validate(this), arguments);
	},
	reverse: function reverse() {
			var that = this;
			var length = validate(that).length;
			var middle = Math.floor(length / 2);
			var index = 0;
			var value;
			while (index < middle) {
		value = that[index];
		that[index++] = that[--length];
		that[length] = value;
			}return that;
	},
	some: function some(callbackfn /* , thisArg */) {
			return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	},
	sort: function sort(comparefn) {
			return arraySort.call(validate(this), comparefn);
	},
	subarray: function subarray(begin, end) {
			var O = validate(this);
			var length = O.length;
			var $begin = toAbsoluteIndex(begin, length);
			return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin));
	}
  };

  var $slice = function slice(start, end) {
	return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
	validate(this);
	var offset = toOffset(arguments[1], 1);
	var length = this.length;
	var src = toObject(arrayLike);
	var len = toLength(src.length);
	var index = 0;
	if (len + offset > length) throw RangeError(WRONG_LENGTH);
	while (index < len) {
			this[offset + index] = src[index++];
	}
  };

  var $iterators = {
	entries: function entries() {
			return arrayEntries.call(validate(this));
	},
	keys: function keys() {
			return arrayKeys.call(validate(this));
	},
	values: function values() {
			return arrayValues.call(validate(this));
	}
  };

  var isTAIndex = function isTAIndex(target, key) {
	return isObject(target) && target[TYPED_ARRAY] && (typeof key === 'undefined' ? 'undefined' : _typeof(key)) != 'symbol' && key in target && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
	return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
	if (isTAIndex(target, key = toPrimitive(key, true)) && isObject(desc) && has(desc, 'value') && !has(desc, 'get') && !has(desc, 'set')
	&& !desc.configurable && (!has(desc, 'writable') || desc.writable) && (!has(desc, 'enumerable') || desc.enumerable)) {
			target[key] = desc.value;
			return target;
	}return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
	$GOPD.f = $getDesc;
	$DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
	getOwnPropertyDescriptor: $getDesc,
	defineProperty: $setDesc
  });

  if (fails(function () {
	arrayToString.call({});
  })) {
	arrayToString = arrayToLocaleString = function toString() {
			return arrayJoin.call(this);
	};
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
	slice: $slice,
	set: $set,
	constructor: function constructor() {/* noop */},
	toString: arrayToString,
	toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
	get: function get() {
			return this[TYPED_ARRAY];
	}
  });
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
	CLAMPED = !!CLAMPED;
	var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
	var GETTER = 'get' + KEY;
	var SETTER = 'set' + KEY;
	var TypedArray = global[NAME];
	var Base = TypedArray || {};
	var TAC = TypedArray && getPrototypeOf(TypedArray);
	var FORCED = !TypedArray || !$typed.ABV;
	var O = {};
	var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
	var getter = function getter(that, index) {
			var data = that._d;
			return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
	};
	var setter = function setter(that, index, value) {
			var data = that._d;
			if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
			data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
	};
	var addElement = function addElement(that, index) {
			dP(that, index, {
		get: function get() {
					return getter(this, index);
		},
		set: function set(value) {
					return setter(this, index, value);
		},
		enumerable: true
			});
	};
	if (FORCED) {
			TypedArray = wrapper(function (that, data, $offset, $length) {
		anInstance(that, TypedArray, NAME, '_d');
		var index = 0;
		var offset = 0;
		var buffer, byteLength, length, klass;
		if (!isObject(data)) {
					length = toIndex(data);
					byteLength = length * BYTES;
					buffer = new $ArrayBuffer(byteLength);
		} else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
					buffer = data;
					offset = toOffset($offset, BYTES);
					var $len = data.byteLength;
					if ($length === undefined) {
			if ($len % BYTES) throw RangeError(WRONG_LENGTH);
			byteLength = $len - offset;
			if (byteLength < 0) throw RangeError(WRONG_LENGTH);
					} else {
			byteLength = toLength($length) * BYTES;
			if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
					}
					length = byteLength / BYTES;
		} else if (TYPED_ARRAY in data) {
					return fromList(TypedArray, data);
		} else {
					return $from.call(TypedArray, data);
		}
		hide(that, '_d', {
					b: buffer,
					o: offset,
					l: byteLength,
					e: length,
					v: new $DataView(buffer)
		});
		while (index < length) {
					addElement(that, index++);
		}
			});
			TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
			hide(TypedArrayPrototype, 'constructor', TypedArray);
	} else if (!fails(function () {
			TypedArray(1);
	}) || !fails(function () {
			new TypedArray(-1); // eslint-disable-line no-new
	}) || !$iterDetect(function (iter) {
			new TypedArray(); // eslint-disable-line no-new
			new TypedArray(null); // eslint-disable-line no-new
			new TypedArray(1.5); // eslint-disable-line no-new
			new TypedArray(iter); // eslint-disable-line no-new
	}, true)) {
			TypedArray = wrapper(function (that, data, $offset, $length) {
		anInstance(that, TypedArray, NAME);
		var klass;
		if (!isObject(data)) return new Base(toIndex(data));
		if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
					return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data);
		}
		if (TYPED_ARRAY in data) return fromList(TypedArray, data);
		return $from.call(TypedArray, data);
			});
			arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
		if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
			});
			TypedArray[PROTOTYPE] = TypedArrayPrototype;
			if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
	}
	var $nativeIterator = TypedArrayPrototype[ITERATOR];
	var CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
	var $iterator = $iterators.values;
	hide(TypedArray, TYPED_CONSTRUCTOR, true);
	hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
	hide(TypedArrayPrototype, VIEW, true);
	hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

	if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
			dP(TypedArrayPrototype, TAG, {
		get: function get() {
					return NAME;
		}
			});
	}

	O[NAME] = TypedArray;

	$export($export.G + $export.W + $export.F * (TypedArray != Base), O);

	$export($export.S, NAME, {
			BYTES_PER_ELEMENT: BYTES
	});

	$export($export.S + $export.F * fails(function () {
			Base.of.call(TypedArray, 1);
	}), NAME, {
			from: $from,
			of: $of
	});

	if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

	$export($export.P, NAME, proto);

	setSpecies(NAME);

	$export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

	$export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

	if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

	$export($export.P + $export.F * fails(function () {
			new TypedArray(1).slice();
	}), NAME, { slice: $slice });

	$export($export.P + $export.F * (fails(function () {
			return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
	}) || !fails(function () {
			TypedArrayPrototype.toLocaleString.call([1, 2]);
	})), NAME, { toLocaleString: $toLocaleString });

	Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
	if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () {/* empty */};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var isObject = __webpack_require__(3);
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var META = __webpack_require__(36)('meta');
var isObject = __webpack_require__(3);
var has = __webpack_require__(14);
var setDesc = __webpack_require__(9).f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(2)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function setMeta(it) {
  setDesc(it, META, { value: {
			i: 'O' + ++id, // object ID
			w: {} // weak collections IDs
	} });
};
var fastKey = function fastKey(it, create) {
  if (!isObject(it)) return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
	if (!isExtensible(it)) return 'F';
	if (!create) return 'E';
	setMeta(it);
  }return it[META].i;
};
var getWeak = function getWeak(it, create) {
  if (!has(it, META)) {
	if (!isExtensible(it)) return true;
	if (!create) return false;
	setMeta(it);
  }return it[META].w;
};
var onFreeze = function onFreeze(it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (bitmap, value) {
  return {
	enumerable: !(bitmap & 1),
	configurable: !(bitmap & 2),
	writable: !(bitmap & 4),
	value: value
  };
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var toInteger = __webpack_require__(29);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var anObject = __webpack_require__(5);
var dPs = __webpack_require__(119);
var enumBugKeys = __webpack_require__(78);
var IE_PROTO = __webpack_require__(77)('IE_PROTO');
var Empty = function Empty() {/* empty */};
var PROTOTYPE = 'prototype';
var _createDict = function createDict() {
  var iframe = __webpack_require__(73)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(80).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  _createDict = iframeDocument.F;
  while (i--) {
	delete _createDict[PROTOTYPE][enumBugKeys[i]];
  }return _createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
	Empty[PROTOTYPE] = anObject(O);
	result = new Empty();
	Empty[PROTOTYPE] = null;
	result[IE_PROTO] = O;
  } else result = _createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $keys = __webpack_require__(118);
var hiddenKeys = __webpack_require__(78).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var has = __webpack_require__(14);
var toObject = __webpack_require__(18);
var IE_PROTO = __webpack_require__(77)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	return O.constructor.prototype;
  }return O instanceof Object ? ObjectProto : null;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var def = __webpack_require__(9).f;
var has = __webpack_require__(14);
var TAG = __webpack_require__(6)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = false;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $keys = __webpack_require__(118);
var enumBugKeys = __webpack_require__(78);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(4);
var dP = __webpack_require__(9);
var DESCRIPTORS = __webpack_require__(11);
var SPECIES = __webpack_require__(6)('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
	configurable: true,
	get: function get() {
			return this;
	}
  });
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
	throw TypeError(name + ': incorrect invocation!');
  }return it;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var ctx = __webpack_require__(22);
var call = __webpack_require__(134);
var isArrayIter = __webpack_require__(90);
var anObject = __webpack_require__(5);
var toLength = __webpack_require__(12);
var getIterFn = __webpack_require__(91);
var BREAK = {};
var RETURN = {};
var _exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () {
	return iterable;
  } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
	result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
	result = call(iterator, f, step.value, entries);
	if (result === BREAK || result === RETURN) return result;
  }
};
_exports.BREAK = BREAK;
_exports.RETURN = RETURN;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var redefine = __webpack_require__(15);
module.exports = function (target, src, safe) {
  for (var key in src) {
	redefine(target, key, src[key], safe);
  }return target;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(3);
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
(function clone(exports) {
	'use strict';

	var Syntax, isArray, VisitorOption, VisitorKeys, objectCreate, objectKeys, BREAK, SKIP, REMOVE;

	function ignoreJSHintError() {}

	isArray = Array.isArray;
	if (!isArray) {
		isArray = function isArray(array) {
			return Object.prototype.toString.call(array) === '[object Array]';
		};
	}

	function deepCopy(obj) {
		var ret = {},
			key,
			val;
		for (key in obj) {
			if (obj.hasOwnProperty(key)) {
				val = obj[key];
				if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val !== null) {
					ret[key] = deepCopy(val);
				} else {
					ret[key] = val;
				}
			}
		}
		return ret;
	}

	function shallowCopy(obj) {
		var ret = {},
			key;
		for (key in obj) {
			if (obj.hasOwnProperty(key)) {
				ret[key] = obj[key];
			}
		}
		return ret;
	}
	ignoreJSHintError(shallowCopy);
	function upperBound(array, func) {
		var diff, len, i, current;

		len = array.length;
		i = 0;

		while (len) {
			diff = len >>> 1;
			current = i + diff;
			if (func(array[current])) {
				len = diff;
			} else {
				i = current + 1;
				len -= diff + 1;
			}
		}
		return i;
	}

	function lowerBound(array, func) {
		var diff, len, i, current;

		len = array.length;
		i = 0;

		while (len) {
			diff = len >>> 1;
			current = i + diff;
			if (func(array[current])) {
				i = current + 1;
				len -= diff + 1;
			} else {
				len = diff;
			}
		}
		return i;
	}
	ignoreJSHintError(lowerBound);

	objectCreate = Object.create || function () {
		function F() {}

		return function (o) {
			F.prototype = o;
			return new F();
		};
	}();

	objectKeys = Object.keys || function (o) {
		var keys = [],
			key;
		for (key in o) {
			keys.push(key);
		}
		return keys;
	};

	function extend(to, from) {
		var keys = objectKeys(from),
			key,
			i,
			len;
		for (i = 0, len = keys.length; i < len; i += 1) {
			key = keys[i];
			to[key] = from[key];
		}
		return to;
	}

	Syntax = {
		AssignmentExpression: 'AssignmentExpression',
		AssignmentPattern: 'AssignmentPattern',
		ArrayExpression: 'ArrayExpression',
		ArrayPattern: 'ArrayPattern',
		ArrowFunctionExpression: 'ArrowFunctionExpression',
		AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.
		BlockStatement: 'BlockStatement',
		BinaryExpression: 'BinaryExpression',
		BreakStatement: 'BreakStatement',
		CallExpression: 'CallExpression',
		CatchClause: 'CatchClause',
		ClassBody: 'ClassBody',
		ClassDeclaration: 'ClassDeclaration',
		ClassExpression: 'ClassExpression',
		ComprehensionBlock: 'ComprehensionBlock', // CAUTION: It's deferred to ES7.
		ComprehensionExpression: 'ComprehensionExpression', // CAUTION: It's deferred to ES7.
		ConditionalExpression: 'ConditionalExpression',
		ContinueStatement: 'ContinueStatement',
		DebuggerStatement: 'DebuggerStatement',
		DirectiveStatement: 'DirectiveStatement',
		DoWhileStatement: 'DoWhileStatement',
		EmptyStatement: 'EmptyStatement',
		ExportAllDeclaration: 'ExportAllDeclaration',
		ExportDefaultDeclaration: 'ExportDefaultDeclaration',
		ExportNamedDeclaration: 'ExportNamedDeclaration',
		ExportSpecifier: 'ExportSpecifier',
		ExpressionStatement: 'ExpressionStatement',
		ForStatement: 'ForStatement',
		ForInStatement: 'ForInStatement',
		ForOfStatement: 'ForOfStatement',
		FunctionDeclaration: 'FunctionDeclaration',
		FunctionExpression: 'FunctionExpression',
		GeneratorExpression: 'GeneratorExpression', // CAUTION: It's deferred to ES7.
		Identifier: 'Identifier',
		IfStatement: 'IfStatement',
		ImportDeclaration: 'ImportDeclaration',
		ImportDefaultSpecifier: 'ImportDefaultSpecifier',
		ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
		ImportSpecifier: 'ImportSpecifier',
		Literal: 'Literal',
		LabeledStatement: 'LabeledStatement',
		LogicalExpression: 'LogicalExpression',
		MemberExpression: 'MemberExpression',
		MetaProperty: 'MetaProperty',
		MethodDefinition: 'MethodDefinition',
		ModuleSpecifier: 'ModuleSpecifier',
		NewExpression: 'NewExpression',
		ObjectExpression: 'ObjectExpression',
		ObjectPattern: 'ObjectPattern',
		Program: 'Program',
		Property: 'Property',
		RestElement: 'RestElement',
		ReturnStatement: 'ReturnStatement',
		SequenceExpression: 'SequenceExpression',
		SpreadElement: 'SpreadElement',
		Super: 'Super',
		SwitchStatement: 'SwitchStatement',
		SwitchCase: 'SwitchCase',
		TaggedTemplateExpression: 'TaggedTemplateExpression',
		TemplateElement: 'TemplateElement',
		TemplateLiteral: 'TemplateLiteral',
		ThisExpression: 'ThisExpression',
		ThrowStatement: 'ThrowStatement',
		TryStatement: 'TryStatement',
		UnaryExpression: 'UnaryExpression',
		UpdateExpression: 'UpdateExpression',
		VariableDeclaration: 'VariableDeclaration',
		VariableDeclarator: 'VariableDeclarator',
		WhileStatement: 'WhileStatement',
		WithStatement: 'WithStatement',
		YieldExpression: 'YieldExpression'
	};

	VisitorKeys = {
		AssignmentExpression: ['left', 'right'],
		AssignmentPattern: ['left', 'right'],
		ArrayExpression: ['elements'],
		ArrayPattern: ['elements'],
		ArrowFunctionExpression: ['params', 'body'],
		AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.
		BlockStatement: ['body'],
		BinaryExpression: ['left', 'right'],
		BreakStatement: ['label'],
		CallExpression: ['callee', 'arguments'],
		CatchClause: ['param', 'body'],
		ClassBody: ['body'],
		ClassDeclaration: ['id', 'superClass', 'body'],
		ClassExpression: ['id', 'superClass', 'body'],
		ComprehensionBlock: ['left', 'right'], // CAUTION: It's deferred to ES7.
		ComprehensionExpression: ['blocks', 'filter', 'body'], // CAUTION: It's deferred to ES7.
		ConditionalExpression: ['test', 'consequent', 'alternate'],
		ContinueStatement: ['label'],
		DebuggerStatement: [],
		DirectiveStatement: [],
		DoWhileStatement: ['body', 'test'],
		EmptyStatement: [],
		ExportAllDeclaration: ['source'],
		ExportDefaultDeclaration: ['declaration'],
		ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],
		ExportSpecifier: ['exported', 'local'],
		ExpressionStatement: ['expression'],
		ForStatement: ['init', 'test', 'update', 'body'],
		ForInStatement: ['left', 'right', 'body'],
		ForOfStatement: ['left', 'right', 'body'],
		FunctionDeclaration: ['id', 'params', 'body'],
		FunctionExpression: ['id', 'params', 'body'],
		GeneratorExpression: ['blocks', 'filter', 'body'], // CAUTION: It's deferred to ES7.
		Identifier: [],
		IfStatement: ['test', 'consequent', 'alternate'],
		ImportDeclaration: ['specifiers', 'source'],
		ImportDefaultSpecifier: ['local'],
		ImportNamespaceSpecifier: ['local'],
		ImportSpecifier: ['imported', 'local'],
		Literal: [],
		LabeledStatement: ['label', 'body'],
		LogicalExpression: ['left', 'right'],
		MemberExpression: ['object', 'property'],
		MetaProperty: ['meta', 'property'],
		MethodDefinition: ['key', 'value'],
		ModuleSpecifier: [],
		NewExpression: ['callee', 'arguments'],
		ObjectExpression: ['properties'],
		ObjectPattern: ['properties'],
		Program: ['body'],
		Property: ['key', 'value'],
		RestElement: ['argument'],
		ReturnStatement: ['argument'],
		SequenceExpression: ['expressions'],
		SpreadElement: ['argument'],
		Super: [],
		SwitchStatement: ['discriminant', 'cases'],
		SwitchCase: ['test', 'consequent'],
		TaggedTemplateExpression: ['tag', 'quasi'],
		TemplateElement: [],
		TemplateLiteral: ['quasis', 'expressions'],
		ThisExpression: [],
		ThrowStatement: ['argument'],
		TryStatement: ['block', 'handler', 'finalizer'],
		UnaryExpression: ['argument'],
		UpdateExpression: ['argument'],
		VariableDeclaration: ['declarations'],
		VariableDeclarator: ['id', 'init'],
		WhileStatement: ['test', 'body'],
		WithStatement: ['object', 'body'],
		YieldExpression: ['argument']
	};
	BREAK = {};
	SKIP = {};
	REMOVE = {};

	VisitorOption = {
		Break: BREAK,
		Skip: SKIP,
		Remove: REMOVE
	};

	function Reference(parent, key) {
		this.parent = parent;
		this.key = key;
	}

	Reference.prototype.replace = function replace(node) {
		this.parent[this.key] = node;
	};

	Reference.prototype.remove = function remove() {
		if (isArray(this.parent)) {
			this.parent.splice(this.key, 1);
			return true;
		} else {
			this.replace(null);
			return false;
		}
	};

	function Element(node, path, wrap, ref) {
		this.node = node;
		this.path = path;
		this.wrap = wrap;
		this.ref = ref;
	}

	function Controller() {}
	Controller.prototype.path = function path() {
		var i, iz, j, jz, result, element;

		function addToPath(result, path) {
			if (isArray(path)) {
				for (j = 0, jz = path.length; j < jz; ++j) {
					result.push(path[j]);
				}
			} else {
				result.push(path);
			}
		}
		if (!this.__current.path) {
			return null;
		}
		result = [];
		for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
			element = this.__leavelist[i];
			addToPath(result, element.path);
		}
		addToPath(result, this.__current.path);
		return result;
	};
	Controller.prototype.type = function () {
		var node = this.current();
		return node.type || this.__current.wrap;
	};
	Controller.prototype.parents = function parents() {
		var i, iz, result;
		result = [];
		for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
			result.push(this.__leavelist[i].node);
		}

		return result;
	};
	Controller.prototype.current = function current() {
		return this.__current.node;
	};

	Controller.prototype.__execute = function __execute(callback, element) {
		var previous, result;

		result = undefined;

		previous = this.__current;
		this.__current = element;
		this.__state = null;
		if (callback) {
			result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
		}
		this.__current = previous;

		return result;
	};
	Controller.prototype.notify = function notify(flag) {
		this.__state = flag;
	};
	Controller.prototype.skip = function () {
		this.notify(SKIP);
	};
	Controller.prototype['break'] = function () {
		this.notify(BREAK);
	};
	Controller.prototype.remove = function () {
		this.notify(REMOVE);
	};

	Controller.prototype.__initialize = function (root, visitor) {
		this.visitor = visitor;
		this.root = root;
		this.__worklist = [];
		this.__leavelist = [];
		this.__current = null;
		this.__state = null;
		this.__fallback = null;
		if (visitor.fallback === 'iteration') {
			this.__fallback = objectKeys;
		} else if (typeof visitor.fallback === 'function') {
			this.__fallback = visitor.fallback;
		}

		this.__keys = VisitorKeys;
		if (visitor.keys) {
			this.__keys = extend(objectCreate(this.__keys), visitor.keys);
		}
	};

	function isNode(node) {
		if (node == null) {
			return false;
		}
		return (typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object' && typeof node.type === 'string';
	}

	function isProperty(nodeType, key) {
		return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
	}

	Controller.prototype.traverse = function traverse(root, visitor) {
		var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;

		this.__initialize(root, visitor);

		sentinel = {};
		worklist = this.__worklist;
		leavelist = this.__leavelist;
		worklist.push(new Element(root, null, null, null));
		leavelist.push(new Element(null, null, null, null));

		while (worklist.length) {
			element = worklist.pop();

			if (element === sentinel) {
				element = leavelist.pop();

				ret = this.__execute(visitor.leave, element);

				if (this.__state === BREAK || ret === BREAK) {
					return;
				}
				continue;
			}

			if (element.node) {

				ret = this.__execute(visitor.enter, element);

				if (this.__state === BREAK || ret === BREAK) {
					return;
				}

				worklist.push(sentinel);
				leavelist.push(element);

				if (this.__state === SKIP || ret === SKIP) {
					continue;
				}

				node = element.node;
				nodeType = node.type || element.wrap;
				candidates = this.__keys[nodeType];
				if (!candidates) {
					if (this.__fallback) {
						candidates = this.__fallback(node);
					} else {
						throw new Error('Unknown node type ' + nodeType + '.');
					}
				}

				current = candidates.length;
				while ((current -= 1) >= 0) {
					key = candidates[current];
					candidate = node[key];
					if (!candidate) {
						continue;
					}

					if (isArray(candidate)) {
						current2 = candidate.length;
						while ((current2 -= 1) >= 0) {
							if (!candidate[current2]) {
								continue;
							}
							if (isProperty(nodeType, candidates[current])) {
								element = new Element(candidate[current2], [key, current2], 'Property', null);
							} else if (isNode(candidate[current2])) {
								element = new Element(candidate[current2], [key, current2], null, null);
							} else {
								continue;
							}
							worklist.push(element);
						}
					} else if (isNode(candidate)) {
						worklist.push(new Element(candidate, key, null, null));
					}
				}
			}
		}
	};

	Controller.prototype.replace = function replace(root, visitor) {
		var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;

		function removeElem(element) {
			var i, key, nextElem, parent;

			if (element.ref.remove()) {
				key = element.ref.key;
				parent = element.ref.parent;
				i = worklist.length;
				while (i--) {
					nextElem = worklist[i];
					if (nextElem.ref && nextElem.ref.parent === parent) {
						if (nextElem.ref.key < key) {
							break;
						}
						--nextElem.ref.key;
					}
				}
			}
		}

		this.__initialize(root, visitor);

		sentinel = {};
		worklist = this.__worklist;
		leavelist = this.__leavelist;
		outer = {
			root: root
		};
		element = new Element(root, null, null, new Reference(outer, 'root'));
		worklist.push(element);
		leavelist.push(element);

		while (worklist.length) {
			element = worklist.pop();

			if (element === sentinel) {
				element = leavelist.pop();

				target = this.__execute(visitor.leave, element);
				if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
					element.ref.replace(target);
				}

				if (this.__state === REMOVE || target === REMOVE) {
					removeElem(element);
				}

				if (this.__state === BREAK || target === BREAK) {
					return outer.root;
				}
				continue;
			}

			target = this.__execute(visitor.enter, element);
			if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
				element.ref.replace(target);
				element.node = target;
			}

			if (this.__state === REMOVE || target === REMOVE) {
				removeElem(element);
				element.node = null;
			}

			if (this.__state === BREAK || target === BREAK) {
				return outer.root;
			}
			node = element.node;
			if (!node) {
				continue;
			}

			worklist.push(sentinel);
			leavelist.push(element);

			if (this.__state === SKIP || target === SKIP) {
				continue;
			}

			nodeType = node.type || element.wrap;
			candidates = this.__keys[nodeType];
			if (!candidates) {
				if (this.__fallback) {
					candidates = this.__fallback(node);
				} else {
					throw new Error('Unknown node type ' + nodeType + '.');
				}
			}

			current = candidates.length;
			while ((current -= 1) >= 0) {
				key = candidates[current];
				candidate = node[key];
				if (!candidate) {
					continue;
				}

				if (isArray(candidate)) {
					current2 = candidate.length;
					while ((current2 -= 1) >= 0) {
						if (!candidate[current2]) {
							continue;
						}
						if (isProperty(nodeType, candidates[current])) {
							element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
						} else if (isNode(candidate[current2])) {
							element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
						} else {
							continue;
						}
						worklist.push(element);
					}
				} else if (isNode(candidate)) {
					worklist.push(new Element(candidate, key, null, new Reference(node, key)));
				}
			}
		}

		return outer.root;
	};

	function traverse(root, visitor) {
		var controller = new Controller();
		return controller.traverse(root, visitor);
	}

	function replace(root, visitor) {
		var controller = new Controller();
		return controller.replace(root, visitor);
	}

	function extendCommentRange(comment, tokens) {
		var target;

		target = upperBound(tokens, function search(token) {
			return token.range[0] > comment.range[0];
		});

		comment.extendedRange = [comment.range[0], comment.range[1]];

		if (target !== tokens.length) {
			comment.extendedRange[1] = tokens[target].range[0];
		}

		target -= 1;
		if (target >= 0) {
			comment.extendedRange[0] = tokens[target].range[1];
		}

		return comment;
	}

	function attachComments(tree, providedComments, tokens) {
		var comments = [],
			comment,
			len,
			i,
			cursor;

		if (!tree.range) {
			throw new Error('attachComments needs range information');
		}
		if (!tokens.length) {
			if (providedComments.length) {
				for (i = 0, len = providedComments.length; i < len; i += 1) {
					comment = deepCopy(providedComments[i]);
					comment.extendedRange = [0, tree.range[0]];
					comments.push(comment);
				}
				tree.leadingComments = comments;
			}
			return tree;
		}

		for (i = 0, len = providedComments.length; i < len; i += 1) {
			comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
		}
		cursor = 0;
		traverse(tree, {
			enter: function enter(node) {
				var comment;

				while (cursor < comments.length) {
					comment = comments[cursor];
					if (comment.extendedRange[1] > node.range[0]) {
						break;
					}

					if (comment.extendedRange[1] === node.range[0]) {
						if (!node.leadingComments) {
							node.leadingComments = [];
						}
						node.leadingComments.push(comment);
						comments.splice(cursor, 1);
					} else {
						cursor += 1;
					}
				}
				if (cursor === comments.length) {
					return VisitorOption.Break;
				}

				if (comments[cursor].extendedRange[0] > node.range[1]) {
					return VisitorOption.Skip;
				}
			}
		});

		cursor = 0;
		traverse(tree, {
			leave: function leave(node) {
				var comment;

				while (cursor < comments.length) {
					comment = comments[cursor];
					if (node.range[1] < comment.extendedRange[0]) {
						break;
					}

					if (node.range[1] === comment.extendedRange[0]) {
						if (!node.trailingComments) {
							node.trailingComments = [];
						}
						node.trailingComments.push(comment);
						comments.splice(cursor, 1);
					} else {
						cursor += 1;
					}
				}
				if (cursor === comments.length) {
					return VisitorOption.Break;
				}

				if (comments[cursor].extendedRange[0] > node.range[1]) {
					return VisitorOption.Skip;
				}
			}
		});

		return tree;
	}

	exports.version = __webpack_require__(333).version;
	exports.Syntax = Syntax;
	exports.traverse = traverse;
	exports.replace = replace;
	exports.attachComments = attachComments;
	exports.VisitorKeys = VisitorKeys;
	exports.VisitorOption = VisitorOption;
	exports.Controller = Controller;
	exports.cloneEnvironment = function () {
		return clone({});
	};

	return exports;
})(exports);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var cof = __webpack_require__(28);
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var classof = __webpack_require__(53);
var test = {};
test[__webpack_require__(6)('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  __webpack_require__(15)(Object.prototype, 'toString', function toString() {
	return '[object ' + classof(this) + ']';
  }, true);
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var cof = __webpack_require__(28);
var TAG = __webpack_require__(6)('toStringTag');
var ARG = cof(function () {
  return arguments;
}()) == 'Arguments';
var tryGet = function tryGet(it, key) {
  try {
	return it[key];
  } catch (e) {/* empty */}
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
  : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
  : ARG ? cof(O)
  : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var UNSCOPABLES = __webpack_require__(6)('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(17)(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

module.exports = function () {
  function Cursor() {
	_classCallCheck(this, Cursor);

	this.current = null;
  }


  _createClass(Cursor, [{
	key: "getOneToken",
	value: function getOneToken() {
			return this.moveNext() ? this.current : null;
	}

  }, {
	key: "getAllTokens",
	value: function getAllTokens() {
			var tokens = [];

			while (this.moveNext()) {
		tokens.push(this.current);
			}

			return tokens;
	}

  }, {
	key: "moveNext",
	value: function moveNext() {
			throw new Error("Not implemented.");
	}
  }]);

  return Cursor;
}();
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var lodash = __webpack_require__(10);
function getStartLocation(token) {
	return token.range[0];
}
exports.search = function search(tokens, location) {
	return lodash.sortedIndexBy(tokens, { range: [location] }, getStartLocation);
};
exports.getFirstIndex = function getFirstIndex(tokens, indexMap, startLoc) {
	if (startLoc in indexMap) {
		return indexMap[startLoc];
	}
	if (startLoc - 1 in indexMap) {
		var index = indexMap[startLoc - 1];
		var token = index >= 0 && index < tokens.length ? tokens[index] : null;
		if (token && token.range[0] >= startLoc) {
			return index;
		}
		return index + 1;
	}
	return 0;
};
exports.getLastIndex = function getLastIndex(tokens, indexMap, endLoc) {
	if (endLoc in indexMap) {
		return indexMap[endLoc] - 1;
	}
	if (endLoc - 1 in indexMap) {
		var index = indexMap[endLoc - 1];
		var token = index >= 0 && index < tokens.length ? tokens[index] : null;
		if (token && token.range[1] > endLoc) {
			return index - 1;
		}
		return index;
	}
	return tokens.length - 1;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


function getReactVersionFromContext(context) {
  var confVer = '999.999.999';
  if (context.settings.react && context.settings.react.version) {
	confVer = context.settings.react.version;
  }
  confVer = /^[0-9]+\.[0-9]+$/.test(confVer) ? confVer + '.0' : confVer;
  return confVer.split('.').map(function (part) {
	return Number(part);
  });
}

function getFlowVersionFromContext(context) {
  var confVer = '999.999.999';
  if (context.settings.react && context.settings.react.flowVersion) {
	confVer = context.settings.react.flowVersion;
  } else {
	throw 'Could not retrieve flowVersion from settings';
  }
  confVer = /^[0-9]+\.[0-9]+$/.test(confVer) ? confVer + '.0' : confVer;
  return confVer.split('.').map(function (part) {
	return Number(part);
  });
}

function test(context, methodVer, confVer) {
  methodVer = methodVer.split('.').map(function (part) {
	return Number(part);
  });
  var higherMajor = methodVer[0] < confVer[0];
  var higherMinor = methodVer[0] === confVer[0] && methodVer[1] < confVer[1];
  var higherOrEqualPatch = methodVer[0] === confVer[0] && methodVer[1] === confVer[1] && methodVer[2] <= confVer[2];

  return higherMajor || higherMinor || higherOrEqualPatch;
}

function testReactVersion(context, methodVer) {
  return test(context, methodVer, getReactVersionFromContext(context));
}

function testFlowVersion(context, methodVer) {
  return test(context, methodVer, getFlowVersionFromContext(context));
}

module.exports = {
  testReactVersion: testReactVersion,
  testFlowVersion: testFlowVersion
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


exports.f = Object.getOwnPropertySymbols;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


exports.f = {}.propertyIsEnumerable;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var defined = __webpack_require__(34);
var fails = __webpack_require__(2);
var spaces = __webpack_require__(82);
var space = '[' + spaces + ']';
var non = '\u200B\x85';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function exporter(KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
	return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $at = __webpack_require__(131)(true);
__webpack_require__(86)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0; // next index
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var ITERATOR = __webpack_require__(6)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () {
	SAFE_CLOSING = true;
  };
  Array.from(riter, function () {
	throw 2;
  });
} catch (e) {/* empty */}

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
	var arr = [7];
	var iter = arr[ITERATOR]();
	iter.next = function () {
			return { done: safe = true };
	};
	arr[ITERATOR] = function () {
			return iter;
	};
	exec(arr);
  } catch (e) {/* empty */}
  return safe;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var hide = __webpack_require__(17);
var redefine = __webpack_require__(15);
var fails = __webpack_require__(2);
var defined = __webpack_require__(34);
var wks = __webpack_require__(6);

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);
  var fns = exec(defined, SYMBOL, ''[KEY]);
  var strfn = fns[0];
  var rxfn = fns[1];
  if (fails(function () {
	var O = {};
	O[SYMBOL] = function () {
			return 7;
	};
	return ''[KEY](O) != 7;
  })) {
	redefine(String.prototype, KEY, strfn);
	hide(RegExp.prototype, SYMBOL, length == 2
	? function (string, arg) {
			return rxfn.call(string, this, arg);
	}
	: function (string) {
			return rxfn.call(string, this);
	});
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(4);
var $export = __webpack_require__(1);
var redefine = __webpack_require__(15);
var redefineAll = __webpack_require__(48);
var meta = __webpack_require__(33);
var forOf = __webpack_require__(47);
var anInstance = __webpack_require__(46);
var isObject = __webpack_require__(3);
var fails = __webpack_require__(2);
var $iterDetect = __webpack_require__(62);
var setToStringTag = __webpack_require__(41);
var inheritIfRequired = __webpack_require__(83);

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function fixMethod(KEY) {
	var fn = proto[KEY];
	redefine(proto, KEY, KEY == 'delete' ? function (a) {
			return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	} : KEY == 'has' ? function has(a) {
			return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	} : KEY == 'get' ? function get(a) {
			return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
	} : KEY == 'add' ? function add(a) {
			fn.call(this, a === 0 ? 0 : a);return this;
	} : function set(a, b) {
			fn.call(this, a === 0 ? 0 : a, b);return this;
	});
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
	new C().entries().next();
  }))) {
	C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	redefineAll(C.prototype, methods);
	meta.NEED = true;
  } else {
	var instance = new C();
	var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
	var THROWS_ON_PRIMITIVES = fails(function () {
			instance.has(1);
	});
	var ACCEPT_ITERABLES = $iterDetect(function (iter) {
			new C(iter);
	}); // eslint-disable-line no-new
	var BUGGY_ZERO = !IS_WEAK && fails(function () {
			var $instance = new C();
			var index = 5;
			while (index--) {
		$instance[ADDER](index, index);
			}return !$instance.has(-0);
	});
	if (!ACCEPT_ITERABLES) {
			C = wrapper(function (target, iterable) {
		anInstance(target, C, NAME);
		var that = inheritIfRequired(new Base(), target, C);
		if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
		return that;
			});
			C.prototype = proto;
			proto.constructor = C;
	}
	if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
			fixMethod('delete');
			fixMethod('has');
			IS_MAP && fixMethod('get');
	}
	if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
	if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(4);
var hide = __webpack_require__(17);
var uid = __webpack_require__(36);
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = 'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'.split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
	hide(Typed.prototype, TYPED, true);
	hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Variable = function Variable(name, scope) {
  _classCallCheck(this, Variable);
  this.name = name;
  this.identifiers = [];
  this.references = [];
  this.defs = [];

  this.tainted = false;
  this.stack = true;
  this.scope = scope;
};

Variable.CatchClause = "CatchClause";
Variable.Parameter = "Parameter";
Variable.FunctionName = "FunctionName";
Variable.ClassName = "ClassName";
Variable.Variable = "Variable";
Variable.ImportBinding = "ImportBinding";
Variable.TDZ = "TDZ";
Variable.ImplicitGlobalVariable = "ImplicitGlobalVariable";

module.exports = Variable;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function(process) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports = module.exports = __webpack_require__(353);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

function useColors() {
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
	return true;
  }
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
	return false;
  }
  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}

exports.formatters.j = function (v) {
  try {
	return JSON.stringify(v);
  } catch (err) {
	return '[UnexpectedJSONParseError]: ' + err.message;
  }
};

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit');
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
	if ('%%' === match) return;
	index++;
	if ('%c' === match) {
			lastC = index;
	}
  });

  args.splice(lastC, 0, c);
}

function log() {
  return 'object' === (typeof console === 'undefined' ? 'undefined' : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
}

function save(namespaces) {
  try {
	if (null == namespaces) {
			exports.storage.removeItem('debug');
	} else {
			exports.storage.debug = namespaces;
	}
  } catch (e) {}
}

function load() {
  var r;
  try {
	r = exports.storage.debug;
  } catch (e) {}
  if (!r && typeof process !== 'undefined' && 'env' in process) {
	r = process.env.DEBUG;
  }

  return r;
}

exports.enable(load());

function localstorage() {
  try {
	return window.localStorage;
  } catch (e) {}
}
}.call(exports, __webpack_require__(20)))
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

(function () {
  'use strict';

  exports.ast = __webpack_require__(356);
  exports.code = __webpack_require__(160);
  exports.keyword = __webpack_require__(357);
})();
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var astNodeTypes = __webpack_require__(161),
	commentAttachment = __webpack_require__(358),
	TokenTranslator = __webpack_require__(359),
	acornJSX = __webpack_require__(360),
	rawAcorn = __webpack_require__(362);

var acorn = acornJSX(rawAcorn);
var DEFAULT_ECMA_VERSION = 5;
var lookahead, extra, lastToken;
var assign = Object.assign || function assign(target) {
	for (var argIndex = 1; argIndex < arguments.length; argIndex++) {
		if (arguments[argIndex] !== null && _typeof(arguments[argIndex]) === "object") {
			var keys = Object.keys(arguments[argIndex]);

			for (var keyIndex = 0; keyIndex < keys.length; keyIndex++) {
				target[keys[keyIndex]] = arguments[argIndex][keys[keyIndex]];
			}
		}
	}

	return target;
};
function resetExtra() {
	extra = {
		tokens: null,
		range: false,
		loc: false,
		comment: false,
		comments: [],
		tolerant: false,
		errors: [],
		strict: false,
		ecmaFeatures: {},
		ecmaVersion: DEFAULT_ECMA_VERSION,
		isModule: false
	};
}

var tt = acorn.tokTypes,
	getLineInfo = acorn.getLineInfo;
tt.jsxAttrValueToken = {};
function normalizeEcmaVersion(ecmaVersion) {
	if (typeof ecmaVersion === "number") {
		var version = ecmaVersion;
		if (version >= 2015) {
			version -= 2009;
		}

		switch (version) {
			case 3:
			case 5:
			case 6:
			case 7:
			case 8:
			case 9:
				return version;

			default:
				throw new Error("Invalid ecmaVersion.");
		}
	} else {
		return DEFAULT_ECMA_VERSION;
	}
}
function isValidNode(node) {
	return true;
	var ecma = extra.ecmaFeatures;

	switch (node.type) {
		case "ExperimentalSpreadProperty":
		case "ExperimentalRestProperty":
			return ecma.experimentalObjectRestSpread;

		case "ImportDeclaration":
		case "ExportNamedDeclaration":
		case "ExportDefaultDeclaration":
		case "ExportAllDeclaration":
			return extra.isModule;

		default:
			return true;
	}
}
function esprimaFinishNode(result) {
	if (!isValidNode(result)) {
		this.unexpected(result.start);
	}
	if (result.type === "TryStatement") {
		delete result.guardedHandlers;
	} else if (result.type === "CatchClause") {
		delete result.guard;
	}
	if (result.type === "TemplateElement") {
		var terminalDollarBraceL = this.input.slice(result.end, result.end + 2) === "${";

		if (result.range) {
			result.range[0]--;
			result.range[1] += terminalDollarBraceL ? 2 : 1;
		}

		if (result.loc) {
			result.loc.start.column--;
			result.loc.end.column += terminalDollarBraceL ? 2 : 1;
		}
	}
	if (result.type === "Literal" && result.value === undefined) {
		result.value = null;
	}

	if (extra.attachComment) {
		commentAttachment.processComment(result);
	}

	if (result.type.indexOf("Function") > -1 && !result.generator) {
		result.generator = false;
	}

	return result;
}
function isValidToken(parser) {
	return true;
	var ecma = extra.ecmaFeatures;
	var type = parser.type;

	switch (type) {
		case tt.jsxName:
		case tt.jsxText:
		case tt.jsxTagStart:
		case tt.jsxTagEnd:
			return ecma.jsx;
		case tt.regexp:
			if (extra.ecmaVersion < 6 && parser.value.flags && parser.value.flags.indexOf("y") > -1) {
				return false;
			}

			return true;

		default:
			return true;
	}
}
function wrapFinishNode(finishNode) {
	return (/** @this acorn.Parser */function (node, type, pos, loc) {
			var result = finishNode.call(this, node, type, pos, loc);
			return esprimaFinishNode.call(this, result);
		}
	);
}

acorn.plugins.espree = function (instance) {

	instance.extend("finishNode", wrapFinishNode);

	instance.extend("finishNodeAt", wrapFinishNode);

	instance.extend("next", function (next) {
		return (/** @this acorn.Parser */function () {
				if (!isValidToken(this)) {
					this.unexpected();
				}
				return next.call(this);
			}
		);
	});
	instance.extend("checkLVal", function (checkLVal) {

		return (/** @this acorn.Parser */function (expr, isBinding, checkClashes) {

				if (extra.ecmaFeatures.experimentalObjectRestSpread && expr.type === "ObjectPattern") {
					for (var i = 0; i < expr.properties.length; i++) {
						if (expr.properties[i].type.indexOf("Experimental") === -1) {
							this.checkLVal(expr.properties[i].value, isBinding, checkClashes);
						}
					}
					return undefined;
				}

				return checkLVal.call(this, expr, isBinding, checkClashes);
			}
		);
	});

	instance.extend("parseTopLevel", function (parseTopLevel) {
		return (/** @this acorn.Parser */function (node) {
				if (extra.ecmaFeatures.impliedStrict && this.options.ecmaVersion >= 5) {
					this.strict = true;
				}
				return parseTopLevel.call(this, node);
			}
		);
	});

	instance.extend("toAssignable", function (toAssignable) {

		return (/** @this acorn.Parser */function (node, isBinding) {

				if (extra.ecmaFeatures.experimentalObjectRestSpread && node.type === "ObjectExpression") {
					node.type = "ObjectPattern";

					for (var i = 0; i < node.properties.length; i++) {
						var prop = node.properties[i];

						if (prop.type === "ExperimentalSpreadProperty") {
							prop.type = "ExperimentalRestProperty";
						} else if (prop.kind !== "init") {
							this.raise(prop.key.start, "Object pattern can't contain getter or setter");
						} else {
							this.toAssignable(prop.value, isBinding);
						}
					}

					return node;
				} else {
					return toAssignable.call(this, node, isBinding);
				}
			}
		);
	});
	instance.parseObjectRest = function () {
		var node = this.startNode();
		this.next();
		node.argument = this.parseIdent();

		if (this.type === tt.comma) {
			this.raise(this.start, "Unexpected trailing comma after rest property");
		}

		return this.finishNode(node, "ExperimentalRestProperty");
	};

	instance.extend("parseProperty", function (parseProperty) {
		return function (isPattern, refDestructuringErrors) {
			if (extra.ecmaFeatures.experimentalObjectRestSpread && this.type === tt.ellipsis) {
				var prop;

				if (isPattern) {
					prop = this.parseObjectRest();
				} else {
					prop = this.parseSpread();
					prop.type = "ExperimentalSpreadProperty";
				}

				return prop;
			}

			return parseProperty.call(this, isPattern, refDestructuringErrors);
		};
	});

	instance.extend("checkPropClash", function (checkPropClash) {
		return function (prop, propHash) {
			if (prop.type === "ExperimentalRestProperty" || prop.type === "ExperimentalSpreadProperty") {
				return;
			}
			checkPropClash.call(this, prop, propHash);
		};
	});
	instance.raise = instance.raiseRecoverable = function (pos, message) {
		var loc = getLineInfo(this.input, pos);
		var err = new SyntaxError(message);
		err.index = pos;
		err.lineNumber = loc.line;
		err.column = loc.column + 1; // acorn uses 0-based columns
		throw err;
	};
	instance.unexpected = function (pos) {
		var message = "Unexpected token";

		if (pos !== null && pos !== undefined) {
			this.pos = pos;

			if (this.options.locations) {
				while (this.pos < this.lineStart) {
					this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
					--this.curLine;
				}
			}

			this.nextToken();
		}

		if (this.end > this.start) {
			message += " " + this.input.slice(this.start, this.end);
		}

		this.raise(this.start, message);
	};
	instance.extend("jsx_readString", function (jsxReadString) {
		return (/** @this acorn.Parser */function (quote) {
				var result = jsxReadString.call(this, quote);
				if (this.type === tt.string) {
					extra.jsxAttrValueToken = true;
				}

				return result;
			}
		);
	});
};
function tokenize(code, options) {
	var toString,
		tokens,
		impliedStrict,
		translator = new TokenTranslator(tt, code);

	toString = String;
	if (typeof code !== "string" && !(code instanceof String)) {
		code = toString(code);
	}

	lookahead = null;
	options = assign({}, options);

	var acornOptions = { allowImportExportEverywhere: true,
		ecmaVersion: DEFAULT_ECMA_VERSION,
		plugins: {
			espree: true
		}
	};

	resetExtra();
	options.tokens = true;
	extra.tokens = [];

	extra.range = typeof options.range === "boolean" && options.range;
	acornOptions.ranges = extra.range;

	extra.loc = typeof options.loc === "boolean" && options.loc;
	acornOptions.locations = extra.loc;

	extra.comment = typeof options.comment === "boolean" && options.comment;

	if (extra.comment) {
		acornOptions.onComment = function () {
			var comment = convertAcornCommentToEsprimaComment.apply(this, arguments);
			extra.comments.push(comment);
		};
	}

	extra.tolerant = typeof options.tolerant === "boolean" && options.tolerant;

	acornOptions.ecmaVersion = extra.ecmaVersion = normalizeEcmaVersion(options.ecmaVersion);
	if (options.ecmaFeatures && _typeof(options.ecmaFeatures) === "object") {
		extra.ecmaFeatures = assign({}, options.ecmaFeatures);
		impliedStrict = extra.ecmaFeatures.impliedStrict;
		extra.ecmaFeatures.impliedStrict = typeof impliedStrict === "boolean" && impliedStrict;
	}

	try {
		var tokenizer = acorn.tokenizer(code, acornOptions);
		while ((lookahead = tokenizer.getToken()).type !== tt.eof) {
			translator.onToken(lookahead, extra);
		}
		tokens = extra.tokens;

		if (extra.comment) {
			tokens.comments = extra.comments;
		}
		if (extra.tolerant) {
			tokens.errors = extra.errors;
		}
	} catch (e) {
		throw e;
	}
	return tokens;
}
function convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc) {
	var comment = {
		type: block ? "Block" : "Line",
		value: text
	};

	if (typeof start === "number") {
		comment.start = start;
		comment.end = end;
		comment.range = [start, end];
	}

	if ((typeof startLoc === "undefined" ? "undefined" : _typeof(startLoc)) === "object") {
		comment.loc = {
			start: startLoc,
			end: endLoc
		};
	}

	return comment;
}
function parse(code, options) {
	var program,
		toString = String,
		translator,
		impliedStrict,
		acornOptions = { allowImportExportEverywhere: true,
		ecmaVersion: DEFAULT_ECMA_VERSION,
		plugins: {
			espree: true
		}
	};

	lastToken = null;

	if (typeof code !== "string" && !(code instanceof String)) {
		code = toString(code);
	}

	resetExtra();
	commentAttachment.reset();

	if (typeof options !== "undefined") {
		extra.range = typeof options.range === "boolean" && options.range;
		extra.loc = typeof options.loc === "boolean" && options.loc;
		extra.attachComment = typeof options.attachComment === "boolean" && options.attachComment;

		if (extra.loc && options.source !== null && options.source !== undefined) {
			extra.source = toString(options.source);
		}

		if (typeof options.tokens === "boolean" && options.tokens) {
			extra.tokens = [];
			translator = new TokenTranslator(tt, code);
		}
		if (typeof options.comment === "boolean" && options.comment) {
			extra.comment = true;
			extra.comments = [];
		}
		if (typeof options.tolerant === "boolean" && options.tolerant) {
			extra.errors = [];
		}
		if (extra.attachComment) {
			extra.range = true;
			extra.comments = [];
			commentAttachment.reset();
		}

		acornOptions.ecmaVersion = extra.ecmaVersion = normalizeEcmaVersion(options.ecmaVersion);

		if (options.sourceType === "module") {
			extra.isModule = true;
			if (acornOptions.ecmaVersion < 6) {
				acornOptions.ecmaVersion = 6;
				extra.ecmaVersion = 6;
			}

			acornOptions.sourceType = "module";
		}
		if (options.ecmaFeatures && _typeof(options.ecmaFeatures) === "object") {
			extra.ecmaFeatures = assign({}, options.ecmaFeatures);
			impliedStrict = extra.ecmaFeatures.impliedStrict;
			extra.ecmaFeatures.impliedStrict = typeof impliedStrict === "boolean" && impliedStrict;
			if (options.ecmaFeatures.globalReturn) {
				acornOptions.allowReturnOutsideFunction = true;
			}
		}

		acornOptions.onToken = function (token) {
			if (extra.tokens) {
				translator.onToken(token, extra);
			}
			if (token.type !== tt.eof) {
				lastToken = token;
			}
		};

		if (extra.attachComment || extra.comment) {
			acornOptions.onComment = function () {
				var comment = convertAcornCommentToEsprimaComment.apply(this, arguments);
				extra.comments.push(comment);

				if (extra.attachComment) {
					commentAttachment.addComment(comment);
				}
			};
		}

		if (extra.range) {
			acornOptions.ranges = true;
		}

		if (extra.loc) {
			acornOptions.locations = true;
		}

		if (extra.ecmaFeatures.jsx) {
			acornOptions.plugins = {
				jsx: true,
				espree: true
			};
		}
	}

	program = acorn.parse(code, acornOptions);
	program.sourceType = extra.isModule ? "module" : "script";

	if (extra.comment || extra.attachComment) {
		program.comments = extra.comments;
	}

	if (extra.tokens) {
		program.tokens = extra.tokens;
	}
	if (program.range) {
		program.range[0] = program.body.length ? program.body[0].range[0] : program.range[0];
		program.range[1] = lastToken ? lastToken.range[1] : program.range[1];
	}

	if (program.loc) {
		program.loc.start = program.body.length ? program.body[0].loc.start : program.loc.start;
		program.loc.end = lastToken ? lastToken.loc.end : program.loc.end;
	}

	return program;
}
exports.version = __webpack_require__(363).version;

exports.tokenize = tokenize;

exports.parse = parse;
exports.Syntax = function () {
	var name,
		types = {};

	if (typeof Object.create === "function") {
		types = Object.create(null);
	}

	for (name in astNodeTypes) {
		if (astNodeTypes.hasOwnProperty(name)) {
			types[name] = astNodeTypes[name];
		}
	}

	if (typeof Object.freeze === "function") {
		Object.freeze(types);
	}

	return types;
}();
exports.VisitorKeys = function () {
	var visitorKeys = __webpack_require__(364);
	var name,
		keys = {};

	if (typeof Object.create === "function") {
		keys = Object.create(null);
	}

	for (name in visitorKeys) {
		if (visitorKeys.hasOwnProperty(name)) {
			keys[name] = visitorKeys[name];
		}
	}

	if (typeof Object.freeze === "function") {
		Object.freeze(keys);
	}

	return keys;
}();
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var astUtils = __webpack_require__(0);

var FixTracker = function () {
	function FixTracker(fixer, sourceCode) {
		_classCallCheck(this, FixTracker);

		this.fixer = fixer;
		this.sourceCode = sourceCode;
		this.retainedRange = null;
	}


	_createClass(FixTracker, [{
		key: "retainRange",
		value: function retainRange(range) {
			this.retainedRange = range;
			return this;
		}

	}, {
		key: "retainEnclosingFunction",
		value: function retainEnclosingFunction(node) {
			var functionNode = astUtils.getUpperFunction(node);

			return this.retainRange(functionNode ? functionNode.range : this.sourceCode.ast.range);
		}

	}, {
		key: "retainSurroundingTokens",
		value: function retainSurroundingTokens(nodeOrToken) {
			var tokenBefore = this.sourceCode.getTokenBefore(nodeOrToken) || nodeOrToken;
			var tokenAfter = this.sourceCode.getTokenAfter(nodeOrToken) || nodeOrToken;

			return this.retainRange([tokenBefore.range[0], tokenAfter.range[1]]);
		}

	}, {
		key: "replaceTextRange",
		value: function replaceTextRange(range, text) {
			var actualRange = void 0;

			if (this.retainedRange) {
				actualRange = [Math.min(this.retainedRange[0], range[0]), Math.max(this.retainedRange[1], range[1])];
			} else {
				actualRange = range;
			}

			return this.fixer.replaceTextRange(actualRange, this.sourceCode.text.slice(actualRange[0], range[0]) + text + this.sourceCode.text.slice(range[1], actualRange[1]));
		}

	}, {
		key: "remove",
		value: function remove(nodeOrToken) {
			return this.replaceTextRange(nodeOrToken.range, "");
		}
	}]);

	return FixTracker;
}();

module.exports = FixTracker;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var JSX_ANNOTATION_REGEX = /^\*\s*@jsx\s+([^\s]+)/;
var JS_IDENTIFIER_REGEX = /^[_$a-zA-Z][_$a-zA-Z0-9]*$/;

function getCreateClassFromContext(context) {
  var pragma = 'createReactClass';
  if (context.settings.react && context.settings.react.createClass) {
	pragma = context.settings.react.createClass;
  }
  if (!JS_IDENTIFIER_REGEX.test(pragma)) {
	throw new Error('createClass pragma ' + pragma + ' is not a valid function name');
  }
  return pragma;
}

function getFromContext(context) {
  var pragma = 'React';

  var sourceCode = context.getSourceCode();
  var pragmaNode = sourceCode.getAllComments().find(function (node) {
	return JSX_ANNOTATION_REGEX.test(node.value);
  });

  if (pragmaNode) {
	var matches = JSX_ANNOTATION_REGEX.exec(pragmaNode.value);
	pragma = matches[1].split('.')[0];
  } else if (context.settings.react && context.settings.react.pragma) {
	pragma = context.settings.react.pragma;
  }

  if (!JS_IDENTIFIER_REGEX.test(pragma)) {
	throw new Error('React pragma ' + pragma + ' is not a valid identifier');
  }
  return pragma;
}

module.exports = {
  getCreateClassFromContext: getCreateClassFromContext,
  getFromContext: getFromContext
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function isAnnotatedFunctionPropsDeclaration(node, context) {
  if (!node || !node.params || !node.params.length) {
	return false;
  }

  var tokens = context.getFirstTokens(node.params[0], 2);
  var isAnnotated = node.params[0].typeAnnotation;
  var isDestructuredProps = node.params[0].type === 'ObjectPattern';
  var isProps = tokens[0].value === 'props' || tokens[1] && tokens[1].value === 'props';

  return isAnnotated && (isDestructuredProps || isProps);
}

module.exports = {
  isAnnotatedFunctionPropsDeclaration: isAnnotatedFunctionPropsDeclaration
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(3);
var document = __webpack_require__(4).document;
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(4);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(4);
var core = __webpack_require__(13);
var LIBRARY = __webpack_require__(42);
var wksExt = __webpack_require__(117);
var defineProperty = __webpack_require__(9).f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var toIObject = __webpack_require__(24);
var toLength = __webpack_require__(12);
var toAbsoluteIndex = __webpack_require__(37);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
	var O = toIObject($this);
	var length = toLength(O.length);
	var index = toAbsoluteIndex(fromIndex, length);
	var value;
	if (IS_INCLUDES && el != el) while (length > index) {
			value = O[index++];
			if (value != value) return true;
	} else for (; length > index; index++) {
			if (IS_INCLUDES || index in O) {
		if (O[index] === el) return IS_INCLUDES || index || 0;
			}
	}return !IS_INCLUDES && -1;
  };
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var shared = __webpack_require__(74)('keys');
var uid = __webpack_require__(36);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var cof = __webpack_require__(28);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var document = __webpack_require__(4).document;
module.exports = document && document.documentElement;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var isObject = __webpack_require__(3);
var anObject = __webpack_require__(5);
var check = function check(O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
  function (test, buggy, set) {
	try {
			set = __webpack_require__(22)(Function.call, __webpack_require__(30).f(Object.prototype, '__proto__').set, 2);
			set(test, []);
			buggy = !(test instanceof Array);
	} catch (e) {
			buggy = true;
	}
	return function setPrototypeOf(O, proto) {
			check(O, proto);
			if (buggy) O.__proto__ = proto;else set(O, proto);
			return O;
	};
  }({}, false) : undefined),
  check: check
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = '\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(3);
var setPrototypeOf = __webpack_require__(81).set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
	setPrototypeOf(that, P);
  }return that;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = Math.sign || function sign(x) {
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $expm1 = Math.expm1;
module.exports = !$expm1
|| $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
|| $expm1(-2e-17) != -2e-17 ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var LIBRARY = __webpack_require__(42);
var $export = __webpack_require__(1);
var redefine = __webpack_require__(15);
var hide = __webpack_require__(17);
var has = __webpack_require__(14);
var Iterators = __webpack_require__(44);
var $iterCreate = __webpack_require__(132);
var setToStringTag = __webpack_require__(41);
var getPrototypeOf = __webpack_require__(40);
var ITERATOR = __webpack_require__(6)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function returnThis() {
  return this;
};

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function getMethod(kind) {
	if (!BUGGY && kind in proto) return proto[kind];
	switch (kind) {
			case KEYS:
		return function keys() {
					return new Constructor(this, kind);
		};
			case VALUES:
		return function values() {
					return new Constructor(this, kind);
		};
	}return function entries() {
			return new Constructor(this, kind);
	};
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = !BUGGY && $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  if ($anyNative) {
	IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
	if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
			setToStringTag(IteratorPrototype, TAG, true);
			if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
	}
  }
  if (DEF_VALUES && $native && $native.name !== VALUES) {
	VALUES_BUG = true;
	$default = function values() {
			return $native.call(this);
	};
  }
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
	hide(proto, ITERATOR, $default);
  }
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
	methods = {
			values: DEF_VALUES ? $default : getMethod(VALUES),
			keys: IS_SET ? $default : getMethod(KEYS),
			entries: $entries
	};
	if (FORCED) for (key in methods) {
			if (!(key in proto)) redefine(proto, key, methods[key]);
	} else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var isRegExp = __webpack_require__(88);
var defined = __webpack_require__(34);

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var isObject = __webpack_require__(3);
var cof = __webpack_require__(28);
var MATCH = __webpack_require__(6)('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var MATCH = __webpack_require__(6)('match');
module.exports = function (KEY) {
  var re = /./;
  try {
	'/./'[KEY](re);
  } catch (e) {
	try {
			re[MATCH] = false;
			return !'/./'[KEY](re);
	} catch (f) {/* empty */}
  }return true;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var Iterators = __webpack_require__(44);
var ITERATOR = __webpack_require__(6)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var classof = __webpack_require__(53);
var ITERATOR = __webpack_require__(6)('iterator');
var Iterators = __webpack_require__(44);
module.exports = __webpack_require__(13).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var toObject = __webpack_require__(18);
var toAbsoluteIndex = __webpack_require__(37);
var toLength = __webpack_require__(12);
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) {
	O[index++] = value;
  }return O;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var addToUnscopables = __webpack_require__(54);
var step = __webpack_require__(139);
var Iterators = __webpack_require__(44);
var toIObject = __webpack_require__(24);
module.exports = __webpack_require__(86)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0; // next index
  this._k = kind; // kind
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
	this._t = undefined;
	return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var anObject = __webpack_require__(5);
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var anObject = __webpack_require__(5);
var aFunction = __webpack_require__(23);
var SPECIES = __webpack_require__(6)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(4);
var DESCRIPTORS = __webpack_require__(11);
var LIBRARY = __webpack_require__(42);
var $typed = __webpack_require__(65);
var hide = __webpack_require__(17);
var redefineAll = __webpack_require__(48);
var fails = __webpack_require__(2);
var anInstance = __webpack_require__(46);
var toInteger = __webpack_require__(29);
var toLength = __webpack_require__(12);
var toIndex = __webpack_require__(148);
var gOPN = __webpack_require__(39).f;
var dP = __webpack_require__(9).f;
var arrayFill = __webpack_require__(92);
var setToStringTag = __webpack_require__(41);
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  if (value != value || value === Infinity) {
	m = value != value ? 1 : 0;
	e = eMax;
  } else {
	e = floor(log(value) / LN2);
	if (value * (c = pow(2, -e)) < 1) {
			e--;
			c *= 2;
	}
	if (e + eBias >= 1) {
			value += rt / c;
	} else {
			value += rt * pow(2, 1 - eBias);
	}
	if (value * c >= 2) {
			e++;
			c /= 2;
	}
	if (e + eBias >= eMax) {
			m = 0;
			e = eMax;
	} else if (e + eBias >= 1) {
			m = (value * c - 1) * pow(2, mLen);
			e = e + eBias;
	} else {
			m = value * pow(2, eBias - 1) * pow(2, mLen);
			e = 0;
	}
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8) {}
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8) {}
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8) {}
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8) {}
  if (e === 0) {
	e = 1 - eBias;
  } else if (e === eMax) {
	return m ? NaN : s ? -Infinity : Infinity;
  } else {
	m = m + pow(2, mLen);
	e = e - eBias;
  }return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function get() {
			return this[internal];
	} });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) {
	store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
  }
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
	anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
	var byteLength = toIndex(length);
	this._b = arrayFill.call(new Array(byteLength), 0);
	this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
	anInstance(this, $DataView, DATA_VIEW);
	anInstance(buffer, $ArrayBuffer, DATA_VIEW);
	var bufferLength = buffer[$LENGTH];
	var offset = toInteger(byteOffset);
	if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
	byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
	if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
	this[$BUFFER] = buffer;
	this[$OFFSET] = offset;
	this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
	addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
	addGetter($DataView, BUFFER, '_b');
	addGetter($DataView, BYTE_LENGTH, '_l');
	addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
	getInt8: function getInt8(byteOffset) {
			return get(this, 1, byteOffset)[0] << 24 >> 24;
	},
	getUint8: function getUint8(byteOffset) {
			return get(this, 1, byteOffset)[0];
	},
	getInt16: function getInt16(byteOffset /* , littleEndian */) {
			var bytes = get(this, 2, byteOffset, arguments[1]);
			return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	},
	getUint16: function getUint16(byteOffset /* , littleEndian */) {
			var bytes = get(this, 2, byteOffset, arguments[1]);
			return bytes[1] << 8 | bytes[0];
	},
	getInt32: function getInt32(byteOffset /* , littleEndian */) {
			return unpackI32(get(this, 4, byteOffset, arguments[1]));
	},
	getUint32: function getUint32(byteOffset /* , littleEndian */) {
			return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
	},
	getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
			return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
	},
	getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
			return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
	},
	setInt8: function setInt8(byteOffset, value) {
			set(this, 1, byteOffset, packI8, value);
	},
	setUint8: function setUint8(byteOffset, value) {
			set(this, 1, byteOffset, packI8, value);
	},
	setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
			set(this, 2, byteOffset, packI16, value, arguments[2]);
	},
	setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
			set(this, 2, byteOffset, packI16, value, arguments[2]);
	},
	setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
			set(this, 4, byteOffset, packI32, value, arguments[2]);
	},
	setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
			set(this, 4, byteOffset, packI32, value, arguments[2]);
	},
	setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
			set(this, 4, byteOffset, packF32, value, arguments[2]);
	},
	setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
			set(this, 8, byteOffset, packF64, value, arguments[2]);
	}
  });
} else {
  if (!fails(function () {
	$ArrayBuffer(1);
  }) || !fails(function () {
	new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
	new $ArrayBuffer(); // eslint-disable-line no-new
	new $ArrayBuffer(1.5); // eslint-disable-line no-new
	new $ArrayBuffer(NaN); // eslint-disable-line no-new
	return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
	$ArrayBuffer = function ArrayBuffer(length) {
			anInstance(this, $ArrayBuffer);
			return new BaseBuffer(toIndex(length));
	};
	var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
	for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
			if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
	}
	if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
	setInt8: function setInt8(byteOffset, value) {
			$setInt8.call(this, byteOffset, value << 24 >> 24);
	},
	setUint8: function setUint8(byteOffset, value) {
			$setInt8.call(this, byteOffset, value << 24 >> 24);
	}
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $iterators = __webpack_require__(93);
var getKeys = __webpack_require__(43);
var redefine = __webpack_require__(15);
var global = __webpack_require__(4);
var hide = __webpack_require__(17);
var Iterators = __webpack_require__(44);
var wks = __webpack_require__(6);
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
	if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
	if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
	Iterators[NAME] = ArrayValues;
	if (explicit) for (key in $iterators) {
			if (!proto[key]) redefine(proto, key, $iterators[key], true);
	}
  }
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
			var length = arguments.length;
			var A = new Array(length);
			while (length--) {
		A[length] = arguments[length];
			}return new this(A);
	} });
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var aFunction = __webpack_require__(23);
var ctx = __webpack_require__(22);
var forOf = __webpack_require__(47);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
			var mapFn = arguments[1];
			var mapping, A, n, cb;
			aFunction(this);
			mapping = mapFn !== undefined;
			if (mapping) aFunction(mapFn);
			if (source == undefined) return new this();
			A = [];
			if (mapping) {
		n = 0;
		cb = ctx(mapFn, arguments[2], 2);
		forOf(source, false, function (nextItem) {
					A.push(cb(nextItem, n++));
		});
			} else {
		forOf(source, false, A.push, A);
			}
			return new this(A);
	} });
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var READ = 0x1;
var WRITE = 0x2;
var RW = READ | WRITE;

var Reference = function () {
  function Reference(ident, scope, flag, writeExpr, maybeImplicitGlobal, partial, init) {
	_classCallCheck(this, Reference);
	this.identifier = ident;
	this.from = scope;
	this.tainted = false;
	this.resolved = null;
	this.flag = flag;
	if (this.isWrite()) {
			this.writeExpr = writeExpr;
			this.partial = partial;
			this.init = init;
	}
	this.__maybeImplicitGlobal = maybeImplicitGlobal;
  }


  _createClass(Reference, [{
	key: "isStatic",
	value: function isStatic() {
			return !this.tainted && this.resolved && this.resolved.scope.isStatic();
	}

  }, {
	key: "isWrite",
	value: function isWrite() {
			return !!(this.flag & Reference.WRITE);
	}

  }, {
	key: "isRead",
	value: function isRead() {
			return !!(this.flag & Reference.READ);
	}

  }, {
	key: "isReadOnly",
	value: function isReadOnly() {
			return this.flag === Reference.READ;
	}

  }, {
	key: "isWriteOnly",
	value: function isWriteOnly() {
			return this.flag === Reference.WRITE;
	}

  }, {
	key: "isReadWrite",
	value: function isReadWrite() {
			return this.flag === Reference.RW;
	}
  }]);

  return Reference;
}();


Reference.READ = READ;
Reference.WRITE = WRITE;
Reference.RW = RW;

module.exports = Reference;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;
g = function () {
	return this;
}();

try {
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}
module.exports = g;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var debug = __webpack_require__(158);
function isReachable(segment) {
	return segment.reachable;
}

var CodePathSegment = function () {
	function CodePathSegment(id, allPrevSegments, reachable) {
		_classCallCheck(this, CodePathSegment);
		this.id = id;
		this.nextSegments = [];
		this.prevSegments = allPrevSegments.filter(isReachable);
		this.allNextSegments = [];
		this.allPrevSegments = allPrevSegments;
		this.reachable = reachable;
		Object.defineProperty(this, "internal", {
			value: {
				used: false,
				loopedPrevSegments: []
			}
		});
		if (debug.enabled) {
			this.internal.nodes = [];
			this.internal.exitNodes = [];
		}
	}


	_createClass(CodePathSegment, [{
		key: "isLoopedPrevSegment",
		value: function isLoopedPrevSegment(segment) {
			return this.internal.loopedPrevSegments.indexOf(segment) !== -1;
		}

	}], [{
		key: "newRoot",
		value: function newRoot(id) {
			return new CodePathSegment(id, [], true);
		}

	}, {
		key: "newNext",
		value: function newNext(id, allPrevSegments) {
			return new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), allPrevSegments.some(isReachable));
		}

	}, {
		key: "newUnreachable",
		value: function newUnreachable(id, allPrevSegments) {
			var segment = new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), false);
			CodePathSegment.markUsed(segment);

			return segment;
		}

	}, {
		key: "newDisconnected",
		value: function newDisconnected(id, allPrevSegments) {
			return new CodePathSegment(id, [], allPrevSegments.some(isReachable));
		}

	}, {
		key: "markUsed",
		value: function markUsed(segment) {
			if (segment.internal.used) {
				return;
			}
			segment.internal.used = true;

			var i = void 0;

			if (segment.reachable) {
				for (i = 0; i < segment.allPrevSegments.length; ++i) {
					var prevSegment = segment.allPrevSegments[i];

					prevSegment.allNextSegments.push(segment);
					prevSegment.nextSegments.push(segment);
				}
			} else {
				for (i = 0; i < segment.allPrevSegments.length; ++i) {
					segment.allPrevSegments[i].allNextSegments.push(segment);
				}
			}
		}

	}, {
		key: "markPrevSegmentAsLooped",
		value: function markPrevSegmentAsLooped(segment, prevSegment) {
			segment.internal.loopedPrevSegments.push(prevSegment);
		}

	}, {
		key: "flattenUnusedSegments",
		value: function flattenUnusedSegments(segments) {
			var done = Object.create(null);
			var retv = [];

			for (var i = 0; i < segments.length; ++i) {
				var segment = segments[i];
				if (done[segment.id]) {
					continue;
				}
				if (!segment.internal.used) {
					for (var j = 0; j < segment.allPrevSegments.length; ++j) {
						var prevSegment = segment.allPrevSegments[j];

						if (!done[prevSegment.id]) {
							done[prevSegment.id] = true;
							retv.push(prevSegment);
						}
					}
				} else {
					done[segment.id] = true;
					retv.push(segment);
				}
			}

			return retv;
		}
	}]);

	return CodePathSegment;
}();

module.exports = CodePathSegment;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function(process) {
//
//
//
function normalizeArray(parts, allowAboveRoot) {
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
	var last = parts[i];
	if (last === '.') {
			parts.splice(i, 1);
	} else if (last === '..') {
			parts.splice(i, 1);
			up++;
	} else if (up) {
			parts.splice(i, 1);
			up--;
	}
  }
  if (allowAboveRoot) {
	for (; up--; up) {
			parts.unshift('..');
	}
  }

  return parts;
}
var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function splitPath(filename) {
  return splitPathRe.exec(filename).slice(1);
};
exports.resolve = function () {
  var resolvedPath = '',
			resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	var path = i >= 0 ? arguments[i] : process.cwd();
	if (typeof path !== 'string') {
			throw new TypeError('Arguments to path.resolve must be strings');
	} else if (!path) {
			continue;
	}

	resolvedPath = path + '/' + resolvedPath;
	resolvedAbsolute = path.charAt(0) === '/';
  }
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
	return !!p;
  }), !resolvedAbsolute).join('/');

  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
};
exports.normalize = function (path) {
  var isAbsolute = exports.isAbsolute(path),
			trailingSlash = substr(path, -1) === '/';
  path = normalizeArray(filter(path.split('/'), function (p) {
	return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
	path = '.';
  }
  if (path && trailingSlash) {
	path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};
exports.isAbsolute = function (path) {
  return path.charAt(0) === '/';
};
exports.join = function () {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function (p, index) {
	if (typeof p !== 'string') {
			throw new TypeError('Arguments to path.join must be strings');
	}
	return p;
  }).join('/'));
};
exports.relative = function (from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
	var start = 0;
	for (; start < arr.length; start++) {
			if (arr[start] !== '') break;
	}

	var end = arr.length - 1;
	for (; end >= 0; end--) {
			if (arr[end] !== '') break;
	}

	if (start > end) return [];
	return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
	if (fromParts[i] !== toParts[i]) {
			samePartsLength = i;
			break;
	}
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
	outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  var result = splitPath(path),
			root = result[0],
			dir = result[1];

  if (!root && !dir) {
	return '.';
  }

  if (dir) {
	dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};

exports.basename = function (path, ext) {
  var f = splitPath(path)[2];
  if (ext && f.substr(-1 * ext.length) === ext) {
	f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  return splitPath(path)[3];
};

function filter(xs, f) {
  if (xs.filter) return xs.filter(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
	if (f(xs[i], i, xs)) res.push(xs[i]);
  }
  return res;
}
var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
  return str.substr(start, len);
} : function (str, start, len) {
  if (start < 0) start = str.length + start;
  return str.substr(start, len);
};
}.call(exports, __webpack_require__(20)))
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Cursor = __webpack_require__(55);
module.exports = function (_Cursor) {
  _inherits(DecorativeCursor, _Cursor);
  function DecorativeCursor(cursor) {
	_classCallCheck(this, DecorativeCursor);

	var _this = _possibleConstructorReturn(this, (DecorativeCursor.__proto__ || Object.getPrototypeOf(DecorativeCursor)).call(this));

	_this.cursor = cursor;
	return _this;
  }


  _createClass(DecorativeCursor, [{
	key: "moveNext",
	value: function moveNext() {
			var retv = this.cursor.moveNext();

			this.current = this.cursor.current;

			return retv;
	}
  }]);

  return DecorativeCursor;
}(Cursor);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Cursor = __webpack_require__(55);
var utils = __webpack_require__(56);
module.exports = function (_Cursor) {
	_inherits(ForwardTokenCursor, _Cursor);
	function ForwardTokenCursor(tokens, comments, indexMap, startLoc, endLoc) {
		_classCallCheck(this, ForwardTokenCursor);

		var _this = _possibleConstructorReturn(this, (ForwardTokenCursor.__proto__ || Object.getPrototypeOf(ForwardTokenCursor)).call(this));

		_this.tokens = tokens;
		_this.index = utils.getFirstIndex(tokens, indexMap, startLoc);
		_this.indexEnd = utils.getLastIndex(tokens, indexMap, endLoc);
		return _this;
	}


	_createClass(ForwardTokenCursor, [{
		key: "moveNext",
		value: function moveNext() {
			if (this.index <= this.indexEnd) {
				this.current = this.tokens[this.index];
				this.index += 1;
				return true;
			}
			return false;
		}

	}, {
		key: "getOneToken",
		value: function getOneToken() {
			return this.index <= this.indexEnd ? this.tokens[this.index] : null;
		}

	}, {
		key: "getAllTokens",
		value: function getAllTokens() {
			return this.tokens.slice(this.index, this.indexEnd + 1);
		}
	}]);

	return ForwardTokenCursor;
}(Cursor);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var estraverse = __webpack_require__(50);
var KEY_BLACKLIST = new Set(["parent", "leadingComments", "trailingComments"]);

var Traverser = function (_estraverse$Controlle) {
	_inherits(Traverser, _estraverse$Controlle);

	function Traverser() {
		_classCallCheck(this, Traverser);

		return _possibleConstructorReturn(this, (Traverser.__proto__ || Object.getPrototypeOf(Traverser)).apply(this, arguments));
	}

	_createClass(Traverser, [{
		key: "traverse",
		value: function traverse(node, visitor) {
			visitor.fallback = Traverser.getKeys;
			return _get(Traverser.prototype.__proto__ || Object.getPrototypeOf(Traverser.prototype), "traverse", this).call(this, node, visitor);
		}

	}], [{
		key: "getKeys",
		value: function getKeys(node) {
			return Object.keys(node).filter(function (key) {
				return !KEY_BLACKLIST.has(key);
			});
		}
	}]);

	return Traverser;
}(estraverse.Controller);

module.exports = Traverser;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = ["abstract", "boolean", "break", "byte", "case", "catch", "char", "class", "const", "continue", "debugger", "default", "delete", "do", "double", "else", "enum", "export", "extends", "false", "final", "finally", "float", "for", "function", "goto", "if", "implements", "import", "in", "instanceof", "int", "interface", "long", "native", "new", "null", "package", "private", "protected", "public", "return", "short", "static", "super", "switch", "synchronized", "this", "throw", "throws", "transient", "true", "try", "typeof", "var", "void", "volatile", "while", "with"];
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function(global, process) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
//
//
//
var formatRegExp = /%[sdj%]/g;
exports.format = function (f) {
  if (!isString(f)) {
	var objects = [];
	for (var i = 0; i < arguments.length; i++) {
			objects.push(inspect(arguments[i]));
	}
	return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function (x) {
	if (x === '%%') return '%';
	if (i >= len) return x;
	switch (x) {
			case '%s':
		return String(args[i++]);
			case '%d':
		return Number(args[i++]);
			case '%j':
		try {
					return JSON.stringify(args[i++]);
		} catch (_) {
					return '[Circular]';
		}
			default:
		return x;
	}
  });
  for (var x = args[i]; i < len; x = args[++i]) {
	if (isNull(x) || !isObject(x)) {
			str += ' ' + x;
	} else {
			str += ' ' + inspect(x);
	}
  }
  return str;
};
exports.deprecate = function (fn, msg) {
  if (isUndefined(global.process)) {
	return function () {
			return exports.deprecate(fn, msg).apply(this, arguments);
	};
  }

  if (process.noDeprecation === true) {
	return fn;
  }

  var warned = false;
  function deprecated() {
	if (!warned) {
			if (process.throwDeprecation) {
		throw new Error(msg);
			} else if (process.traceDeprecation) {
		console.trace(msg);
			} else {
		console.error(msg);
			}
			warned = true;
	}
	return fn.apply(this, arguments);
  }

  return deprecated;
};

var debugs = {};
var debugEnviron;
exports.debuglog = function (set) {
  if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
	if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
			var pid = process.pid;
			debugs[set] = function () {
		var msg = exports.format.apply(exports, arguments);
		console.error('%s %d: %s', set, pid, msg);
			};
	} else {
			debugs[set] = function () {};
	}
  }
  return debugs[set];
};
function inspect(obj, opts) {
  var ctx = {
	seen: [],
	stylize: stylizeNoColor
  };
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
	ctx.showHidden = opts;
  } else if (opts) {
	exports._extend(ctx, opts);
  }
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;
inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
};
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  'regexp': 'red'
};

function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
	return '\x1B[' + inspect.colors[style][0] + 'm' + str + '\x1B[' + inspect.colors[style][1] + 'm';
  } else {
	return str;
  }
}

function stylizeNoColor(str, styleType) {
  return str;
}

function arrayToHash(array) {
  var hash = {};

  array.forEach(function (val, idx) {
	hash[val] = true;
  });

  return hash;
}

function formatValue(ctx, value, recurseTimes) {
  if (ctx.customInspect && value && isFunction(value.inspect) &&
  value.inspect !== exports.inspect &&
  !(value.constructor && value.constructor.prototype === value)) {
	var ret = value.inspect(recurseTimes, ctx);
	if (!isString(ret)) {
			ret = formatValue(ctx, ret, recurseTimes);
	}
	return ret;
  }
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
	return primitive;
  }
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
	keys = Object.getOwnPropertyNames(value);
  }
  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	return formatError(value);
  }
  if (keys.length === 0) {
	if (isFunction(value)) {
			var name = value.name ? ': ' + value.name : '';
			return ctx.stylize('[Function' + name + ']', 'special');
	}
	if (isRegExp(value)) {
			return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	}
	if (isDate(value)) {
			return ctx.stylize(Date.prototype.toString.call(value), 'date');
	}
	if (isError(value)) {
			return formatError(value);
	}
  }

  var base = '',
			array = false,
			braces = ['{', '}'];
  if (isArray(value)) {
	array = true;
	braces = ['[', ']'];
  }
  if (isFunction(value)) {
	var n = value.name ? ': ' + value.name : '';
	base = ' [Function' + n + ']';
  }
  if (isRegExp(value)) {
	base = ' ' + RegExp.prototype.toString.call(value);
  }
  if (isDate(value)) {
	base = ' ' + Date.prototype.toUTCString.call(value);
  }
  if (isError(value)) {
	base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
	return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
	if (isRegExp(value)) {
			return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	} else {
			return ctx.stylize('[Object]', 'special');
	}
  }

  ctx.seen.push(value);

  var output;
  if (array) {
	output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
	output = keys.map(function (key) {
			return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	});
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}

function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
	var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
	return ctx.stylize(simple, 'string');
  }
  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
  if (isNull(value)) return ctx.stylize('null', 'null');
}

function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
	if (hasOwnProperty(value, String(i))) {
			output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
	} else {
			output.push('');
	}
  }
  keys.forEach(function (key) {
	if (!key.match(/^\d+$/)) {
			output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
	}
  });
  return output;
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
	if (desc.set) {
			str = ctx.stylize('[Getter/Setter]', 'special');
	} else {
			str = ctx.stylize('[Getter]', 'special');
	}
  } else {
	if (desc.set) {
			str = ctx.stylize('[Setter]', 'special');
	}
  }
  if (!hasOwnProperty(visibleKeys, key)) {
	name = '[' + key + ']';
  }
  if (!str) {
	if (ctx.seen.indexOf(desc.value) < 0) {
			if (isNull(recurseTimes)) {
		str = formatValue(ctx, desc.value, null);
			} else {
		str = formatValue(ctx, desc.value, recurseTimes - 1);
			}
			if (str.indexOf('\n') > -1) {
		if (array) {
					str = str.split('\n').map(function (line) {
			return '  ' + line;
					}).join('\n').substr(2);
		} else {
					str = '\n' + str.split('\n').map(function (line) {
			return '   ' + line;
					}).join('\n');
		}
			}
	} else {
			str = ctx.stylize('[Circular]', 'special');
	}
  }
  if (isUndefined(name)) {
	if (array && key.match(/^\d+$/)) {
			return str;
	}
	name = JSON.stringify('' + key);
	if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
			name = name.substr(1, name.length - 2);
			name = ctx.stylize(name, 'name');
	} else {
			name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
			name = ctx.stylize(name, 'string');
	}
  }

  return name + ': ' + str;
}

function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function (prev, cur) {
	numLinesEst++;
	if (cur.indexOf('\n') >= 0) numLinesEst++;
	return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
	return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(649);

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}
exports.log = function () {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};
exports.inherits = __webpack_require__(650);

exports._extend = function (origin, add) {
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
	origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
}.call(exports, __webpack_require__(101), __webpack_require__(20)))
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _hasProp = __webpack_require__(679);

var _hasProp2 = _interopRequireDefault(_hasProp);

var _elementType = __webpack_require__(680);

var _elementType2 = _interopRequireDefault(_elementType);

var _eventHandlers = __webpack_require__(681);

var _eventHandlers2 = _interopRequireDefault(_eventHandlers);

var _getProp = __webpack_require__(682);

var _getProp2 = _interopRequireDefault(_getProp);

var _getPropValue = __webpack_require__(683);

var _getPropValue2 = _interopRequireDefault(_getPropValue);

var _propName = __webpack_require__(110);

var _propName2 = _interopRequireDefault(_propName);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

module.exports = {
  hasProp: _hasProp2.default,
  hasAnyProp: _hasProp.hasAnyProp,
  hasEveryProp: _hasProp.hasEveryProp,
  elementType: _elementType2.default,
  eventHandlers: _eventHandlers2.default,
  eventHandlersByType: _eventHandlers.eventHandlersByType,
  getProp: _getProp2.default,
  getPropValue: _getPropValue2.default,
  getLiteralPropValue: _getPropValue.getLiteralPropValue,
  propName: _propName2.default
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = propName;
function propName() {
  var prop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  if (!prop.type || prop.type !== 'JSXAttribute') {
	throw new Error('The prop must be a JSXAttribute collected by the AST parser.');
  }

  if (prop.name.type === 'JSXNamespacedName') {
	return prop.name.namespace.name + ':' + prop.name.name.name;
  }

  return prop.name.name;
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
function makeNoMethodSetStateRule(methodName) {
  return {
	meta: {
			docs: {
		description: 'Prevent usage of setState in ' + methodName,
		category: 'Best Practices',
		recommended: false
			},

			schema: [{
		enum: ['disallow-in-func']
			}]
	},

	create: function create(context) {
			var mode = context.options[0] || 'allow-in-func';
			return {

		CallExpression: function CallExpression(node) {
					var callee = node.callee;
					if (callee.type !== 'MemberExpression' || callee.object.type !== 'ThisExpression' || callee.property.name !== 'setState') {
			return;
					}
					var ancestors = context.getAncestors(callee).reverse();
					var depth = 0;
					for (var i = 0, j = ancestors.length; i < j; i++) {
			if (/Function(Expression|Declaration)$/.test(ancestors[i].type)) {
							depth++;
			}
			if (ancestors[i].type !== 'Property' && ancestors[i].type !== 'MethodDefinition' || ancestors[i].key.name !== methodName || mode !== 'disallow-in-func' && depth > 1) {
							continue;
			}
			context.report({
							node: callee,
							message: 'Do not use setState in ' + methodName
			});
			break;
					}
		}
			};
	}
  };
}

module.exports = makeNoMethodSetStateRule;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function makeEmptyFunction(arg) {
  return function () {
	return arg;
  };
}
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
	if (format === undefined) {
			throw new Error('invariant requires an error message argument');
	}
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
	var error;
	if (format === undefined) {
			error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	} else {
			var args = [a, b, c, d, e, f];
			var argIndex = 0;
			error = new Error(format.replace(/%s/g, function () {
		return args[argIndex++];
			}));
			error.name = 'Invariant Violation';
	}

	error.framesToPop = 1; // we don't care about invariant's own frame
	throw error;
  }
}

module.exports = invariant;
}.call(exports, __webpack_require__(20)))
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var global = __webpack_require__(4);
var has = __webpack_require__(14);
var DESCRIPTORS = __webpack_require__(11);
var $export = __webpack_require__(1);
var redefine = __webpack_require__(15);
var META = __webpack_require__(33).KEY;
var $fails = __webpack_require__(2);
var shared = __webpack_require__(74);
var setToStringTag = __webpack_require__(41);
var uid = __webpack_require__(36);
var wks = __webpack_require__(6);
var wksExt = __webpack_require__(117);
var wksDefine = __webpack_require__(75);
var enumKeys = __webpack_require__(175);
var isArray = __webpack_require__(79);
var anObject = __webpack_require__(5);
var isObject = __webpack_require__(3);
var toIObject = __webpack_require__(24);
var toPrimitive = __webpack_require__(32);
var createDesc = __webpack_require__(35);
var _create = __webpack_require__(38);
var gOPNExt = __webpack_require__(120);
var $GOPD = __webpack_require__(30);
var $DP = __webpack_require__(9);
var $keys = __webpack_require__(43);
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
	get: function get() {
			return dP(this, 'a', { value: 7 }).a;
	}
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function wrap(tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && _typeof($Symbol.iterator) == 'symbol' ? function (it) {
  return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
	if (!D.enumerable) {
			if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
			it[HIDDEN][key] = true;
	} else {
			if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
			D = _create(D, { enumerable: createDesc(0, false) });
	}return setSymbolDesc(it, key, D);
  }return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) {
	$defineProperty(it, key = keys[i++], P[key]);
  }return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
	if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  }return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
	if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  }return result;
};
if (!USE_NATIVE) {
  $Symbol = function _Symbol() {
	if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
	var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	var $set = function $set(value) {
			if (this === ObjectProto) $set.call(OPSymbols, value);
			if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
			setSymbolDesc(this, tag, createDesc(1, value));
	};
	if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
	return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
	return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(39).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(59).f = $propertyIsEnumerable;
  __webpack_require__(58).f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(42)) {
	redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
	return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols =
'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), j = 0; es6Symbols.length > j;) {
  wks(es6Symbols[j++]);
}for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) {
  wksDefine(wellKnownSymbols[k++]);
}$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  'for': function _for(key) {
	return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
  },
  keyFor: function keyFor(sym) {
	if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
	for (var key in SymbolRegistry) {
			if (SymbolRegistry[key] === sym) return key;
	}
  },
  useSetter: function useSetter() {
	setter = true;
  },
  useSimple: function useSimple() {
	setter = false;
  }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  create: $create,
  defineProperty: $defineProperty,
  defineProperties: $defineProperties,
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  getOwnPropertyNames: $getOwnPropertyNames,
  getOwnPropertySymbols: $getOwnPropertySymbols
});
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
	var args = [it];
	var i = 1;
	var replacer, $replacer;
	while (arguments.length > i) {
			args.push(arguments[i++]);
	}$replacer = replacer = args[1];
	if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
	if (!isArray(replacer)) replacer = function replacer(key, value) {
			if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
			if (!isSymbol(value)) return value;
	};
	args[1] = replacer;
	return _stringify.apply($JSON, args);
  }
});
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(17)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
setToStringTag($Symbol, 'Symbol');
setToStringTag(Math, 'Math', true);
setToStringTag(global.JSON, 'JSON', true);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = !__webpack_require__(11) && !__webpack_require__(2)(function () {
  return Object.defineProperty(__webpack_require__(73)('div'), 'a', { get: function get() {
			return 7;
	} }).a != 7;
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


exports.f = __webpack_require__(6);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(14);
var toIObject = __webpack_require__(24);
var arrayIndexOf = __webpack_require__(76)(false);
var IE_PROTO = __webpack_require__(77)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) {
	if (key != IE_PROTO) has(O, key) && result.push(key);
  } // Don't enum bug & hidden keys
  while (names.length > i) {
	if (has(O, key = names[i++])) {
			~arrayIndexOf(result, key) || result.push(key);
	}
  }return result;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var dP = __webpack_require__(9);
var anObject = __webpack_require__(5);
var getKeys = __webpack_require__(43);

module.exports = __webpack_require__(11) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) {
	dP.f(O, P = keys[i++], Properties[P]);
  }return O;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
var toIObject = __webpack_require__(24);
var gOPN = __webpack_require__(39).f;
var toString = {}.toString;

var windowNames = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function getWindowNames(it) {
  try {
	return gOPN(it);
  } catch (e) {
	return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var getKeys = __webpack_require__(43);
var gOPS = __webpack_require__(58);
var pIE = __webpack_require__(59);
var toObject = __webpack_require__(18);
var IObject = __webpack_require__(51);
var $assign = Object.assign;
module.exports = !$assign || __webpack_require__(2)(function () {
  var A = {};
  var B = {};
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) {
	B[k] = k;
  });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) {
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
	var S = IObject(arguments[index++]);
	var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
	var length = keys.length;
	var j = 0;
	var key;
	while (length > j) {
			if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
	}
  }return T;
} : $assign;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var aFunction = __webpack_require__(23);
var isObject = __webpack_require__(3);
var invoke = __webpack_require__(123);
var arraySlice = [].slice;
var factories = {};

var construct = function construct(F, len, args) {
  if (!(len in factories)) {
	for (var n = [], i = 0; i < len; i++) {
			n[i] = 'a[' + i + ']';
	} // eslint-disable-next-line no-new-func
	factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  }return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function bound() /* args... */{
	var args = partArgs.concat(arraySlice.call(arguments));
	return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = function (fn, args, that) {
									var un = that === undefined;
									switch (args.length) {
									case 0:
																											return un ? fn() : fn.call(that);
									case 1:
																											return un ? fn(args[0]) : fn.call(that, args[0]);
									case 2:
																											return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
									case 3:
																											return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
									case 4:
																											return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
									}return fn.apply(that, args);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $parseInt = __webpack_require__(4).parseInt;
var $trim = __webpack_require__(60).trim;
var ws = __webpack_require__(82);
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, radix >>> 0 || (hex.test(string) ? 16 : 10));
} : $parseInt;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $parseFloat = __webpack_require__(4).parseFloat;
var $trim = __webpack_require__(60).trim;

module.exports = 1 / $parseFloat(__webpack_require__(82) + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var cof = __webpack_require__(28);
module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var toInteger = __webpack_require__(29);
var defined = __webpack_require__(34);

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (; n > 0; (n >>>= 1) && (str += str)) {
	if (n & 1) res += str;
  }return res;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var isObject = __webpack_require__(3);
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var toIObject = __webpack_require__(24);
var toLength = __webpack_require__(12);

$export($export.S, 'String', {
  raw: function raw(callSite) {
	var tpl = toIObject(callSite.raw);
	var len = toLength(tpl.length);
	var aLen = arguments.length;
	var res = [];
	var i = 0;
	while (len > i) {
			res.push(String(tpl[i++]));
			if (i < aLen) res.push(String(arguments[i]));
	}return res.join('');
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var toInteger = __webpack_require__(29);
var defined = __webpack_require__(34);
module.exports = function (TO_STRING) {
  return function (that, pos) {
	var s = String(defined(that));
	var i = toInteger(pos);
	var l = s.length;
	var a, b;
	if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
	a = s.charCodeAt(i);
	return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var create = __webpack_require__(38);
var descriptor = __webpack_require__(35);
var setToStringTag = __webpack_require__(41);
var IteratorPrototype = {};
__webpack_require__(17)(IteratorPrototype, __webpack_require__(6)('iterator'), function () {
  return this;
});

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var ctx = __webpack_require__(22);
var $export = __webpack_require__(1);
var toObject = __webpack_require__(18);
var call = __webpack_require__(134);
var isArrayIter = __webpack_require__(90);
var toLength = __webpack_require__(12);
var createProperty = __webpack_require__(135);
var getIterFn = __webpack_require__(91);

$export($export.S + $export.F * !__webpack_require__(62)(function (iter) {
  Array.from(iter);
}), 'Array', {
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
	var O = toObject(arrayLike);
	var C = typeof this == 'function' ? this : Array;
	var aLen = arguments.length;
	var mapfn = aLen > 1 ? arguments[1] : undefined;
	var mapping = mapfn !== undefined;
	var index = 0;
	var iterFn = getIterFn(O);
	var length, result, step, iterator;
	if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
			for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
		createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
			}
	} else {
			length = toLength(O.length);
			for (result = new C(length); length > index; index++) {
		createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
			}
	}
	result.length = index;
	return result;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var anObject = __webpack_require__(5);
module.exports = function (iterator, fn, value, entries) {
  try {
	return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  } catch (e) {
	var ret = iterator['return'];
	if (ret !== undefined) anObject(ret.call(iterator));
	throw e;
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $defineProperty = __webpack_require__(9);
var createDesc = __webpack_require__(35);

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));else object[index] = value;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var aFunction = __webpack_require__(23);
var toObject = __webpack_require__(18);
var IObject = __webpack_require__(51);
var toLength = __webpack_require__(12);

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
	if (index in self) {
			memo = self[index];
			index += i;
			break;
	}
	index += i;
	if (isRight ? index < 0 : length <= index) {
			throw TypeError('Reduce of empty array with no initial value');
	}
  }
  for (; isRight ? index >= 0 : length > index; index += i) {
	if (index in self) {
			memo = callbackfn(memo, self[index], index, O);
	}
  }return memo;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var toObject = __webpack_require__(18);
var toAbsoluteIndex = __webpack_require__(37);
var toLength = __webpack_require__(12);

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
	inc = -1;
	from += count - 1;
	to += count - 1;
  }
  while (count-- > 0) {
	if (from in O) O[to] = O[from];else delete O[to];
	to += inc;
	from += inc;
  }return O;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var $find = __webpack_require__(26)(6);
var KEY = 'findIndex';
var forced = true;
if (KEY in []) Array(1)[KEY](function () {
  forced = false;
});
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
	return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(54)(KEY);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (done, value) {
  return { value: value, done: !!done };
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
if (__webpack_require__(11) && /./g.flags != 'g') __webpack_require__(9).f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__(94)
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var ctx = __webpack_require__(22);
var invoke = __webpack_require__(123);
var html = __webpack_require__(80);
var cel = __webpack_require__(73);
var global = __webpack_require__(4);
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function run() {
  var id = +this;
  if (queue.hasOwnProperty(id)) {
	var fn = queue[id];
	delete queue[id];
	fn();
  }
};
var listener = function listener(event) {
  run.call(event.data);
};
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
	var args = [];
	var i = 1;
	while (arguments.length > i) {
			args.push(arguments[i++]);
	}queue[++counter] = function () {
			invoke(typeof fn == 'function' ? fn : Function(fn), args);
	};
	defer(counter);
	return counter;
  };
  clearTask = function clearImmediate(id) {
	delete queue[id];
  };
  if (__webpack_require__(28)(process) == 'process') {
	defer = function defer(id) {
			process.nextTick(ctx(run, id, 1));
	};
  } else if (Dispatch && Dispatch.now) {
	defer = function defer(id) {
			Dispatch.now(ctx(run, id, 1));
	};
  } else if (MessageChannel) {
	channel = new MessageChannel();
	port = channel.port2;
	channel.port1.onmessage = listener;
	defer = ctx(port.postMessage, port, 1);
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
	defer = function defer(id) {
			global.postMessage(id + '', '*');
	};
	global.addEventListener('message', listener, false);
  } else if (ONREADYSTATECHANGE in cel('script')) {
	defer = function defer(id) {
			html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
		html.removeChild(this);
		run.call(id);
			};
	};
  } else {
	defer = function defer(id) {
			setTimeout(ctx(run, id, 1), 0);
	};
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var aFunction = __webpack_require__(23);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
	if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
	resolve = $$resolve;
	reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var strong = __webpack_require__(144);
var validate = __webpack_require__(49);
var MAP = 'Map';
module.exports = __webpack_require__(64)(MAP, function (get) {
  return function Map() {
	return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  get: function get(key) {
	var entry = strong.getEntry(validate(this, MAP), key);
	return entry && entry.v;
  },
  set: function set(key, value) {
	return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var dP = __webpack_require__(9).f;
var create = __webpack_require__(38);
var redefineAll = __webpack_require__(48);
var ctx = __webpack_require__(22);
var anInstance = __webpack_require__(46);
var forOf = __webpack_require__(47);
var $iterDefine = __webpack_require__(86);
var step = __webpack_require__(139);
var setSpecies = __webpack_require__(45);
var DESCRIPTORS = __webpack_require__(11);
var fastKey = __webpack_require__(33).fastKey;
var validate = __webpack_require__(49);
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function getEntry(that, key) {
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  for (entry = that._f; entry; entry = entry.n) {
	if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
	var C = wrapper(function (that, iterable) {
			anInstance(that, C, NAME, '_i');
			that._t = NAME; // collection type
			that._i = create(null); // index
			that._f = undefined; // first entry
			that._l = undefined; // last entry
			that[SIZE] = 0; // size
			if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
	});
	redefineAll(C.prototype, {
			clear: function clear() {
		for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
					entry.r = true;
					if (entry.p) entry.p = entry.p.n = undefined;
					delete data[entry.i];
		}
		that._f = that._l = undefined;
		that[SIZE] = 0;
			},
			'delete': function _delete(key) {
		var that = validate(this, NAME);
		var entry = getEntry(that, key);
		if (entry) {
					var next = entry.n;
					var prev = entry.p;
					delete that._i[entry.i];
					entry.r = true;
					if (prev) prev.n = next;
					if (next) next.p = prev;
					if (that._f == entry) that._f = next;
					if (that._l == entry) that._l = prev;
					that[SIZE]--;
		}return !!entry;
			},
			forEach: function forEach(callbackfn /* , that = undefined */) {
		validate(this, NAME);
		var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
		var entry;
		while (entry = entry ? entry.n : this._f) {
					f(entry.v, entry.k, this);
					while (entry && entry.r) {
			entry = entry.p;
					}
		}
			},
			has: function has(key) {
		return !!getEntry(validate(this, NAME), key);
			}
	});
	if (DESCRIPTORS) dP(C.prototype, 'size', {
			get: function get() {
		return validate(this, NAME)[SIZE];
			}
	});
	return C;
  },
  def: function def(that, key, value) {
	var entry = getEntry(that, key);
	var prev, index;
	if (entry) {
			entry.v = value;
	} else {
			that._l = entry = {
		i: index = fastKey(key, true), // <- index
		k: key, // <- key
		v: value, // <- value
		p: prev = that._l, // <- previous entry
		n: undefined, // <- next entry
		r: false // <- removed
			};
			if (!that._f) that._f = entry;
			if (prev) prev.n = entry;
			that[SIZE]++;
			if (index !== 'F') that._i[index] = entry;
	}return that;
  },
  getEntry: getEntry,
  setStrong: function setStrong(C, NAME, IS_MAP) {
	$iterDefine(C, NAME, function (iterated, kind) {
			this._t = validate(iterated, NAME); // target
			this._k = kind; // kind
			this._l = undefined; // previous
	}, function () {
			var that = this;
			var kind = that._k;
			var entry = that._l;
			while (entry && entry.r) {
		entry = entry.p;
			} // get next entry
			if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
		that._t = undefined;
		return step(1);
			}
			if (kind == 'keys') return step(0, entry.k);
			if (kind == 'values') return step(0, entry.v);
			return step(0, [entry.k, entry.v]);
	}, IS_MAP ? 'entries' : 'values', !IS_MAP, true);
	setSpecies(NAME);
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var strong = __webpack_require__(144);
var validate = __webpack_require__(49);
var SET = 'Set';
module.exports = __webpack_require__(64)(SET, function (get) {
  return function Set() {
	return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  add: function add(value) {
	return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var each = __webpack_require__(26)(0);
var redefine = __webpack_require__(15);
var meta = __webpack_require__(33);
var assign = __webpack_require__(121);
var weak = __webpack_require__(147);
var isObject = __webpack_require__(3);
var fails = __webpack_require__(2);
var validate = __webpack_require__(49);
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function wrapper(get) {
  return function WeakMap() {
	return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  get: function get(key) {
	if (isObject(key)) {
			var data = getWeak(key);
			if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
			return data ? data[this._i] : undefined;
	}
  },
  set: function set(key, value) {
	return weak.def(validate(this, WEAK_MAP), key, value);
  }
};
var $WeakMap = module.exports = __webpack_require__(64)(WEAK_MAP, wrapper, methods, weak, true, true);
if (fails(function () {
  return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7;
})) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
	var proto = $WeakMap.prototype;
	var method = proto[key];
	redefine(proto, key, function (a, b) {
			if (isObject(a) && !isExtensible(a)) {
		if (!this._f) this._f = new InternalMap();
		var result = this._f[key](a, b);
		return key == 'set' ? this : result;
			}return method.call(this, a, b);
	});
  });
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var redefineAll = __webpack_require__(48);
var getWeak = __webpack_require__(33).getWeak;
var anObject = __webpack_require__(5);
var isObject = __webpack_require__(3);
var anInstance = __webpack_require__(46);
var forOf = __webpack_require__(47);
var createArrayMethod = __webpack_require__(26);
var $has = __webpack_require__(14);
var validate = __webpack_require__(49);
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;
var uncaughtFrozenStore = function uncaughtFrozenStore(that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function UncaughtFrozenStore() {
  this.a = [];
};
var findUncaughtFrozen = function findUncaughtFrozen(store, key) {
  return arrayFind(store.a, function (it) {
	return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function get(key) {
	var entry = findUncaughtFrozen(this, key);
	if (entry) return entry[1];
  },
  has: function has(key) {
	return !!findUncaughtFrozen(this, key);
  },
  set: function set(key, value) {
	var entry = findUncaughtFrozen(this, key);
	if (entry) entry[1] = value;else this.a.push([key, value]);
  },
  'delete': function _delete(key) {
	var index = arrayFindIndex(this.a, function (it) {
			return it[0] === key;
	});
	if (~index) this.a.splice(index, 1);
	return !!~index;
  }
};

module.exports = {
  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
	var C = wrapper(function (that, iterable) {
			anInstance(that, C, NAME, '_i');
			that._t = NAME; // collection type
			that._i = id++; // collection id
			that._l = undefined; // leak store for uncaught frozen objects
			if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
	});
	redefineAll(C.prototype, {
			'delete': function _delete(key) {
		if (!isObject(key)) return false;
		var data = getWeak(key);
		if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
		return data && $has(data, this._i) && delete data[this._i];
			},
			has: function has(key) {
		if (!isObject(key)) return false;
		var data = getWeak(key);
		if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
		return data && $has(data, this._i);
			}
	});
	return C;
  },
  def: function def(that, key, value) {
	var data = getWeak(anObject(key), true);
	if (data === true) uncaughtFrozenStore(that).set(key, value);else data[that._i] = value;
	return that;
  },
  ufstore: uncaughtFrozenStore
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var toInteger = __webpack_require__(29);
var toLength = __webpack_require__(12);
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var classof = __webpack_require__(53);
var from = __webpack_require__(317);
module.exports = function (NAME) {
  return function toJSON() {
	if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
	return from(this);
  };
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function get() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function get() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Syntax = __webpack_require__(50).Syntax;

var Reference = __webpack_require__(100);
var Variable = __webpack_require__(66);
var Definition = __webpack_require__(152).Definition;
function isStrictScope(scope, block, isMethodDefinition, useDirective) {
	var body = void 0;
	if (scope.upper && scope.upper.isStrict) {
		return true;
	}
	if (block.type === Syntax.ArrowFunctionExpression) {
		return true;
	}

	if (isMethodDefinition) {
		return true;
	}

	if (scope.type === "class" || scope.type === "module") {
		return true;
	}

	if (scope.type === "block" || scope.type === "switch") {
		return false;
	}

	if (scope.type === "function") {
		if (block.type === Syntax.Program) {
			body = block;
		} else {
			body = block.body;
		}

		if (!body) {
			return false;
		}
	} else if (scope.type === "global") {
		body = block;
	} else {
		return false;
	}
	if (useDirective) {
		for (var i = 0, iz = body.body.length; i < iz; ++i) {
			var stmt = body.body[i];

			if (stmt.type !== Syntax.DirectiveStatement) {
				break;
			}
			if (stmt.raw === "\"use strict\"" || stmt.raw === "'use strict'") {
				return true;
			}
		}
	} else {
		for (var _i = 0, _iz = body.body.length; _i < _iz; ++_i) {
			var _stmt = body.body[_i];

			if (_stmt.type !== Syntax.ExpressionStatement) {
				break;
			}
			var expr = _stmt.expression;

			if (expr.type !== Syntax.Literal || typeof expr.value !== "string") {
				break;
			}
			if (expr.raw !== null && expr.raw !== undefined) {
				if (expr.raw === "\"use strict\"" || expr.raw === "'use strict'") {
					return true;
				}
			} else {
				if (expr.value === "use strict") {
					return true;
				}
			}
		}
	}
	return false;
}
function registerScope(scopeManager, scope) {
	scopeManager.scopes.push(scope);

	var scopes = scopeManager.__nodeToScope.get(scope.block);

	if (scopes) {
		scopes.push(scope);
	} else {
		scopeManager.__nodeToScope.set(scope.block, [scope]);
	}
}
function shouldBeStatically(def) {
	return def.type === Variable.ClassName || def.type === Variable.Variable && def.parent.kind !== "var";
}

var Scope = function () {
	function Scope(scopeManager, type, upperScope, block, isMethodDefinition) {
		_classCallCheck(this, Scope);
		this.type = type;
		this.set = new Map();
		this.taints = new Map();
		this.dynamic = this.type === "global" || this.type === "with";
		this.block = block;
		this.through = [];
		this.variables = [];
		this.references = [];
		this.variableScope = this.type === "global" || this.type === "function" || this.type === "module" ? this : upperScope.variableScope;
		this.functionExpressionScope = false;
		this.directCallToEvalScope = false;
		this.thisFound = false;

		this.__left = [];
		this.upper = upperScope;
		this.isStrict = isStrictScope(this, block, isMethodDefinition, scopeManager.__useDirective());
		this.childScopes = [];
		if (this.upper) {
			this.upper.childScopes.push(this);
		}

		this.__declaredVariables = scopeManager.__declaredVariables;

		registerScope(scopeManager, this);
	}

	_createClass(Scope, [{
		key: "__shouldStaticallyClose",
		value: function __shouldStaticallyClose(scopeManager) {
			return !this.dynamic || scopeManager.__isOptimistic();
		}
	}, {
		key: "__shouldStaticallyCloseForGlobal",
		value: function __shouldStaticallyCloseForGlobal(ref) {
			var name = ref.identifier.name;

			if (!this.set.has(name)) {
				return false;
			}

			var variable = this.set.get(name);
			var defs = variable.defs;

			return defs.length > 0 && defs.every(shouldBeStatically);
		}
	}, {
		key: "__staticCloseRef",
		value: function __staticCloseRef(ref) {
			if (!this.__resolve(ref)) {
				this.__delegateToUpperScope(ref);
			}
		}
	}, {
		key: "__dynamicCloseRef",
		value: function __dynamicCloseRef(ref) {
			var current = this;

			do {
				current.through.push(ref);
				current = current.upper;
			} while (current);
		}
	}, {
		key: "__globalCloseRef",
		value: function __globalCloseRef(ref) {
			if (this.__shouldStaticallyCloseForGlobal(ref)) {
				this.__staticCloseRef(ref);
			} else {
				this.__dynamicCloseRef(ref);
			}
		}
	}, {
		key: "__close",
		value: function __close(scopeManager) {
			var closeRef = void 0;

			if (this.__shouldStaticallyClose(scopeManager)) {
				closeRef = this.__staticCloseRef;
			} else if (this.type !== "global") {
				closeRef = this.__dynamicCloseRef;
			} else {
				closeRef = this.__globalCloseRef;
			}
			for (var i = 0, iz = this.__left.length; i < iz; ++i) {
				var ref = this.__left[i];

				closeRef.call(this, ref);
			}
			this.__left = null;

			return this.upper;
		}
	}, {
		key: "__resolve",
		value: function __resolve(ref) {
			var name = ref.identifier.name;

			if (this.set.has(name)) {
				var variable = this.set.get(name);

				variable.references.push(ref);
				variable.stack = variable.stack && ref.from.variableScope === this.variableScope;
				if (ref.tainted) {
					variable.tainted = true;
					this.taints.set(variable.name, true);
				}
				ref.resolved = variable;
				return true;
			}
			return false;
		}
	}, {
		key: "__delegateToUpperScope",
		value: function __delegateToUpperScope(ref) {
			if (this.upper) {
				this.upper.__left.push(ref);
			}
			this.through.push(ref);
		}
	}, {
		key: "__addDeclaredVariablesOfNode",
		value: function __addDeclaredVariablesOfNode(variable, node) {
			if (node === null || node === undefined) {
				return;
			}

			var variables = this.__declaredVariables.get(node);

			if (variables === null || variables === undefined) {
				variables = [];
				this.__declaredVariables.set(node, variables);
			}
			if (variables.indexOf(variable) === -1) {
				variables.push(variable);
			}
		}
	}, {
		key: "__defineGeneric",
		value: function __defineGeneric(name, set, variables, node, def) {
			var variable = void 0;

			variable = set.get(name);
			if (!variable) {
				variable = new Variable(name, this);
				set.set(name, variable);
				variables.push(variable);
			}

			if (def) {
				variable.defs.push(def);
				if (def.type !== Variable.TDZ) {
					this.__addDeclaredVariablesOfNode(variable, def.node);
					this.__addDeclaredVariablesOfNode(variable, def.parent);
				}
			}
			if (node) {
				variable.identifiers.push(node);
			}
		}
	}, {
		key: "__define",
		value: function __define(node, def) {
			if (node && node.type === Syntax.Identifier) {
				this.__defineGeneric(node.name, this.set, this.variables, node, def);
			}
		}
	}, {
		key: "__referencing",
		value: function __referencing(node, assign, writeExpr, maybeImplicitGlobal, partial, init) {
			if (!node || node.type !== Syntax.Identifier) {
				return;
			}
			if (node.name === "super") {
				return;
			}

			var ref = new Reference(node, this, assign || Reference.READ, writeExpr, maybeImplicitGlobal, !!partial, !!init);

			this.references.push(ref);
			this.__left.push(ref);
		}
	}, {
		key: "__detectEval",
		value: function __detectEval() {
			var current = this;

			this.directCallToEvalScope = true;
			do {
				current.dynamic = true;
				current = current.upper;
			} while (current);
		}
	}, {
		key: "__detectThis",
		value: function __detectThis() {
			this.thisFound = true;
		}
	}, {
		key: "__isClosed",
		value: function __isClosed() {
			return this.__left === null;
		}

	}, {
		key: "resolve",
		value: function resolve(ident) {
			var ref = void 0,
				i = void 0,
				iz = void 0;

			for (i = 0, iz = this.references.length; i < iz; ++i) {
				ref = this.references[i];
				if (ref.identifier === ident) {
					return ref;
				}
			}
			return null;
		}

	}, {
		key: "isStatic",
		value: function isStatic() {
			return !this.dynamic;
		}

	}, {
		key: "isArgumentsMaterialized",
		value: function isArgumentsMaterialized() {
			return true;
		}

	}, {
		key: "isThisMaterialized",
		value: function isThisMaterialized() {
			return true;
		}
	}, {
		key: "isUsedName",
		value: function isUsedName(name) {
			if (this.set.has(name)) {
				return true;
			}
			for (var i = 0, iz = this.through.length; i < iz; ++i) {
				if (this.through[i].identifier.name === name) {
					return true;
				}
			}
			return false;
		}
	}]);

	return Scope;
}();

var GlobalScope = function (_Scope) {
	_inherits(GlobalScope, _Scope);

	function GlobalScope(scopeManager, block) {
		_classCallCheck(this, GlobalScope);

		var _this = _possibleConstructorReturn(this, (GlobalScope.__proto__ || Object.getPrototypeOf(GlobalScope)).call(this, scopeManager, "global", null, block, false));

		_this.implicit = {
			set: new Map(),
			variables: [],
			left: []
		};
		return _this;
	}

	_createClass(GlobalScope, [{
		key: "__close",
		value: function __close(scopeManager) {
			var implicit = [];

			for (var i = 0, iz = this.__left.length; i < iz; ++i) {
				var ref = this.__left[i];

				if (ref.__maybeImplicitGlobal && !this.set.has(ref.identifier.name)) {
					implicit.push(ref.__maybeImplicitGlobal);
				}
			}
			for (var _i2 = 0, _iz2 = implicit.length; _i2 < _iz2; ++_i2) {
				var info = implicit[_i2];

				this.__defineImplicit(info.pattern, new Definition(Variable.ImplicitGlobalVariable, info.pattern, info.node, null, null, null));
			}

			this.implicit.left = this.__left;

			return _get(GlobalScope.prototype.__proto__ || Object.getPrototypeOf(GlobalScope.prototype), "__close", this).call(this, scopeManager);
		}
	}, {
		key: "__defineImplicit",
		value: function __defineImplicit(node, def) {
			if (node && node.type === Syntax.Identifier) {
				this.__defineGeneric(node.name, this.implicit.set, this.implicit.variables, node, def);
			}
		}
	}]);

	return GlobalScope;
}(Scope);

var ModuleScope = function (_Scope2) {
	_inherits(ModuleScope, _Scope2);

	function ModuleScope(scopeManager, upperScope, block) {
		_classCallCheck(this, ModuleScope);

		return _possibleConstructorReturn(this, (ModuleScope.__proto__ || Object.getPrototypeOf(ModuleScope)).call(this, scopeManager, "module", upperScope, block, false));
	}

	return ModuleScope;
}(Scope);

var FunctionExpressionNameScope = function (_Scope3) {
	_inherits(FunctionExpressionNameScope, _Scope3);

	function FunctionExpressionNameScope(scopeManager, upperScope, block) {
		_classCallCheck(this, FunctionExpressionNameScope);

		var _this3 = _possibleConstructorReturn(this, (FunctionExpressionNameScope.__proto__ || Object.getPrototypeOf(FunctionExpressionNameScope)).call(this, scopeManager, "function-expression-name", upperScope, block, false));

		_this3.__define(block.id, new Definition(Variable.FunctionName, block.id, block, null, null, null));
		_this3.functionExpressionScope = true;
		return _this3;
	}

	return FunctionExpressionNameScope;
}(Scope);

var CatchScope = function (_Scope4) {
	_inherits(CatchScope, _Scope4);

	function CatchScope(scopeManager, upperScope, block) {
		_classCallCheck(this, CatchScope);

		return _possibleConstructorReturn(this, (CatchScope.__proto__ || Object.getPrototypeOf(CatchScope)).call(this, scopeManager, "catch", upperScope, block, false));
	}

	return CatchScope;
}(Scope);

var WithScope = function (_Scope5) {
	_inherits(WithScope, _Scope5);

	function WithScope(scopeManager, upperScope, block) {
		_classCallCheck(this, WithScope);

		return _possibleConstructorReturn(this, (WithScope.__proto__ || Object.getPrototypeOf(WithScope)).call(this, scopeManager, "with", upperScope, block, false));
	}

	_createClass(WithScope, [{
		key: "__close",
		value: function __close(scopeManager) {
			if (this.__shouldStaticallyClose(scopeManager)) {
				return _get(WithScope.prototype.__proto__ || Object.getPrototypeOf(WithScope.prototype), "__close", this).call(this, scopeManager);
			}

			for (var i = 0, iz = this.__left.length; i < iz; ++i) {
				var ref = this.__left[i];

				ref.tainted = true;
				this.__delegateToUpperScope(ref);
			}
			this.__left = null;

			return this.upper;
		}
	}]);

	return WithScope;
}(Scope);

var TDZScope = function (_Scope6) {
	_inherits(TDZScope, _Scope6);

	function TDZScope(scopeManager, upperScope, block) {
		_classCallCheck(this, TDZScope);

		return _possibleConstructorReturn(this, (TDZScope.__proto__ || Object.getPrototypeOf(TDZScope)).call(this, scopeManager, "TDZ", upperScope, block, false));
	}

	return TDZScope;
}(Scope);

var BlockScope = function (_Scope7) {
	_inherits(BlockScope, _Scope7);

	function BlockScope(scopeManager, upperScope, block) {
		_classCallCheck(this, BlockScope);

		return _possibleConstructorReturn(this, (BlockScope.__proto__ || Object.getPrototypeOf(BlockScope)).call(this, scopeManager, "block", upperScope, block, false));
	}

	return BlockScope;
}(Scope);

var SwitchScope = function (_Scope8) {
	_inherits(SwitchScope, _Scope8);

	function SwitchScope(scopeManager, upperScope, block) {
		_classCallCheck(this, SwitchScope);

		return _possibleConstructorReturn(this, (SwitchScope.__proto__ || Object.getPrototypeOf(SwitchScope)).call(this, scopeManager, "switch", upperScope, block, false));
	}

	return SwitchScope;
}(Scope);

var FunctionScope = function (_Scope9) {
	_inherits(FunctionScope, _Scope9);

	function FunctionScope(scopeManager, upperScope, block, isMethodDefinition) {
		_classCallCheck(this, FunctionScope);
		var _this9 = _possibleConstructorReturn(this, (FunctionScope.__proto__ || Object.getPrototypeOf(FunctionScope)).call(this, scopeManager, "function", upperScope, block, isMethodDefinition));

		if (_this9.block.type !== Syntax.ArrowFunctionExpression) {
			_this9.__defineArguments();
		}
		return _this9;
	}

	_createClass(FunctionScope, [{
		key: "isArgumentsMaterialized",
		value: function isArgumentsMaterialized() {
			//
			if (this.block.type === Syntax.ArrowFunctionExpression) {
				return false;
			}

			if (!this.isStatic()) {
				return true;
			}

			var variable = this.set.get("arguments");

			return variable.tainted || variable.references.length !== 0;
		}
	}, {
		key: "isThisMaterialized",
		value: function isThisMaterialized() {
			if (!this.isStatic()) {
				return true;
			}
			return this.thisFound;
		}
	}, {
		key: "__defineArguments",
		value: function __defineArguments() {
			this.__defineGeneric("arguments", this.set, this.variables, null, null);
			this.taints.set("arguments", true);
		}
	}]);

	return FunctionScope;
}(Scope);

var ForScope = function (_Scope10) {
	_inherits(ForScope, _Scope10);

	function ForScope(scopeManager, upperScope, block) {
		_classCallCheck(this, ForScope);

		return _possibleConstructorReturn(this, (ForScope.__proto__ || Object.getPrototypeOf(ForScope)).call(this, scopeManager, "for", upperScope, block, false));
	}

	return ForScope;
}(Scope);

var ClassScope = function (_Scope11) {
	_inherits(ClassScope, _Scope11);

	function ClassScope(scopeManager, upperScope, block) {
		_classCallCheck(this, ClassScope);

		return _possibleConstructorReturn(this, (ClassScope.__proto__ || Object.getPrototypeOf(ClassScope)).call(this, scopeManager, "class", upperScope, block, false));
	}

	return ClassScope;
}(Scope);

module.exports = {
	Scope: Scope,
	GlobalScope: GlobalScope,
	ModuleScope: ModuleScope,
	FunctionExpressionNameScope: FunctionExpressionNameScope,
	CatchScope: CatchScope,
	WithScope: WithScope,
	TDZScope: TDZScope,
	BlockScope: BlockScope,
	SwitchScope: SwitchScope,
	FunctionScope: FunctionScope,
	ForScope: ForScope,
	ClassScope: ClassScope
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Variable = __webpack_require__(66);

var Definition = function Definition(type, name, node, parent, index, kind) {
  _classCallCheck(this, Definition);
  this.type = type;
  this.name = name;
  this.node = node;
  this.parent = parent;
  this.index = index;
  this.kind = kind;
};


var ParameterDefinition = function (_Definition) {
  _inherits(ParameterDefinition, _Definition);

  function ParameterDefinition(name, node, index, rest) {
	_classCallCheck(this, ParameterDefinition);
	var _this = _possibleConstructorReturn(this, (ParameterDefinition.__proto__ || Object.getPrototypeOf(ParameterDefinition)).call(this, Variable.Parameter, name, node, null, index, null));

	_this.rest = rest;
	return _this;
  }

  return ParameterDefinition;
}(Definition);

module.exports = {
  ParameterDefinition: ParameterDefinition,
  Definition: Definition
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
(function () {
	'use strict';

	var assign, estraverse, isArray, objectKeys;

	assign = __webpack_require__(154);
	estraverse = __webpack_require__(50);

	isArray = Array.isArray || function isArray(array) {
		return Object.prototype.toString.call(array) === '[object Array]';
	};

	objectKeys = Object.keys || function (o) {
		var keys = [],
			key;
		for (key in o) {
			keys.push(key);
		}
		return keys;
	};

	function isNode(node) {
		if (node == null) {
			return false;
		}
		return (typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object' && typeof node.type === 'string';
	}

	function isProperty(nodeType, key) {
		return (nodeType === estraverse.Syntax.ObjectExpression || nodeType === estraverse.Syntax.ObjectPattern) && key === 'properties';
	}

	function Visitor(visitor, options) {
		options = options || {};

		this.__visitor = visitor || this;
		this.__childVisitorKeys = options.childVisitorKeys ? assign({}, estraverse.VisitorKeys, options.childVisitorKeys) : estraverse.VisitorKeys;
		if (options.fallback === 'iteration') {
			this.__fallback = objectKeys;
		} else if (typeof options.fallback === 'function') {
			this.__fallback = options.fallback;
		}
	}
	Visitor.prototype.visitChildren = function (node) {
		var type, children, i, iz, j, jz, child;

		if (node == null) {
			return;
		}

		type = node.type || estraverse.Syntax.Property;

		children = this.__childVisitorKeys[type];
		if (!children) {
			if (this.__fallback) {
				children = this.__fallback(node);
			} else {
				throw new Error('Unknown node type ' + type + '.');
			}
		}

		for (i = 0, iz = children.length; i < iz; ++i) {
			child = node[children[i]];
			if (child) {
				if (isArray(child)) {
					for (j = 0, jz = child.length; j < jz; ++j) {
						if (child[j]) {
							if (isNode(child[j]) || isProperty(type, children[i])) {
								this.visit(child[j]);
							}
						}
					}
				} else if (isNode(child)) {
					this.visit(child);
				}
			}
		}
	};
	Visitor.prototype.visit = function (node) {
		var type;

		if (node == null) {
			return;
		}

		type = node.type || estraverse.Syntax.Property;
		if (this.__visitor[type]) {
			this.__visitor[type].call(this, node);
			return;
		}
		this.visitChildren(node);
	};

	exports.version = __webpack_require__(335).version;
	exports.Visitor = Visitor;
	exports.visit = function (node, visitor, options) {
		var v = new Visitor(visitor, options);
		v.visit(node);
	};
})();
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}
		var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var Func,
	List,
	Obj,
	Str,
	Num,
	id,
	isType,
	replicate,
	prelude,
	toString$ = {}.toString;
Func = __webpack_require__(340);
List = __webpack_require__(341);
Obj = __webpack_require__(342);
Str = __webpack_require__(343);
Num = __webpack_require__(344);
id = function id(x) {
  return x;
};
isType = curry$(function (type, x) {
  return toString$.call(x).slice(8, -1) === type;
});
replicate = curry$(function (n, x) {
  var i$,
			results$ = [];
  for (i$ = 0; i$ < n; ++i$) {
	results$.push(x);
  }
  return results$;
});
Str.empty = List.empty;
Str.slice = List.slice;
Str.take = List.take;
Str.drop = List.drop;
Str.splitAt = List.splitAt;
Str.takeWhile = List.takeWhile;
Str.dropWhile = List.dropWhile;
Str.span = List.span;
Str.breakStr = List.breakList;
prelude = {
  Func: Func,
  List: List,
  Obj: Obj,
  Str: Str,
  Num: Num,
  id: id,
  isType: isType,
  replicate: replicate
};
prelude.each = List.each;
prelude.map = List.map;
prelude.filter = List.filter;
prelude.compact = List.compact;
prelude.reject = List.reject;
prelude.partition = List.partition;
prelude.find = List.find;
prelude.head = List.head;
prelude.first = List.first;
prelude.tail = List.tail;
prelude.last = List.last;
prelude.initial = List.initial;
prelude.empty = List.empty;
prelude.reverse = List.reverse;
prelude.difference = List.difference;
prelude.intersection = List.intersection;
prelude.union = List.union;
prelude.countBy = List.countBy;
prelude.groupBy = List.groupBy;
prelude.fold = List.fold;
prelude.foldl = List.foldl;
prelude.fold1 = List.fold1;
prelude.foldl1 = List.foldl1;
prelude.foldr = List.foldr;
prelude.foldr1 = List.foldr1;
prelude.unfoldr = List.unfoldr;
prelude.andList = List.andList;
prelude.orList = List.orList;
prelude.any = List.any;
prelude.all = List.all;
prelude.unique = List.unique;
prelude.uniqueBy = List.uniqueBy;
prelude.sort = List.sort;
prelude.sortWith = List.sortWith;
prelude.sortBy = List.sortBy;
prelude.sum = List.sum;
prelude.product = List.product;
prelude.mean = List.mean;
prelude.average = List.average;
prelude.concat = List.concat;
prelude.concatMap = List.concatMap;
prelude.flatten = List.flatten;
prelude.maximum = List.maximum;
prelude.minimum = List.minimum;
prelude.maximumBy = List.maximumBy;
prelude.minimumBy = List.minimumBy;
prelude.scan = List.scan;
prelude.scanl = List.scanl;
prelude.scan1 = List.scan1;
prelude.scanl1 = List.scanl1;
prelude.scanr = List.scanr;
prelude.scanr1 = List.scanr1;
prelude.slice = List.slice;
prelude.take = List.take;
prelude.drop = List.drop;
prelude.splitAt = List.splitAt;
prelude.takeWhile = List.takeWhile;
prelude.dropWhile = List.dropWhile;
prelude.span = List.span;
prelude.breakList = List.breakList;
prelude.zip = List.zip;
prelude.zipWith = List.zipWith;
prelude.zipAll = List.zipAll;
prelude.zipAllWith = List.zipAllWith;
prelude.at = List.at;
prelude.elemIndex = List.elemIndex;
prelude.elemIndices = List.elemIndices;
prelude.findIndex = List.findIndex;
prelude.findIndices = List.findIndices;
prelude.apply = Func.apply;
prelude.curry = Func.curry;
prelude.flip = Func.flip;
prelude.fix = Func.fix;
prelude.over = Func.over;
prelude.split = Str.split;
prelude.join = Str.join;
prelude.lines = Str.lines;
prelude.unlines = Str.unlines;
prelude.words = Str.words;
prelude.unwords = Str.unwords;
prelude.chars = Str.chars;
prelude.unchars = Str.unchars;
prelude.repeat = Str.repeat;
prelude.capitalize = Str.capitalize;
prelude.camelize = Str.camelize;
prelude.dasherize = Str.dasherize;
prelude.values = Obj.values;
prelude.keys = Obj.keys;
prelude.pairsToObj = Obj.pairsToObj;
prelude.objToPairs = Obj.objToPairs;
prelude.listsToObj = Obj.listsToObj;
prelude.objToLists = Obj.objToLists;
prelude.max = Num.max;
prelude.min = Num.min;
prelude.negate = Num.negate;
prelude.abs = Num.abs;
prelude.signum = Num.signum;
prelude.quot = Num.quot;
prelude.rem = Num.rem;
prelude.div = Num.div;
prelude.mod = Num.mod;
prelude.recip = Num.recip;
prelude.pi = Num.pi;
prelude.tau = Num.tau;
prelude.exp = Num.exp;
prelude.sqrt = Num.sqrt;
prelude.ln = Num.ln;
prelude.pow = Num.pow;
prelude.sin = Num.sin;
prelude.tan = Num.tan;
prelude.cos = Num.cos;
prelude.acos = Num.acos;
prelude.asin = Num.asin;
prelude.atan = Num.atan;
prelude.atan2 = Num.atan2;
prelude.truncate = Num.truncate;
prelude.round = Num.round;
prelude.ceiling = Num.ceiling;
prelude.floor = Num.floor;
prelude.isItNaN = Num.isItNaN;
prelude.even = Num.even;
prelude.odd = Num.odd;
prelude.gcd = Num.gcd;
prelude.lcm = Num.lcm;
prelude.VERSION = '1.1.2';
module.exports = prelude;
function curry$(f, bound) {
  var context,
			_curry = function _curry(args) {
	return f.length > 1 ? function () {
			var params = args ? args.concat() : [];
			context = bound ? context || this : this;
			return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);
	} : f;
  };
  return _curry();
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function () {
  var VERSION, parseType, parsedTypeCheck, typeCheck;
  VERSION = '0.3.2';
  parseType = __webpack_require__(346);
  parsedTypeCheck = __webpack_require__(347);
  typeCheck = function typeCheck(type, input, options) {
	return parsedTypeCheck(parseType(type), input, options);
  };
  module.exports = {
	VERSION: VERSION,
	typeCheck: typeCheck,
	parsedTypeCheck: parsedTypeCheck,
	parseType: parseType
  };
}).call(undefined);
 }),
 (function(module, exports) {
(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;}.call(exports, {}))
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var debug = __webpack_require__(67)("eslint:code-path");
function getId(segment) {
	return segment.id + (segment.reachable ? "" : "!");
}
module.exports = {
	enabled: debug.enabled,
	dump: debug,
	dumpState: !debug.enabled ? debug : /* istanbul ignore next */function (node, state, leaving) {
		for (var i = 0; i < state.currentSegments.length; ++i) {
			var segInternal = state.currentSegments[i].internal;

			if (leaving) {
				segInternal.exitNodes.push(node);
			} else {
				segInternal.nodes.push(node);
			}
		}

		debug([state.currentSegments.map(getId).join(",") + ")", "" + node.type + (leaving ? ":exit" : "")].join(" "));
	},
	dumpDot: !debug.enabled ? debug : /* istanbul ignore next */function (codePath) {
		var text = "\n" + "digraph {\n" + "node[shape=box,style=\"rounded,filled\",fillcolor=white];\n" + "initial[label=\"\",shape=circle,style=filled,fillcolor=black,width=0.25,height=0.25];\n";

		if (codePath.returnedSegments.length > 0) {
			text += "final[label=\"\",shape=doublecircle,style=filled,fillcolor=black,width=0.25,height=0.25];\n";
		}
		if (codePath.thrownSegments.length > 0) {
			text += "thrown[label=\"\",shape=circle,width=0.3,height=0.3,fixedsize];\n";
		}

		var traceMap = Object.create(null);
		var arrows = this.makeDotArrows(codePath, traceMap);

		for (var id in traceMap) {
			var segment = traceMap[id];

			text += id + "[";

			if (segment.reachable) {
				text += "label=\"";
			} else {
				text += "style=\"rounded,dashed,filled\",fillcolor=\"#FF9800\",label=\"<<unreachable>>\\n";
			}

			if (segment.internal.nodes.length > 0 || segment.internal.exitNodes.length > 0) {
				text += [].concat(segment.internal.nodes.map(function (node) {
					switch (node.type) {
						case "Identifier":
							return node.type + " (" + node.name + ")";
						case "Literal":
							return node.type + " (" + node.value + ")";
						default:
							return node.type;
					}
				}), segment.internal.exitNodes.map(function (node) {
					switch (node.type) {
						case "Identifier":
							return node.type + ":exit (" + node.name + ")";
						case "Literal":
							return node.type + ":exit (" + node.value + ")";
						default:
							return node.type + ":exit";
					}
				})).join("\\n");
			} else {
				text += "????";
			}

			text += "\"];\n";
		}

		text += arrows + "\n";
		text += "}";
		debug("DOT", text);
	},
	makeDotArrows: function makeDotArrows(codePath, traceMap) {
		var stack = [[codePath.initialSegment, 0]];
		var done = traceMap || Object.create(null);
		var lastId = codePath.initialSegment.id;
		var text = "initial->" + codePath.initialSegment.id;

		while (stack.length > 0) {
			var item = stack.pop();
			var segment = item[0];
			var index = item[1];

			if (done[segment.id] && index === 0) {
				continue;
			}
			done[segment.id] = segment;

			var nextSegment = segment.allNextSegments[index];

			if (!nextSegment) {
				continue;
			}

			if (lastId === segment.id) {
				text += "->" + nextSegment.id;
			} else {
				text += ";\n" + segment.id + "->" + nextSegment.id;
			}
			lastId = nextSegment.id;

			stack.unshift([segment, 1 + index]);
			stack.push([nextSegment, 0]);
		}

		codePath.returnedSegments.forEach(function (finalSegment) {
			if (lastId === finalSegment.id) {
				text += "->final";
			} else {
				text += ";\n" + finalSegment.id + "->final";
			}
			lastId = null;
		});

		codePath.thrownSegments.forEach(function (finalSegment) {
			if (lastId === finalSegment.id) {
				text += "->thrown";
			} else {
				text += ";\n" + finalSegment.id + "->thrown";
			}
			lastId = null;
		});

		return text + ";";
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var IdGenerator = function () {
  function IdGenerator(prefix) {
	_classCallCheck(this, IdGenerator);

	this.prefix = String(prefix);
	this.n = 0;
  }


  _createClass(IdGenerator, [{
	key: "next",
	value: function next() {
			this.n = 1 + this.n | 0;
			if (this.n < 0) {
		this.n = 1;
			}

			return this.prefix + this.n;
	}
  }]);

  return IdGenerator;
}();

module.exports = IdGenerator;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

(function () {
	'use strict';

	var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;
	ES5Regex = {
		NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
		NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
	};

	ES6Regex = {
		NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,
		NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
	};

	function isDecimalDigit(ch) {
		return 0x30 <= ch && ch <= 0x39; // 0..9
	}

	function isHexDigit(ch) {
		return 0x30 <= ch && ch <= 0x39 || // 0..9
		0x61 <= ch && ch <= 0x66 || // a..f
		0x41 <= ch && ch <= 0x46; // A..F
	}

	function isOctalDigit(ch) {
		return ch >= 0x30 && ch <= 0x37; // 0..7
	}
	NON_ASCII_WHITESPACES = [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF];

	function isWhiteSpace(ch) {
		return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 || ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
	}
	function isLineTerminator(ch) {
		return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
	}
	function fromCodePoint(cp) {
		if (cp <= 0xFFFF) {
			return String.fromCharCode(cp);
		}
		var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
		var cu2 = String.fromCharCode((cp - 0x10000) % 0x400 + 0xDC00);
		return cu1 + cu2;
	}

	IDENTIFIER_START = new Array(0x80);
	for (ch = 0; ch < 0x80; ++ch) {
		IDENTIFIER_START[ch] = ch >= 0x61 && ch <= 0x7A || // a..z
		ch >= 0x41 && ch <= 0x5A || // A..Z
		ch === 0x24 || ch === 0x5F; // $ (dollar) and _ (underscore)
	}

	IDENTIFIER_PART = new Array(0x80);
	for (ch = 0; ch < 0x80; ++ch) {
		IDENTIFIER_PART[ch] = ch >= 0x61 && ch <= 0x7A || // a..z
		ch >= 0x41 && ch <= 0x5A || // A..Z
		ch >= 0x30 && ch <= 0x39 || // 0..9
		ch === 0x24 || ch === 0x5F; // $ (dollar) and _ (underscore)
	}

	function isIdentifierStartES5(ch) {
		return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
	}

	function isIdentifierPartES5(ch) {
		return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
	}

	function isIdentifierStartES6(ch) {
		return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
	}

	function isIdentifierPartES6(ch) {
		return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
	}

	module.exports = {
		isDecimalDigit: isDecimalDigit,
		isHexDigit: isHexDigit,
		isOctalDigit: isOctalDigit,
		isWhiteSpace: isWhiteSpace,
		isLineTerminator: isLineTerminator,
		isIdentifierStartES5: isIdentifierStartES5,
		isIdentifierPartES5: isIdentifierPartES5,
		isIdentifierStartES6: isIdentifierStartES6,
		isIdentifierPartES6: isIdentifierPartES6
	};
})();
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	AssignmentExpression: "AssignmentExpression",
	AssignmentPattern: "AssignmentPattern",
	ArrayExpression: "ArrayExpression",
	ArrayPattern: "ArrayPattern",
	ArrowFunctionExpression: "ArrowFunctionExpression",
	AwaitExpression: "AwaitExpression",
	BlockStatement: "BlockStatement",
	BinaryExpression: "BinaryExpression",
	BreakStatement: "BreakStatement",
	CallExpression: "CallExpression",
	CatchClause: "CatchClause",
	ClassBody: "ClassBody",
	ClassDeclaration: "ClassDeclaration",
	ClassExpression: "ClassExpression",
	ConditionalExpression: "ConditionalExpression",
	ContinueStatement: "ContinueStatement",
	DoWhileStatement: "DoWhileStatement",
	DebuggerStatement: "DebuggerStatement",
	EmptyStatement: "EmptyStatement",
	ExperimentalRestProperty: "ExperimentalRestProperty",
	ExperimentalSpreadProperty: "ExperimentalSpreadProperty",
	ExpressionStatement: "ExpressionStatement",
	ForStatement: "ForStatement",
	ForInStatement: "ForInStatement",
	ForOfStatement: "ForOfStatement",
	FunctionDeclaration: "FunctionDeclaration",
	FunctionExpression: "FunctionExpression",
	Identifier: "Identifier",
	IfStatement: "IfStatement",
	Literal: "Literal",
	LabeledStatement: "LabeledStatement",
	LogicalExpression: "LogicalExpression",
	MemberExpression: "MemberExpression",
	MetaProperty: "MetaProperty",
	MethodDefinition: "MethodDefinition",
	NewExpression: "NewExpression",
	ObjectExpression: "ObjectExpression",
	ObjectPattern: "ObjectPattern",
	Program: "Program",
	Property: "Property",
	RestElement: "RestElement",
	ReturnStatement: "ReturnStatement",
	SequenceExpression: "SequenceExpression",
	SpreadElement: "SpreadElement",
	Super: "Super",
	SwitchCase: "SwitchCase",
	SwitchStatement: "SwitchStatement",
	TaggedTemplateExpression: "TaggedTemplateExpression",
	TemplateElement: "TemplateElement",
	TemplateLiteral: "TemplateLiteral",
	ThisExpression: "ThisExpression",
	ThrowStatement: "ThrowStatement",
	TryStatement: "TryStatement",
	UnaryExpression: "UnaryExpression",
	UpdateExpression: "UpdateExpression",
	VariableDeclaration: "VariableDeclaration",
	VariableDeclarator: "VariableDeclarator",
	WhileStatement: "WhileStatement",
	WithStatement: "WithStatement",
	YieldExpression: "YieldExpression",
	JSXIdentifier: "JSXIdentifier",
	JSXNamespacedName: "JSXNamespacedName",
	JSXMemberExpression: "JSXMemberExpression",
	JSXEmptyExpression: "JSXEmptyExpression",
	JSXExpressionContainer: "JSXExpressionContainer",
	JSXElement: "JSXElement",
	JSXClosingElement: "JSXClosingElement",
	JSXOpeningElement: "JSXOpeningElement",
	JSXAttribute: "JSXAttribute",
	JSXSpreadAttribute: "JSXSpreadAttribute",
	JSXText: "JSXText",
	ExportDefaultDeclaration: "ExportDefaultDeclaration",
	ExportNamedDeclaration: "ExportNamedDeclaration",
	ExportAllDeclaration: "ExportAllDeclaration",
	ExportSpecifier: "ExportSpecifier",
	ImportDeclaration: "ImportDeclaration",
	ImportSpecifier: "ImportSpecifier",
	ImportDefaultSpecifier: "ImportDefaultSpecifier",
	ImportNamespaceSpecifier: "ImportNamespaceSpecifier"
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(372);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function(process) {

var _createClass = function () {
  function defineProperties(target, props) {
	for (var i = 0; i < props.length; i++) {
			var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	}
  }return function (Constructor, protoProps, staticProps) {
	if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
	throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = function () {
  return new IgnoreBase();
};
function make_array(subject) {
  return Array.isArray(subject) ? subject : [subject];
}

var REGEX_BLANK_LINE = /^\s+$/;
var REGEX_LEADING_EXCAPED_EXCLAMATION = /^\\\!/;
var REGEX_LEADING_EXCAPED_HASH = /^\\#/;
var SLASH = '/';
var KEY_IGNORE = typeof Symbol !== 'undefined' ? Symbol.for('node-ignore')
: 'node-ignore';

var IgnoreBase = function () {
  function IgnoreBase() {
	_classCallCheck(this, IgnoreBase);

	this._rules = [];
	this[KEY_IGNORE] = true;
	this._initCache();
  }

  _createClass(IgnoreBase, [{
	key: '_initCache',
	value: function _initCache() {
			this._cache = {};
	}
  }, {
	key: 'add',
	value: function add(pattern) {
			this._added = false;

			if (typeof pattern === 'string') {
		pattern = pattern.split(/\r?\n/g);
			}

			make_array(pattern).forEach(this._addPattern, this);
			if (this._added) {
		this._initCache();
			}

			return this;
	}
  }, {
	key: 'addPattern',
	value: function addPattern(pattern) {
			return this.add(pattern);
	}
  }, {
	key: '_addPattern',
	value: function _addPattern(pattern) {
			if (pattern && pattern[KEY_IGNORE]) {
		this._rules = this._rules.concat(pattern._rules);
		this._added = true;
		return;
			}

			if (this._checkPattern(pattern)) {
		var rule = this._createRule(pattern);
		this._added = true;
		this._rules.push(rule);
			}
	}
  }, {
	key: '_checkPattern',
	value: function _checkPattern(pattern) {
			return pattern && typeof pattern === 'string' && !REGEX_BLANK_LINE.test(pattern)
			&& pattern.indexOf('#') !== 0;
	}
  }, {
	key: 'filter',
	value: function filter(paths) {
			var _this = this;

			return make_array(paths).filter(function (path) {
		return _this._filter(path);
			});
	}
  }, {
	key: 'createFilter',
	value: function createFilter() {
			var _this2 = this;

			return function (path) {
		return _this2._filter(path);
			};
	}
  }, {
	key: 'ignores',
	value: function ignores(path) {
			return !this._filter(path);
	}
  }, {
	key: '_createRule',
	value: function _createRule(pattern) {
			var origin = pattern;
			var negative = false;
			if (pattern.indexOf('!') === 0) {
		negative = true;
		pattern = pattern.substr(1);
			}

			pattern = pattern
			.replace(REGEX_LEADING_EXCAPED_EXCLAMATION, '!')
			.replace(REGEX_LEADING_EXCAPED_HASH, '#');

			var regex = make_regex(pattern, negative);

			return {
		origin: origin,
		pattern: pattern,
		negative: negative,
		regex: regex
			};
	}
  }, {
	key: '_filter',
	value: function _filter(path, slices) {
			if (!path) {
		return false;
			}

			if (path in this._cache) {
		return this._cache[path];
			}

			if (!slices) {
		slices = path.split(SLASH);
			}

			slices.pop();

			return this._cache[path] = slices.length
			? this._filter(slices.join(SLASH) + SLASH, slices) && this._test(path)
			: this._test(path);
	}
  }, {
	key: '_test',
	value: function _test(path) {
			var matched = 0;

			this._rules.forEach(function (rule) {
		if (!(matched ^ rule.negative)) {
					matched = rule.negative ^ rule.regex.test(path);
		}
			});

			return !matched;
	}
  }]);

  return IgnoreBase;
}();

var DEFAULT_REPLACER_PREFIX = [
[
/\\?\s+$/, function (match) {
  return match.indexOf('\\') === 0 ? ' ' : '';
}],
[/\\\s/g, function () {
  return ' ';
}],
[/[\\\^$.|?*+()\[{]/g, function (match) {
  return '\\' + match;
}],
[
/^\//, function () {
  return '^';
}],
[/\//g, function () {
  return '\\/';
}], [
/^\^*\\\*\\\*\\\//,
function () {
  return '^(?:.*\\/)?';
}]];

var DEFAULT_REPLACER_SUFFIX = [
[
/^(?=[^\^])/, function () {
  return !/\/(?!$)/.test(this)
  ? '(?:^|\\/)'
  : '^';
}],
[
/\\\/\\\*\\\*(?=\\\/|$)/g,
function (match, index, str) {
  return index + 6 < str.length
  ? '(?:\\/[^\\/]+)*'
  : '\\/.+';
}],
[
/(^|[^\\]+)\\\*(?=.+)/g,
function (match, p1) {
  return p1 + '[^\\/]*';
}],
[/(\^|\\\/)?\\\*$/, function (match, p1) {
  return (p1
  ? p1 + '[^/]+'
  : '[^/]*') + '(?=$|\\/$)';
}], [
/\\\\\\/g, function () {
  return '\\';
}]];

var POSITIVE_REPLACERS = [].concat(DEFAULT_REPLACER_PREFIX, [
[
/(?:[^*\/])$/,
function (match) {
  return match + '(?=$|\\/)';
}]], DEFAULT_REPLACER_SUFFIX);

var NEGATIVE_REPLACERS = [].concat(DEFAULT_REPLACER_PREFIX, [
[/(?:[^*\/])$/, function (match) {
  return match + '(?=$|\\/$)';
}]], DEFAULT_REPLACER_SUFFIX);
var cache = {};
function make_regex(pattern, negative) {
  var r = cache[pattern];
  if (r) {
	return r;
  }

  var replacers = negative ? NEGATIVE_REPLACERS : POSITIVE_REPLACERS;

  var source = replacers.reduce(function (prev, current) {
	return prev.replace(current[0], current[1].bind(pattern));
  }, pattern);

  return cache[pattern] = new RegExp(source, 'i');
}
if (
typeof process !== 'undefined' && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === 'win32')) {

  var filter = IgnoreBase.prototype._filter;
  var make_posix = function make_posix(str) {
	return (/^\\\\\?\\/.test(str) || /[^\x00-\x80]+/.test(str) ? str : str.replace(/\\/g, '/')
	);
  };

  IgnoreBase.prototype._filter = function (path, slices) {
	path = make_posix(path);
	return filter.call(this, path, slices);
  };
}
}.call(exports, __webpack_require__(20)))
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

(function () {
	'use strict';

	var typed, utility, jsdoc, esutils, hasOwnProperty;

	esutils = __webpack_require__(68);
	typed = __webpack_require__(646);
	utility = __webpack_require__(165);

	function sliceSource(source, index, last) {
		return source.slice(index, last);
	}

	hasOwnProperty = function () {
		var func = Object.prototype.hasOwnProperty;
		return function hasOwnProperty(obj, name) {
			return func.call(obj, name);
		};
	}();

	function shallowCopy(obj) {
		var ret = {},
			key;
		for (key in obj) {
			if (obj.hasOwnProperty(key)) {
				ret[key] = obj[key];
			}
		}
		return ret;
	}

	function isASCIIAlphanumeric(ch) {
		return ch >= 0x61 /* 'a' */ && ch <= 0x7A /* 'z' */ || ch >= 0x41 /* 'A' */ && ch <= 0x5A /* 'Z' */ || ch >= 0x30 /* '0' */ && ch <= 0x39 /* '9' */;
	}

	function isParamTitle(title) {
		return title === 'param' || title === 'argument' || title === 'arg';
	}

	function isReturnTitle(title) {
		return title === 'return' || title === 'returns';
	}

	function isProperty(title) {
		return title === 'property' || title === 'prop';
	}

	function isNameParameterRequired(title) {
		return isParamTitle(title) || isProperty(title) || title === 'alias' || title === 'this' || title === 'mixes' || title === 'requires';
	}

	function isAllowedName(title) {
		return isNameParameterRequired(title) || title === 'const' || title === 'constant';
	}

	function isAllowedNested(title) {
		return isProperty(title) || isParamTitle(title);
	}

	function isAllowedOptional(title) {
		return isProperty(title) || isParamTitle(title);
	}

	function isTypeParameterRequired(title) {
		return isParamTitle(title) || isReturnTitle(title) || title === 'define' || title === 'enum' || title === 'implements' || title === 'this' || title === 'type' || title === 'typedef' || isProperty(title);
	}
	function isAllowedType(title) {
		return isTypeParameterRequired(title) || title === 'throws' || title === 'const' || title === 'constant' || title === 'namespace' || title === 'member' || title === 'var' || title === 'module' || title === 'constructor' || title === 'class' || title === 'extends' || title === 'augments' || title === 'public' || title === 'private' || title === 'protected';
	}

	function unwrapComment(doc) {
		var BEFORE_STAR = 0,
			STAR = 1,
			AFTER_STAR = 2,
			index,
			len,
			mode,
			result,
			ch;

		doc = doc.replace(/^\/\*\*?/, '').replace(/\*\/$/, '');
		index = 0;
		len = doc.length;
		mode = BEFORE_STAR;
		result = '';

		while (index < len) {
			ch = doc.charCodeAt(index);
			switch (mode) {
				case BEFORE_STAR:
					if (esutils.code.isLineTerminator(ch)) {
						result += String.fromCharCode(ch);
					} else if (ch === 0x2A /* '*' */) {
							mode = STAR;
						} else if (!esutils.code.isWhiteSpace(ch)) {
						result += String.fromCharCode(ch);
						mode = AFTER_STAR;
					}
					break;

				case STAR:
					if (!esutils.code.isWhiteSpace(ch)) {
						result += String.fromCharCode(ch);
					}
					mode = esutils.code.isLineTerminator(ch) ? BEFORE_STAR : AFTER_STAR;
					break;

				case AFTER_STAR:
					result += String.fromCharCode(ch);
					if (esutils.code.isLineTerminator(ch)) {
						mode = BEFORE_STAR;
					}
					break;
			}
			index += 1;
		}

		return result.replace(/\s+$/, '');
	}
	(function (exports) {
		var Rules, index, lineNumber, length, source, recoverable, sloppy, strict;

		function advance() {
			var ch = source.charCodeAt(index);
			index += 1;
			if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D /* '\r' */ && source.charCodeAt(index) === 0x0A /* '\n' */)) {
				lineNumber += 1;
			}
			return String.fromCharCode(ch);
		}

		function scanTitle() {
			var title = '';
			advance();

			while (index < length && isASCIIAlphanumeric(source.charCodeAt(index))) {
				title += advance();
			}

			return title;
		}

		function seekContent() {
			var ch,
				waiting,
				last = index;

			waiting = false;
			while (last < length) {
				ch = source.charCodeAt(last);
				if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D /* '\r' */ && source.charCodeAt(last + 1) === 0x0A /* '\n' */)) {
					waiting = true;
				} else if (waiting) {
					if (ch === 0x40 /* '@' */) {
							break;
						}
					if (!esutils.code.isWhiteSpace(ch)) {
						waiting = false;
					}
				}
				last += 1;
			}
			return last;
		}
		//
		function parseType(title, last) {
			var ch,
				brace,
				type,
				direct = false;
			while (index < last) {
				ch = source.charCodeAt(index);
				if (esutils.code.isWhiteSpace(ch)) {
					advance();
				} else if (ch === 0x7B /* '{' */) {
						advance();
						break;
					} else {
					direct = true;
					break;
				}
			}

			if (direct) {
				return null;
			}
			brace = 1;
			type = '';
			while (index < last) {
				ch = source.charCodeAt(index);
				if (esutils.code.isLineTerminator(ch)) {
					advance();
				} else {
					if (ch === 0x7D /* '}' */) {
							brace -= 1;
							if (brace === 0) {
								advance();
								break;
							}
						} else if (ch === 0x7B /* '{' */) {
							brace += 1;
						}
					type += advance();
				}
			}

			if (brace !== 0) {
				return utility.throwError('Braces are not balanced');
			}

			if (isAllowedOptional(title)) {
				return typed.parseParamType(type);
			}

			return typed.parseType(type);
		}

		function scanIdentifier(last) {
			var identifier;
			if (!esutils.code.isIdentifierStartES5(source.charCodeAt(index)) && !source[index].match(/[0-9]/)) {
				return null;
			}
			identifier = advance();
			while (index < last && esutils.code.isIdentifierPartES5(source.charCodeAt(index))) {
				identifier += advance();
			}
			return identifier;
		}

		function skipWhiteSpace(last) {
			while (index < last && (esutils.code.isWhiteSpace(source.charCodeAt(index)) || esutils.code.isLineTerminator(source.charCodeAt(index)))) {
				advance();
			}
		}

		function parseName(last, allowBrackets, allowNestedParams) {
			var name = '',
				useBrackets,
				insideString;

			skipWhiteSpace(last);

			if (index >= last) {
				return null;
			}

			if (source.charCodeAt(index) === 0x5B /* '[' */) {
					if (allowBrackets) {
						useBrackets = true;
						name = advance();
					} else {
						return null;
					}
				}

			name += scanIdentifier(last);

			if (allowNestedParams) {
				if (source.charCodeAt(index) === 0x3A /* ':' */ && (name === 'module' || name === 'external' || name === 'event')) {
					name += advance();
					name += scanIdentifier(last);
				}
				if (source.charCodeAt(index) === 0x5B /* '[' */ && source.charCodeAt(index + 1) === 0x5D /* ']' */) {
						name += advance();
						name += advance();
					}
				while (source.charCodeAt(index) === 0x2E /* '.' */ || source.charCodeAt(index) === 0x2F /* '/' */ || source.charCodeAt(index) === 0x23 /* '#' */ || source.charCodeAt(index) === 0x2D /* '-' */ || source.charCodeAt(index) === 0x7E /* '~' */) {
					name += advance();
					name += scanIdentifier(last);
				}
			}

			if (useBrackets) {
				skipWhiteSpace(last);
				if (source.charCodeAt(index) === 0x3D /* '=' */) {
						name += advance();
						skipWhiteSpace(last);

						var ch;
						var bracketDepth = 1;
						while (index < last) {
							ch = source.charCodeAt(index);

							if (esutils.code.isWhiteSpace(ch)) {
								if (!insideString) {
									skipWhiteSpace(last);
									ch = source.charCodeAt(index);
								}
							}

							if (ch === 0x27 /* ''' */) {
									if (!insideString) {
										insideString = '\'';
									} else {
										if (insideString === '\'') {
											insideString = '';
										}
									}
								}

							if (ch === 0x22 /* '"' */) {
									if (!insideString) {
										insideString = '"';
									} else {
										if (insideString === '"') {
											insideString = '';
										}
									}
								}

							if (ch === 0x5B /* '[' */) {
									bracketDepth++;
								} else if (ch === 0x5D /* ']' */ && --bracketDepth === 0) {
								break;
							}

							name += advance();
						}
					}

				skipWhiteSpace(last);

				if (index >= last || source.charCodeAt(index) !== 0x5D /* ']' */) {
						return null;
					}
				name += advance();
			}

			return name;
		}

		function skipToTag() {
			while (index < length && source.charCodeAt(index) !== 0x40 /* '@' */) {
				advance();
			}
			if (index >= length) {
				return false;
			}
			utility.assert(source.charCodeAt(index) === 0x40 /* '@' */);
			return true;
		}

		function TagParser(options, title) {
			this._options = options;
			this._title = title.toLowerCase();
			this._tag = {
				title: title,
				description: null
			};
			if (this._options.lineNumbers) {
				this._tag.lineNumber = lineNumber;
			}
			this._last = 0;
			this._extra = {};
		}
		TagParser.prototype.addError = function addError(errorText) {
			var args = Array.prototype.slice.call(arguments, 1),
				msg = errorText.replace(/%(\d)/g, function (whole, index) {
				utility.assert(index < args.length, 'Message reference must be in range');
				return args[index];
			});

			if (!this._tag.errors) {
				this._tag.errors = [];
			}
			if (strict) {
				utility.throwError(msg);
			}
			this._tag.errors.push(msg);
			return recoverable;
		};

		TagParser.prototype.parseType = function () {
			if (isTypeParameterRequired(this._title)) {
				try {
					this._tag.type = parseType(this._title, this._last);
					if (!this._tag.type) {
						if (!isParamTitle(this._title) && !isReturnTitle(this._title)) {
							if (!this.addError('Missing or invalid tag type')) {
								return false;
							}
						}
					}
				} catch (error) {
					this._tag.type = null;
					if (!this.addError(error.message)) {
						return false;
					}
				}
			} else if (isAllowedType(this._title)) {
				try {
					this._tag.type = parseType(this._title, this._last);
				} catch (e) {
				}
			}
			return true;
		};

		TagParser.prototype._parseNamePath = function (optional) {
			var name;
			name = parseName(this._last, sloppy && isAllowedOptional(this._title), true);
			if (!name) {
				if (!optional) {
					if (!this.addError('Missing or invalid tag name')) {
						return false;
					}
				}
			}
			this._tag.name = name;
			return true;
		};

		TagParser.prototype.parseNamePath = function () {
			return this._parseNamePath(false);
		};

		TagParser.prototype.parseNamePathOptional = function () {
			return this._parseNamePath(true);
		};

		TagParser.prototype.parseName = function () {
			var assign, name;
			if (isAllowedName(this._title)) {
				this._tag.name = parseName(this._last, sloppy && isAllowedOptional(this._title), isAllowedNested(this._title));
				if (!this._tag.name) {
					if (!isNameParameterRequired(this._title)) {
						return true;
					}
					if (isParamTitle(this._title) && this._tag.type && this._tag.type.name) {
						this._extra.name = this._tag.type;
						this._tag.name = this._tag.type.name;
						this._tag.type = null;
					} else {
						if (!this.addError('Missing or invalid tag name')) {
							return false;
						}
					}
				} else {
					name = this._tag.name;
					if (name.charAt(0) === '[' && name.charAt(name.length - 1) === ']') {
						assign = name.substring(1, name.length - 1).split('=');
						if (assign.length > 1) {
							this._tag['default'] = assign.slice(1).join('=');
						}
						this._tag.name = assign[0];
						if (this._tag.type && this._tag.type.type !== 'OptionalType') {
							this._tag.type = {
								type: 'OptionalType',
								expression: this._tag.type
							};
						}
					}
				}
			}

			return true;
		};

		TagParser.prototype.parseDescription = function parseDescription() {
			var description = sliceSource(source, index, this._last).trim();
			if (description) {
				if (/^-\s+/.test(description)) {
					description = description.substring(2);
				}
				this._tag.description = description;
			}
			return true;
		};

		TagParser.prototype.parseCaption = function parseDescription() {
			var description = sliceSource(source, index, this._last).trim();
			var captionStartTag = '<caption>';
			var captionEndTag = '</caption>';
			var captionStart = description.indexOf(captionStartTag);
			var captionEnd = description.indexOf(captionEndTag);
			if (captionStart >= 0 && captionEnd >= 0) {
				this._tag.caption = description.substring(captionStart + captionStartTag.length, captionEnd).trim();
				this._tag.description = description.substring(captionEnd + captionEndTag.length).trim();
			} else {
				this._tag.description = description;
			}
			return true;
		};

		TagParser.prototype.parseKind = function parseKind() {
			var kind, kinds;
			kinds = {
				'class': true,
				'constant': true,
				'event': true,
				'external': true,
				'file': true,
				'function': true,
				'member': true,
				'mixin': true,
				'module': true,
				'namespace': true,
				'typedef': true
			};
			kind = sliceSource(source, index, this._last).trim();
			this._tag.kind = kind;
			if (!hasOwnProperty(kinds, kind)) {
				if (!this.addError('Invalid kind name \'%0\'', kind)) {
					return false;
				}
			}
			return true;
		};

		TagParser.prototype.parseAccess = function parseAccess() {
			var access;
			access = sliceSource(source, index, this._last).trim();
			this._tag.access = access;
			if (access !== 'private' && access !== 'protected' && access !== 'public') {
				if (!this.addError('Invalid access name \'%0\'', access)) {
					return false;
				}
			}
			return true;
		};

		TagParser.prototype.parseThis = function parseThis() {
			var value = sliceSource(source, index, this._last).trim();
			if (value && value.charAt(0) === '{') {
				var gotType = this.parseType();
				if (gotType && this._tag.type.type === 'NameExpression' || this._tag.type.type === 'UnionType') {
					this._tag.name = this._tag.type.name;
					return true;
				} else {
					return this.addError('Invalid name for this');
				}
			} else {
				return this.parseNamePath();
			}
		};

		TagParser.prototype.parseVariation = function parseVariation() {
			var variation, text;
			text = sliceSource(source, index, this._last).trim();
			variation = parseFloat(text, 10);
			this._tag.variation = variation;
			if (isNaN(variation)) {
				if (!this.addError('Invalid variation \'%0\'', text)) {
					return false;
				}
			}
			return true;
		};

		TagParser.prototype.ensureEnd = function () {
			var shouldBeEmpty = sliceSource(source, index, this._last).trim();
			if (shouldBeEmpty) {
				if (!this.addError('Unknown content \'%0\'', shouldBeEmpty)) {
					return false;
				}
			}
			return true;
		};

		TagParser.prototype.epilogue = function epilogue() {
			var description;

			description = this._tag.description;
			if (isAllowedOptional(this._title) && !this._tag.type && description && description.charAt(0) === '[') {
				this._tag.type = this._extra.name;
				if (!this._tag.name) {
					this._tag.name = undefined;
				}

				if (!sloppy) {
					if (!this.addError('Missing or invalid tag name')) {
						return false;
					}
				}
			}

			return true;
		};

		Rules = {
			'access': ['parseAccess'],
			'alias': ['parseNamePath', 'ensureEnd'],
			'augments': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
			'constructor': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
			'class': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
			'extends': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
			'example': ['parseCaption'],
			'deprecated': ['parseDescription'],
			'global': ['ensureEnd'],
			'inner': ['ensureEnd'],
			'instance': ['ensureEnd'],
			'kind': ['parseKind'],
			'mixes': ['parseNamePath', 'ensureEnd'],
			'mixin': ['parseNamePathOptional', 'ensureEnd'],
			'member': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
			'method': ['parseNamePathOptional', 'ensureEnd'],
			'module': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
			'func': ['parseNamePathOptional', 'ensureEnd'],
			'function': ['parseNamePathOptional', 'ensureEnd'],
			'var': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
			'name': ['parseNamePath', 'ensureEnd'],
			'namespace': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
			'private': ['parseType', 'parseDescription'],
			'protected': ['parseType', 'parseDescription'],
			'public': ['parseType', 'parseDescription'],
			'readonly': ['ensureEnd'],
			'requires': ['parseNamePath', 'ensureEnd'],
			'since': ['parseDescription'],
			'static': ['ensureEnd'],
			'summary': ['parseDescription'],
			'this': ['parseThis', 'ensureEnd'],
			'todo': ['parseDescription'],
			'typedef': ['parseType', 'parseNamePathOptional'],
			'variation': ['parseVariation'],
			'version': ['parseDescription']
		};

		TagParser.prototype.parse = function parse() {
			var i, iz, sequences, method;
			if (!this._title) {
				if (!this.addError('Missing or invalid title')) {
					return null;
				}
			}
			this._last = seekContent(this._title);

			if (hasOwnProperty(Rules, this._title)) {
				sequences = Rules[this._title];
			} else {
				sequences = ['parseType', 'parseName', 'parseDescription', 'epilogue'];
			}

			for (i = 0, iz = sequences.length; i < iz; ++i) {
				method = sequences[i];
				if (!this[method]()) {
					return null;
				}
			}

			return this._tag;
		};

		function parseTag(options) {
			var title, parser, tag;
			if (!skipToTag()) {
				return null;
			}
			title = scanTitle();
			parser = new TagParser(options, title);
			tag = parser.parse();
			while (index < parser._last) {
				advance();
			}

			return tag;
		}

		//
		//

		function scanJSDocDescription(preserveWhitespace) {
			var description = '',
				ch,
				atAllowed;

			atAllowed = true;
			while (index < length) {
				ch = source.charCodeAt(index);

				if (atAllowed && ch === 0x40 /* '@' */) {
						break;
					}

				if (esutils.code.isLineTerminator(ch)) {
					atAllowed = true;
				} else if (atAllowed && !esutils.code.isWhiteSpace(ch)) {
					atAllowed = false;
				}

				description += advance();
			}

			return preserveWhitespace ? description : description.trim();
		}

		function parse(comment, options) {
			var tags = [],
				tag,
				description,
				interestingTags,
				i,
				iz;

			if (options === undefined) {
				options = {};
			}

			if (typeof options.unwrap === 'boolean' && options.unwrap) {
				source = unwrapComment(comment);
			} else {
				source = comment;
			}
			if (options.tags) {
				if (Array.isArray(options.tags)) {
					interestingTags = {};
					for (i = 0, iz = options.tags.length; i < iz; i++) {
						if (typeof options.tags[i] === 'string') {
							interestingTags[options.tags[i]] = true;
						} else {
							utility.throwError('Invalid "tags" parameter: ' + options.tags);
						}
					}
				} else {
					utility.throwError('Invalid "tags" parameter: ' + options.tags);
				}
			}

			length = source.length;
			index = 0;
			lineNumber = 0;
			recoverable = options.recoverable;
			sloppy = options.sloppy;
			strict = options.strict;

			description = scanJSDocDescription(options.preserveWhitespace);

			while (true) {
				tag = parseTag(options);
				if (!tag) {
					break;
				}
				if (!interestingTags || interestingTags.hasOwnProperty(tag.title)) {
					tags.push(tag);
				}
			}

			return {
				description: description,
				tags: tags
			};
		}
		exports.parse = parse;
	})(jsdoc = {});

	exports.version = utility.VERSION;
	exports.parse = jsdoc.parse;
	exports.parseType = typed.parseType;
	exports.parseParamType = typed.parseParamType;
	exports.unwrapComment = unwrapComment;
	exports.Syntax = shallowCopy(typed.Syntax);
	exports.Error = utility.DoctrineError;
	exports.type = {
		Syntax: exports.Syntax,
		parseType: typed.parseType,
		parseParamType: typed.parseParamType,
		stringify: typed.stringify
	};
})();
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

(function () {
	'use strict';

	var VERSION;

	VERSION = __webpack_require__(647).version;
	exports.VERSION = VERSION;

	function DoctrineError(message) {
		this.name = 'DoctrineError';
		this.message = message;
	}
	DoctrineError.prototype = function () {
		var Middle = function Middle() {};
		Middle.prototype = Error.prototype;
		return new Middle();
	}();
	DoctrineError.prototype.constructor = DoctrineError;
	exports.DoctrineError = DoctrineError;

	function throwError(message) {
		throw new DoctrineError(message);
	}
	exports.throwError = throwError;

	exports.assert = __webpack_require__(648);
})();
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromLiteral;
function extractValueFromLiteral(value) {
  var extractedValue = value.value;

  var normalizedStringValue = typeof extractedValue === 'string' && extractedValue.toLowerCase();
  if (normalizedStringValue === 'true') {
	return true;
  } else if (normalizedStringValue === 'false') {
	return false;
  }

  return extractedValue;
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromJSXElement;
function extractValueFromJSXElement(value) {
  return "<" + value.openingElement.name.name + " />";
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromTemplateLiteral;
function extractValueFromTemplateLiteral(value) {
  var quasis = value.quasis,
			expressions = value.expressions;

  var partitions = quasis.concat(expressions);

  return partitions.sort(function (a, b) {
	return a.start - b.start;
  }).reduce(function (raw, part) {
	var type = part.type;

	if (type === 'TemplateElement') {
			return raw + part.value.raw;
	} else if (type === 'Identifier') {
			return part.name === 'undefined' ? raw : raw + '{' + part.name + '}';
	} else if (type.indexOf('Expression') > -1) {
			return raw + '{' + type + '}';
	}

	return raw;
  }, '');
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(109).propName; // eslint-disable-line import/no-unresolved
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(109).elementType; // eslint-disable-line import/no-unresolved
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function getTokenBeforeClosingBracket(node) {
  var attributes = node.attributes;
  if (attributes.length === 0) {
	return node.name;
  }
  return attributes[attributes.length - 1];
}

module.exports = getTokenBeforeClosingBracket;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function(process) {/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyFunction = __webpack_require__(112);

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  var printWarning = function printWarning(format) {
	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
			args[_key - 1] = arguments[_key];
	}

	var argIndex = 0;
	var message = 'Warning: ' + format.replace(/%s/g, function () {
			return args[argIndex++];
	});
	if (typeof console !== 'undefined') {
			console.error(message);
	}
	try {
			throw new Error(message);
	} catch (x) {}
  };

  warning = function warning(condition, format) {
	if (format === undefined) {
			throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	}

	if (format.indexOf('Failed Composite propType: ') === 0) {
			return; // Ignore CompositeComponent proptype check.
	}

	if (!condition) {
			for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
		args[_key2 - 2] = arguments[_key2];
			}

			printWarning.apply(undefined, [format].concat(args));
	}
  };
}

module.exports = warning;
}.call(exports, __webpack_require__(20)))
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
__webpack_require__(174);
__webpack_require__(312);
__webpack_require__(315);
__webpack_require__(320);
__webpack_require__(321);
__webpack_require__(322);
__webpack_require__(323);
__webpack_require__(327);
__webpack_require__(330);

"use strict";
var eslintScope = __webpack_require__(331),
	levn = __webpack_require__(338),
	lodash = __webpack_require__(10),
	blankScriptAST = __webpack_require__(348),
	defaultConfig = __webpack_require__(349),
	CodePathAnalyzer = __webpack_require__(350),
	ConfigOps = __webpack_require__(365),
	validator = { validateRuleOptions: function validateRuleOptions(x) {
		return x;
	} },
	Environments = __webpack_require__(370),
	applyDisableDirectives = __webpack_require__(373),
	createEmitter = __webpack_require__(374),
	NodeEventGenerator = __webpack_require__(375),
	SourceCode = __webpack_require__(378),
	Traverser = __webpack_require__(106),
	createReportTranslator = __webpack_require__(388),
	Rules = __webpack_require__(390),
	timing = __webpack_require__(754),
	astUtils = __webpack_require__(0),
	pkg = __webpack_require__(755),
	SourceCodeFixer = __webpack_require__(756);

var debug = __webpack_require__(67)("eslint:linter");
var MAX_AUTOFIX_PASSES = 10;
function parseBooleanConfig(string, comment) {
	var items = {};
	string = string.replace(/\s*([:,])\s*/g, "$1");

	string.split(/\s|,+/).forEach(function (name) {
		if (!name) {
			return;
		}
		var pos = name.indexOf(":");
		var value = void 0;

		if (pos !== -1) {
			value = name.slice(pos + 1);
			name = name.slice(0, pos);
		}

		items[name] = {
			value: value === "true",
			comment: comment
		};
	});
	return items;
}
function parseJsonConfig(string, location) {
	var items = {};
	try {
		items = levn.parse("Object", string) || {};
		if (ConfigOps.isEverySeverityValid(items)) {
			return {
				success: true,
				config: items
			};
		}
	} catch (ex) {}
	items = {};
	string = string.replace(/([a-zA-Z0-9\-/]+):/g, "\"$1\":").replace(/(]|[0-9])\s+(?=")/, "$1,");
	try {
		items = JSON.parse('{' + string + '}');
	} catch (ex) {
		return {
			success: false,
			error: {
				ruleId: null,
				fatal: true,
				severity: 2,
				source: null,
				message: 'Failed to parse JSON from \'' + string + '\': ' + ex.message,
				line: location.start.line,
				column: location.start.column + 1
			}
		};
	}

	return {
		success: true,
		config: items
	};
}
function parseListConfig(string) {
	var items = {};
	string = string.replace(/\s*,\s*/g, ",");

	string.split(/,+/).forEach(function (name) {
		name = name.trim();
		if (!name) {
			return;
		}
		items[name] = true;
	});
	return items;
}
function addDeclaredGlobals(globalScope, config, envContext) {
	var declaredGlobals = {},
		exportedGlobals = {},
		explicitGlobals = {},
		builtin = envContext.get("builtin");

	Object.assign(declaredGlobals, builtin);

	Object.keys(config.env).filter(function (name) {
		return config.env[name];
	}).forEach(function (name) {
		var env = envContext.get(name),
			environmentGlobals = env && env.globals;

		if (environmentGlobals) {
			Object.assign(declaredGlobals, environmentGlobals);
		}
	});

	Object.assign(exportedGlobals, config.exported);
	Object.assign(declaredGlobals, config.globals);
	Object.assign(explicitGlobals, config.astGlobals);

	Object.keys(declaredGlobals).forEach(function (name) {
		var variable = globalScope.set.get(name);

		if (!variable) {
			variable = new eslintScope.Variable(name, globalScope);
			variable.eslintExplicitGlobal = false;
			globalScope.variables.push(variable);
			globalScope.set.set(name, variable);
		}
		variable.writeable = declaredGlobals[name];
	});

	Object.keys(explicitGlobals).forEach(function (name) {
		var variable = globalScope.set.get(name);

		if (!variable) {
			variable = new eslintScope.Variable(name, globalScope);
			variable.eslintExplicitGlobal = true;
			variable.eslintExplicitGlobalComment = explicitGlobals[name].comment;
			globalScope.variables.push(variable);
			globalScope.set.set(name, variable);
		}
		variable.writeable = explicitGlobals[name].value;
	});
	Object.keys(exportedGlobals).forEach(function (name) {
		var variable = globalScope.set.get(name);

		if (variable) {
			variable.eslintUsed = true;
		}
	});
	globalScope.through = globalScope.through.filter(function (reference) {
		var name = reference.identifier.name;
		var variable = globalScope.set.get(name);

		if (variable) {
			reference.resolved = variable;
			variable.references.push(reference);

			return false;
		}

		return true;
	});
}
function createDisableDirectives(type, loc, value) {
	var ruleIds = Object.keys(parseListConfig(value));
	var directiveRules = ruleIds.length ? ruleIds : [null];

	return directiveRules.map(function (ruleId) {
		return { type: type, line: loc.line, column: loc.column + 1, ruleId: ruleId };
	});
}
function modifyConfigsFromComments(filename, ast, config, ruleMapper) {

	var commentConfig = {
		exported: {},
		astGlobals: {},
		rules: {},
		env: {}
	};
	var commentRules = {};
	var problems = [];
	var disableDirectives = [];

	ast.comments.filter(function (token) {
		return token.type !== "Shebang";
	}).forEach(function (comment) {

		var value = comment.value.trim();
		var match = /^(eslint(-\w+){0,3}|exported|globals?)(\s|$)/.exec(value);

		if (match) {
			value = value.slice(match.index + match[1].length);

			if (comment.type === "Block") {
				switch (match[1]) {
					case "exported":
						Object.assign(commentConfig.exported, parseBooleanConfig(value, comment));
						break;

					case "globals":
					case "global":
						Object.assign(commentConfig.astGlobals, parseBooleanConfig(value, comment));
						break;

					case "eslint-disable":
						[].push.apply(disableDirectives, createDisableDirectives("disable", comment.loc.start, value));
						break;

					case "eslint-enable":
						[].push.apply(disableDirectives, createDisableDirectives("enable", comment.loc.start, value));
						break;

					case "eslint":
						{
							var parseResult = parseJsonConfig(value, comment.loc);

							if (parseResult.success) {
								Object.keys(parseResult.config).forEach(function (name) {
									var ruleValue = parseResult.config[name];

									validator.validateRuleOptions(ruleMapper(name), name, ruleValue, filename + ' line ' + comment.loc.start.line);
									commentRules[name] = ruleValue;
								});
							} else {
								problems.push(parseResult.error);
							}

							break;
						}
				}
			} else {
				if (match[1] === "eslint-disable-line") {
					[].push.apply(disableDirectives, createDisableDirectives("disable-line", comment.loc.start, value));
				} else if (match[1] === "eslint-disable-next-line") {
					[].push.apply(disableDirectives, createDisableDirectives("disable-next-line", comment.loc.start, value));
				}
			}
		}
	});

	Object.assign(commentConfig.rules, commentRules);

	return {
		config: ConfigOps.merge(config, commentConfig),
		problems: problems,
		disableDirectives: disableDirectives
	};
}
function normalizeEcmaVersion(ecmaVersion, isModule) {
	if (isModule && (!ecmaVersion || ecmaVersion < 6)) {
		ecmaVersion = 6;
	}
	if (ecmaVersion >= 2015) {
		ecmaVersion -= 2009;
	}

	return ecmaVersion;
}
function prepareConfig(config, envContext) {
	config.globals = config.globals || {};
	var copiedRules = {};
	var parserOptions = {};

	if (_typeof(config.rules) === "object") {
		Object.keys(config.rules).forEach(function (k) {
			var rule = config.rules[k];

			if (rule === null) {
				throw new Error('Invalid config for rule \'' + k + '\'.');
			}
			if (Array.isArray(rule)) {
				copiedRules[k] = rule.slice();
			} else {
				copiedRules[k] = rule;
			}
		});
	}
	if (_typeof(config.env) === "object") {
		Object.keys(config.env).forEach(function (envName) {
			var env = envContext.get(envName);

			if (config.env[envName] && env && env.parserOptions) {
				parserOptions = ConfigOps.merge(parserOptions, env.parserOptions);
			}
		});
	}

	var preparedConfig = {
		rules: copiedRules,
		parser: config.parser || defaultConfig.parser,
		globals: ConfigOps.merge(defaultConfig.globals, config.globals),
		env: ConfigOps.merge(defaultConfig.env, config.env || {}),
		settings: ConfigOps.merge(defaultConfig.settings, config.settings || {}),
		parserOptions: ConfigOps.merge(parserOptions, config.parserOptions || {})
	};
	var isModule = preparedConfig.parserOptions.sourceType === "module";

	if (isModule) {
		preparedConfig.parserOptions.ecmaFeatures = Object.assign({}, preparedConfig.parserOptions.ecmaFeatures, { globalReturn: false });
	}

	preparedConfig.parserOptions.ecmaVersion = normalizeEcmaVersion(preparedConfig.parserOptions.ecmaVersion, isModule);

	return preparedConfig;
}

var eslintEnvPattern = /\/\*\s*eslint-env\s(.+?)\*\//g;
function findEslintEnv(text) {
	var match = void 0,
		retv = void 0;

	eslintEnvPattern.lastIndex = 0;

	while (match = eslintEnvPattern.exec(text)) {
		retv = Object.assign(retv || {}, parseListConfig(match[1]));
	}

	return retv;
}
function stripUnicodeBOM(text) {
	if (text.charCodeAt(0) === 0xFEFF) {
		return text.slice(1);
	}
	return text;
}
function getRuleOptions(ruleConfig) {
	if (Array.isArray(ruleConfig)) {
		return ruleConfig.slice(1);
	}
	return [];
}
function parse(text, providedParserOptions, parser, filePath) {

	var parserOptions = Object.assign({}, providedParserOptions, {
		loc: true,
		range: true,
		raw: true,
		tokens: true,
		comment: true,
		filePath: filePath
	});
	try {
		if (typeof parser.parseForESLint === "function") {
			var parseResult = parser.parseForESLint(text, parserOptions);

			return {
				success: true,
				ast: parseResult.ast,
				services: parseResult.services || {}
			};
		}

		return {
			success: true,
			ast: parser.parse(text, parserOptions),
			services: {}
		};
	} catch (ex) {
		var message = 'Parsing error: ' + ex.message.replace(/^line \d+:/i, "").trim();
		var source = ex.lineNumber ? SourceCode.splitLines(text)[ex.lineNumber - 1] : null;

		return {
			success: false,
			error: {
				ruleId: null,
				fatal: true,
				severity: 2,
				source: source,
				message: message,
				line: ex.lineNumber,
				column: ex.column
			}
		};
	}
}
function _getScope(scopeManager, currentNode, ecmaVersion) {
	var initialNode = void 0;
	if (["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"].indexOf(currentNode.type) >= 0 || ecmaVersion >= 6 && ["BlockStatement", "SwitchStatement", "CatchClause"].indexOf(currentNode.type) >= 0) {
		initialNode = currentNode;
	} else {
		initialNode = currentNode.parent;
	}
	for (var node = initialNode; node; node = node.parent) {
		var scope = scopeManager.acquire(node, true);

		if (scope) {
			if (scope.type === "function-expression-name") {
				return scope.childScopes[0];
			}
			return scope;
		}
	}

	return scopeManager.scopes[0];
}
function _markVariableAsUsed(scopeManager, currentNode, parserOptions, name) {
	var hasGlobalReturn = parserOptions.ecmaFeatures && parserOptions.ecmaFeatures.globalReturn;
	var specialScope = hasGlobalReturn || parserOptions.sourceType === "module";
	var currentScope = _getScope(scopeManager, currentNode, parserOptions.ecmaVersion);
	var initialScope = currentScope.type === "global" && specialScope ? currentScope.childScopes[0] : currentScope;

	for (var scope = initialScope; scope; scope = scope.upper) {
		var variable = scope.variables.find(function (scopeVar) {
			return scopeVar.name === name;
		});

		if (variable) {
			variable.eslintUsed = true;
			return true;
		}
	}

	return false;
}
var DEPRECATED_SOURCECODE_PASSTHROUGHS = {
	getSource: "getText",
	getSourceLines: "getLines",
	getAllComments: "getAllComments",
	getNodeByRangeIndex: "getNodeByRangeIndex",
	getComments: "getComments",
	getCommentsBefore: "getCommentsBefore",
	getCommentsAfter: "getCommentsAfter",
	getCommentsInside: "getCommentsInside",
	getJSDocComment: "getJSDocComment",
	getFirstToken: "getFirstToken",
	getFirstTokens: "getFirstTokens",
	getLastToken: "getLastToken",
	getLastTokens: "getLastTokens",
	getTokenAfter: "getTokenAfter",
	getTokenBefore: "getTokenBefore",
	getTokenByRangeStart: "getTokenByRangeStart",
	getTokens: "getTokens",
	getTokensAfter: "getTokensAfter",
	getTokensBefore: "getTokensBefore",
	getTokensBetween: "getTokensBetween"
};

var BASE_TRAVERSAL_CONTEXT = Object.freeze(Object.keys(DEPRECATED_SOURCECODE_PASSTHROUGHS).reduce(function (contextInfo, methodName) {
	return Object.assign(contextInfo, _defineProperty({}, methodName, function () {
		var sourceCode = this.getSourceCode();

		return sourceCode[DEPRECATED_SOURCECODE_PASSTHROUGHS[methodName]].apply(sourceCode, arguments);
	}));
}, {}));

var lastSourceCodes = new WeakMap();
module.exports = function () {
	function Linter() {
		_classCallCheck(this, Linter);

		lastSourceCodes.set(this, null);
		this.version = pkg.version;

		this.rules = new Rules();
		this._parsers = new Map();
		this.environments = new Environments();
	}


	_createClass(Linter, [{
		key: '_verifyWithoutProcessors',
		value: function _verifyWithoutProcessors(textOrSourceCode, config, filenameOrOptions) {
			var _this = this;

			var text = void 0,
				parserServices = void 0,
				allowInlineConfig = void 0,
				providedFilename = void 0,
				reportUnusedDisableDirectives = void 0;
			if ((typeof filenameOrOptions === 'undefined' ? 'undefined' : _typeof(filenameOrOptions)) === "object") {
				providedFilename = filenameOrOptions.filename;
				allowInlineConfig = filenameOrOptions.allowInlineConfig;
				reportUnusedDisableDirectives = filenameOrOptions.reportUnusedDisableDirectives;
			} else {
				providedFilename = filenameOrOptions;
			}

			var filename = typeof providedFilename === "string" ? providedFilename : "<input>";

			if (typeof textOrSourceCode === "string") {
				lastSourceCodes.set(this, null);
				text = textOrSourceCode;
			} else {
				lastSourceCodes.set(this, textOrSourceCode);
				text = textOrSourceCode.text;
			}
			var envInFile = findEslintEnv(text);

			config = Object.assign({}, config);

			if (envInFile) {
				if (config.env) {
					config.env = Object.assign({}, config.env, envInFile);
				} else {
					config.env = envInFile;
				}
			}
			config = prepareConfig(config, this.environments);

			if (lastSourceCodes.get(this)) {
				parserServices = {};
			} else {
				if (text.trim().length === 0) {
					lastSourceCodes.set(this, new SourceCode(text, blankScriptAST));
					return [];
				}

				var parser = void 0;

				try {
					parser = this._parsers.get(config.parser) || __webpack_require__(69);
				} catch (ex) {
					return [{
						ruleId: null,
						fatal: true,
						severity: 2,
						source: null,
						message: ex.message,
						line: 0,
						column: 0
					}];
				}
				var parseResult = parse(stripUnicodeBOM(text).replace(astUtils.SHEBANG_MATCHER, function (match, captured) {
					return '//' + captured;
				}), config.parserOptions, parser, filename);

				if (!parseResult.success) {
					return [parseResult.error];
				}

				parserServices = parseResult.services;
				lastSourceCodes.set(this, new SourceCode(text, parseResult.ast));
			}

			var problems = [];
			var sourceCode = lastSourceCodes.get(this);
			var disableDirectives = void 0;
			if (allowInlineConfig !== false) {
				var modifyConfigResult = modifyConfigsFromComments(filename, sourceCode.ast, config, function (ruleId) {
					return _this.rules.get(ruleId);
				});

				config = modifyConfigResult.config;
				modifyConfigResult.problems.forEach(function (problem) {
					return problems.push(problem);
				});
				disableDirectives = modifyConfigResult.disableDirectives;
			} else {
				disableDirectives = [];
			}

			var emitter = createEmitter();
			var traverser = new Traverser();
			var ecmaFeatures = config.parserOptions.ecmaFeatures || {};
			var ecmaVersion = config.parserOptions.ecmaVersion || 5;
			var scopeManager = eslintScope.analyze(sourceCode.ast, {
				ignoreEval: true,
				nodejsScope: ecmaFeatures.globalReturn,
				impliedStrict: ecmaFeatures.impliedStrict,
				ecmaVersion: ecmaVersion,
				sourceType: config.parserOptions.sourceType || "script",
				fallback: Traverser.getKeys
			});
			var sharedTraversalContext = Object.freeze(Object.assign(Object.create(BASE_TRAVERSAL_CONTEXT), {
				getAncestors: function getAncestors() {
					return traverser.parents();
				},
				getDeclaredVariables: scopeManager.getDeclaredVariables.bind(scopeManager),
				getFilename: function getFilename() {
					return filename;
				},
				getScope: function getScope() {
					return _getScope(scopeManager, traverser.current(), config.parserOptions.ecmaVersion);
				},
				getSourceCode: function getSourceCode() {
					return sourceCode;
				},
				markVariableAsUsed: function markVariableAsUsed(name) {
					return _markVariableAsUsed(scopeManager, traverser.current(), config.parserOptions, name);
				},
				parserOptions: config.parserOptions,
				parserPath: config.parser,
				parserServices: parserServices,
				settings: config.settings,
				_linter: {
					report: function report() {},

					on: emitter.on
				}
			}));
			Object.keys(config.rules).forEach(function (ruleId) {
				var severity = ConfigOps.getRuleSeverity(config.rules[ruleId]);

				if (severity === 0) {
					return;
				}

				var rule = _this.rules.get(ruleId);
				var reportTranslator = null;
				var ruleContext = Object.freeze(Object.assign(Object.create(sharedTraversalContext), {
					id: ruleId,
					options: getRuleOptions(config.rules[ruleId]),
					report: function report() {
						if (reportTranslator === null) {
							reportTranslator = createReportTranslator({ ruleId: ruleId, severity: severity, sourceCode: sourceCode });
						}
						var problem = reportTranslator.apply(null, arguments);

						if (problem.fix && rule.meta && !rule.meta.fixable) {
							throw new Error("Fixable rules should export a `meta.fixable` property.");
						}
						problems.push(problem);
						sharedTraversalContext._linter.report( // eslint-disable-line no-underscore-dangle
						problem.ruleId, problem.severity, { loc: { start: { line: problem.line, column: problem.column - 1 } } }, problem.message);
					}
				}));

				try {
					var ruleListeners = rule.create(ruleContext);
					Object.keys(ruleListeners).forEach(function (selector) {
						emitter.on(selector, timing.enabled ? timing.time(ruleId, ruleListeners[selector]) : ruleListeners[selector]);
					});
				} catch (ex) {
					ex.message = 'Error while loading rule \'' + ruleId + '\': ' + ex.message;
					throw ex;
				}
			});
			addDeclaredGlobals(scopeManager.scopes[0], config, this.environments);

			var eventGenerator = new CodePathAnalyzer(new NodeEventGenerator(emitter));
			traverser.traverse(sourceCode.ast, {
				enter: function enter(node, parent) {
					node.parent = parent;
					eventGenerator.enterNode(node);
				},
				leave: function leave(node) {
					eventGenerator.leaveNode(node);
				}
			});

			return applyDisableDirectives({
				directives: disableDirectives,
				problems: problems.sort(function (problemA, problemB) {
					return problemA.line - problemB.line || problemA.column - problemB.column;
				}),
				reportUnusedDisableDirectives: reportUnusedDisableDirectives
			});
		}

	}, {
		key: 'verify',
		value: function verify(textOrSourceCode, config, filenameOrOptions) {
			var _this2 = this;

			var preprocess = filenameOrOptions && filenameOrOptions.preprocess || function (rawText) {
				return [rawText];
			};
			var postprocess = filenameOrOptions && filenameOrOptions.postprocess || lodash.flatten;

			return postprocess(preprocess(textOrSourceCode).map(function (textBlock) {
				return _this2._verifyWithoutProcessors(textBlock, config, filenameOrOptions);
			}));
		}

	}, {
		key: 'getSourceCode',
		value: function getSourceCode() {
			return lastSourceCodes.get(this);
		}

	}, {
		key: 'defineRule',
		value: function defineRule(ruleId, ruleModule) {
			this.rules.define(ruleId, ruleModule);
		}

	}, {
		key: 'defineRules',
		value: function defineRules(rulesToDefine) {
			var _this3 = this;

			Object.getOwnPropertyNames(rulesToDefine).forEach(function (ruleId) {
				_this3.defineRule(ruleId, rulesToDefine[ruleId]);
			});
		}

	}, {
		key: 'getRules',
		value: function getRules() {
			return this.rules.getAllLoadedRules();
		}

	}, {
		key: 'defineParser',
		value: function defineParser(parserId, parserModule) {
			this._parsers.set(parserId, parserModule);
		}

	}, {
		key: 'verifyAndFix',
		value: function verifyAndFix(text, config, options) {
			var messages = [],
				fixedResult = void 0,
				fixed = false,
				passNumber = 0;
			var debugTextDescription = options && options.filename || text.slice(0, 10) + '...';
			var shouldFix = options && typeof options.fix !== "undefined" ? options.fix : true;
			do {
				passNumber++;

				debug('Linting code for ' + debugTextDescription + ' (pass ' + passNumber + ')');
				messages = this.verify(text, config, options);

				debug('Generating fixed text for ' + debugTextDescription + ' (pass ' + passNumber + ')');
				fixedResult = SourceCodeFixer.applyFixes(text, messages, shouldFix);
				if (messages.length === 1 && messages[0].fatal) {
					break;
				}
				fixed = fixed || fixedResult.fixed;
				text = fixedResult.output;
			} while (fixedResult.fixed && passNumber < MAX_AUTOFIX_PASSES);
			if (fixedResult.fixed) {
				fixedResult.messages = this.verify(text, config, options);
			}
			fixedResult.fixed = fixed;
			fixedResult.output = text;

			return fixedResult;
		}
	}]);

	return Linter;
}();
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(115);
__webpack_require__(176);
__webpack_require__(177);
__webpack_require__(178);
__webpack_require__(179);
__webpack_require__(180);
__webpack_require__(181);
__webpack_require__(182);
__webpack_require__(183);
__webpack_require__(184);
__webpack_require__(185);
__webpack_require__(186);
__webpack_require__(187);
__webpack_require__(188);
__webpack_require__(189);
__webpack_require__(190);
__webpack_require__(192);
__webpack_require__(52);
__webpack_require__(193);
__webpack_require__(194);
__webpack_require__(195);
__webpack_require__(196);
__webpack_require__(197);
__webpack_require__(198);
__webpack_require__(199);
__webpack_require__(200);
__webpack_require__(201);
__webpack_require__(202);
__webpack_require__(203);
__webpack_require__(204);
__webpack_require__(205);
__webpack_require__(206);
__webpack_require__(207);
__webpack_require__(208);
__webpack_require__(209);
__webpack_require__(210);
__webpack_require__(211);
__webpack_require__(212);
__webpack_require__(213);
__webpack_require__(214);
__webpack_require__(215);
__webpack_require__(216);
__webpack_require__(217);
__webpack_require__(219);
__webpack_require__(220);
__webpack_require__(221);
__webpack_require__(222);
__webpack_require__(223);
__webpack_require__(224);
__webpack_require__(225);
__webpack_require__(226);
__webpack_require__(227);
__webpack_require__(228);
__webpack_require__(130);
__webpack_require__(229);
__webpack_require__(61);
__webpack_require__(230);
__webpack_require__(231);
__webpack_require__(232);
__webpack_require__(233);
__webpack_require__(234);
__webpack_require__(235);
__webpack_require__(236);
__webpack_require__(237);
__webpack_require__(238);
__webpack_require__(239);
__webpack_require__(240);
__webpack_require__(241);
__webpack_require__(242);
__webpack_require__(243);
__webpack_require__(244);
__webpack_require__(245);
__webpack_require__(246);
__webpack_require__(247);
__webpack_require__(248);
__webpack_require__(249);
__webpack_require__(250);
__webpack_require__(252);
__webpack_require__(253);
__webpack_require__(255);
__webpack_require__(133);
__webpack_require__(256);
__webpack_require__(257);
__webpack_require__(258);
__webpack_require__(259);
__webpack_require__(260);
__webpack_require__(263);
__webpack_require__(264);
__webpack_require__(265);
__webpack_require__(266);
__webpack_require__(267);
__webpack_require__(268);
__webpack_require__(269);
__webpack_require__(270);
__webpack_require__(271);
__webpack_require__(272);
__webpack_require__(273);
__webpack_require__(138);
__webpack_require__(274);
__webpack_require__(93);
__webpack_require__(275);
__webpack_require__(276);
__webpack_require__(140);
__webpack_require__(277);
__webpack_require__(278);
__webpack_require__(279);
__webpack_require__(280);
__webpack_require__(281);
__webpack_require__(143);
__webpack_require__(145);
__webpack_require__(146);
__webpack_require__(285);
__webpack_require__(286);
__webpack_require__(287);
__webpack_require__(288);
__webpack_require__(289);
__webpack_require__(290);
__webpack_require__(291);
__webpack_require__(292);
__webpack_require__(293);
__webpack_require__(294);
__webpack_require__(295);
__webpack_require__(296);
__webpack_require__(297);
__webpack_require__(298);
__webpack_require__(299);
__webpack_require__(300);
__webpack_require__(301);
__webpack_require__(302);
__webpack_require__(303);
__webpack_require__(304);
__webpack_require__(305);
__webpack_require__(306);
__webpack_require__(307);
__webpack_require__(309);
__webpack_require__(310);
__webpack_require__(311);
module.exports = __webpack_require__(13);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var getKeys = __webpack_require__(43);
var gOPS = __webpack_require__(58);
var pIE = __webpack_require__(59);
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
	var symbols = getSymbols(it);
	var isEnum = pIE.f;
	var i = 0;
	var key;
	while (symbols.length > i) {
			if (isEnum.call(it, key = symbols[i++])) result.push(key);
	}
  }return result;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
$export($export.S, 'Object', { create: __webpack_require__(38) });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
$export($export.S + $export.F * !__webpack_require__(11), 'Object', { defineProperty: __webpack_require__(9).f });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
$export($export.S + $export.F * !__webpack_require__(11), 'Object', { defineProperties: __webpack_require__(119) });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var toIObject = __webpack_require__(24);
var $getOwnPropertyDescriptor = __webpack_require__(30).f;

__webpack_require__(25)('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
	return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var toObject = __webpack_require__(18);
var $getPrototypeOf = __webpack_require__(40);

__webpack_require__(25)('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
	return $getPrototypeOf(toObject(it));
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var toObject = __webpack_require__(18);
var $keys = __webpack_require__(43);

__webpack_require__(25)('keys', function () {
  return function keys(it) {
	return $keys(toObject(it));
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(25)('getOwnPropertyNames', function () {
  return __webpack_require__(120).f;
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var isObject = __webpack_require__(3);
var meta = __webpack_require__(33).onFreeze;

__webpack_require__(25)('freeze', function ($freeze) {
  return function freeze(it) {
	return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var isObject = __webpack_require__(3);
var meta = __webpack_require__(33).onFreeze;

__webpack_require__(25)('seal', function ($seal) {
  return function seal(it) {
	return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var isObject = __webpack_require__(3);
var meta = __webpack_require__(33).onFreeze;

__webpack_require__(25)('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
	return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var isObject = __webpack_require__(3);

__webpack_require__(25)('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
	return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var isObject = __webpack_require__(3);

__webpack_require__(25)('isSealed', function ($isSealed) {
  return function isSealed(it) {
	return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var isObject = __webpack_require__(3);

__webpack_require__(25)('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
	return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(121) });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
$export($export.S, 'Object', { is: __webpack_require__(191) });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = Object.is || function is(x, y) {
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(81).set });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.P, 'Function', { bind: __webpack_require__(122) });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var dP = __webpack_require__(9).f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';
NAME in FProto || __webpack_require__(11) && dP(FProto, NAME, {
  configurable: true,
  get: function get() {
	try {
			return ('' + this).match(nameRE)[1];
	} catch (e) {
			return '';
	}
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(3);
var getPrototypeOf = __webpack_require__(40);
var HAS_INSTANCE = __webpack_require__(6)('hasInstance');
var FunctionProto = Function.prototype;
if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(9).f(FunctionProto, HAS_INSTANCE, { value: function value(O) {
	if (typeof this != 'function' || !isObject(O)) return false;
	if (!isObject(this.prototype)) return O instanceof this;
	while (O = getPrototypeOf(O)) {
			if (this.prototype === O) return true;
	}return false;
  } });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $parseInt = __webpack_require__(124);
$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $parseFloat = __webpack_require__(125);
$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(4);
var has = __webpack_require__(14);
var cof = __webpack_require__(28);
var inheritIfRequired = __webpack_require__(83);
var toPrimitive = __webpack_require__(32);
var fails = __webpack_require__(2);
var gOPN = __webpack_require__(39).f;
var gOPD = __webpack_require__(30).f;
var dP = __webpack_require__(9).f;
var $trim = __webpack_require__(60).trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
var BROKEN_COF = cof(__webpack_require__(38)(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;
var toNumber = function toNumber(argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
	it = TRIM ? it.trim() : $trim(it, 3);
	var first = it.charCodeAt(0);
	var third, radix, maxCode;
	if (first === 43 || first === 45) {
			third = it.charCodeAt(2);
			if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
	} else if (first === 48) {
			switch (it.charCodeAt(1)) {
		case 66:case 98:
					radix = 2;maxCode = 49;break; // fast equal /^0b[01]+$/i
		case 79:case 111:
					radix = 8;maxCode = 55;break; // fast equal /^0o[0-7]+$/i
		default:
					return +it;
			}
			for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
		code = digits.charCodeAt(i);
		if (code < 48 || code > maxCode) return NaN;
			}return parseInt(digits, radix);
	}
  }return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
	var it = arguments.length < 1 ? 0 : value;
	var that = this;
	return that instanceof $Number
	&& (BROKEN_COF ? fails(function () {
			proto.valueOf.call(that);
	}) : cof(that) != NUMBER) ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = __webpack_require__(11) ? gOPN(Base) : (
  'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
  'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j = 0, key; keys.length > j; j++) {
	if (has(Base, key = keys[j]) && !has($Number, key)) {
			dP($Number, key, gOPD(Base, key));
	}
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  __webpack_require__(15)(global, NUMBER, $Number);
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var toInteger = __webpack_require__(29);
var aNumberValue = __webpack_require__(126);
var repeat = __webpack_require__(127);
var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function multiply(n, c) {
  var i = -1;
  var c2 = c;
  while (++i < 6) {
	c2 += n * data[i];
	data[i] = c2 % 1e7;
	c2 = floor(c2 / 1e7);
  }
};
var divide = function divide(n) {
  var i = 6;
  var c = 0;
  while (--i >= 0) {
	c += data[i];
	data[i] = floor(c / n);
	c = c % n * 1e7;
  }
};
var numToString = function numToString() {
  var i = 6;
  var s = '';
  while (--i >= 0) {
	if (s !== '' || i === 0 || data[i] !== 0) {
			var t = String(data[i]);
			s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
	}
  }return s;
};
var pow = function pow(x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function log(x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
	n += 12;
	x2 /= 4096;
  }
  while (x2 >= 2) {
	n += 1;
	x2 /= 2;
  }return n;
};

$export($export.P + $export.F * (!!$toFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128.0.toFixed(0) !== '1000000000000000128') || !__webpack_require__(2)(function () {
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
	var x = aNumberValue(this, ERROR);
	var f = toInteger(fractionDigits);
	var s = '';
	var m = ZERO;
	var e, z, j, k;
	if (f < 0 || f > 20) throw RangeError(ERROR);
	if (x != x) return 'NaN';
	if (x <= -1e21 || x >= 1e21) return String(x);
	if (x < 0) {
			s = '-';
			x = -x;
	}
	if (x > 1e-21) {
			e = log(x * pow(2, 69, 1)) - 69;
			z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
			z *= 0x10000000000000;
			e = 52 - e;
			if (e > 0) {
		multiply(0, z);
		j = f;
		while (j >= 7) {
					multiply(1e7, 0);
					j -= 7;
		}
		multiply(pow(10, j, 1), 0);
		j = e - 1;
		while (j >= 23) {
					divide(1 << 23);
					j -= 23;
		}
		divide(1 << j);
		multiply(1, 1);
		divide(2);
		m = numToString();
			} else {
		multiply(0, z);
		multiply(1 << -e, 0);
		m = numToString() + repeat.call(ZERO, f);
			}
	}
	if (f > 0) {
			k = m.length;
			m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
	} else {
			m = s + m;
	}return m;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $fails = __webpack_require__(2);
var aNumberValue = __webpack_require__(126);
var $toPrecision = 1.0.toPrecision;

$export($export.P + $export.F * ($fails(function () {
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
	var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
	return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var _isFinite = __webpack_require__(4).isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
	return typeof it == 'number' && _isFinite(it);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Number', { isInteger: __webpack_require__(128) });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
	return number != number;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var isInteger = __webpack_require__(128);
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
	return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $parseFloat = __webpack_require__(125);
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $parseInt = __webpack_require__(124);
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var log1p = __webpack_require__(129);
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
&& Math.floor($acosh(Number.MAX_VALUE)) == 710
&& $acosh(Infinity) == Infinity), 'Math', {
  acosh: function acosh(x) {
	return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var $atanh = Math.atanh;
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
	return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var sign = __webpack_require__(84);

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
	return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Math', {
  clz32: function clz32(x) {
	return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
	return (exp(x = +x) + exp(-x)) / 2;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var $expm1 = __webpack_require__(85);

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Math', { fround: __webpack_require__(218) });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var sign = __webpack_require__(84);
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function roundTiesToEven(n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) {
	var sum = 0;
	var i = 0;
	var aLen = arguments.length;
	var larg = 0;
	var arg, div;
	while (i < aLen) {
			arg = abs(arguments[i++]);
			if (larg < arg) {
		div = larg / arg;
		sum = sum * div * div + 1;
		larg = arg;
			} else if (arg > 0) {
		div = arg / larg;
		sum += div * div;
			} else sum += arg;
	}
	return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var $imul = Math.imul;
$export($export.S + $export.F * __webpack_require__(2)(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
	var UINT16 = 0xffff;
	var xn = +x;
	var yn = +y;
	var xl = UINT16 & xn;
	var yl = UINT16 & yn;
	return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Math', {
  log10: function log10(x) {
	return Math.log(x) * Math.LOG10E;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Math', { log1p: __webpack_require__(129) });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Math', {
  log2: function log2(x) {
	return Math.log(x) / Math.LN2;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Math', { sign: __webpack_require__(84) });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var expm1 = __webpack_require__(85);
var exp = Math.exp;
$export($export.S + $export.F * __webpack_require__(2)(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
	return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var expm1 = __webpack_require__(85);
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
	var a = expm1(x = +x);
	var b = expm1(-x);
	return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Math', {
  trunc: function trunc(it) {
	return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var toAbsoluteIndex = __webpack_require__(37);
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  fromCodePoint: function fromCodePoint(x) {
	var res = [];
	var aLen = arguments.length;
	var i = 0;
	var code;
	while (aLen > i) {
			code = +arguments[i++];
			if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
			res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
	}return res.join('');
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(60)('trim', function ($trim) {
  return function trim() {
	return $trim(this, 3);
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $at = __webpack_require__(131)(false);
$export($export.P, 'String', {
  codePointAt: function codePointAt(pos) {
	return $at(this, pos);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(1);
var toLength = __webpack_require__(12);
var context = __webpack_require__(87);
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * __webpack_require__(89)(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
	var that = context(this, searchString, ENDS_WITH);
	var endPosition = arguments.length > 1 ? arguments[1] : undefined;
	var len = toLength(that.length);
	var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
	var search = String(searchString);
	return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(1);
var context = __webpack_require__(87);
var INCLUDES = 'includes';

$export($export.P + $export.F * __webpack_require__(89)(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
	return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);

$export($export.P, 'String', {
  repeat: __webpack_require__(127)
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(1);
var toLength = __webpack_require__(12);
var context = __webpack_require__(87);
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * __webpack_require__(89)(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
	var that = context(this, searchString, STARTS_WITH);
	var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
	var search = String(searchString);
	return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(16)('anchor', function (createHTML) {
  return function anchor(name) {
	return createHTML(this, 'a', 'name', name);
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(16)('big', function (createHTML) {
  return function big() {
	return createHTML(this, 'big', '', '');
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(16)('blink', function (createHTML) {
  return function blink() {
	return createHTML(this, 'blink', '', '');
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(16)('bold', function (createHTML) {
  return function bold() {
	return createHTML(this, 'b', '', '');
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(16)('fixed', function (createHTML) {
  return function fixed() {
	return createHTML(this, 'tt', '', '');
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(16)('fontcolor', function (createHTML) {
  return function fontcolor(color) {
	return createHTML(this, 'font', 'color', color);
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(16)('fontsize', function (createHTML) {
  return function fontsize(size) {
	return createHTML(this, 'font', 'size', size);
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(16)('italics', function (createHTML) {
  return function italics() {
	return createHTML(this, 'i', '', '');
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(16)('link', function (createHTML) {
  return function link(url) {
	return createHTML(this, 'a', 'href', url);
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(16)('small', function (createHTML) {
  return function small() {
	return createHTML(this, 'small', '', '');
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(16)('strike', function (createHTML) {
  return function strike() {
	return createHTML(this, 'strike', '', '');
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(16)('sub', function (createHTML) {
  return function sub() {
	return createHTML(this, 'sub', '', '');
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(16)('sup', function (createHTML) {
  return function sup() {
	return createHTML(this, 'sup', '', '');
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Date', { now: function now() {
	return new Date().getTime();
  } });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var toObject = __webpack_require__(18);
var toPrimitive = __webpack_require__(32);

$export($export.P + $export.F * __webpack_require__(2)(function () {
  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({ toISOString: function toISOString() {
			return 1;
	} }) !== 1;
}), 'Date', {
  toJSON: function toJSON(key) {
	var O = toObject(this);
	var pv = toPrimitive(O);
	return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var toISOString = __webpack_require__(251);
$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var fails = __webpack_require__(2);
var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function lz(num) {
  return num > 9 ? num : '0' + num;
};
module.exports = fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
}) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) + '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) + 'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) + ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  __webpack_require__(15)(DateProto, TO_STRING, function toString() {
	var value = getTime.call(this);
	return value === value ? $toString.call(this) : INVALID_DATE;
  });
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var TO_PRIMITIVE = __webpack_require__(6)('toPrimitive');
var proto = Date.prototype;

if (!(TO_PRIMITIVE in proto)) __webpack_require__(17)(proto, TO_PRIMITIVE, __webpack_require__(254));
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(5);
var toPrimitive = __webpack_require__(32);
var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Array', { isArray: __webpack_require__(79) });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var createProperty = __webpack_require__(135);
$export($export.S + $export.F * __webpack_require__(2)(function () {
  function F() {/* empty */}
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  of: function of() /* ...args */{
	var index = 0;
	var aLen = arguments.length;
	var result = new (typeof this == 'function' ? this : Array)(aLen);
	while (aLen > index) {
			createProperty(result, index, arguments[index++]);
	}result.length = aLen;
	return result;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var toIObject = __webpack_require__(24);
var arrayJoin = [].join;
$export($export.P + $export.F * (__webpack_require__(51) != Object || !__webpack_require__(19)(arrayJoin)), 'Array', {
  join: function join(separator) {
	return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var html = __webpack_require__(80);
var cof = __webpack_require__(28);
var toAbsoluteIndex = __webpack_require__(37);
var toLength = __webpack_require__(12);
var arraySlice = [].slice;
$export($export.P + $export.F * __webpack_require__(2)(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
	var len = toLength(this.length);
	var klass = cof(this);
	end = end === undefined ? len : end;
	if (klass == 'Array') return arraySlice.call(this, begin, end);
	var start = toAbsoluteIndex(begin, len);
	var upTo = toAbsoluteIndex(end, len);
	var size = toLength(upTo - start);
	var cloned = new Array(size);
	var i = 0;
	for (; i < size; i++) {
			cloned[i] = klass == 'String' ? this.charAt(start + i) : this[start + i];
	}return cloned;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var aFunction = __webpack_require__(23);
var toObject = __webpack_require__(18);
var fails = __webpack_require__(2);
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  test.sort(undefined);
}) || !fails(function () {
  test.sort(null);
}) || !__webpack_require__(19)($sort)), 'Array', {
  sort: function sort(comparefn) {
	return comparefn === undefined ? $sort.call(toObject(this)) : $sort.call(toObject(this), aFunction(comparefn));
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $forEach = __webpack_require__(26)(0);
var STRICT = __webpack_require__(19)([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  forEach: function forEach(callbackfn /* , thisArg */) {
	return $forEach(this, callbackfn, arguments[1]);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var speciesConstructor = __webpack_require__(262);

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(3);
var isArray = __webpack_require__(79);
var SPECIES = __webpack_require__(6)('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
	C = original.constructor;
	if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
	if (isObject(C)) {
			C = C[SPECIES];
			if (C === null) C = undefined;
	}
  }return C === undefined ? Array : C;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $map = __webpack_require__(26)(1);

$export($export.P + $export.F * !__webpack_require__(19)([].map, true), 'Array', {
  map: function map(callbackfn /* , thisArg */) {
	return $map(this, callbackfn, arguments[1]);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $filter = __webpack_require__(26)(2);

$export($export.P + $export.F * !__webpack_require__(19)([].filter, true), 'Array', {
  filter: function filter(callbackfn /* , thisArg */) {
	return $filter(this, callbackfn, arguments[1]);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $some = __webpack_require__(26)(3);

$export($export.P + $export.F * !__webpack_require__(19)([].some, true), 'Array', {
  some: function some(callbackfn /* , thisArg */) {
	return $some(this, callbackfn, arguments[1]);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $every = __webpack_require__(26)(4);

$export($export.P + $export.F * !__webpack_require__(19)([].every, true), 'Array', {
  every: function every(callbackfn /* , thisArg */) {
	return $every(this, callbackfn, arguments[1]);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $reduce = __webpack_require__(136);

$export($export.P + $export.F * !__webpack_require__(19)([].reduce, true), 'Array', {
  reduce: function reduce(callbackfn /* , initialValue */) {
	return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $reduce = __webpack_require__(136);

$export($export.P + $export.F * !__webpack_require__(19)([].reduceRight, true), 'Array', {
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
	return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $indexOf = __webpack_require__(76)(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(19)($native)), 'Array', {
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
	return NEGATIVE_ZERO
	? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var toIObject = __webpack_require__(24);
var toInteger = __webpack_require__(29);
var toLength = __webpack_require__(12);
var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(19)($native)), 'Array', {
  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
	if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
	var O = toIObject(this);
	var length = toLength(O.length);
	var index = length - 1;
	if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
	if (index < 0) index = length + index;
	for (; index >= 0; index--) {
			if (index in O) if (O[index] === searchElement) return index || 0;
	}return -1;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.P, 'Array', { copyWithin: __webpack_require__(137) });

__webpack_require__(54)('copyWithin');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.P, 'Array', { fill: __webpack_require__(92) });

__webpack_require__(54)('fill');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var $find = __webpack_require__(26)(5);
var KEY = 'find';
var forced = true;
if (KEY in []) Array(1)[KEY](function () {
  forced = false;
});
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
	return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(54)(KEY);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(45)('Array');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(4);
var inheritIfRequired = __webpack_require__(83);
var dP = __webpack_require__(9).f;
var gOPN = __webpack_require__(39).f;
var isRegExp = __webpack_require__(88);
var $flags = __webpack_require__(94);
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (__webpack_require__(11) && (!CORRECT_NEW || __webpack_require__(2)(function () {
  re2[__webpack_require__(6)('match')] = false;
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
	var tiRE = this instanceof $RegExp;
	var piRE = isRegExp(p);
	var fiU = f === undefined;
	return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : inheritIfRequired(CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f), tiRE ? this : proto, $RegExp);
  };
  var proxy = function proxy(key) {
	key in $RegExp || dP($RegExp, key, {
			configurable: true,
			get: function get() {
		return Base[key];
			},
			set: function set(it) {
		Base[key] = it;
			}
	});
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) {
	proxy(keys[i++]);
  }proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  __webpack_require__(15)(global, 'RegExp', $RegExp);
}

__webpack_require__(45)('RegExp');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(140);
var anObject = __webpack_require__(5);
var $flags = __webpack_require__(94);
var DESCRIPTORS = __webpack_require__(11);
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function define(fn) {
  __webpack_require__(15)(RegExp.prototype, TO_STRING, fn, true);
};
if (__webpack_require__(2)(function () {
  return $toString.call({ source: 'a', flags: 'b' }) != '/a/b';
})) {
  define(function toString() {
	var R = anObject(this);
	return '/'.concat(R.source, '/', 'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
} else if ($toString.name != TO_STRING) {
  define(function toString() {
	return $toString.call(this);
  });
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(63)('match', 1, function (defined, MATCH, $match) {
  return [function match(regexp) {
	'use strict';

	var O = defined(this);
	var fn = regexp == undefined ? undefined : regexp[MATCH];
	return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, $match];
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(63)('replace', 2, function (defined, REPLACE, $replace) {
  return [function replace(searchValue, replaceValue) {
	'use strict';

	var O = defined(this);
	var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
	return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(63)('search', 1, function (defined, SEARCH, $search) {
  return [function search(regexp) {
	'use strict';

	var O = defined(this);
	var fn = regexp == undefined ? undefined : regexp[SEARCH];
	return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, $search];
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(63)('split', 2, function (defined, SPLIT, $split) {
  'use strict';

  var isRegExp = __webpack_require__(88);
  var _split = $split;
  var $push = [].push;
  var $SPLIT = 'split';
  var LENGTH = 'length';
  var LAST_INDEX = 'lastIndex';
  if ('abbc'[$SPLIT](/(b)*/)[1] == 'c' || 'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 || 'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 || '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 || '.'[$SPLIT](/()()/)[LENGTH] > 1 || ''[$SPLIT](/.?/)[LENGTH]) {
	var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
	$split = function $split(separator, limit) {
			var string = String(this);
			if (separator === undefined && limit === 0) return [];
			if (!isRegExp(separator)) return _split.call(string, separator, limit);
			var output = [];
			var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
			var lastLastIndex = 0;
			var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
			var separatorCopy = new RegExp(separator.source, flags + 'g');
			var separator2, match, lastIndex, lastLength, i;
			if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
			while (match = separatorCopy.exec(string)) {
		lastIndex = match.index + match[0][LENGTH];
		if (lastIndex > lastLastIndex) {
					output.push(string.slice(lastLastIndex, match.index));
					if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
			for (i = 1; i < arguments[LENGTH] - 2; i++) {
							if (arguments[i] === undefined) match[i] = undefined;
			}
					});
					if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
					lastLength = match[0][LENGTH];
					lastLastIndex = lastIndex;
					if (output[LENGTH] >= splitLimit) break;
		}
		if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
			}
			if (lastLastIndex === string[LENGTH]) {
		if (lastLength || !separatorCopy.test('')) output.push('');
			} else output.push(string.slice(lastLastIndex));
			return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
	};
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
	$split = function $split(separator, limit) {
			return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
	};
  }
  return [function split(separator, limit) {
	var O = defined(this);
	var fn = separator == undefined ? undefined : separator[SPLIT];
	return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
  }, $split];
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var LIBRARY = __webpack_require__(42);
var global = __webpack_require__(4);
var ctx = __webpack_require__(22);
var classof = __webpack_require__(53);
var $export = __webpack_require__(1);
var isObject = __webpack_require__(3);
var aFunction = __webpack_require__(23);
var anInstance = __webpack_require__(46);
var forOf = __webpack_require__(47);
var speciesConstructor = __webpack_require__(95);
var task = __webpack_require__(141).set;
var microtask = __webpack_require__(282)();
var newPromiseCapabilityModule = __webpack_require__(142);
var perform = __webpack_require__(283);
var promiseResolve = __webpack_require__(284);
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function empty() {/* empty */};
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
	var promise = $Promise.resolve(1);
	var FakePromise = (promise.constructor = {})[__webpack_require__(6)('species')] = function (exec) {
			exec(empty, empty);
	};
	return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch (e) {/* empty */}
}();
var isThenable = function isThenable(it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function notify(promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
	var value = promise._v;
	var ok = promise._s == 1;
	var i = 0;
	var run = function run(reaction) {
			var handler = ok ? reaction.ok : reaction.fail;
			var resolve = reaction.resolve;
			var reject = reaction.reject;
			var domain = reaction.domain;
			var result, then;
			try {
		if (handler) {
					if (!ok) {
			if (promise._h == 2) onHandleUnhandled(promise);
			promise._h = 1;
					}
					if (handler === true) result = value;else {
			if (domain) domain.enter();
			result = handler(value);
			if (domain) domain.exit();
					}
					if (result === reaction.promise) {
			reject(TypeError('Promise-chain cycle'));
					} else if (then = isThenable(result)) {
			then.call(result, resolve, reject);
					} else resolve(result);
		} else reject(value);
			} catch (e) {
		reject(e);
			}
	};
	while (chain.length > i) {
			run(chain[i++]);
	} // variable length - can't use forEach
	promise._c = [];
	promise._n = false;
	if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function onUnhandled(promise) {
  task.call(global, function () {
	var value = promise._v;
	var unhandled = isUnhandled(promise);
	var result, handler, console;
	if (unhandled) {
			result = perform(function () {
		if (isNode) {
					process.emit('unhandledRejection', value, promise);
		} else if (handler = global.onunhandledrejection) {
					handler({ promise: promise, reason: value });
		} else if ((console = global.console) && console.error) {
					console.error('Unhandled promise rejection', value);
		}
			});
			promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	}promise._a = undefined;
	if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function isUnhandled(promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function onHandleUnhandled(promise) {
  task.call(global, function () {
	var handler;
	if (isNode) {
			process.emit('rejectionHandled', promise);
	} else if (handler = global.onrejectionhandled) {
			handler({ promise: promise, reason: promise._v });
	}
  });
};
var $reject = function $reject(value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function $resolve(value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
	if (promise === value) throw TypeError("Promise can't be resolved itself");
	if (then = isThenable(value)) {
			microtask(function () {
		var wrapper = { _w: promise, _d: false }; // wrap
		try {
					then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
		} catch (e) {
					$reject.call(wrapper, e);
		}
			});
	} else {
			promise._v = value;
			promise._s = 1;
			notify(promise, false);
	}
  } catch (e) {
	$reject.call({ _w: promise, _d: false }, e); // wrap
  }
};
if (!USE_NATIVE) {
  $Promise = function Promise(executor) {
	anInstance(this, $Promise, PROMISE, '_h');
	aFunction(executor);
	Internal.call(this);
	try {
			executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	} catch (err) {
			$reject.call(this, err);
	}
  };
  Internal = function Promise(executor) {
	this._c = []; // <- awaiting reactions
	this._a = undefined; // <- checked in isUnhandled reactions
	this._s = 0; // <- state
	this._d = false; // <- done
	this._v = undefined; // <- value
	this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	this._n = false; // <- notify
  };
  Internal.prototype = __webpack_require__(48)($Promise.prototype, {
	then: function then(onFulfilled, onRejected) {
			var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
			reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
			reaction.fail = typeof onRejected == 'function' && onRejected;
			reaction.domain = isNode ? process.domain : undefined;
			this._c.push(reaction);
			if (this._a) this._a.push(reaction);
			if (this._s) notify(this, false);
			return reaction.promise;
	},
	'catch': function _catch(onRejected) {
			return this.then(undefined, onRejected);
	}
  });
  OwnPromiseCapability = function OwnPromiseCapability() {
	var promise = new Internal();
	this.promise = promise;
	this.resolve = ctx($resolve, promise, 1);
	this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function newPromiseCapability(C) {
	return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(41)($Promise, PROMISE);
__webpack_require__(45)(PROMISE);
Wrapper = __webpack_require__(13)[PROMISE];
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  reject: function reject(r) {
	var capability = newPromiseCapability(this);
	var $$reject = capability.reject;
	$$reject(r);
	return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  resolve: function resolve(x) {
	return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(62)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  all: function all(iterable) {
	var C = this;
	var capability = newPromiseCapability(C);
	var resolve = capability.resolve;
	var reject = capability.reject;
	var result = perform(function () {
			var values = [];
			var index = 0;
			var remaining = 1;
			forOf(iterable, false, function (promise) {
		var $index = index++;
		var alreadyCalled = false;
		values.push(undefined);
		remaining++;
		C.resolve(promise).then(function (value) {
					if (alreadyCalled) return;
					alreadyCalled = true;
					values[$index] = value;
					--remaining || resolve(values);
		}, reject);
			});
			--remaining || resolve(values);
	});
	if (result.e) reject(result.v);
	return capability.promise;
  },
  race: function race(iterable) {
	var C = this;
	var capability = newPromiseCapability(C);
	var reject = capability.reject;
	var result = perform(function () {
			forOf(iterable, false, function (promise) {
		C.resolve(promise).then(capability.resolve, reject);
			});
	});
	if (result.e) reject(result.v);
	return capability.promise;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(4);
var macrotask = __webpack_require__(141).set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(28)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function flush() {
	var parent, fn;
	if (isNode && (parent = process.domain)) parent.exit();
	while (head) {
			fn = head.fn;
			head = head.next;
			try {
		fn();
			} catch (e) {
		if (head) notify();else last = undefined;
		throw e;
			}
	}last = undefined;
	if (parent) parent.enter();
  };
  if (isNode) {
	notify = function notify() {
			process.nextTick(flush);
	};
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
	var toggle = true;
	var node = document.createTextNode('');
	new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
	notify = function notify() {
			node.data = toggle = !toggle;
	};
  } else if (Promise && Promise.resolve) {
	var promise = Promise.resolve();
	notify = function notify() {
			promise.then(flush);
	};
  } else {
	notify = function notify() {
			macrotask.call(global, flush);
	};
  }

  return function (fn) {
	var task = { fn: fn, next: undefined };
	if (last) last.next = task;
	if (!head) {
			head = task;
			notify();
	}last = task;
  };
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (exec) {
  try {
	return { e: false, v: exec() };
  } catch (e) {
	return { e: true, v: e };
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(5);
var isObject = __webpack_require__(3);
var newPromiseCapability = __webpack_require__(142);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var weak = __webpack_require__(147);
var validate = __webpack_require__(49);
var WEAK_SET = 'WeakSet';
__webpack_require__(64)(WEAK_SET, function (get) {
  return function WeakSet() {
	return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  add: function add(value) {
	return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
var $typed = __webpack_require__(65);
var buffer = __webpack_require__(96);
var anObject = __webpack_require__(5);
var toAbsoluteIndex = __webpack_require__(37);
var toLength = __webpack_require__(12);
var isObject = __webpack_require__(3);
var ArrayBuffer = __webpack_require__(4).ArrayBuffer;
var speciesConstructor = __webpack_require__(95);
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  isView: function isView(it) {
	return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * __webpack_require__(2)(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  slice: function slice(start, end) {
	if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
	var len = anObject(this).byteLength;
	var first = toAbsoluteIndex(start, len);
	var final = toAbsoluteIndex(end === undefined ? len : end, len);
	var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first));
	var viewS = new $DataView(this);
	var viewT = new $DataView(result);
	var index = 0;
	while (first < final) {
			viewT.setUint8(index++, viewS.getUint8(first++));
	}return result;
  }
});

__webpack_require__(45)(ARRAY_BUFFER);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(1);
$export($export.G + $export.W + $export.F * !__webpack_require__(65).ABV, {
  DataView: __webpack_require__(96).DataView
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(31)('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
	return init(this, data, byteOffset, length);
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(31)('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
	return init(this, data, byteOffset, length);
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(31)('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
	return init(this, data, byteOffset, length);
  };
}, true);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(31)('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
	return init(this, data, byteOffset, length);
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(31)('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
	return init(this, data, byteOffset, length);
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(31)('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
	return init(this, data, byteOffset, length);
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(31)('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
	return init(this, data, byteOffset, length);
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(31)('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
	return init(this, data, byteOffset, length);
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(31)('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
	return init(this, data, byteOffset, length);
  };
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var aFunction = __webpack_require__(23);
var anObject = __webpack_require__(5);
var rApply = (__webpack_require__(4).Reflect || {}).apply;
var fApply = Function.apply;
$export($export.S + $export.F * !__webpack_require__(2)(function () {
  rApply(function () {/* empty */});
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
	var T = aFunction(target);
	var L = anObject(argumentsList);
	return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var create = __webpack_require__(38);
var aFunction = __webpack_require__(23);
var anObject = __webpack_require__(5);
var isObject = __webpack_require__(3);
var fails = __webpack_require__(2);
var bind = __webpack_require__(122);
var rConstruct = (__webpack_require__(4).Reflect || {}).construct;
var NEW_TARGET_BUG = fails(function () {
  function F() {/* empty */}
  return !(rConstruct(function () {/* empty */}, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () {/* empty */});
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
	aFunction(Target);
	anObject(args);
	var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
	if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
	if (Target == newTarget) {
			switch (args.length) {
		case 0:
					return new Target();
		case 1:
					return new Target(args[0]);
		case 2:
					return new Target(args[0], args[1]);
		case 3:
					return new Target(args[0], args[1], args[2]);
		case 4:
					return new Target(args[0], args[1], args[2], args[3]);
			}
			var $args = [null];
			$args.push.apply($args, args);
			return new (bind.apply(Target, $args))();
	}
	var proto = newTarget.prototype;
	var instance = create(isObject(proto) ? proto : Object.prototype);
	var result = Function.apply.call(Target, instance, args);
	return isObject(result) ? result : instance;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var dP = __webpack_require__(9);
var $export = __webpack_require__(1);
var anObject = __webpack_require__(5);
var toPrimitive = __webpack_require__(32);
$export($export.S + $export.F * __webpack_require__(2)(function () {
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
	anObject(target);
	propertyKey = toPrimitive(propertyKey, true);
	anObject(attributes);
	try {
			dP.f(target, propertyKey, attributes);
			return true;
	} catch (e) {
			return false;
	}
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var gOPD = __webpack_require__(30).f;
var anObject = __webpack_require__(5);

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
	var desc = gOPD(anObject(target), propertyKey);
	return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var anObject = __webpack_require__(5);
var Enumerate = function Enumerate(iterated) {
  this._t = anObject(iterated); // target
  this._i = 0; // next index
  var keys = this._k = []; // keys
  var key;
  for (key in iterated) {
	keys.push(key);
  }
};
__webpack_require__(132)(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;
  do {
	if (that._i >= keys.length) return { value: undefined, done: true };
  } while (!((key = keys[that._i++]) in that._t));
  return { value: key, done: false };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
	return new Enumerate(target);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var gOPD = __webpack_require__(30);
var getPrototypeOf = __webpack_require__(40);
var has = __webpack_require__(14);
var $export = __webpack_require__(1);
var isObject = __webpack_require__(3);
var anObject = __webpack_require__(5);

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var gOPD = __webpack_require__(30);
var $export = __webpack_require__(1);
var anObject = __webpack_require__(5);

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
	return gOPD.f(anObject(target), propertyKey);
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var getProto = __webpack_require__(40);
var anObject = __webpack_require__(5);

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
	return getProto(anObject(target));
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
	return propertyKey in target;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var anObject = __webpack_require__(5);
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
	anObject(target);
	return $isExtensible ? $isExtensible(target) : true;
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.S, 'Reflect', { ownKeys: __webpack_require__(308) });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var gOPN = __webpack_require__(39);
var gOPS = __webpack_require__(58);
var anObject = __webpack_require__(5);
var Reflect = __webpack_require__(4).Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var anObject = __webpack_require__(5);
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
	anObject(target);
	try {
			if ($preventExtensions) $preventExtensions(target);
			return true;
	} catch (e) {
			return false;
	}
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var dP = __webpack_require__(9);
var gOPD = __webpack_require__(30);
var getPrototypeOf = __webpack_require__(40);
var has = __webpack_require__(14);
var $export = __webpack_require__(1);
var createDesc = __webpack_require__(35);
var anObject = __webpack_require__(5);
var isObject = __webpack_require__(3);

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
	if (isObject(proto = getPrototypeOf(target))) {
			return set(proto, propertyKey, V, receiver);
	}
	ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
	if (ownDesc.writable === false || !isObject(receiver)) return false;
	existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
	existingDescriptor.value = V;
	dP.f(receiver, propertyKey, existingDescriptor);
	return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);
var setProto = __webpack_require__(81);

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
	setProto.check(target, proto);
	try {
			setProto.set(target, proto);
			return true;
	} catch (e) {
			return false;
	}
  }
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(115);
__webpack_require__(52);
__webpack_require__(313);
__webpack_require__(314);
module.exports = __webpack_require__(13).Symbol;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(75)('asyncIterator');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(75)('observable');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(52);
__webpack_require__(61);
__webpack_require__(97);
__webpack_require__(145);
__webpack_require__(316);
__webpack_require__(318);
__webpack_require__(319);
module.exports = __webpack_require__(13).Set;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.P + $export.R, 'Set', { toJSON: __webpack_require__(149)('Set') });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var forOf = __webpack_require__(47);

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(98)('Set');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(99)('Set');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(61);
__webpack_require__(133);
module.exports = __webpack_require__(13).Array.from;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(138);
module.exports = __webpack_require__(13).Array.findIndex;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(130);
module.exports = __webpack_require__(13).String.raw;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(52);
__webpack_require__(61);
__webpack_require__(97);
__webpack_require__(143);
__webpack_require__(324);
__webpack_require__(325);
__webpack_require__(326);
module.exports = __webpack_require__(13).Map;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var $export = __webpack_require__(1);

$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(149)('Map') });
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(98)('Map');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(99)('Map');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(52);
__webpack_require__(97);
__webpack_require__(146);
__webpack_require__(328);
__webpack_require__(329);
module.exports = __webpack_require__(13).WeakMap;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(98)('WeakMap');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__(99)('WeakMap');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function(module) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

!function (global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = ( false ? "undefined" : _typeof(module)) === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
	if (inModule) {
			module.exports = runtime;
	}
	return;
  }
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
	var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	var generator = Object.create(protoGenerator.prototype);
	var context = new Context(tryLocsList || []);
	generator._invoke = makeInvokeMethod(innerFn, self, context);

	return generator;
  }
  runtime.wrap = wrap;
  function tryCatch(fn, obj, arg) {
	try {
			return { type: "normal", arg: fn.call(obj, arg) };
	} catch (err) {
			return { type: "throw", arg: err };
	}
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";
  var ContinueSentinel = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
	return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";
  function defineIteratorMethods(prototype) {
	["next", "throw", "return"].forEach(function (method) {
			prototype[method] = function (arg) {
		return this._invoke(method, arg);
			};
	});
  }

  runtime.isGeneratorFunction = function (genFun) {
	var ctor = typeof genFun === "function" && genFun.constructor;
	return ctor ? ctor === GeneratorFunction ||
	(ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  runtime.mark = function (genFun) {
	if (Object.setPrototypeOf) {
			Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	} else {
			genFun.__proto__ = GeneratorFunctionPrototype;
			if (!(toStringTagSymbol in genFun)) {
		genFun[toStringTagSymbol] = "GeneratorFunction";
			}
	}
	genFun.prototype = Object.create(Gp);
	return genFun;
  };
  runtime.awrap = function (arg) {
	return { __await: arg };
  };

  function AsyncIterator(generator) {
	function invoke(method, arg, resolve, reject) {
			var record = tryCatch(generator[method], generator, arg);
			if (record.type === "throw") {
		reject(record.arg);
			} else {
		var result = record.arg;
		var value = result.value;
		if (value && (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" && hasOwn.call(value, "__await")) {
					return Promise.resolve(value.__await).then(function (value) {
			invoke("next", value, resolve, reject);
					}, function (err) {
			invoke("throw", err, resolve, reject);
					});
		}

		return Promise.resolve(value).then(function (unwrapped) {
					result.value = unwrapped;
					resolve(result);
		}, reject);
			}
	}

	var previousPromise;

	function enqueue(method, arg) {
			function callInvokeWithMethodAndArg() {
		return new Promise(function (resolve, reject) {
					invoke(method, arg, resolve, reject);
		});
			}

			return previousPromise =
			previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,
			callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
	}
	this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
	return this;
  };
  runtime.AsyncIterator = AsyncIterator;
  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
	var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));

	return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
	: iter.next().then(function (result) {
			return result.done ? result.value : iter.next();
	});
  };

  function makeInvokeMethod(innerFn, self, context) {
	var state = GenStateSuspendedStart;

	return function invoke(method, arg) {
			if (state === GenStateExecuting) {
		throw new Error("Generator is already running");
			}

			if (state === GenStateCompleted) {
		if (method === "throw") {
					throw arg;
		}
		return doneResult();
			}

			context.method = method;
			context.arg = arg;

			while (true) {
		var delegate = context.delegate;
		if (delegate) {
					var delegateResult = maybeInvokeDelegate(delegate, context);
					if (delegateResult) {
			if (delegateResult === ContinueSentinel) continue;
			return delegateResult;
					}
		}

		if (context.method === "next") {
					context.sent = context._sent = context.arg;
		} else if (context.method === "throw") {
					if (state === GenStateSuspendedStart) {
			state = GenStateCompleted;
			throw context.arg;
					}

					context.dispatchException(context.arg);
		} else if (context.method === "return") {
					context.abrupt("return", context.arg);
		}

		state = GenStateExecuting;

		var record = tryCatch(innerFn, self, context);
		if (record.type === "normal") {
					state = context.done ? GenStateCompleted : GenStateSuspendedYield;

					if (record.arg === ContinueSentinel) {
			continue;
					}

					return {
			value: record.arg,
			done: context.done
					};
		} else if (record.type === "throw") {
					state = GenStateCompleted;
					context.method = "throw";
					context.arg = record.arg;
		}
			}
	};
  }
  function maybeInvokeDelegate(delegate, context) {
	var method = delegate.iterator[context.method];
	if (method === undefined) {
			context.delegate = null;

			if (context.method === "throw") {
		if (delegate.iterator.return) {
					context.method = "return";
					context.arg = undefined;
					maybeInvokeDelegate(delegate, context);

					if (context.method === "throw") {
			return ContinueSentinel;
					}
		}

		context.method = "throw";
		context.arg = new TypeError("The iterator does not provide a 'throw' method");
			}

			return ContinueSentinel;
	}

	var record = tryCatch(method, delegate.iterator, context.arg);

	if (record.type === "throw") {
			context.method = "throw";
			context.arg = record.arg;
			context.delegate = null;
			return ContinueSentinel;
	}

	var info = record.arg;

	if (!info) {
			context.method = "throw";
			context.arg = new TypeError("iterator result is not an object");
			context.delegate = null;
			return ContinueSentinel;
	}

	if (info.done) {
			context[delegate.resultName] = info.value;
			context.next = delegate.nextLoc;
			if (context.method !== "return") {
		context.method = "next";
		context.arg = undefined;
			}
	} else {
			return info;
	}
	context.delegate = null;
	return ContinueSentinel;
  }
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";
  Gp[iteratorSymbol] = function () {
	return this;
  };

  Gp.toString = function () {
	return "[object Generator]";
  };

  function pushTryEntry(locs) {
	var entry = { tryLoc: locs[0] };

	if (1 in locs) {
			entry.catchLoc = locs[1];
	}

	if (2 in locs) {
			entry.finallyLoc = locs[2];
			entry.afterLoc = locs[3];
	}

	this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
	var record = entry.completion || {};
	record.type = "normal";
	delete record.arg;
	entry.completion = record;
  }

  function Context(tryLocsList) {
	this.tryEntries = [{ tryLoc: "root" }];
	tryLocsList.forEach(pushTryEntry, this);
	this.reset(true);
  }

  runtime.keys = function (object) {
	var keys = [];
	for (var key in object) {
			keys.push(key);
	}
	keys.reverse();
	return function next() {
			while (keys.length) {
		var key = keys.pop();
		if (key in object) {
					next.value = key;
					next.done = false;
					return next;
		}
			}
			next.done = true;
			return next;
	};
  };

  function values(iterable) {
	if (iterable) {
			var iteratorMethod = iterable[iteratorSymbol];
			if (iteratorMethod) {
		return iteratorMethod.call(iterable);
			}

			if (typeof iterable.next === "function") {
		return iterable;
			}

			if (!isNaN(iterable.length)) {
		var i = -1,
			next = function next() {
					while (++i < iterable.length) {
			if (hasOwn.call(iterable, i)) {
							next.value = iterable[i];
							next.done = false;
							return next;
			}
					}

					next.value = undefined;
					next.done = true;

					return next;
		};

		return next.next = next;
			}
	}
	return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
	return { value: undefined, done: true };
  }

  Context.prototype = {
	constructor: Context,

	reset: function reset(skipTempReset) {
			this.prev = 0;
			this.next = 0;
			this.sent = this._sent = undefined;
			this.done = false;
			this.delegate = null;

			this.method = "next";
			this.arg = undefined;

			this.tryEntries.forEach(resetTryEntry);

			if (!skipTempReset) {
		for (var name in this) {
					if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
			this[name] = undefined;
					}
		}
			}
	},

	stop: function stop() {
			this.done = true;

			var rootEntry = this.tryEntries[0];
			var rootRecord = rootEntry.completion;
			if (rootRecord.type === "throw") {
		throw rootRecord.arg;
			}

			return this.rval;
	},

	dispatchException: function dispatchException(exception) {
			if (this.done) {
		throw exception;
			}

			var context = this;
			function handle(loc, caught) {
		record.type = "throw";
		record.arg = exception;
		context.next = loc;

		if (caught) {
					context.method = "next";
					context.arg = undefined;
		}

		return !!caught;
			}

			for (var i = this.tryEntries.length - 1; i >= 0; --i) {
		var entry = this.tryEntries[i];
		var record = entry.completion;

		if (entry.tryLoc === "root") {
					return handle("end");
		}

		if (entry.tryLoc <= this.prev) {
					var hasCatch = hasOwn.call(entry, "catchLoc");
					var hasFinally = hasOwn.call(entry, "finallyLoc");

					if (hasCatch && hasFinally) {
			if (this.prev < entry.catchLoc) {
							return handle(entry.catchLoc, true);
			} else if (this.prev < entry.finallyLoc) {
							return handle(entry.finallyLoc);
			}
					} else if (hasCatch) {
			if (this.prev < entry.catchLoc) {
							return handle(entry.catchLoc, true);
			}
					} else if (hasFinally) {
			if (this.prev < entry.finallyLoc) {
							return handle(entry.finallyLoc);
			}
					} else {
			throw new Error("try statement without catch or finally");
					}
		}
			}
	},

	abrupt: function abrupt(type, arg) {
			for (var i = this.tryEntries.length - 1; i >= 0; --i) {
		var entry = this.tryEntries[i];
		if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
					var finallyEntry = entry;
					break;
		}
			}

			if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
		finallyEntry = null;
			}

			var record = finallyEntry ? finallyEntry.completion : {};
			record.type = type;
			record.arg = arg;

			if (finallyEntry) {
		this.method = "next";
		this.next = finallyEntry.finallyLoc;
		return ContinueSentinel;
			}

			return this.complete(record);
	},

	complete: function complete(record, afterLoc) {
			if (record.type === "throw") {
		throw record.arg;
			}

			if (record.type === "break" || record.type === "continue") {
		this.next = record.arg;
			} else if (record.type === "return") {
		this.rval = this.arg = record.arg;
		this.method = "return";
		this.next = "end";
			} else if (record.type === "normal" && afterLoc) {
		this.next = afterLoc;
			}

			return ContinueSentinel;
	},

	finish: function finish(finallyLoc) {
			for (var i = this.tryEntries.length - 1; i >= 0; --i) {
		var entry = this.tryEntries[i];
		if (entry.finallyLoc === finallyLoc) {
					this.complete(entry.completion, entry.afterLoc);
					resetTryEntry(entry);
					return ContinueSentinel;
		}
			}
	},

	"catch": function _catch(tryLoc) {
			for (var i = this.tryEntries.length - 1; i >= 0; --i) {
		var entry = this.tryEntries[i];
		if (entry.tryLoc === tryLoc) {
					var record = entry.completion;
					if (record.type === "throw") {
			var thrown = record.arg;
			resetTryEntry(entry);
					}
					return thrown;
		}
			}
			throw new Error("illegal catch attempt");
	},

	delegateYield: function delegateYield(iterable, resultName, nextLoc) {
			this.delegate = {
		iterator: values(iterable),
		resultName: resultName,
		nextLoc: nextLoc
			};

			if (this.method === "next") {
		this.arg = undefined;
			}

			return ContinueSentinel;
	}
  };
}(
function () {
  return this;
}() || Function("return this")());
}.call(exports, __webpack_require__(150)(module)))
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var ScopeManager = __webpack_require__(332);
var Referencer = __webpack_require__(334);
var Reference = __webpack_require__(100);
var Variable = __webpack_require__(66);
var Scope = __webpack_require__(151).Scope;
var version = __webpack_require__(337).version;
function defaultOptions() {
	return {
		optimistic: false,
		directive: false,
		nodejsScope: false,
		impliedStrict: false,
		sourceType: "script", // one of ['script', 'module']
		ecmaVersion: 5,
		childVisitorKeys: null,
		fallback: "iteration"
	};
}
function updateDeeply(target, override) {
	function isHashObject(value) {
		return (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" && value instanceof Object && !(value instanceof Array) && !(value instanceof RegExp);
	}

	for (var key in override) {
		if (override.hasOwnProperty(key)) {
			var val = override[key];

			if (isHashObject(val)) {
				if (isHashObject(target[key])) {
					updateDeeply(target[key], val);
				} else {
					target[key] = updateDeeply({}, val);
				}
			} else {
				target[key] = val;
			}
		}
	}
	return target;
}
function analyze(tree, providedOptions) {
	var options = updateDeeply(defaultOptions(), providedOptions);
	var scopeManager = new ScopeManager(options);
	var referencer = new Referencer(options, scopeManager);

	referencer.visit(tree);

	return scopeManager;
}

module.exports = {
	version: version,
	Reference: Reference,
	Variable: Variable,
	Scope: Scope,
	ScopeManager: ScopeManager,
	analyze: analyze
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Scope = __webpack_require__(151);


var GlobalScope = Scope.GlobalScope;
var CatchScope = Scope.CatchScope;
var WithScope = Scope.WithScope;
var ModuleScope = Scope.ModuleScope;
var ClassScope = Scope.ClassScope;
var SwitchScope = Scope.SwitchScope;
var FunctionScope = Scope.FunctionScope;
var ForScope = Scope.ForScope;
var TDZScope = Scope.TDZScope;
var FunctionExpressionNameScope = Scope.FunctionExpressionNameScope;
var BlockScope = Scope.BlockScope;

var ScopeManager = function () {
	function ScopeManager(options) {
		_classCallCheck(this, ScopeManager);

		this.scopes = [];
		this.globalScope = null;
		this.__nodeToScope = new WeakMap();
		this.__currentScope = null;
		this.__options = options;
		this.__declaredVariables = new WeakMap();
	}

	_createClass(ScopeManager, [{
		key: "__useDirective",
		value: function __useDirective() {
			return this.__options.directive;
		}
	}, {
		key: "__isOptimistic",
		value: function __isOptimistic() {
			return this.__options.optimistic;
		}
	}, {
		key: "__ignoreEval",
		value: function __ignoreEval() {
			return this.__options.ignoreEval;
		}
	}, {
		key: "__isNodejsScope",
		value: function __isNodejsScope() {
			return this.__options.nodejsScope;
		}
	}, {
		key: "isModule",
		value: function isModule() {
			return this.__options.sourceType === "module";
		}
	}, {
		key: "isImpliedStrict",
		value: function isImpliedStrict() {
			return this.__options.impliedStrict;
		}
	}, {
		key: "isStrictModeSupported",
		value: function isStrictModeSupported() {
			return this.__options.ecmaVersion >= 5;
		}
	}, {
		key: "__get",
		value: function __get(node) {
			return this.__nodeToScope.get(node);
		}

	}, {
		key: "getDeclaredVariables",
		value: function getDeclaredVariables(node) {
			return this.__declaredVariables.get(node) || [];
		}

	}, {
		key: "acquire",
		value: function acquire(node, inner) {
			function predicate(testScope) {
				if (testScope.type === "function" && testScope.functionExpressionScope) {
					return false;
				}
				if (testScope.type === "TDZ") {
					return false;
				}
				return true;
			}

			var scopes = this.__get(node);

			if (!scopes || scopes.length === 0) {
				return null;
			}
			if (scopes.length === 1) {
				return scopes[0];
			}

			if (inner) {
				for (var i = scopes.length - 1; i >= 0; --i) {
					var scope = scopes[i];

					if (predicate(scope)) {
						return scope;
					}
				}
			} else {
				for (var _i = 0, iz = scopes.length; _i < iz; ++_i) {
					var _scope = scopes[_i];

					if (predicate(_scope)) {
						return _scope;
					}
				}
			}

			return null;
		}

	}, {
		key: "acquireAll",
		value: function acquireAll(node) {
			return this.__get(node);
		}

	}, {
		key: "release",
		value: function release(node, inner) {
			var scopes = this.__get(node);

			if (scopes && scopes.length) {
				var scope = scopes[0].upper;

				if (!scope) {
					return null;
				}
				return this.acquire(scope.block, inner);
			}
			return null;
		}
	}, {
		key: "attach",
		value: function attach() {} // eslint-disable-line class-methods-use-this

	}, {
		key: "detach",
		value: function detach() {} // eslint-disable-line class-methods-use-this

	}, {
		key: "__nestScope",
		value: function __nestScope(scope) {
			if (scope instanceof GlobalScope) {
				this.globalScope = scope;
			}
			this.__currentScope = scope;
			return scope;
		}
	}, {
		key: "__nestGlobalScope",
		value: function __nestGlobalScope(node) {
			return this.__nestScope(new GlobalScope(this, node));
		}
	}, {
		key: "__nestBlockScope",
		value: function __nestBlockScope(node) {
			return this.__nestScope(new BlockScope(this, this.__currentScope, node));
		}
	}, {
		key: "__nestFunctionScope",
		value: function __nestFunctionScope(node, isMethodDefinition) {
			return this.__nestScope(new FunctionScope(this, this.__currentScope, node, isMethodDefinition));
		}
	}, {
		key: "__nestForScope",
		value: function __nestForScope(node) {
			return this.__nestScope(new ForScope(this, this.__currentScope, node));
		}
	}, {
		key: "__nestCatchScope",
		value: function __nestCatchScope(node) {
			return this.__nestScope(new CatchScope(this, this.__currentScope, node));
		}
	}, {
		key: "__nestWithScope",
		value: function __nestWithScope(node) {
			return this.__nestScope(new WithScope(this, this.__currentScope, node));
		}
	}, {
		key: "__nestClassScope",
		value: function __nestClassScope(node) {
			return this.__nestScope(new ClassScope(this, this.__currentScope, node));
		}
	}, {
		key: "__nestSwitchScope",
		value: function __nestSwitchScope(node) {
			return this.__nestScope(new SwitchScope(this, this.__currentScope, node));
		}
	}, {
		key: "__nestModuleScope",
		value: function __nestModuleScope(node) {
			return this.__nestScope(new ModuleScope(this, this.__currentScope, node));
		}
	}, {
		key: "__nestTDZScope",
		value: function __nestTDZScope(node) {
			return this.__nestScope(new TDZScope(this, this.__currentScope, node));
		}
	}, {
		key: "__nestFunctionExpressionNameScope",
		value: function __nestFunctionExpressionNameScope(node) {
			return this.__nestScope(new FunctionExpressionNameScope(this, this.__currentScope, node));
		}
	}, {
		key: "__isES6",
		value: function __isES6() {
			return this.__options.ecmaVersion >= 6;
		}
	}]);

	return ScopeManager;
}();

module.exports = ScopeManager;
 }),
 (function(module, exports) {

module.exports = {"_from":"estraverse@^4.2.0","_id":"estraverse@4.2.0","_inBundle":false,"_integrity":"sha1-De4/7TH81GlhjOc0IJn8GvoL2xM=","_location":"/estraverse","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"estraverse@^4.2.0","name":"estraverse","escapedName":"estraverse","rawSpec":"^4.2.0","saveSpec":null,"fetchSpec":"^4.2.0"},"_requiredBy":["/escope","/eslint","/eslint-scope","/esquery","/esrecurse"],"_resolved":"https://registry.npmjs.org/estraverse/-/estraverse-4.2.0.tgz","_shasum":"0dee3fed31fcd469618ce7342099fc1afa0bdb13","_spec":"estraverse@^4.2.0","_where":"J:\\Chromium\\newclient\\plugins\\c9.ide.language.javascript.eslint\\packager\\node_modules\\eslint","bugs":{"url":"https://github.com/estools/estraverse/issues"},"bundleDependencies":false,"deprecated":false,"description":"ECMAScript JS AST traversal functions","devDependencies":{"babel-preset-es2015":"^6.3.13","babel-register":"^6.3.13","chai":"^2.1.1","espree":"^1.11.0","gulp":"^3.8.10","gulp-bump":"^0.2.2","gulp-filter":"^2.0.0","gulp-git":"^1.0.1","gulp-tag-version":"^1.2.1","jshint":"^2.5.6","mocha":"^2.1.0"},"engines":{"node":">=0.10.0"},"homepage":"https://github.com/estools/estraverse","license":"BSD-2-Clause","main":"estraverse.js","maintainers":[{"name":"Yusuke Suzuki","email":"utatane.tea@gmail.com","url":"http://github.com/Constellation"}],"name":"estraverse","repository":{"type":"git","url":"git+ssh://git@github.com/estools/estraverse.git"},"scripts":{"lint":"jshint estraverse.js","test":"npm run-script lint && npm run-script unit-test","unit-test":"mocha --compilers js:babel-register"},"version":"4.2.0"}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Syntax = __webpack_require__(50).Syntax;
var esrecurse = __webpack_require__(153);
var Reference = __webpack_require__(100);
var Variable = __webpack_require__(66);
var PatternVisitor = __webpack_require__(336);
var definition = __webpack_require__(152);


var ParameterDefinition = definition.ParameterDefinition;
var Definition = definition.Definition;
function traverseIdentifierInPattern(options, rootPattern, referencer, callback) {
	var visitor = new PatternVisitor(options, rootPattern, callback);

	visitor.visit(rootPattern);
	if (referencer !== null && referencer !== undefined) {
		visitor.rightHandNodes.forEach(referencer.visit, referencer);
	}
}
var Importer = function (_esrecurse$Visitor) {
	_inherits(Importer, _esrecurse$Visitor);

	function Importer(declaration, referencer) {
		_classCallCheck(this, Importer);

		var _this = _possibleConstructorReturn(this, (Importer.__proto__ || Object.getPrototypeOf(Importer)).call(this, null, referencer.options));

		_this.declaration = declaration;
		_this.referencer = referencer;
		return _this;
	}

	_createClass(Importer, [{
		key: "visitImport",
		value: function visitImport(id, specifier) {
			var _this2 = this;

			this.referencer.visitPattern(id, function (pattern) {
				_this2.referencer.currentScope().__define(pattern, new Definition(Variable.ImportBinding, pattern, specifier, _this2.declaration, null, null));
			});
		}
	}, {
		key: "ImportNamespaceSpecifier",
		value: function ImportNamespaceSpecifier(node) {
			var local = node.local || node.id;

			if (local) {
				this.visitImport(local, node);
			}
		}
	}, {
		key: "ImportDefaultSpecifier",
		value: function ImportDefaultSpecifier(node) {
			var local = node.local || node.id;

			this.visitImport(local, node);
		}
	}, {
		key: "ImportSpecifier",
		value: function ImportSpecifier(node) {
			var local = node.local || node.id;

			if (node.name) {
				this.visitImport(node.name, node);
			} else {
				this.visitImport(local, node);
			}
		}
	}]);

	return Importer;
}(esrecurse.Visitor);

var Referencer = function (_esrecurse$Visitor2) {
	_inherits(Referencer, _esrecurse$Visitor2);

	function Referencer(options, scopeManager) {
		_classCallCheck(this, Referencer);

		var _this3 = _possibleConstructorReturn(this, (Referencer.__proto__ || Object.getPrototypeOf(Referencer)).call(this, null, options));

		_this3.options = options;
		_this3.scopeManager = scopeManager;
		_this3.parent = null;
		_this3.isInnerMethodDefinition = false;
		return _this3;
	}

	_createClass(Referencer, [{
		key: "currentScope",
		value: function currentScope() {
			return this.scopeManager.__currentScope;
		}
	}, {
		key: "close",
		value: function close(node) {
			while (this.currentScope() && node === this.currentScope().block) {
				this.scopeManager.__currentScope = this.currentScope().__close(this.scopeManager);
			}
		}
	}, {
		key: "pushInnerMethodDefinition",
		value: function pushInnerMethodDefinition(isInnerMethodDefinition) {
			var previous = this.isInnerMethodDefinition;

			this.isInnerMethodDefinition = isInnerMethodDefinition;
			return previous;
		}
	}, {
		key: "popInnerMethodDefinition",
		value: function popInnerMethodDefinition(isInnerMethodDefinition) {
			this.isInnerMethodDefinition = isInnerMethodDefinition;
		}
	}, {
		key: "materializeTDZScope",
		value: function materializeTDZScope(node, iterationNode) {
			this.scopeManager.__nestTDZScope(node, iterationNode);
			this.visitVariableDeclaration(this.currentScope(), Variable.TDZ, iterationNode.left, 0, true);
		}
	}, {
		key: "materializeIterationScope",
		value: function materializeIterationScope(node) {
			var _this4 = this;
			var letOrConstDecl = node.left;

			this.scopeManager.__nestForScope(node);
			this.visitVariableDeclaration(this.currentScope(), Variable.Variable, letOrConstDecl, 0);
			this.visitPattern(letOrConstDecl.declarations[0].id, function (pattern) {
				_this4.currentScope().__referencing(pattern, Reference.WRITE, node.right, null, true, true);
			});
		}
	}, {
		key: "referencingDefaultValue",
		value: function referencingDefaultValue(pattern, assignments, maybeImplicitGlobal, init) {
			var scope = this.currentScope();

			assignments.forEach(function (assignment) {
				scope.__referencing(pattern, Reference.WRITE, assignment.right, maybeImplicitGlobal, pattern !== assignment.left, init);
			});
		}
	}, {
		key: "visitPattern",
		value: function visitPattern(node, options, callback) {
			if (typeof options === "function") {
				callback = options;
				options = { processRightHandNodes: false };
			}
			traverseIdentifierInPattern(this.options, node, options.processRightHandNodes ? this : null, callback);
		}
	}, {
		key: "visitFunction",
		value: function visitFunction(node) {
			var _this5 = this;

			var i = void 0,
				iz = void 0;
			if (node.type === Syntax.FunctionDeclaration) {
				this.currentScope().__define(node.id, new Definition(Variable.FunctionName, node.id, node, null, null, null));
			}
			if (node.type === Syntax.FunctionExpression && node.id) {
				this.scopeManager.__nestFunctionExpressionNameScope(node);
			}
			this.scopeManager.__nestFunctionScope(node, this.isInnerMethodDefinition);

			var that = this;
			function visitPatternCallback(pattern, info) {
				that.currentScope().__define(pattern, new ParameterDefinition(pattern, node, i, info.rest));

				that.referencingDefaultValue(pattern, info.assignments, null, true);
			}
			for (i = 0, iz = node.params.length; i < iz; ++i) {
				this.visitPattern(node.params[i], { processRightHandNodes: true }, visitPatternCallback);
			}
			if (node.rest) {
				this.visitPattern({
					type: "RestElement",
					argument: node.rest
				}, function (pattern) {
					_this5.currentScope().__define(pattern, new ParameterDefinition(pattern, node, node.params.length, true));
				});
			}
			if (node.body) {
				if (node.body.type === Syntax.BlockStatement) {
					this.visitChildren(node.body);
				} else {
					this.visit(node.body);
				}
			}

			this.close(node);
		}
	}, {
		key: "visitClass",
		value: function visitClass(node) {
			if (node.type === Syntax.ClassDeclaration) {
				this.currentScope().__define(node.id, new Definition(Variable.ClassName, node.id, node, null, null, null));
			}
			this.visit(node.superClass);

			this.scopeManager.__nestClassScope(node);

			if (node.id) {
				this.currentScope().__define(node.id, new Definition(Variable.ClassName, node.id, node));
			}
			this.visit(node.body);

			this.close(node);
		}
	}, {
		key: "visitProperty",
		value: function visitProperty(node) {
			var previous = void 0;

			if (node.computed) {
				this.visit(node.key);
			}

			var isMethodDefinition = node.type === Syntax.MethodDefinition;

			if (isMethodDefinition) {
				previous = this.pushInnerMethodDefinition(true);
			}
			this.visit(node.value);
			if (isMethodDefinition) {
				this.popInnerMethodDefinition(previous);
			}
		}
	}, {
		key: "visitForIn",
		value: function visitForIn(node) {
			var _this6 = this;

			if (node.left.type === Syntax.VariableDeclaration && node.left.kind !== "var") {
				this.materializeTDZScope(node.right, node);
				this.visit(node.right);
				this.close(node.right);

				this.materializeIterationScope(node);
				this.visit(node.body);
				this.close(node);
			} else {
				if (node.left.type === Syntax.VariableDeclaration) {
					this.visit(node.left);
					this.visitPattern(node.left.declarations[0].id, function (pattern) {
						_this6.currentScope().__referencing(pattern, Reference.WRITE, node.right, null, true, true);
					});
				} else {
					this.visitPattern(node.left, { processRightHandNodes: true }, function (pattern, info) {
						var maybeImplicitGlobal = null;

						if (!_this6.currentScope().isStrict) {
							maybeImplicitGlobal = {
								pattern: pattern,
								node: node
							};
						}
						_this6.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);
						_this6.currentScope().__referencing(pattern, Reference.WRITE, node.right, maybeImplicitGlobal, true, false);
					});
				}
				this.visit(node.right);
				this.visit(node.body);
			}
		}
	}, {
		key: "visitVariableDeclaration",
		value: function visitVariableDeclaration(variableTargetScope, type, node, index, fromTDZ) {
			var _this7 = this;
			var decl = node.declarations[index];
			var init = decl.init;

			this.visitPattern(decl.id, { processRightHandNodes: !fromTDZ }, function (pattern, info) {
				variableTargetScope.__define(pattern, new Definition(type, pattern, decl, node, index, node.kind));

				if (!fromTDZ) {
					_this7.referencingDefaultValue(pattern, info.assignments, null, true);
				}
				if (init) {
					_this7.currentScope().__referencing(pattern, Reference.WRITE, init, null, !info.topLevel, true);
				}
			});
		}
	}, {
		key: "AssignmentExpression",
		value: function AssignmentExpression(node) {
			var _this8 = this;

			if (PatternVisitor.isPattern(node.left)) {
				if (node.operator === "=") {
					this.visitPattern(node.left, { processRightHandNodes: true }, function (pattern, info) {
						var maybeImplicitGlobal = null;

						if (!_this8.currentScope().isStrict) {
							maybeImplicitGlobal = {
								pattern: pattern,
								node: node
							};
						}
						_this8.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);
						_this8.currentScope().__referencing(pattern, Reference.WRITE, node.right, maybeImplicitGlobal, !info.topLevel, false);
					});
				} else {
					this.currentScope().__referencing(node.left, Reference.RW, node.right);
				}
			} else {
				this.visit(node.left);
			}
			this.visit(node.right);
		}
	}, {
		key: "CatchClause",
		value: function CatchClause(node) {
			var _this9 = this;

			this.scopeManager.__nestCatchScope(node);

			this.visitPattern(node.param, { processRightHandNodes: true }, function (pattern, info) {
				_this9.currentScope().__define(pattern, new Definition(Variable.CatchClause, node.param, node, null, null, null));
				_this9.referencingDefaultValue(pattern, info.assignments, null, true);
			});
			this.visit(node.body);

			this.close(node);
		}
	}, {
		key: "Program",
		value: function Program(node) {
			this.scopeManager.__nestGlobalScope(node);

			if (this.scopeManager.__isNodejsScope()) {
				this.currentScope().isStrict = false;
				this.scopeManager.__nestFunctionScope(node, false);
			}

			if (this.scopeManager.__isES6() && this.scopeManager.isModule()) {
				this.scopeManager.__nestModuleScope(node);
			}

			if (this.scopeManager.isStrictModeSupported() && this.scopeManager.isImpliedStrict()) {
				this.currentScope().isStrict = true;
			}

			this.visitChildren(node);
			this.close(node);
		}
	}, {
		key: "Identifier",
		value: function Identifier(node) {
			this.currentScope().__referencing(node);
		}
	}, {
		key: "UpdateExpression",
		value: function UpdateExpression(node) {
			if (PatternVisitor.isPattern(node.argument)) {
				this.currentScope().__referencing(node.argument, Reference.RW, null);
			} else {
				this.visitChildren(node);
			}
		}
	}, {
		key: "MemberExpression",
		value: function MemberExpression(node) {
			this.visit(node.object);
			if (node.computed) {
				this.visit(node.property);
			}
		}
	}, {
		key: "Property",
		value: function Property(node) {
			this.visitProperty(node);
		}
	}, {
		key: "MethodDefinition",
		value: function MethodDefinition(node) {
			this.visitProperty(node);
		}
	}, {
		key: "BreakStatement",
		value: function BreakStatement() {} // eslint-disable-line class-methods-use-this

	}, {
		key: "ContinueStatement",
		value: function ContinueStatement() {} // eslint-disable-line class-methods-use-this

	}, {
		key: "LabeledStatement",
		value: function LabeledStatement(node) {
			this.visit(node.body);
		}
	}, {
		key: "ForStatement",
		value: function ForStatement(node) {
			if (node.init && node.init.type === Syntax.VariableDeclaration && node.init.kind !== "var") {
				this.scopeManager.__nestForScope(node);
			}

			this.visitChildren(node);

			this.close(node);
		}
	}, {
		key: "ClassExpression",
		value: function ClassExpression(node) {
			this.visitClass(node);
		}
	}, {
		key: "ClassDeclaration",
		value: function ClassDeclaration(node) {
			this.visitClass(node);
		}
	}, {
		key: "CallExpression",
		value: function CallExpression(node) {
			if (!this.scopeManager.__ignoreEval() && node.callee.type === Syntax.Identifier && node.callee.name === "eval") {
				this.currentScope().variableScope.__detectEval();
			}
			this.visitChildren(node);
		}
	}, {
		key: "BlockStatement",
		value: function BlockStatement(node) {
			if (this.scopeManager.__isES6()) {
				this.scopeManager.__nestBlockScope(node);
			}

			this.visitChildren(node);

			this.close(node);
		}
	}, {
		key: "ThisExpression",
		value: function ThisExpression() {
			this.currentScope().variableScope.__detectThis();
		}
	}, {
		key: "WithStatement",
		value: function WithStatement(node) {
			this.visit(node.object);
			this.scopeManager.__nestWithScope(node);

			this.visit(node.body);

			this.close(node);
		}
	}, {
		key: "VariableDeclaration",
		value: function VariableDeclaration(node) {
			var variableTargetScope = node.kind === "var" ? this.currentScope().variableScope : this.currentScope();

			for (var i = 0, iz = node.declarations.length; i < iz; ++i) {
				var decl = node.declarations[i];

				this.visitVariableDeclaration(variableTargetScope, Variable.Variable, node, i);
				if (decl.init) {
					this.visit(decl.init);
				}
			}
		}
	}, {
		key: "SwitchStatement",
		value: function SwitchStatement(node) {
			this.visit(node.discriminant);

			if (this.scopeManager.__isES6()) {
				this.scopeManager.__nestSwitchScope(node);
			}

			for (var i = 0, iz = node.cases.length; i < iz; ++i) {
				this.visit(node.cases[i]);
			}

			this.close(node);
		}
	}, {
		key: "FunctionDeclaration",
		value: function FunctionDeclaration(node) {
			this.visitFunction(node);
		}
	}, {
		key: "FunctionExpression",
		value: function FunctionExpression(node) {
			this.visitFunction(node);
		}
	}, {
		key: "ForOfStatement",
		value: function ForOfStatement(node) {
			this.visitForIn(node);
		}
	}, {
		key: "ForInStatement",
		value: function ForInStatement(node) {
			this.visitForIn(node);
		}
	}, {
		key: "ArrowFunctionExpression",
		value: function ArrowFunctionExpression(node) {
			this.visitFunction(node);
		}
	}, {
		key: "ImportDeclaration",
		value: function ImportDeclaration(node) {

			var importer = new Importer(node, this);

			importer.visit(node);
		}
	}, {
		key: "visitExportDeclaration",
		value: function visitExportDeclaration(node) {
			if (node.source) {
				return;
			}
			if (node.declaration) {
				this.visit(node.declaration);
				return;
			}

			this.visitChildren(node);
		}
	}, {
		key: "ExportDeclaration",
		value: function ExportDeclaration(node) {
			this.visitExportDeclaration(node);
		}
	}, {
		key: "ExportNamedDeclaration",
		value: function ExportNamedDeclaration(node) {
			this.visitExportDeclaration(node);
		}
	}, {
		key: "ExportSpecifier",
		value: function ExportSpecifier(node) {
			var local = node.id || node.local;

			this.visit(local);
		}
	}, {
		key: "MetaProperty",
		value: function MetaProperty() {// eslint-disable-line class-methods-use-this
		}
	}]);

	return Referencer;
}(esrecurse.Visitor);

module.exports = Referencer;
 }),
 (function(module, exports) {

module.exports = {"_from":"esrecurse@^4.1.0","_id":"esrecurse@4.2.0","_inBundle":false,"_integrity":"sha1-+pVo2Y04I/mkHZHpAtyrnqblsWM=","_location":"/esrecurse","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"esrecurse@^4.1.0","name":"esrecurse","escapedName":"esrecurse","rawSpec":"^4.1.0","saveSpec":null,"fetchSpec":"^4.1.0"},"_requiredBy":["/escope","/eslint-scope"],"_resolved":"https://registry.npmjs.org/esrecurse/-/esrecurse-4.2.0.tgz","_shasum":"fa9568d98d3823f9a41d91e902dcab9ea6e5b163","_spec":"esrecurse@^4.1.0","_where":"J:\\Chromium\\newclient\\plugins\\c9.ide.language.javascript.eslint\\packager\\node_modules\\eslint-scope","babel":{"presets":["es2015"]},"bugs":{"url":"https://github.com/estools/esrecurse/issues"},"bundleDependencies":false,"dependencies":{"estraverse":"^4.1.0","object-assign":"^4.0.1"},"deprecated":false,"description":"ECMAScript AST recursive visitor","devDependencies":{"babel-cli":"^6.24.1","babel-eslint":"^7.2.3","babel-preset-es2015":"^6.24.1","babel-register":"^6.24.1","chai":"^4.0.2","esprima":"^4.0.0","gulp":"^3.9.0","gulp-bump":"^2.7.0","gulp-eslint":"^4.0.0","gulp-filter":"^5.0.0","gulp-git":"^2.4.1","gulp-mocha":"^4.3.1","gulp-tag-version":"^1.2.1","jsdoc":"^3.3.0-alpha10","minimist":"^1.1.0"},"engines":{"node":">=0.10.0"},"homepage":"https://github.com/estools/esrecurse","license":"BSD-2-Clause","main":"esrecurse.js","maintainers":[{"name":"Yusuke Suzuki","email":"utatane.tea@gmail.com","url":"https://github.com/Constellation"}],"name":"esrecurse","repository":{"type":"git","url":"git+https://github.com/estools/esrecurse.git"},"scripts":{"lint":"gulp lint","test":"gulp travis","unit-test":"gulp test"},"version":"4.2.0"}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Syntax = __webpack_require__(50).Syntax;
var esrecurse = __webpack_require__(153);
function getLast(xs) {
	return xs[xs.length - 1] || null;
}

var PatternVisitor = function (_esrecurse$Visitor) {
	_inherits(PatternVisitor, _esrecurse$Visitor);

	_createClass(PatternVisitor, null, [{
		key: "isPattern",
		value: function isPattern(node) {
			var nodeType = node.type;

			return nodeType === Syntax.Identifier || nodeType === Syntax.ObjectPattern || nodeType === Syntax.ArrayPattern || nodeType === Syntax.SpreadElement || nodeType === Syntax.RestElement || nodeType === Syntax.AssignmentPattern;
		}
	}]);

	function PatternVisitor(options, rootPattern, callback) {
		_classCallCheck(this, PatternVisitor);

		var _this = _possibleConstructorReturn(this, (PatternVisitor.__proto__ || Object.getPrototypeOf(PatternVisitor)).call(this, null, options));

		_this.rootPattern = rootPattern;
		_this.callback = callback;
		_this.assignments = [];
		_this.rightHandNodes = [];
		_this.restElements = [];
		return _this;
	}

	_createClass(PatternVisitor, [{
		key: "Identifier",
		value: function Identifier(pattern) {
			var lastRestElement = getLast(this.restElements);

			this.callback(pattern, {
				topLevel: pattern === this.rootPattern,
				rest: lastRestElement !== null && lastRestElement !== undefined && lastRestElement.argument === pattern,
				assignments: this.assignments
			});
		}
	}, {
		key: "Property",
		value: function Property(property) {
			if (property.computed) {
				this.rightHandNodes.push(property.key);
			}
			this.visit(property.value);
		}
	}, {
		key: "ArrayPattern",
		value: function ArrayPattern(pattern) {
			for (var i = 0, iz = pattern.elements.length; i < iz; ++i) {
				var element = pattern.elements[i];

				this.visit(element);
			}
		}
	}, {
		key: "AssignmentPattern",
		value: function AssignmentPattern(pattern) {
			this.assignments.push(pattern);
			this.visit(pattern.left);
			this.rightHandNodes.push(pattern.right);
			this.assignments.pop();
		}
	}, {
		key: "RestElement",
		value: function RestElement(pattern) {
			this.restElements.push(pattern);
			this.visit(pattern.argument);
			this.restElements.pop();
		}
	}, {
		key: "MemberExpression",
		value: function MemberExpression(node) {
			if (node.computed) {
				this.rightHandNodes.push(node.property);
			}
			this.rightHandNodes.push(node.object);
		}

		//
		//

	}, {
		key: "SpreadElement",
		value: function SpreadElement(node) {
			this.visit(node.argument);
		}
	}, {
		key: "ArrayExpression",
		value: function ArrayExpression(node) {
			node.elements.forEach(this.visit, this);
		}
	}, {
		key: "AssignmentExpression",
		value: function AssignmentExpression(node) {
			this.assignments.push(node);
			this.visit(node.left);
			this.rightHandNodes.push(node.right);
			this.assignments.pop();
		}
	}, {
		key: "CallExpression",
		value: function CallExpression(node) {
			var _this2 = this;
			node.arguments.forEach(function (a) {
				_this2.rightHandNodes.push(a);
			});
			this.visit(node.callee);
		}
	}]);

	return PatternVisitor;
}(esrecurse.Visitor);

module.exports = PatternVisitor;
 }),
 (function(module, exports) {

module.exports = {"_from":"eslint-scope@^3.7.1","_id":"eslint-scope@3.7.1","_inBundle":false,"_integrity":"sha1-PWPD7f2gLgbgGkUq2IyqzHzctug=","_location":"/eslint-scope","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"eslint-scope@^3.7.1","name":"eslint-scope","escapedName":"eslint-scope","rawSpec":"^3.7.1","saveSpec":null,"fetchSpec":"^3.7.1"},"_requiredBy":["/eslint"],"_resolved":"https://registry.npmjs.org/eslint-scope/-/eslint-scope-3.7.1.tgz","_shasum":"3d63c3edfda02e06e01a452ad88caacc7cdcb6e8","_spec":"eslint-scope@^3.7.1","_where":"J:\\Chromium\\newclient\\plugins\\c9.ide.language.javascript.eslint\\packager\\node_modules\\eslint","bugs":{"url":"https://github.com/eslint/eslint-scope/issues"},"bundleDependencies":false,"dependencies":{"esrecurse":"^4.1.0","estraverse":"^4.1.1"},"deprecated":false,"description":"ECMAScript scope analyzer for ESLint","devDependencies":{"chai":"^3.4.1","eslint":"^3.15.0","eslint-config-eslint":"^4.0.0","eslint-release":"^0.10.1","espree":"^3.1.1","istanbul":"^0.4.5","mocha":"^3.2.0","npm-license":"^0.3.3","shelljs":"^0.7.6","typescript":"~2.0.10","typescript-eslint-parser":"^1.0.0"},"engines":{"node":">=4.0.0"},"files":["LICENSE","README.md","lib"],"homepage":"http://github.com/eslint/eslint-scope","license":"BSD-2-Clause","main":"lib/index.js","name":"eslint-scope","repository":{"type":"git","url":"git+https://github.com/eslint/eslint-scope.git"},"scripts":{"alpharelease":"eslint-prerelease alpha","betarelease":"eslint-prerelease beta","ci-release":"eslint-ci-release","gh-release":"eslint-gh-release","lint":"node Makefile.js lint","release":"eslint-release","test":"node Makefile.js test"},"version":"3.7.1"}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function () {
  var parseString, cast, parseType, VERSION, parsedTypeParse, parse;
  parseString = __webpack_require__(339);
  cast = __webpack_require__(345);
  parseType = __webpack_require__(156).parseType;
  VERSION = '0.3.0';
  parsedTypeParse = function parsedTypeParse(parsedType, string, options) {
	options == null && (options = {});
	options.explicit == null && (options.explicit = false);
	options.customTypes == null && (options.customTypes = {});
	return cast(parseString(parsedType, string, options), parsedType, options);
  };
  parse = function parse(type, string, options) {
	return parsedTypeParse(parseType(type), string, options);
  };
  module.exports = {
	VERSION: VERSION,
	parse: parse,
	parsedTypeParse: parsedTypeParse
  };
}).call(undefined);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function () {
  var reject, special, tokenRegex;
  reject = __webpack_require__(155).reject;
  function consumeOp(tokens, op) {
	if (tokens[0] === op) {
			return tokens.shift();
	} else {
			throw new Error("Expected '" + op + "', but got '" + tokens[0] + "' instead in " + JSON.stringify(tokens) + ".");
	}
  }
  function maybeConsumeOp(tokens, op) {
	if (tokens[0] === op) {
			return tokens.shift();
	}
  }
  function consumeList(tokens, arg$, hasDelimiters) {
	var open, close, result, untilTest;
	open = arg$[0], close = arg$[1];
	if (hasDelimiters) {
			consumeOp(tokens, open);
	}
	result = [];
	untilTest = "," + (hasDelimiters ? close : '');
	while (tokens.length && hasDelimiters && tokens[0] !== close) {
			result.push(consumeElement(tokens, untilTest));
			maybeConsumeOp(tokens, ',');
	}
	if (hasDelimiters) {
			consumeOp(tokens, close);
	}
	return result;
  }
  function consumeArray(tokens, hasDelimiters) {
	return consumeList(tokens, ['[', ']'], hasDelimiters);
  }
  function consumeTuple(tokens, hasDelimiters) {
	return consumeList(tokens, ['(', ')'], hasDelimiters);
  }
  function consumeFields(tokens, hasDelimiters) {
	var result, untilTest, key;
	if (hasDelimiters) {
			consumeOp(tokens, '{');
	}
	result = {};
	untilTest = "," + (hasDelimiters ? '}' : '');
	while (tokens.length && (!hasDelimiters || tokens[0] !== '}')) {
			key = consumeValue(tokens, ':');
			consumeOp(tokens, ':');
			result[key] = consumeElement(tokens, untilTest);
			maybeConsumeOp(tokens, ',');
	}
	if (hasDelimiters) {
			consumeOp(tokens, '}');
	}
	return result;
  }
  function consumeValue(tokens, untilTest) {
	var out;
	untilTest == null && (untilTest = '');
	out = '';
	while (tokens.length && -1 === untilTest.indexOf(tokens[0])) {
			out += tokens.shift();
	}
	return out;
  }
  function consumeElement(tokens, untilTest) {
	switch (tokens[0]) {
			case '[':
		return consumeArray(tokens, true);
			case '(':
		return consumeTuple(tokens, true);
			case '{':
		return consumeFields(tokens, true);
			default:
		return consumeValue(tokens, untilTest);
	}
  }
  function consumeTopLevel(tokens, types, options) {
	var ref$, type, structure, origTokens, result, finalResult, x$, y$;
	ref$ = types[0], type = ref$.type, structure = ref$.structure;
	origTokens = tokens.concat();
	if (!options.explicit && types.length === 1 && (!type && structure || type === 'Array' || type === 'Object')) {
			result = structure === 'array' || type === 'Array' ? consumeArray(tokens, tokens[0] === '[') : structure === 'tuple' ? consumeTuple(tokens, tokens[0] === '(') : consumeFields(tokens, tokens[0] === '{');
			finalResult = tokens.length ? consumeElement(structure === 'array' || type === 'Array' ? (x$ = origTokens, x$.unshift('['), x$.push(']'), x$) : (y$ = origTokens, y$.unshift('('), y$.push(')'), y$)) : result;
	} else {
			finalResult = consumeElement(tokens);
	}
	return finalResult;
  }
  special = /\[\]\(\)}{:,/.source;
  tokenRegex = RegExp('("(?:\\\\"|[^"])*")|(\'(?:\\\\\'|[^\'])*\')|(/(?:\\\\/|[^/])*/[a-zA-Z]*)|(#.*#)|([' + special + '])|([^\\s' + special + '](?:\\s*[^\\s' + special + ']+)*)|\\s*');
  module.exports = function (types, string, options) {
	var tokens, node;
	options == null && (options = {});
	if (!options.explicit && types.length === 1 && types[0].type === 'String') {
			return "'" + string.replace(/\\'/g, "\\\\'") + "'";
	}
	tokens = reject(not$, string.split(tokenRegex));
	node = consumeTopLevel(tokens, types, options);
	if (!node) {
			throw new Error("Error parsing '" + string + "'.");
	}
	return node;
  };
  function not$(x) {
	return !x;
  }
}).call(undefined);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var apply,
	curry,
	flip,
	fix,
	over,
	memoize,
	slice$ = [].slice,
	toString$ = {}.toString;
apply = curry$(function (f, list) {
  return f.apply(null, list);
});
curry = function curry(f) {
  return curry$(f);
};
flip = curry$(function (f, x, y) {
  return f(y, x);
});
fix = function fix(f) {
  return function (g) {
	return function () {
			return f(g(g)).apply(null, arguments);
	};
  }(function (g) {
	return function () {
			return f(g(g)).apply(null, arguments);
	};
  });
};
over = curry$(function (f, g, x, y) {
  return f(g(x), g(y));
});
memoize = function memoize(f) {
  var memo;
  memo = {};
  return function () {
	var args, key, arg;
	args = slice$.call(arguments);
	key = function () {
			var i$,
					ref$,
					len$,
					results$ = [];
			for (i$ = 0, len$ = (ref$ = args).length; i$ < len$; ++i$) {
		arg = ref$[i$];
		results$.push(arg + toString$.call(arg).slice(8, -1));
			}
			return results$;
	}().join('');
	return memo[key] = key in memo ? memo[key] : f.apply(null, args);
  };
};
module.exports = {
  curry: curry,
  flip: flip,
  fix: fix,
  apply: apply,
  over: over,
  memoize: memoize
};
function curry$(f, bound) {
  var context,
			_curry = function _curry(args) {
	return f.length > 1 ? function () {
			var params = args ? args.concat() : [];
			context = bound ? context || this : this;
			return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);
	} : f;
  };
  return _curry();
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var each,
	map,
	compact,
	filter,
	reject,
	partition,
	find,
	head,
	first,
	tail,
	last,
	initial,
	empty,
	reverse,
	unique,
	uniqueBy,
	fold,
	foldl,
	fold1,
	foldl1,
	foldr,
	foldr1,
	unfoldr,
	concat,
	concatMap,
	_flatten,
	difference,
	intersection,
	union,
	countBy,
	groupBy,
	andList,
	orList,
	any,
	all,
	sort,
	sortWith,
	sortBy,
	sum,
	product,
	mean,
	average,
	maximum,
	minimum,
	maximumBy,
	minimumBy,
	scan,
	scanl,
	scan1,
	scanl1,
	scanr,
	scanr1,
	slice,
	take,
	drop,
	splitAt,
	takeWhile,
	dropWhile,
	span,
	breakList,
	zip,
	zipWith,
	zipAll,
	zipAllWith,
	at,
	elemIndex,
	elemIndices,
	findIndex,
	findIndices,
	toString$ = {}.toString,
	slice$ = [].slice;
each = curry$(function (f, xs) {
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	f(x);
  }
  return xs;
});
map = curry$(function (f, xs) {
  var i$,
			len$,
			x,
			results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	results$.push(f(x));
  }
  return results$;
});
compact = function compact(xs) {
  var i$,
			len$,
			x,
			results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	if (x) {
			results$.push(x);
	}
  }
  return results$;
};
filter = curry$(function (f, xs) {
  var i$,
			len$,
			x,
			results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	if (f(x)) {
			results$.push(x);
	}
  }
  return results$;
});
reject = curry$(function (f, xs) {
  var i$,
			len$,
			x,
			results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	if (!f(x)) {
			results$.push(x);
	}
  }
  return results$;
});
partition = curry$(function (f, xs) {
  var passed, failed, i$, len$, x;
  passed = [];
  failed = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	(f(x) ? passed : failed).push(x);
  }
  return [passed, failed];
});
find = curry$(function (f, xs) {
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	if (f(x)) {
			return x;
	}
  }
});
head = first = function first(xs) {
  return xs[0];
};
tail = function tail(xs) {
  if (!xs.length) {
	return;
  }
  return xs.slice(1);
};
last = function last(xs) {
  return xs[xs.length - 1];
};
initial = function initial(xs) {
  if (!xs.length) {
	return;
  }
  return xs.slice(0, -1);
};
empty = function empty(xs) {
  return !xs.length;
};
reverse = function reverse(xs) {
  return xs.concat().reverse();
};
unique = function unique(xs) {
  var result, i$, len$, x;
  result = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	if (!in$(x, result)) {
			result.push(x);
	}
  }
  return result;
};
uniqueBy = curry$(function (f, xs) {
  var seen,
			i$,
			len$,
			x,
			val,
			results$ = [];
  seen = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	val = f(x);
	if (in$(val, seen)) {
			continue;
	}
	seen.push(val);
	results$.push(x);
  }
  return results$;
});
fold = foldl = curry$(function (f, memo, xs) {
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	memo = f(memo, x);
  }
  return memo;
});
fold1 = foldl1 = curry$(function (f, xs) {
  return fold(f, xs[0], xs.slice(1));
});
foldr = curry$(function (f, memo, xs) {
  var i$, x;
  for (i$ = xs.length - 1; i$ >= 0; --i$) {
	x = xs[i$];
	memo = f(x, memo);
  }
  return memo;
});
foldr1 = curry$(function (f, xs) {
  return foldr(f, xs[xs.length - 1], xs.slice(0, -1));
});
unfoldr = curry$(function (f, b) {
  var result, x, that;
  result = [];
  x = b;
  while ((that = f(x)) != null) {
	result.push(that[0]);
	x = that[1];
  }
  return result;
});
concat = function concat(xss) {
  return [].concat.apply([], xss);
};
concatMap = curry$(function (f, xs) {
  var x;
  return [].concat.apply([], function () {
	var i$,
		ref$,
		len$,
		results$ = [];
	for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
			x = ref$[i$];
			results$.push(f(x));
	}
	return results$;
  }());
});
_flatten = function flatten(xs) {
  var x;
  return [].concat.apply([], function () {
	var i$,
		ref$,
		len$,
		results$ = [];
	for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
			x = ref$[i$];
			if (toString$.call(x).slice(8, -1) === 'Array') {
		results$.push(_flatten(x));
			} else {
		results$.push(x);
			}
	}
	return results$;
  }());
};
difference = function difference(xs) {
  var yss, results, i$, len$, x, j$, len1$, ys;
  yss = slice$.call(arguments, 1);
  results = [];
  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
			ys = yss[j$];
			if (in$(x, ys)) {
		continue outer;
			}
	}
	results.push(x);
  }
  return results;
};
intersection = function intersection(xs) {
  var yss, results, i$, len$, x, j$, len1$, ys;
  yss = slice$.call(arguments, 1);
  results = [];
  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
			ys = yss[j$];
			if (!in$(x, ys)) {
		continue outer;
			}
	}
	results.push(x);
  }
  return results;
};
union = function union() {
  var xss, results, i$, len$, xs, j$, len1$, x;
  xss = slice$.call(arguments);
  results = [];
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
	xs = xss[i$];
	for (j$ = 0, len1$ = xs.length; j$ < len1$; ++j$) {
			x = xs[j$];
			if (!in$(x, results)) {
		results.push(x);
			}
	}
  }
  return results;
};
countBy = curry$(function (f, xs) {
  var results, i$, len$, x, key;
  results = {};
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	key = f(x);
	if (key in results) {
			results[key] += 1;
	} else {
			results[key] = 1;
	}
  }
  return results;
});
groupBy = curry$(function (f, xs) {
  var results, i$, len$, x, key;
  results = {};
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	key = f(x);
	if (key in results) {
			results[key].push(x);
	} else {
			results[key] = [x];
	}
  }
  return results;
});
andList = function andList(xs) {
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	if (!x) {
			return false;
	}
  }
  return true;
};
orList = function orList(xs) {
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	if (x) {
			return true;
	}
  }
  return false;
};
any = curry$(function (f, xs) {
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	if (f(x)) {
			return true;
	}
  }
  return false;
});
all = curry$(function (f, xs) {
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	if (!f(x)) {
			return false;
	}
  }
  return true;
});
sort = function sort(xs) {
  return xs.concat().sort(function (x, y) {
	if (x > y) {
			return 1;
	} else if (x < y) {
			return -1;
	} else {
			return 0;
	}
  });
};
sortWith = curry$(function (f, xs) {
  return xs.concat().sort(f);
});
sortBy = curry$(function (f, xs) {
  return xs.concat().sort(function (x, y) {
	if (f(x) > f(y)) {
			return 1;
	} else if (f(x) < f(y)) {
			return -1;
	} else {
			return 0;
	}
  });
});
sum = function sum(xs) {
  var result, i$, len$, x;
  result = 0;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	result += x;
  }
  return result;
};
product = function product(xs) {
  var result, i$, len$, x;
  result = 1;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	result *= x;
  }
  return result;
};
mean = average = function average(xs) {
  var sum, i$, len$, x;
  sum = 0;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	x = xs[i$];
	sum += x;
  }
  return sum / xs.length;
};
maximum = function maximum(xs) {
  var max, i$, ref$, len$, x;
  max = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
	x = ref$[i$];
	if (x > max) {
			max = x;
	}
  }
  return max;
};
minimum = function minimum(xs) {
  var min, i$, ref$, len$, x;
  min = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
	x = ref$[i$];
	if (x < min) {
			min = x;
	}
  }
  return min;
};
maximumBy = curry$(function (f, xs) {
  var max, i$, ref$, len$, x;
  max = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
	x = ref$[i$];
	if (f(x) > f(max)) {
			max = x;
	}
  }
  return max;
});
minimumBy = curry$(function (f, xs) {
  var min, i$, ref$, len$, x;
  min = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
	x = ref$[i$];
	if (f(x) < f(min)) {
			min = x;
	}
  }
  return min;
});
scan = scanl = curry$(function (f, memo, xs) {
  var last, x;
  last = memo;
  return [memo].concat(function () {
	var i$,
		ref$,
		len$,
		results$ = [];
	for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
			x = ref$[i$];
			results$.push(last = f(last, x));
	}
	return results$;
  }());
});
scan1 = scanl1 = curry$(function (f, xs) {
  if (!xs.length) {
	return;
  }
  return scan(f, xs[0], xs.slice(1));
});
scanr = curry$(function (f, memo, xs) {
  xs = xs.concat().reverse();
  return scan(f, memo, xs).reverse();
});
scanr1 = curry$(function (f, xs) {
  if (!xs.length) {
	return;
  }
  xs = xs.concat().reverse();
  return scan(f, xs[0], xs.slice(1)).reverse();
});
slice = curry$(function (x, y, xs) {
  return xs.slice(x, y);
});
take = curry$(function (n, xs) {
  if (n <= 0) {
	return xs.slice(0, 0);
  } else {
	return xs.slice(0, n);
  }
});
drop = curry$(function (n, xs) {
  if (n <= 0) {
	return xs;
  } else {
	return xs.slice(n);
  }
});
splitAt = curry$(function (n, xs) {
  return [take(n, xs), drop(n, xs)];
});
takeWhile = curry$(function (p, xs) {
  var len, i;
  len = xs.length;
  if (!len) {
	return xs;
  }
  i = 0;
  while (i < len && p(xs[i])) {
	i += 1;
  }
  return xs.slice(0, i);
});
dropWhile = curry$(function (p, xs) {
  var len, i;
  len = xs.length;
  if (!len) {
	return xs;
  }
  i = 0;
  while (i < len && p(xs[i])) {
	i += 1;
  }
  return xs.slice(i);
});
span = curry$(function (p, xs) {
  return [takeWhile(p, xs), dropWhile(p, xs)];
});
breakList = curry$(function (p, xs) {
  return span(compose$(p, not$), xs);
});
zip = curry$(function (xs, ys) {
  var result, len, i$, len$, i, x;
  result = [];
  len = ys.length;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	i = i$;
	x = xs[i$];
	if (i === len) {
			break;
	}
	result.push([x, ys[i]]);
  }
  return result;
});
zipWith = curry$(function (f, xs, ys) {
  var result, len, i$, len$, i, x;
  result = [];
  len = ys.length;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	i = i$;
	x = xs[i$];
	if (i === len) {
			break;
	}
	result.push(f(x, ys[i]));
  }
  return result;
});
zipAll = function zipAll() {
  var xss,
			minLength,
			i$,
			len$,
			xs,
			ref$,
			i,
			lresult$,
			j$,
			results$ = [];
  xss = slice$.call(arguments);
  minLength = undefined;
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
	xs = xss[i$];
	minLength <= (ref$ = xs.length) || (minLength = ref$);
  }
  for (i$ = 0; i$ < minLength; ++i$) {
	i = i$;
	lresult$ = [];
	for (j$ = 0, len$ = xss.length; j$ < len$; ++j$) {
			xs = xss[j$];
			lresult$.push(xs[i]);
	}
	results$.push(lresult$);
  }
  return results$;
};
zipAllWith = function zipAllWith(f) {
  var xss,
			minLength,
			i$,
			len$,
			xs,
			ref$,
			i,
			results$ = [];
  xss = slice$.call(arguments, 1);
  minLength = undefined;
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
	xs = xss[i$];
	minLength <= (ref$ = xs.length) || (minLength = ref$);
  }
  for (i$ = 0; i$ < minLength; ++i$) {
	i = i$;
	results$.push(f.apply(null, fn$()));
  }
  return results$;
  function fn$() {
	var i$,
		ref$,
		len$,
		results$ = [];
	for (i$ = 0, len$ = (ref$ = xss).length; i$ < len$; ++i$) {
			xs = ref$[i$];
			results$.push(xs[i]);
	}
	return results$;
  }
};
at = curry$(function (n, xs) {
  if (n < 0) {
	return xs[xs.length + n];
  } else {
	return xs[n];
  }
});
elemIndex = curry$(function (el, xs) {
  var i$, len$, i, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	i = i$;
	x = xs[i$];
	if (x === el) {
			return i;
	}
  }
});
elemIndices = curry$(function (el, xs) {
  var i$,
			len$,
			i,
			x,
			results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	i = i$;
	x = xs[i$];
	if (x === el) {
			results$.push(i);
	}
  }
  return results$;
});
findIndex = curry$(function (f, xs) {
  var i$, len$, i, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	i = i$;
	x = xs[i$];
	if (f(x)) {
			return i;
	}
  }
});
findIndices = curry$(function (f, xs) {
  var i$,
			len$,
			i,
			x,
			results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	i = i$;
	x = xs[i$];
	if (f(x)) {
			results$.push(i);
	}
  }
  return results$;
});
module.exports = {
  each: each,
  map: map,
  filter: filter,
  compact: compact,
  reject: reject,
  partition: partition,
  find: find,
  head: head,
  first: first,
  tail: tail,
  last: last,
  initial: initial,
  empty: empty,
  reverse: reverse,
  difference: difference,
  intersection: intersection,
  union: union,
  countBy: countBy,
  groupBy: groupBy,
  fold: fold,
  fold1: fold1,
  foldl: foldl,
  foldl1: foldl1,
  foldr: foldr,
  foldr1: foldr1,
  unfoldr: unfoldr,
  andList: andList,
  orList: orList,
  any: any,
  all: all,
  unique: unique,
  uniqueBy: uniqueBy,
  sort: sort,
  sortWith: sortWith,
  sortBy: sortBy,
  sum: sum,
  product: product,
  mean: mean,
  average: average,
  concat: concat,
  concatMap: concatMap,
  flatten: _flatten,
  maximum: maximum,
  minimum: minimum,
  maximumBy: maximumBy,
  minimumBy: minimumBy,
  scan: scan,
  scan1: scan1,
  scanl: scanl,
  scanl1: scanl1,
  scanr: scanr,
  scanr1: scanr1,
  slice: slice,
  take: take,
  drop: drop,
  splitAt: splitAt,
  takeWhile: takeWhile,
  dropWhile: dropWhile,
  span: span,
  breakList: breakList,
  zip: zip,
  zipWith: zipWith,
  zipAll: zipAll,
  zipAllWith: zipAllWith,
  at: at,
  elemIndex: elemIndex,
  elemIndices: elemIndices,
  findIndex: findIndex,
  findIndices: findIndices
};
function curry$(f, bound) {
  var context,
			_curry = function _curry(args) {
	return f.length > 1 ? function () {
			var params = args ? args.concat() : [];
			context = bound ? context || this : this;
			return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);
	} : f;
  };
  return _curry();
}
function in$(x, xs) {
  var i = -1,
			l = xs.length >>> 0;
  while (++i < l) {
	if (x === xs[i]) return true;
  }return false;
}
function compose$() {
  var functions = arguments;
  return function () {
	var i, result;
	result = functions[0].apply(this, arguments);
	for (i = 1; i < functions.length; ++i) {
			result = functions[i](result);
	}
	return result;
  };
}
function not$(x) {
  return !x;
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var values, keys, pairsToObj, objToPairs, listsToObj, objToLists, empty, each, map, compact, filter, reject, partition, find;
values = function values(object) {
  var i$,
			x,
			results$ = [];
  for (i$ in object) {
	x = object[i$];
	results$.push(x);
  }
  return results$;
};
keys = function keys(object) {
  var x,
			results$ = [];
  for (x in object) {
	results$.push(x);
  }
  return results$;
};
pairsToObj = function pairsToObj(object) {
  var i$,
			len$,
			x,
			resultObj$ = {};
  for (i$ = 0, len$ = object.length; i$ < len$; ++i$) {
	x = object[i$];
	resultObj$[x[0]] = x[1];
  }
  return resultObj$;
};
objToPairs = function objToPairs(object) {
  var key,
			value,
			results$ = [];
  for (key in object) {
	value = object[key];
	results$.push([key, value]);
  }
  return results$;
};
listsToObj = curry$(function (keys, values) {
  var i$,
			len$,
			i,
			key,
			resultObj$ = {};
  for (i$ = 0, len$ = keys.length; i$ < len$; ++i$) {
	i = i$;
	key = keys[i$];
	resultObj$[key] = values[i];
  }
  return resultObj$;
});
objToLists = function objToLists(object) {
  var keys, values, key, value;
  keys = [];
  values = [];
  for (key in object) {
	value = object[key];
	keys.push(key);
	values.push(value);
  }
  return [keys, values];
};
empty = function empty(object) {
  var x;
  for (x in object) {
	return false;
  }
  return true;
};
each = curry$(function (f, object) {
  var i$, x;
  for (i$ in object) {
	x = object[i$];
	f(x);
  }
  return object;
});
map = curry$(function (f, object) {
  var k,
			x,
			resultObj$ = {};
  for (k in object) {
	x = object[k];
	resultObj$[k] = f(x);
  }
  return resultObj$;
});
compact = function compact(object) {
  var k,
			x,
			resultObj$ = {};
  for (k in object) {
	x = object[k];
	if (x) {
			resultObj$[k] = x;
	}
  }
  return resultObj$;
};
filter = curry$(function (f, object) {
  var k,
			x,
			resultObj$ = {};
  for (k in object) {
	x = object[k];
	if (f(x)) {
			resultObj$[k] = x;
	}
  }
  return resultObj$;
});
reject = curry$(function (f, object) {
  var k,
			x,
			resultObj$ = {};
  for (k in object) {
	x = object[k];
	if (!f(x)) {
			resultObj$[k] = x;
	}
  }
  return resultObj$;
});
partition = curry$(function (f, object) {
  var passed, failed, k, x;
  passed = {};
  failed = {};
  for (k in object) {
	x = object[k];
	(f(x) ? passed : failed)[k] = x;
  }
  return [passed, failed];
});
find = curry$(function (f, object) {
  var i$, x;
  for (i$ in object) {
	x = object[i$];
	if (f(x)) {
			return x;
	}
  }
});
module.exports = {
  values: values,
  keys: keys,
  pairsToObj: pairsToObj,
  objToPairs: objToPairs,
  listsToObj: listsToObj,
  objToLists: objToLists,
  empty: empty,
  each: each,
  map: map,
  filter: filter,
  compact: compact,
  reject: reject,
  partition: partition,
  find: find
};
function curry$(f, bound) {
  var context,
			_curry = function _curry(args) {
	return f.length > 1 ? function () {
			var params = args ? args.concat() : [];
			context = bound ? context || this : this;
			return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);
	} : f;
  };
  return _curry();
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var split, join, lines, unlines, words, unwords, chars, unchars, reverse, repeat, capitalize, camelize, dasherize;
split = curry$(function (sep, str) {
  return str.split(sep);
});
join = curry$(function (sep, xs) {
  return xs.join(sep);
});
lines = function lines(str) {
  if (!str.length) {
	return [];
  }
  return str.split('\n');
};
unlines = function unlines(it) {
  return it.join('\n');
};
words = function words(str) {
  if (!str.length) {
	return [];
  }
  return str.split(/[ ]+/);
};
unwords = function unwords(it) {
  return it.join(' ');
};
chars = function chars(it) {
  return it.split('');
};
unchars = function unchars(it) {
  return it.join('');
};
reverse = function reverse(str) {
  return str.split('').reverse().join('');
};
repeat = curry$(function (n, str) {
  var result, i$;
  result = '';
  for (i$ = 0; i$ < n; ++i$) {
	result += str;
  }
  return result;
});
capitalize = function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
};
camelize = function camelize(it) {
  return it.replace(/[-_]+(.)?/g, function (arg$, c) {
	return (c != null ? c : '').toUpperCase();
  });
};
dasherize = function dasherize(str) {
  return str.replace(/([^-A-Z])([A-Z]+)/g, function (arg$, lower, upper) {
	return lower + "-" + (upper.length > 1 ? upper : upper.toLowerCase());
  }).replace(/^([A-Z]+)/, function (arg$, upper) {
	if (upper.length > 1) {
			return upper + "-";
	} else {
			return upper.toLowerCase();
	}
  });
};
module.exports = {
  split: split,
  join: join,
  lines: lines,
  unlines: unlines,
  words: words,
  unwords: unwords,
  chars: chars,
  unchars: unchars,
  reverse: reverse,
  repeat: repeat,
  capitalize: capitalize,
  camelize: camelize,
  dasherize: dasherize
};
function curry$(f, bound) {
  var context,
			_curry = function _curry(args) {
	return f.length > 1 ? function () {
			var params = args ? args.concat() : [];
			context = bound ? context || this : this;
			return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);
	} : f;
  };
  return _curry();
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var max, min, negate, abs, signum, quot, rem, div, mod, recip, pi, tau, exp, sqrt, ln, pow, sin, tan, cos, asin, acos, atan, atan2, truncate, round, ceiling, floor, isItNaN, even, odd, gcd, lcm;
max = curry$(function (x$, y$) {
  return x$ > y$ ? x$ : y$;
});
min = curry$(function (x$, y$) {
  return x$ < y$ ? x$ : y$;
});
negate = function negate(x) {
  return -x;
};
abs = Math.abs;
signum = function signum(x) {
  if (x < 0) {
	return -1;
  } else if (x > 0) {
	return 1;
  } else {
	return 0;
  }
};
quot = curry$(function (x, y) {
  return ~~(x / y);
});
rem = curry$(function (x$, y$) {
  return x$ % y$;
});
div = curry$(function (x, y) {
  return Math.floor(x / y);
});
mod = curry$(function (x$, y$) {
  var ref$;
  return (x$ % (ref$ = y$) + ref$) % ref$;
});
recip = function recip(it) {
  return 1 / it;
};
pi = Math.PI;
tau = pi * 2;
exp = Math.exp;
sqrt = Math.sqrt;
ln = Math.log;
pow = curry$(function (x$, y$) {
  return Math.pow(x$, y$);
});
sin = Math.sin;
tan = Math.tan;
cos = Math.cos;
asin = Math.asin;
acos = Math.acos;
atan = Math.atan;
atan2 = curry$(function (x, y) {
  return Math.atan2(x, y);
});
truncate = function truncate(x) {
  return ~~x;
};
round = Math.round;
ceiling = Math.ceil;
floor = Math.floor;
isItNaN = function isItNaN(x) {
  return x !== x;
};
even = function even(x) {
  return x % 2 === 0;
};
odd = function odd(x) {
  return x % 2 !== 0;
};
gcd = curry$(function (x, y) {
  var z;
  x = Math.abs(x);
  y = Math.abs(y);
  while (y !== 0) {
	z = x % y;
	x = y;
	y = z;
  }
  return x;
});
lcm = curry$(function (x, y) {
  return Math.abs(Math.floor(x / gcd(x, y) * y));
});
module.exports = {
  max: max,
  min: min,
  negate: negate,
  abs: abs,
  signum: signum,
  quot: quot,
  rem: rem,
  div: div,
  mod: mod,
  recip: recip,
  pi: pi,
  tau: tau,
  exp: exp,
  sqrt: sqrt,
  ln: ln,
  pow: pow,
  sin: sin,
  tan: tan,
  cos: cos,
  acos: acos,
  asin: asin,
  atan: atan,
  atan2: atan2,
  truncate: truncate,
  round: round,
  ceiling: ceiling,
  floor: floor,
  isItNaN: isItNaN,
  even: even,
  odd: odd,
  gcd: gcd,
  lcm: lcm
};
function curry$(f, bound) {
  var context,
			_curry = function _curry(args) {
	return f.length > 1 ? function () {
			var params = args ? args.concat() : [];
			context = bound ? context || this : this;
			return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);
	} : f;
  };
  return _curry();
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function () {
  var parsedTypeCheck,
			types,
			toString$ = {}.toString;
  parsedTypeCheck = __webpack_require__(156).parsedTypeCheck;
  types = {
	'*': function _(value, options) {
			switch (toString$.call(value).slice(8, -1)) {
		case 'Array':
					return typeCast(value, {
			type: 'Array'
					}, options);
		case 'Object':
					return typeCast(value, {
			type: 'Object'
					}, options);
		default:
					return {
			type: 'Just',
			value: typesCast(value, [{
							type: 'Undefined'
			}, {
							type: 'Null'
			}, {
							type: 'NaN'
			}, {
							type: 'Boolean'
			}, {
							type: 'Number'
			}, {
							type: 'Date'
			}, {
							type: 'RegExp'
			}, {
							type: 'Array'
			}, {
							type: 'Object'
			}, {
							type: 'String'
			}], (options.explicit = true, options))
					};
			}
	},
	Undefined: function Undefined(it) {
			if (it === 'undefined' || it === void 8) {
		return {
					type: 'Just',
					value: void 8
		};
			} else {
		return {
					type: 'Nothing'
		};
			}
	},
	Null: function Null(it) {
			if (it === 'null') {
		return {
					type: 'Just',
					value: null
		};
			} else {
		return {
					type: 'Nothing'
		};
			}
	},
	NaN: function (_NaN) {
			function NaN(_x) {
		return _NaN.apply(this, arguments);
			}

			NaN.toString = function () {
		return _NaN.toString();
			};

			return NaN;
	}(function (it) {
			if (it === 'NaN') {
		return {
					type: 'Just',
					value: NaN
		};
			} else {
		return {
					type: 'Nothing'
		};
			}
	}),
	Boolean: function Boolean(it) {
			if (it === 'true') {
		return {
					type: 'Just',
					value: true
		};
			} else if (it === 'false') {
		return {
					type: 'Just',
					value: false
		};
			} else {
		return {
					type: 'Nothing'
		};
			}
	},
	Number: function Number(it) {
			return {
		type: 'Just',
		value: +it
			};
	},
	Int: function Int(it) {
			return {
		type: 'Just',
		value: +it
			};
	},
	Float: function Float(it) {
			return {
		type: 'Just',
		value: +it
			};
	},
	Date: function (_Date) {
			function Date(_x2, _x3) {
		return _Date.apply(this, arguments);
			}

			Date.toString = function () {
		return _Date.toString();
			};

			return Date;
	}(function (value, options) {
			var that;
			if (that = /^\#([\s\S]*)\#$/.exec(value)) {
		return {
					type: 'Just',
					value: new Date(+that[1] || that[1])
		};
			} else if (options.explicit) {
		return {
					type: 'Nothing'
		};
			} else {
		return {
					type: 'Just',
					value: new Date(+value || value)
		};
			}
	}),
	RegExp: function (_RegExp) {
			function RegExp(_x4, _x5) {
		return _RegExp.apply(this, arguments);
			}

			RegExp.toString = function () {
		return _RegExp.toString();
			};

			return RegExp;
	}(function (value, options) {
			var that;
			if (that = /^\/([\s\S]*)\/([gimy]*)$/.exec(value)) {
		return {
					type: 'Just',
					value: new RegExp(that[1], that[2])
		};
			} else if (options.explicit) {
		return {
					type: 'Nothing'
		};
			} else {
		return {
					type: 'Just',
					value: new RegExp(value)
		};
			}
	}),
	Array: function Array(value, options) {
			return castArray(value, {
		of: [{
					type: '*'
		}]
			}, options);
	},
	Object: function Object(value, options) {
			return castFields(value, {
		of: {}
			}, options);
	},
	String: function String(it) {
			var that;
			if (toString$.call(it).slice(8, -1) !== 'String') {
		return {
					type: 'Nothing'
		};
			}
			if (that = it.match(/^'([\s\S]*)'$/)) {
		return {
					type: 'Just',
					value: that[1].replace(/\\'/g, "'")
		};
			} else if (that = it.match(/^"([\s\S]*)"$/)) {
		return {
					type: 'Just',
					value: that[1].replace(/\\"/g, '"')
		};
			} else {
		return {
					type: 'Just',
					value: it
		};
			}
	}
  };
  function castArray(node, type, options) {
	var typeOf, element;
	if (toString$.call(node).slice(8, -1) !== 'Array') {
			return {
		type: 'Nothing'
			};
	}
	typeOf = type.of;
	return {
			type: 'Just',
			value: function () {
		var i$,
			ref$,
			len$,
			results$ = [];
		for (i$ = 0, len$ = (ref$ = node).length; i$ < len$; ++i$) {
					element = ref$[i$];
					results$.push(typesCast(element, typeOf, options));
		}
		return results$;
			}()
	};
  }
  function castTuple(node, type, options) {
	var result, i, i$, ref$, len$, types, cast;
	if (toString$.call(node).slice(8, -1) !== 'Array') {
			return {
		type: 'Nothing'
			};
	}
	result = [];
	i = 0;
	for (i$ = 0, len$ = (ref$ = type.of).length; i$ < len$; ++i$) {
			types = ref$[i$];
			cast = typesCast(node[i], types, options);
			if (toString$.call(cast).slice(8, -1) !== 'Undefined') {
		result.push(cast);
			}
			i++;
	}
	if (node.length <= i) {
			return {
		type: 'Just',
		value: result
			};
	} else {
			return {
		type: 'Nothing'
			};
	}
  }
  function castFields(node, type, options) {
	var typeOf, key, value;
	if (toString$.call(node).slice(8, -1) !== 'Object') {
			return {
		type: 'Nothing'
			};
	}
	typeOf = type.of;
	return {
			type: 'Just',
			value: function () {
		var ref$,
			resultObj$ = {};
		for (key in ref$ = node) {
					value = ref$[key];
					resultObj$[typesCast(key, [{
			type: 'String'
					}], options)] = typesCast(value, typeOf[key] || [{
			type: '*'
					}], options);
		}
		return resultObj$;
			}()
	};
  }
  function typeCast(node, typeObj, options) {
	var type, structure, castFunc, ref$;
	type = typeObj.type, structure = typeObj.structure;
	if (type) {
			castFunc = ((ref$ = options.customTypes[type]) != null ? ref$.cast : void 8) || types[type];
			if (!castFunc) {
		throw new Error("Type not defined: " + type + ".");
			}
			return castFunc(node, options, typesCast);
	} else {
			switch (structure) {
		case 'array':
					return castArray(node, typeObj, options);
		case 'tuple':
					return castTuple(node, typeObj, options);
		case 'fields':
					return castFields(node, typeObj, options);
			}
	}
  }
  function typesCast(node, types, options) {
	var i$, len$, type, ref$, valueType, value;
	for (i$ = 0, len$ = types.length; i$ < len$; ++i$) {
			type = types[i$];
			ref$ = typeCast(node, type, options), valueType = ref$.type, value = ref$.value;
			if (valueType === 'Nothing') {
		continue;
			}
			if (parsedTypeCheck([type], value, {
		customTypes: options.customTypes
			})) {
		return value;
			}
	}
	throw new Error("Value " + JSON.stringify(node) + " does not type check against " + JSON.stringify(types) + ".");
  }
  module.exports = typesCast;
}).call(undefined);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function () {
  var identifierRegex, tokenRegex;
  identifierRegex = /[\$\w]+/;
  function peek(tokens) {
	var token;
	token = tokens[0];
	if (token == null) {
			throw new Error('Unexpected end of input.');
	}
	return token;
  }
  function consumeIdent(tokens) {
	var token;
	token = peek(tokens);
	if (!identifierRegex.test(token)) {
			throw new Error("Expected text, got '" + token + "' instead.");
	}
	return tokens.shift();
  }
  function consumeOp(tokens, op) {
	var token;
	token = peek(tokens);
	if (token !== op) {
			throw new Error("Expected '" + op + "', got '" + token + "' instead.");
	}
	return tokens.shift();
  }
  function maybeConsumeOp(tokens, op) {
	var token;
	token = tokens[0];
	if (token === op) {
			return tokens.shift();
	} else {
			return null;
	}
  }
  function consumeArray(tokens) {
	var types;
	consumeOp(tokens, '[');
	if (peek(tokens) === ']') {
			throw new Error("Must specify type of Array - eg. [Type], got [] instead.");
	}
	types = consumeTypes(tokens);
	consumeOp(tokens, ']');
	return {
			structure: 'array',
			of: types
	};
  }
  function consumeTuple(tokens) {
	var components;
	components = [];
	consumeOp(tokens, '(');
	if (peek(tokens) === ')') {
			throw new Error("Tuple must be of at least length 1 - eg. (Type), got () instead.");
	}
	for (;;) {
			components.push(consumeTypes(tokens));
			maybeConsumeOp(tokens, ',');
			if (')' === peek(tokens)) {
		break;
			}
	}
	consumeOp(tokens, ')');
	return {
			structure: 'tuple',
			of: components
	};
  }
  function consumeFields(tokens) {
	var fields, subset, ref$, key, types;
	fields = {};
	consumeOp(tokens, '{');
	subset = false;
	for (;;) {
			if (maybeConsumeOp(tokens, '...')) {
		subset = true;
		break;
			}
			ref$ = consumeField(tokens), key = ref$[0], types = ref$[1];
			fields[key] = types;
			maybeConsumeOp(tokens, ',');
			if ('}' === peek(tokens)) {
		break;
			}
	}
	consumeOp(tokens, '}');
	return {
			structure: 'fields',
			of: fields,
			subset: subset
	};
  }
  function consumeField(tokens) {
	var key, types;
	key = consumeIdent(tokens);
	consumeOp(tokens, ':');
	types = consumeTypes(tokens);
	return [key, types];
  }
  function maybeConsumeStructure(tokens) {
	switch (tokens[0]) {
			case '[':
		return consumeArray(tokens);
			case '(':
		return consumeTuple(tokens);
			case '{':
		return consumeFields(tokens);
	}
  }
  function consumeType(tokens) {
	var token, wildcard, type, structure;
	token = peek(tokens);
	wildcard = token === '*';
	if (wildcard || identifierRegex.test(token)) {
			type = wildcard ? consumeOp(tokens, '*') : consumeIdent(tokens);
			structure = maybeConsumeStructure(tokens);
			if (structure) {
		return structure.type = type, structure;
			} else {
		return {
					type: type
		};
			}
	} else {
			structure = maybeConsumeStructure(tokens);
			if (!structure) {
		throw new Error("Unexpected character: " + token);
			}
			return structure;
	}
  }
  function consumeTypes(tokens) {
	var lookahead, types, typesSoFar, typeObj, type;
	if ('::' === peek(tokens)) {
			throw new Error("No comment before comment separator '::' found.");
	}
	lookahead = tokens[1];
	if (lookahead != null && lookahead === '::') {
			tokens.shift();
			tokens.shift();
	}
	types = [];
	typesSoFar = {};
	if ('Maybe' === peek(tokens)) {
			tokens.shift();
			types = [{
		type: 'Undefined'
			}, {
		type: 'Null'
			}];
			typesSoFar = {
		Undefined: true,
		Null: true
			};
	}
	for (;;) {
			typeObj = consumeType(tokens), type = typeObj.type;
			if (!typesSoFar[type]) {
		types.push(typeObj);
			}
			typesSoFar[type] = true;
			if (!maybeConsumeOp(tokens, '|')) {
		break;
			}
	}
	return types;
  }
  tokenRegex = RegExp('\\.\\.\\.|::|->|' + identifierRegex.source + '|\\S', 'g');
  module.exports = function (input) {
	var tokens, e;
	if (!input.length) {
			throw new Error('No type specified.');
	}
	tokens = input.match(tokenRegex) || [];
	if (in$('->', tokens)) {
			throw new Error("Function types are not supported.\ To validate that something is a function, you may use 'Function'.");
	}
	try {
			return consumeTypes(tokens);
	} catch (e$) {
			e = e$;
			throw new Error(e.message + " - Remaining tokens: " + JSON.stringify(tokens) + " - Initial input: '" + input + "'");
	}
  };
  function in$(x, xs) {
	var i = -1,
		l = xs.length >>> 0;
	while (++i < l) {
			if (x === xs[i]) return true;
	}return false;
  }
}).call(undefined);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function () {
  var ref$,
			any,
			all,
			isItNaN,
			types,
			defaultType,
			customTypes,
			toString$ = {}.toString;
  ref$ = __webpack_require__(155), any = ref$.any, all = ref$.all, isItNaN = ref$.isItNaN;
  types = {
	Number: {
			typeOf: 'Number',
			validate: function validate(it) {
		return !isItNaN(it);
			}
	},
	NaN: {
			typeOf: 'Number',
			validate: isItNaN
	},
	Int: {
			typeOf: 'Number',
			validate: function validate(it) {
		return !isItNaN(it) && it % 1 === 0;
			}
	},
	Float: {
			typeOf: 'Number',
			validate: function validate(it) {
		return !isItNaN(it);
			}
	},
	Date: {
			typeOf: 'Date',
			validate: function validate(it) {
		return !isItNaN(it.getTime());
			}
	}
  };
  defaultType = {
	array: 'Array',
	tuple: 'Array'
  };
  function checkArray(input, type) {
	return all(function (it) {
			return checkMultiple(it, type.of);
	}, input);
  }
  function checkTuple(input, type) {
	var i, i$, ref$, len$, types;
	i = 0;
	for (i$ = 0, len$ = (ref$ = type.of).length; i$ < len$; ++i$) {
			types = ref$[i$];
			if (!checkMultiple(input[i], types)) {
		return false;
			}
			i++;
	}
	return input.length <= i;
  }
  function checkFields(input, type) {
	var inputKeys, numInputKeys, k, numOfKeys, key, ref$, types;
	inputKeys = {};
	numInputKeys = 0;
	for (k in input) {
			inputKeys[k] = true;
			numInputKeys++;
	}
	numOfKeys = 0;
	for (key in ref$ = type.of) {
			types = ref$[key];
			if (!checkMultiple(input[key], types)) {
		return false;
			}
			if (inputKeys[key]) {
		numOfKeys++;
			}
	}
	return type.subset || numInputKeys === numOfKeys;
  }
  function checkStructure(input, type) {
	if (!(input instanceof Object)) {
			return false;
	}
	switch (type.structure) {
			case 'fields':
		return checkFields(input, type);
			case 'array':
		return checkArray(input, type);
			case 'tuple':
		return checkTuple(input, type);
	}
  }
  function check(input, typeObj) {
	var type, structure, setting, that;
	type = typeObj.type, structure = typeObj.structure;
	if (type) {
			if (type === '*') {
		return true;
			}
			setting = customTypes[type] || types[type];
			if (setting) {
		return setting.typeOf === toString$.call(input).slice(8, -1) && setting.validate(input);
			} else {
		return type === toString$.call(input).slice(8, -1) && (!structure || checkStructure(input, typeObj));
			}
	} else if (structure) {
			if (that = defaultType[structure]) {
		if (that !== toString$.call(input).slice(8, -1)) {
					return false;
		}
			}
			return checkStructure(input, typeObj);
	} else {
			throw new Error("No type defined. Input: " + input + ".");
	}
  }
  function checkMultiple(input, types) {
	if (toString$.call(types).slice(8, -1) !== 'Array') {
			throw new Error("Types must be in an array. Input: " + input + ".");
	}
	return any(function (it) {
			return check(input, it);
	}, types);
  }
  module.exports = function (parsedType, input, options) {
	options == null && (options = {});
	customTypes = options.customTypes || {};
	return checkMultiple(input, parsedType);
  };
}).call(undefined);
 }),
 (function(module, exports) {

module.exports = {"type":"Program","body":[],"sourceType":"script","range":[0,0],"loc":{"start":{"line":0,"column":0},"end":{"line":0,"column":0}},"comments":[],"tokens":[]}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function deepFreeze(obj) {
	if (obj === null || (typeof obj === "undefined" ? "undefined" : _typeof(obj)) !== "object") {
		return obj;
	}

	Object.keys(obj).map(function (key) {
		return obj[key];
	}).forEach(deepFreeze);
	return Object.freeze(obj);
}

module.exports = deepFreeze({
	env: {},
	globals: {},
	rules: {},
	settings: {},
	parser: "espree",
	parserOptions: {}
});
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CodePath = __webpack_require__(351),
	CodePathSegment = __webpack_require__(102),
	IdGenerator = __webpack_require__(159),
	debug = __webpack_require__(158),
	astUtils = __webpack_require__(0);
function isCaseNode(node) {
	return Boolean(node.test);
}
function isForkingByTrueOrFalse(node) {
	var parent = node.parent;

	switch (parent.type) {
		case "ConditionalExpression":
		case "IfStatement":
		case "WhileStatement":
		case "DoWhileStatement":
		case "ForStatement":
			return parent.test === node;

		case "LogicalExpression":
			return true;

		default:
			return false;
	}
}
function getBooleanValueIfSimpleConstant(node) {
	if (node.type === "Literal") {
		return Boolean(node.value);
	}
	return void 0;
}
function isIdentifierReference(node) {
	var parent = node.parent;

	switch (parent.type) {
		case "LabeledStatement":
		case "BreakStatement":
		case "ContinueStatement":
		case "ArrayPattern":
		case "RestElement":
		case "ImportSpecifier":
		case "ImportDefaultSpecifier":
		case "ImportNamespaceSpecifier":
		case "CatchClause":
			return false;

		case "FunctionDeclaration":
		case "FunctionExpression":
		case "ArrowFunctionExpression":
		case "ClassDeclaration":
		case "ClassExpression":
		case "VariableDeclarator":
			return parent.id !== node;

		case "Property":
		case "MethodDefinition":
			return parent.key !== node || parent.computed || parent.shorthand;

		case "AssignmentPattern":
			return parent.key !== node;

		default:
			return true;
	}
}
function forwardCurrentToHead(analyzer, node) {
	var codePath = analyzer.codePath;
	var state = CodePath.getState(codePath);
	var currentSegments = state.currentSegments;
	var headSegments = state.headSegments;
	var end = Math.max(currentSegments.length, headSegments.length);
	var i = void 0,
		currentSegment = void 0,
		headSegment = void 0;
	for (i = 0; i < end; ++i) {
		currentSegment = currentSegments[i];
		headSegment = headSegments[i];

		if (currentSegment !== headSegment && currentSegment) {
			debug.dump("onCodePathSegmentEnd " + currentSegment.id);

			if (currentSegment.reachable) {
				analyzer.emitter.emit("onCodePathSegmentEnd", currentSegment, node);
			}
		}
	}
	state.currentSegments = headSegments;
	for (i = 0; i < end; ++i) {
		currentSegment = currentSegments[i];
		headSegment = headSegments[i];

		if (currentSegment !== headSegment && headSegment) {
			debug.dump("onCodePathSegmentStart " + headSegment.id);

			CodePathSegment.markUsed(headSegment);
			if (headSegment.reachable) {
				analyzer.emitter.emit("onCodePathSegmentStart", headSegment, node);
			}
		}
	}
}
function leaveFromCurrentSegment(analyzer, node) {
	var state = CodePath.getState(analyzer.codePath);
	var currentSegments = state.currentSegments;

	for (var i = 0; i < currentSegments.length; ++i) {
		var currentSegment = currentSegments[i];

		debug.dump("onCodePathSegmentEnd " + currentSegment.id);
		if (currentSegment.reachable) {
			analyzer.emitter.emit("onCodePathSegmentEnd", currentSegment, node);
		}
	}

	state.currentSegments = [];
}
function preprocess(analyzer, node) {
	var codePath = analyzer.codePath;
	var state = CodePath.getState(codePath);
	var parent = node.parent;

	switch (parent.type) {
		case "LogicalExpression":
			if (parent.right === node) {
				state.makeLogicalRight();
			}
			break;

		case "ConditionalExpression":
		case "IfStatement":
			if (parent.consequent === node) {
				state.makeIfConsequent();
			} else if (parent.alternate === node) {
				state.makeIfAlternate();
			}
			break;

		case "SwitchCase":
			if (parent.consequent[0] === node) {
				state.makeSwitchCaseBody(false, !parent.test);
			}
			break;

		case "TryStatement":
			if (parent.handler === node) {
				state.makeCatchBlock();
			} else if (parent.finalizer === node) {
				state.makeFinallyBlock();
			}
			break;

		case "WhileStatement":
			if (parent.test === node) {
				state.makeWhileTest(getBooleanValueIfSimpleConstant(node));
			} else {
				state.makeWhileBody();
			}
			break;

		case "DoWhileStatement":
			if (parent.body === node) {
				state.makeDoWhileBody();
			} else {
				state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));
			}
			break;

		case "ForStatement":
			if (parent.test === node) {
				state.makeForTest(getBooleanValueIfSimpleConstant(node));
			} else if (parent.update === node) {
				state.makeForUpdate();
			} else if (parent.body === node) {
				state.makeForBody();
			}
			break;

		case "ForInStatement":
		case "ForOfStatement":
			if (parent.left === node) {
				state.makeForInOfLeft();
			} else if (parent.right === node) {
				state.makeForInOfRight();
			} else {
				state.makeForInOfBody();
			}
			break;

		case "AssignmentPattern":
			if (parent.right === node) {
				state.pushForkContext();
				state.forkBypassPath();
				state.forkPath();
			}
			break;

		default:
			break;
	}
}
function processCodePathToEnter(analyzer, node) {
	var codePath = analyzer.codePath;
	var state = codePath && CodePath.getState(codePath);
	var parent = node.parent;

	switch (node.type) {
		case "Program":
		case "FunctionDeclaration":
		case "FunctionExpression":
		case "ArrowFunctionExpression":
			if (codePath) {
				forwardCurrentToHead(analyzer, node);
				debug.dumpState(node, state, false);
			}
			codePath = analyzer.codePath = new CodePath(analyzer.idGenerator.next(), codePath, analyzer.onLooped);
			state = CodePath.getState(codePath);
			debug.dump("onCodePathStart " + codePath.id);
			analyzer.emitter.emit("onCodePathStart", codePath, node);
			break;

		case "LogicalExpression":
			state.pushChoiceContext(node.operator, isForkingByTrueOrFalse(node));
			break;

		case "ConditionalExpression":
		case "IfStatement":
			state.pushChoiceContext("test", false);
			break;

		case "SwitchStatement":
			state.pushSwitchContext(node.cases.some(isCaseNode), astUtils.getLabel(node));
			break;

		case "TryStatement":
			state.pushTryContext(Boolean(node.finalizer));
			break;

		case "SwitchCase":
			if (parent.discriminant !== node && parent.cases[0] !== node) {
				state.forkPath();
			}
			break;

		case "WhileStatement":
		case "DoWhileStatement":
		case "ForStatement":
		case "ForInStatement":
		case "ForOfStatement":
			state.pushLoopContext(node.type, astUtils.getLabel(node));
			break;

		case "LabeledStatement":
			if (!astUtils.isBreakableStatement(node.body)) {
				state.pushBreakContext(false, node.label.name);
			}
			break;

		default:
			break;
	}
	forwardCurrentToHead(analyzer, node);
	debug.dumpState(node, state, false);
}
function processCodePathToExit(analyzer, node) {
	var codePath = analyzer.codePath;
	var state = CodePath.getState(codePath);
	var dontForward = false;

	switch (node.type) {
		case "IfStatement":
		case "ConditionalExpression":
		case "LogicalExpression":
			state.popChoiceContext();
			break;

		case "SwitchStatement":
			state.popSwitchContext();
			break;

		case "SwitchCase":
			if (node.consequent.length === 0) {
				state.makeSwitchCaseBody(true, !node.test);
			}
			if (state.forkContext.reachable) {
				dontForward = true;
			}
			break;

		case "TryStatement":
			state.popTryContext();
			break;

		case "BreakStatement":
			forwardCurrentToHead(analyzer, node);
			state.makeBreak(node.label && node.label.name);
			dontForward = true;
			break;

		case "ContinueStatement":
			forwardCurrentToHead(analyzer, node);
			state.makeContinue(node.label && node.label.name);
			dontForward = true;
			break;

		case "ReturnStatement":
			forwardCurrentToHead(analyzer, node);
			state.makeReturn();
			dontForward = true;
			break;

		case "ThrowStatement":
			forwardCurrentToHead(analyzer, node);
			state.makeThrow();
			dontForward = true;
			break;

		case "Identifier":
			if (isIdentifierReference(node)) {
				state.makeFirstThrowablePathInTryBlock();
				dontForward = true;
			}
			break;

		case "CallExpression":
		case "MemberExpression":
		case "NewExpression":
			state.makeFirstThrowablePathInTryBlock();
			break;

		case "WhileStatement":
		case "DoWhileStatement":
		case "ForStatement":
		case "ForInStatement":
		case "ForOfStatement":
			state.popLoopContext();
			break;

		case "AssignmentPattern":
			state.popForkContext();
			break;

		case "LabeledStatement":
			if (!astUtils.isBreakableStatement(node.body)) {
				state.popBreakContext();
			}
			break;

		default:
			break;
	}
	if (!dontForward) {
		forwardCurrentToHead(analyzer, node);
	}
	debug.dumpState(node, state, true);
}
function postprocess(analyzer, node) {
	switch (node.type) {
		case "Program":
		case "FunctionDeclaration":
		case "FunctionExpression":
		case "ArrowFunctionExpression":
			{
				var codePath = analyzer.codePath;
				CodePath.getState(codePath).makeFinal();
				leaveFromCurrentSegment(analyzer, node);
				debug.dump("onCodePathEnd " + codePath.id);
				analyzer.emitter.emit("onCodePathEnd", codePath, node);
				debug.dumpDot(codePath);

				codePath = analyzer.codePath = analyzer.codePath.upper;
				if (codePath) {
					debug.dumpState(node, CodePath.getState(codePath), true);
				}
				break;
			}

		default:
			break;
	}
}

var CodePathAnalyzer = function () {
	function CodePathAnalyzer(eventGenerator) {
		_classCallCheck(this, CodePathAnalyzer);

		this.original = eventGenerator;
		this.emitter = eventGenerator.emitter;
		this.codePath = null;
		this.idGenerator = new IdGenerator("s");
		this.currentNode = null;
		this.onLooped = this.onLooped.bind(this);
	}


	_createClass(CodePathAnalyzer, [{
		key: "enterNode",
		value: function enterNode(node) {
			this.currentNode = node;
			if (node.parent) {
				preprocess(this, node);
			}
			processCodePathToEnter(this, node);
			this.original.enterNode(node);

			this.currentNode = null;
		}

	}, {
		key: "leaveNode",
		value: function leaveNode(node) {
			this.currentNode = node;
			processCodePathToExit(this, node);
			this.original.leaveNode(node);
			postprocess(this, node);

			this.currentNode = null;
		}

	}, {
		key: "onLooped",
		value: function onLooped(fromSegment, toSegment) {
			if (fromSegment.reachable && toSegment.reachable) {
				debug.dump("onCodePathSegmentLoop " + fromSegment.id + " -> " + toSegment.id);
				this.emitter.emit("onCodePathSegmentLoop", fromSegment, toSegment, this.currentNode);
			}
		}
	}]);

	return CodePathAnalyzer;
}();

module.exports = CodePathAnalyzer;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CodePathState = __webpack_require__(352);
var IdGenerator = __webpack_require__(159);

var CodePath = function () {
	function CodePath(id, upper, onLooped) {
		_classCallCheck(this, CodePath);
		this.id = id;
		this.upper = upper;
		this.childCodePaths = [];
		Object.defineProperty(this, "internal", { value: new CodePathState(new IdGenerator(id + "_"), onLooped) });
		if (upper) {
			upper.childCodePaths.push(this);
		}
	}


	_createClass(CodePath, [{
		key: "traverseSegments",
		value: function traverseSegments(options, callback) {
			if (typeof options === "function") {
				callback = options;
				options = null;
			}

			options = options || {};
			var startSegment = options.first || this.internal.initialSegment;
			var lastSegment = options.last;

			var item = null;
			var index = 0;
			var end = 0;
			var segment = null;
			var visited = Object.create(null);
			var stack = [[startSegment, 0]];
			var skippedSegment = null;
			var broken = false;
			var controller = {
				skip: function skip() {
					if (stack.length <= 1) {
						broken = true;
					} else {
						skippedSegment = stack[stack.length - 2][0];
					}
				},
				break: function _break() {
					broken = true;
				}
			};
			function isVisited(prevSegment) {
				return visited[prevSegment.id] || segment.isLoopedPrevSegment(prevSegment);
			}

			while (stack.length > 0) {
				item = stack[stack.length - 1];
				segment = item[0];
				index = item[1];

				if (index === 0) {
					if (visited[segment.id]) {
						stack.pop();
						continue;
					}
					if (segment !== startSegment && segment.prevSegments.length > 0 && !segment.prevSegments.every(isVisited)) {
						stack.pop();
						continue;
					}
					if (skippedSegment && segment.prevSegments.indexOf(skippedSegment) !== -1) {
						skippedSegment = null;
					}
					visited[segment.id] = true;
					if (!skippedSegment) {
						callback.call(this, segment, controller);
						if (segment === lastSegment) {
							controller.skip();
						}
						if (broken) {
							break;
						}
					}
				}
				end = segment.nextSegments.length - 1;
				if (index < end) {
					item[1] += 1;
					stack.push([segment.nextSegments[index], 0]);
				} else if (index === end) {
					item[0] = segment.nextSegments[index];
					item[1] = 0;
				} else {
					stack.pop();
				}
			}
		}
	}, {
		key: "initialSegment",
		get: function get() {
			return this.internal.initialSegment;
		}

	}, {
		key: "finalSegments",
		get: function get() {
			return this.internal.finalSegments;
		}

	}, {
		key: "returnedSegments",
		get: function get() {
			return this.internal.returnedForkContext;
		}

	}, {
		key: "thrownSegments",
		get: function get() {
			return this.internal.thrownForkContext;
		}

	}, {
		key: "currentSegments",
		get: function get() {
			return this.internal.currentSegments;
		}
	}], [{
		key: "getState",
		value: function getState(codePath) {
			return codePath.internal;
		}
	}]);

	return CodePath;
}();

module.exports = CodePath;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CodePathSegment = __webpack_require__(102),
	ForkContext = __webpack_require__(355);
function addToReturnedOrThrown(dest, others, all, segments) {
	for (var i = 0; i < segments.length; ++i) {
		var segment = segments[i];

		dest.push(segment);
		if (others.indexOf(segment) === -1) {
			all.push(segment);
		}
	}
}
function getContinueContext(state, label) {
	if (!label) {
		return state.loopContext;
	}

	var context = state.loopContext;

	while (context) {
		if (context.label === label) {
			return context;
		}
		context = context.upper;
	}
	return null;
}
function getBreakContext(state, label) {
	var context = state.breakContext;

	while (context) {
		if (label ? context.label === label : context.breakable) {
			return context;
		}
		context = context.upper;
	}
	return null;
}
function getReturnContext(state) {
	var context = state.tryContext;

	while (context) {
		if (context.hasFinalizer && context.position !== "finally") {
			return context;
		}
		context = context.upper;
	}

	return state;
}
function getThrowContext(state) {
	var context = state.tryContext;

	while (context) {
		if (context.position === "try" || context.hasFinalizer && context.position === "catch") {
			return context;
		}
		context = context.upper;
	}

	return state;
}
function remove(xs, x) {
	xs.splice(xs.indexOf(x), 1);
}
function removeConnection(prevSegments, nextSegments) {
	for (var i = 0; i < prevSegments.length; ++i) {
		var prevSegment = prevSegments[i];
		var nextSegment = nextSegments[i];

		remove(prevSegment.nextSegments, nextSegment);
		remove(prevSegment.allNextSegments, nextSegment);
		remove(nextSegment.prevSegments, prevSegment);
		remove(nextSegment.allPrevSegments, prevSegment);
	}
}
function makeLooped(state, fromSegments, toSegments) {
	fromSegments = CodePathSegment.flattenUnusedSegments(fromSegments);
	toSegments = CodePathSegment.flattenUnusedSegments(toSegments);

	var end = Math.min(fromSegments.length, toSegments.length);

	for (var i = 0; i < end; ++i) {
		var fromSegment = fromSegments[i];
		var toSegment = toSegments[i];

		if (toSegment.reachable) {
			fromSegment.nextSegments.push(toSegment);
		}
		if (fromSegment.reachable) {
			toSegment.prevSegments.push(fromSegment);
		}
		fromSegment.allNextSegments.push(toSegment);
		toSegment.allPrevSegments.push(fromSegment);

		if (toSegment.allPrevSegments.length >= 2) {
			CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);
		}

		state.notifyLooped(fromSegment, toSegment);
	}
}
function finalizeTestSegmentsOfFor(context, choiceContext, head) {
	if (!choiceContext.processed) {
		choiceContext.trueForkContext.add(head);
		choiceContext.falseForkContext.add(head);
	}

	if (context.test !== true) {
		context.brokenForkContext.addAll(choiceContext.falseForkContext);
	}
	context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);
}

var CodePathState = function () {
	function CodePathState(idGenerator, onLooped) {
		_classCallCheck(this, CodePathState);

		this.idGenerator = idGenerator;
		this.notifyLooped = onLooped;
		this.forkContext = ForkContext.newRoot(idGenerator);
		this.choiceContext = null;
		this.switchContext = null;
		this.tryContext = null;
		this.loopContext = null;
		this.breakContext = null;

		this.currentSegments = [];
		this.initialSegment = this.forkContext.head[0];
		var final = this.finalSegments = [];
		var returned = this.returnedForkContext = [];
		var thrown = this.thrownForkContext = [];

		returned.add = addToReturnedOrThrown.bind(null, returned, thrown, final);
		thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);
	}


	_createClass(CodePathState, [{
		key: "pushForkContext",
		value: function pushForkContext(forkLeavingPath) {
			this.forkContext = ForkContext.newEmpty(this.forkContext, forkLeavingPath);

			return this.forkContext;
		}

	}, {
		key: "popForkContext",
		value: function popForkContext() {
			var lastContext = this.forkContext;

			this.forkContext = lastContext.upper;
			this.forkContext.replaceHead(lastContext.makeNext(0, -1));

			return lastContext;
		}

	}, {
		key: "forkPath",
		value: function forkPath() {
			this.forkContext.add(this.parentForkContext.makeNext(-1, -1));
		}

	}, {
		key: "forkBypassPath",
		value: function forkBypassPath() {
			this.forkContext.add(this.parentForkContext.head);
		}

	}, {
		key: "pushChoiceContext",
		value: function pushChoiceContext(kind, isForkingAsResult) {
			this.choiceContext = {
				upper: this.choiceContext,
				kind: kind,
				isForkingAsResult: isForkingAsResult,
				trueForkContext: ForkContext.newEmpty(this.forkContext),
				falseForkContext: ForkContext.newEmpty(this.forkContext),
				processed: false
			};
		}

	}, {
		key: "popChoiceContext",
		value: function popChoiceContext() {
			var context = this.choiceContext;

			this.choiceContext = context.upper;

			var forkContext = this.forkContext;
			var headSegments = forkContext.head;

			switch (context.kind) {
				case "&&":
				case "||":
					if (!context.processed) {
						context.trueForkContext.add(headSegments);
						context.falseForkContext.add(headSegments);
					}
					if (context.isForkingAsResult) {
						var parentContext = this.choiceContext;

						parentContext.trueForkContext.addAll(context.trueForkContext);
						parentContext.falseForkContext.addAll(context.falseForkContext);
						parentContext.processed = true;

						return context;
					}

					break;

				case "test":
					if (!context.processed) {
						context.trueForkContext.clear();
						context.trueForkContext.add(headSegments);
					} else {
						context.falseForkContext.clear();
						context.falseForkContext.add(headSegments);
					}

					break;

				case "loop":
					return context;
				default:
					throw new Error("unreachable");
			}
			var prevForkContext = context.trueForkContext;

			prevForkContext.addAll(context.falseForkContext);
			forkContext.replaceHead(prevForkContext.makeNext(0, -1));

			return context;
		}

	}, {
		key: "makeLogicalRight",
		value: function makeLogicalRight() {
			var context = this.choiceContext;
			var forkContext = this.forkContext;

			if (context.processed) {
				var prevForkContext = context.kind === "&&" ? context.trueForkContext
 : context.falseForkContext;

				forkContext.replaceHead(prevForkContext.makeNext(0, -1));
				prevForkContext.clear();

				context.processed = false;
			} else {
				if (context.kind === "&&") {
					context.falseForkContext.add(forkContext.head);
				} else {
					context.trueForkContext.add(forkContext.head);
				}

				forkContext.replaceHead(forkContext.makeNext(-1, -1));
			}
		}

	}, {
		key: "makeIfConsequent",
		value: function makeIfConsequent() {
			var context = this.choiceContext;
			var forkContext = this.forkContext;
			if (!context.processed) {
				context.trueForkContext.add(forkContext.head);
				context.falseForkContext.add(forkContext.head);
			}

			context.processed = false;
			forkContext.replaceHead(context.trueForkContext.makeNext(0, -1));
		}

	}, {
		key: "makeIfAlternate",
		value: function makeIfAlternate() {
			var context = this.choiceContext;
			var forkContext = this.forkContext;
			context.trueForkContext.clear();
			context.trueForkContext.add(forkContext.head);
			context.processed = true;
			forkContext.replaceHead(context.falseForkContext.makeNext(0, -1));
		}

	}, {
		key: "pushSwitchContext",
		value: function pushSwitchContext(hasCase, label) {
			this.switchContext = {
				upper: this.switchContext,
				hasCase: hasCase,
				defaultSegments: null,
				defaultBodySegments: null,
				foundDefault: false,
				lastIsDefault: false,
				countForks: 0
			};

			this.pushBreakContext(true, label);
		}

	}, {
		key: "popSwitchContext",
		value: function popSwitchContext() {
			var context = this.switchContext;

			this.switchContext = context.upper;

			var forkContext = this.forkContext;
			var brokenForkContext = this.popBreakContext().brokenForkContext;

			if (context.countForks === 0) {
				if (!brokenForkContext.empty) {
					brokenForkContext.add(forkContext.makeNext(-1, -1));
					forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
				}

				return;
			}

			var lastSegments = forkContext.head;

			this.forkBypassPath();
			var lastCaseSegments = forkContext.head;
			brokenForkContext.add(lastSegments);
			if (!context.lastIsDefault) {
				if (context.defaultBodySegments) {
					removeConnection(context.defaultSegments, context.defaultBodySegments);
					makeLooped(this, lastCaseSegments, context.defaultBodySegments);
				} else {
					brokenForkContext.add(lastCaseSegments);
				}
			}
			for (var i = 0; i < context.countForks; ++i) {
				this.forkContext = this.forkContext.upper;
			}
			this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
		}

	}, {
		key: "makeSwitchCaseBody",
		value: function makeSwitchCaseBody(isEmpty, isDefault) {
			var context = this.switchContext;

			if (!context.hasCase) {
				return;
			}
			var parentForkContext = this.forkContext;
			var forkContext = this.pushForkContext();

			forkContext.add(parentForkContext.makeNext(0, -1));
			if (isDefault) {
				context.defaultSegments = parentForkContext.head;
				if (isEmpty) {
					context.foundDefault = true;
				} else {
					context.defaultBodySegments = forkContext.head;
				}
			} else {
				if (!isEmpty && context.foundDefault) {
					context.foundDefault = false;
					context.defaultBodySegments = forkContext.head;
				}
			}

			context.lastIsDefault = isDefault;
			context.countForks += 1;
		}

	}, {
		key: "pushTryContext",
		value: function pushTryContext(hasFinalizer) {
			this.tryContext = {
				upper: this.tryContext,
				position: "try",
				hasFinalizer: hasFinalizer,

				returnedForkContext: hasFinalizer ? ForkContext.newEmpty(this.forkContext) : null,

				thrownForkContext: ForkContext.newEmpty(this.forkContext),
				lastOfTryIsReachable: false,
				lastOfCatchIsReachable: false
			};
		}

	}, {
		key: "popTryContext",
		value: function popTryContext() {
			var context = this.tryContext;

			this.tryContext = context.upper;

			if (context.position === "catch") {
				this.popForkContext();
				return;
			}

			var returned = context.returnedForkContext;
			var thrown = context.thrownForkContext;

			if (returned.empty && thrown.empty) {
				return;
			}
			var headSegments = this.forkContext.head;

			this.forkContext = this.forkContext.upper;
			var normalSegments = headSegments.slice(0, headSegments.length / 2 | 0);
			var leavingSegments = headSegments.slice(headSegments.length / 2 | 0);
			if (!returned.empty) {
				getReturnContext(this).returnedForkContext.add(leavingSegments);
			}
			if (!thrown.empty) {
				getThrowContext(this).thrownForkContext.add(leavingSegments);
			}
			this.forkContext.replaceHead(normalSegments);
			if (!context.lastOfTryIsReachable && !context.lastOfCatchIsReachable) {
				this.forkContext.makeUnreachable();
			}
		}

	}, {
		key: "makeCatchBlock",
		value: function makeCatchBlock() {
			var context = this.tryContext;
			var forkContext = this.forkContext;
			var thrown = context.thrownForkContext;
			context.position = "catch";
			context.thrownForkContext = ForkContext.newEmpty(forkContext);
			context.lastOfTryIsReachable = forkContext.reachable;
			thrown.add(forkContext.head);
			var thrownSegments = thrown.makeNext(0, -1);
			this.pushForkContext();
			this.forkBypassPath();
			this.forkContext.add(thrownSegments);
		}

	}, {
		key: "makeFinallyBlock",
		value: function makeFinallyBlock() {
			var context = this.tryContext;
			var forkContext = this.forkContext;
			var returned = context.returnedForkContext;
			var thrown = context.thrownForkContext;
			var headOfLeavingSegments = forkContext.head;
			if (context.position === "catch") {
				this.popForkContext();
				forkContext = this.forkContext;

				context.lastOfCatchIsReachable = forkContext.reachable;
			} else {
				context.lastOfTryIsReachable = forkContext.reachable;
			}
			context.position = "finally";

			if (returned.empty && thrown.empty) {
				return;
			}
			var segments = forkContext.makeNext(-1, -1);

			for (var i = 0; i < forkContext.count; ++i) {
				var prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];

				for (var j = 0; j < returned.segmentsList.length; ++j) {
					prevSegsOfLeavingSegment.push(returned.segmentsList[j][i]);
				}
				for (var _j = 0; _j < thrown.segmentsList.length; ++_j) {
					prevSegsOfLeavingSegment.push(thrown.segmentsList[_j][i]);
				}

				segments.push(CodePathSegment.newNext(this.idGenerator.next(), prevSegsOfLeavingSegment));
			}

			this.pushForkContext(true);
			this.forkContext.add(segments);
		}

	}, {
		key: "makeFirstThrowablePathInTryBlock",
		value: function makeFirstThrowablePathInTryBlock() {
			var forkContext = this.forkContext;

			if (!forkContext.reachable) {
				return;
			}

			var context = getThrowContext(this);

			if (context === this || context.position !== "try" || !context.thrownForkContext.empty) {
				return;
			}

			context.thrownForkContext.add(forkContext.head);
			forkContext.replaceHead(forkContext.makeNext(-1, -1));
		}

	}, {
		key: "pushLoopContext",
		value: function pushLoopContext(type, label) {
			var forkContext = this.forkContext;
			var breakContext = this.pushBreakContext(true, label);

			switch (type) {
				case "WhileStatement":
					this.pushChoiceContext("loop", false);
					this.loopContext = {
						upper: this.loopContext,
						type: type,
						label: label,
						test: void 0,
						continueDestSegments: null,
						brokenForkContext: breakContext.brokenForkContext
					};
					break;

				case "DoWhileStatement":
					this.pushChoiceContext("loop", false);
					this.loopContext = {
						upper: this.loopContext,
						type: type,
						label: label,
						test: void 0,
						entrySegments: null,
						continueForkContext: ForkContext.newEmpty(forkContext),
						brokenForkContext: breakContext.brokenForkContext
					};
					break;

				case "ForStatement":
					this.pushChoiceContext("loop", false);
					this.loopContext = {
						upper: this.loopContext,
						type: type,
						label: label,
						test: void 0,
						endOfInitSegments: null,
						testSegments: null,
						endOfTestSegments: null,
						updateSegments: null,
						endOfUpdateSegments: null,
						continueDestSegments: null,
						brokenForkContext: breakContext.brokenForkContext
					};
					break;

				case "ForInStatement":
				case "ForOfStatement":
					this.loopContext = {
						upper: this.loopContext,
						type: type,
						label: label,
						prevSegments: null,
						leftSegments: null,
						endOfLeftSegments: null,
						continueDestSegments: null,
						brokenForkContext: breakContext.brokenForkContext
					};
					break;
				default:
					throw new Error("unknown type: \"" + type + "\"");
			}
		}

	}, {
		key: "popLoopContext",
		value: function popLoopContext() {
			var context = this.loopContext;

			this.loopContext = context.upper;

			var forkContext = this.forkContext;
			var brokenForkContext = this.popBreakContext().brokenForkContext;
			switch (context.type) {
				case "WhileStatement":
				case "ForStatement":
					this.popChoiceContext();
					makeLooped(this, forkContext.head, context.continueDestSegments);
					break;

				case "DoWhileStatement":
					{
						var choiceContext = this.popChoiceContext();

						if (!choiceContext.processed) {
							choiceContext.trueForkContext.add(forkContext.head);
							choiceContext.falseForkContext.add(forkContext.head);
						}
						if (context.test !== true) {
							brokenForkContext.addAll(choiceContext.falseForkContext);
						}
						var segmentsList = choiceContext.trueForkContext.segmentsList;

						for (var i = 0; i < segmentsList.length; ++i) {
							makeLooped(this, segmentsList[i], context.entrySegments);
						}
						break;
					}

				case "ForInStatement":
				case "ForOfStatement":
					brokenForkContext.add(forkContext.head);
					makeLooped(this, forkContext.head, context.leftSegments);
					break;
				default:
					throw new Error("unreachable");
			}
			if (brokenForkContext.empty) {
				forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
			} else {
				forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
			}
		}

	}, {
		key: "makeWhileTest",
		value: function makeWhileTest(test) {
			var context = this.loopContext;
			var forkContext = this.forkContext;
			var testSegments = forkContext.makeNext(0, -1);
			context.test = test;
			context.continueDestSegments = testSegments;
			forkContext.replaceHead(testSegments);
		}

	}, {
		key: "makeWhileBody",
		value: function makeWhileBody() {
			var context = this.loopContext;
			var choiceContext = this.choiceContext;
			var forkContext = this.forkContext;

			if (!choiceContext.processed) {
				choiceContext.trueForkContext.add(forkContext.head);
				choiceContext.falseForkContext.add(forkContext.head);
			}
			if (context.test !== true) {
				context.brokenForkContext.addAll(choiceContext.falseForkContext);
			}
			forkContext.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));
		}

	}, {
		key: "makeDoWhileBody",
		value: function makeDoWhileBody() {
			var context = this.loopContext;
			var forkContext = this.forkContext;
			var bodySegments = forkContext.makeNext(-1, -1);
			context.entrySegments = bodySegments;
			forkContext.replaceHead(bodySegments);
		}

	}, {
		key: "makeDoWhileTest",
		value: function makeDoWhileTest(test) {
			var context = this.loopContext;
			var forkContext = this.forkContext;

			context.test = test;
			if (!context.continueForkContext.empty) {
				context.continueForkContext.add(forkContext.head);
				var testSegments = context.continueForkContext.makeNext(0, -1);

				forkContext.replaceHead(testSegments);
			}
		}

	}, {
		key: "makeForTest",
		value: function makeForTest(test) {
			var context = this.loopContext;
			var forkContext = this.forkContext;
			var endOfInitSegments = forkContext.head;
			var testSegments = forkContext.makeNext(-1, -1);
			context.test = test;
			context.endOfInitSegments = endOfInitSegments;
			context.continueDestSegments = context.testSegments = testSegments;
			forkContext.replaceHead(testSegments);
		}

	}, {
		key: "makeForUpdate",
		value: function makeForUpdate() {
			var context = this.loopContext;
			var choiceContext = this.choiceContext;
			var forkContext = this.forkContext;
			if (context.testSegments) {
				finalizeTestSegmentsOfFor(context, choiceContext, forkContext.head);
			} else {
				context.endOfInitSegments = forkContext.head;
			}
			var updateSegments = forkContext.makeDisconnected(-1, -1);

			context.continueDestSegments = context.updateSegments = updateSegments;
			forkContext.replaceHead(updateSegments);
		}

	}, {
		key: "makeForBody",
		value: function makeForBody() {
			var context = this.loopContext;
			var choiceContext = this.choiceContext;
			var forkContext = this.forkContext;
			if (context.updateSegments) {
				context.endOfUpdateSegments = forkContext.head;
				if (context.testSegments) {
					makeLooped(this, context.endOfUpdateSegments, context.testSegments);
				}
			} else if (context.testSegments) {
				finalizeTestSegmentsOfFor(context, choiceContext, forkContext.head);
			} else {
				context.endOfInitSegments = forkContext.head;
			}

			var bodySegments = context.endOfTestSegments;

			if (!bodySegments) {
				var prevForkContext = ForkContext.newEmpty(forkContext);

				prevForkContext.add(context.endOfInitSegments);
				if (context.endOfUpdateSegments) {
					prevForkContext.add(context.endOfUpdateSegments);
				}

				bodySegments = prevForkContext.makeNext(0, -1);
			}
			context.continueDestSegments = context.continueDestSegments || bodySegments;
			forkContext.replaceHead(bodySegments);
		}

	}, {
		key: "makeForInOfLeft",
		value: function makeForInOfLeft() {
			var context = this.loopContext;
			var forkContext = this.forkContext;
			var leftSegments = forkContext.makeDisconnected(-1, -1);
			context.prevSegments = forkContext.head;
			context.leftSegments = context.continueDestSegments = leftSegments;
			forkContext.replaceHead(leftSegments);
		}

	}, {
		key: "makeForInOfRight",
		value: function makeForInOfRight() {
			var context = this.loopContext;
			var forkContext = this.forkContext;
			var temp = ForkContext.newEmpty(forkContext);

			temp.add(context.prevSegments);
			var rightSegments = temp.makeNext(-1, -1);
			context.endOfLeftSegments = forkContext.head;
			forkContext.replaceHead(rightSegments);
		}

	}, {
		key: "makeForInOfBody",
		value: function makeForInOfBody() {
			var context = this.loopContext;
			var forkContext = this.forkContext;
			var temp = ForkContext.newEmpty(forkContext);

			temp.add(context.endOfLeftSegments);
			var bodySegments = temp.makeNext(-1, -1);
			makeLooped(this, forkContext.head, context.leftSegments);
			context.brokenForkContext.add(forkContext.head);
			forkContext.replaceHead(bodySegments);
		}

	}, {
		key: "pushBreakContext",
		value: function pushBreakContext(breakable, label) {
			this.breakContext = {
				upper: this.breakContext,
				breakable: breakable,
				label: label,
				brokenForkContext: ForkContext.newEmpty(this.forkContext)
			};
			return this.breakContext;
		}

	}, {
		key: "popBreakContext",
		value: function popBreakContext() {
			var context = this.breakContext;
			var forkContext = this.forkContext;

			this.breakContext = context.upper;
			if (!context.breakable) {
				var brokenForkContext = context.brokenForkContext;

				if (!brokenForkContext.empty) {
					brokenForkContext.add(forkContext.head);
					forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
				}
			}

			return context;
		}

	}, {
		key: "makeBreak",
		value: function makeBreak(label) {
			var forkContext = this.forkContext;

			if (!forkContext.reachable) {
				return;
			}

			var context = getBreakContext(this, label);
			if (context) {
				context.brokenForkContext.add(forkContext.head);
			}

			forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
		}

	}, {
		key: "makeContinue",
		value: function makeContinue(label) {
			var forkContext = this.forkContext;

			if (!forkContext.reachable) {
				return;
			}

			var context = getContinueContext(this, label);
			if (context) {
				if (context.continueDestSegments) {
					makeLooped(this, forkContext.head, context.continueDestSegments);
					if (context.type === "ForInStatement" || context.type === "ForOfStatement") {
						context.brokenForkContext.add(forkContext.head);
					}
				} else {
					context.continueForkContext.add(forkContext.head);
				}
			}
			forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
		}

	}, {
		key: "makeReturn",
		value: function makeReturn() {
			var forkContext = this.forkContext;

			if (forkContext.reachable) {
				getReturnContext(this).returnedForkContext.add(forkContext.head);
				forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
			}
		}

	}, {
		key: "makeThrow",
		value: function makeThrow() {
			var forkContext = this.forkContext;

			if (forkContext.reachable) {
				getThrowContext(this).thrownForkContext.add(forkContext.head);
				forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
			}
		}

	}, {
		key: "makeFinal",
		value: function makeFinal() {
			var segments = this.currentSegments;

			if (segments.length > 0 && segments[0].reachable) {
				this.returnedForkContext.add(segments);
			}
		}
	}, {
		key: "headSegments",
		get: function get() {
			return this.forkContext.head;
		}

	}, {
		key: "parentForkContext",
		get: function get() {
			var current = this.forkContext;

			return current && current.upper;
		}
	}]);

	return CodePathState;
}();

module.exports = CodePathState;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(354);
exports.instances = [];

exports.names = [];
exports.skips = [];

exports.formatters = {};

function selectColor(namespace) {
  var hash = 0,
			i;

  for (i in namespace) {
	hash = (hash << 5) - hash + namespace.charCodeAt(i);
	hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

function createDebug(namespace) {

  var prevTime;

  function debug() {
	if (!debug.enabled) return;

	var self = debug;
	var curr = +new Date();
	var ms = curr - (prevTime || curr);
	self.diff = ms;
	self.prev = prevTime;
	self.curr = curr;
	prevTime = curr;
	var args = new Array(arguments.length);
	for (var i = 0; i < args.length; i++) {
			args[i] = arguments[i];
	}

	args[0] = exports.coerce(args[0]);

	if ('string' !== typeof args[0]) {
			args.unshift('%O');
	}
	var index = 0;
	args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
			if (match === '%%') return match;
			index++;
			var formatter = exports.formatters[format];
			if ('function' === typeof formatter) {
		var val = args[index];
		match = formatter.call(self, val);
		args.splice(index, 1);
		index--;
			}
			return match;
	});
	exports.formatArgs.call(self, args);

	var logFn = debug.log || exports.log || console.log.bind(console);
	logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;
  if ('function' === typeof exports.init) {
	exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy() {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
	exports.instances.splice(index, 1);
	return true;
  } else {
	return false;
  }
}

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
	if (!split[i]) continue; // ignore empty strings
	namespaces = split[i].replace(/\*/g, '.*?');
	if (namespaces[0] === '-') {
			exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	} else {
			exports.names.push(new RegExp('^' + namespaces + '$'));
	}
  }

  for (i = 0; i < exports.instances.length; i++) {
	var instance = exports.instances[i];
	instance.enabled = exports.enabled(instance.namespace);
  }
}

function disable() {
  exports.enable('');
}

function enabled(name) {
  if (name[name.length - 1] === '*') {
	return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
	if (exports.skips[i].test(name)) {
			return false;
	}
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
	if (exports.names[i].test(name)) {
			return true;
	}
  }
  return false;
}

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
  if (type === 'string' && val.length > 0) {
	return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
	return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};

function parse(str) {
  str = String(str);
  if (str.length > 100) {
	return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) {
	return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
	case 'years':
	case 'year':
	case 'yrs':
	case 'yr':
	case 'y':
			return n * y;
	case 'days':
	case 'day':
	case 'd':
			return n * d;
	case 'hours':
	case 'hour':
	case 'hrs':
	case 'hr':
	case 'h':
			return n * h;
	case 'minutes':
	case 'minute':
	case 'mins':
	case 'min':
	case 'm':
			return n * m;
	case 'seconds':
	case 'second':
	case 'secs':
	case 'sec':
	case 's':
			return n * s;
	case 'milliseconds':
	case 'millisecond':
	case 'msecs':
	case 'msec':
	case 'ms':
			return n;
	default:
			return undefined;
  }
}

function fmtShort(ms) {
  if (ms >= d) {
	return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
	return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
	return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
	return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

function fmtLong(ms) {
  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
}

function plural(ms, n, name) {
  if (ms < n) {
	return;
  }
  if (ms < n * 1.5) {
	return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CodePathSegment = __webpack_require__(102);
function isReachable(segment) {
	return segment.reachable;
}
function makeSegments(context, begin, end, create) {
	var list = context.segmentsList;

	if (begin < 0) {
		begin = list.length + begin;
	}
	if (end < 0) {
		end = list.length + end;
	}

	var segments = [];

	for (var i = 0; i < context.count; ++i) {
		var allPrevSegments = [];

		for (var j = begin; j <= end; ++j) {
			allPrevSegments.push(list[j][i]);
		}

		segments.push(create(context.idGenerator.next(), allPrevSegments));
	}

	return segments;
}
function mergeExtraSegments(context, segments) {
	while (segments.length > context.count) {
		var merged = [];

		for (var i = 0, length = segments.length / 2 | 0; i < length; ++i) {
			merged.push(CodePathSegment.newNext(context.idGenerator.next(), [segments[i], segments[i + length]]));
		}
		segments = merged;
	}
	return segments;
}

var ForkContext = function () {
	function ForkContext(idGenerator, upper, count) {
		_classCallCheck(this, ForkContext);

		this.idGenerator = idGenerator;
		this.upper = upper;
		this.count = count;
		this.segmentsList = [];
	}


	_createClass(ForkContext, [{
		key: "makeNext",
		value: function makeNext(begin, end) {
			return makeSegments(this, begin, end, CodePathSegment.newNext);
		}

	}, {
		key: "makeUnreachable",
		value: function makeUnreachable(begin, end) {
			return makeSegments(this, begin, end, CodePathSegment.newUnreachable);
		}

	}, {
		key: "makeDisconnected",
		value: function makeDisconnected(begin, end) {
			return makeSegments(this, begin, end, CodePathSegment.newDisconnected);
		}

	}, {
		key: "add",
		value: function add(segments) {

			this.segmentsList.push(mergeExtraSegments(this, segments));
		}

	}, {
		key: "replaceHead",
		value: function replaceHead(segments) {

			this.segmentsList.splice(-1, 1, mergeExtraSegments(this, segments));
		}

	}, {
		key: "addAll",
		value: function addAll(context) {

			var source = context.segmentsList;

			for (var i = 0; i < source.length; ++i) {
				this.segmentsList.push(source[i]);
			}
		}

	}, {
		key: "clear",
		value: function clear() {
			this.segmentsList = [];
		}

	}, {
		key: "head",
		get: function get() {
			var list = this.segmentsList;

			return list.length === 0 ? [] : list[list.length - 1];
		}

	}, {
		key: "empty",
		get: function get() {
			return this.segmentsList.length === 0;
		}

	}, {
		key: "reachable",
		get: function get() {
			var segments = this.head;

			return segments.length > 0 && segments.some(isReachable);
		}
	}], [{
		key: "newRoot",
		value: function newRoot(idGenerator) {
			var context = new ForkContext(idGenerator, null, 1);

			context.add([CodePathSegment.newRoot(idGenerator.next())]);

			return context;
		}

	}, {
		key: "newEmpty",
		value: function newEmpty(parentContext, forkLeavingPath) {
			return new ForkContext(parentContext.idGenerator, parentContext, (forkLeavingPath ? 2 : 1) * parentContext.count);
		}
	}]);

	return ForkContext;
}();

module.exports = ForkContext;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

(function () {
	'use strict';

	function isExpression(node) {
		if (node == null) {
			return false;
		}
		switch (node.type) {
			case 'ArrayExpression':
			case 'AssignmentExpression':
			case 'BinaryExpression':
			case 'CallExpression':
			case 'ConditionalExpression':
			case 'FunctionExpression':
			case 'Identifier':
			case 'Literal':
			case 'LogicalExpression':
			case 'MemberExpression':
			case 'NewExpression':
			case 'ObjectExpression':
			case 'SequenceExpression':
			case 'ThisExpression':
			case 'UnaryExpression':
			case 'UpdateExpression':
				return true;
		}
		return false;
	}

	function isIterationStatement(node) {
		if (node == null) {
			return false;
		}
		switch (node.type) {
			case 'DoWhileStatement':
			case 'ForInStatement':
			case 'ForStatement':
			case 'WhileStatement':
				return true;
		}
		return false;
	}

	function isStatement(node) {
		if (node == null) {
			return false;
		}
		switch (node.type) {
			case 'BlockStatement':
			case 'BreakStatement':
			case 'ContinueStatement':
			case 'DebuggerStatement':
			case 'DoWhileStatement':
			case 'EmptyStatement':
			case 'ExpressionStatement':
			case 'ForInStatement':
			case 'ForStatement':
			case 'IfStatement':
			case 'LabeledStatement':
			case 'ReturnStatement':
			case 'SwitchStatement':
			case 'ThrowStatement':
			case 'TryStatement':
			case 'VariableDeclaration':
			case 'WhileStatement':
			case 'WithStatement':
				return true;
		}
		return false;
	}

	function isSourceElement(node) {
		return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
	}

	function trailingStatement(node) {
		switch (node.type) {
			case 'IfStatement':
				if (node.alternate != null) {
					return node.alternate;
				}
				return node.consequent;

			case 'LabeledStatement':
			case 'ForStatement':
			case 'ForInStatement':
			case 'WhileStatement':
			case 'WithStatement':
				return node.body;
		}
		return null;
	}

	function isProblematicIfStatement(node) {
		var current;

		if (node.type !== 'IfStatement') {
			return false;
		}
		if (node.alternate == null) {
			return false;
		}
		current = node.consequent;
		do {
			if (current.type === 'IfStatement') {
				if (current.alternate == null) {
					return true;
				}
			}
			current = trailingStatement(current);
		} while (current);

		return false;
	}

	module.exports = {
		isExpression: isExpression,
		isStatement: isStatement,
		isIterationStatement: isIterationStatement,
		isSourceElement: isSourceElement,
		isProblematicIfStatement: isProblematicIfStatement,

		trailingStatement: trailingStatement
	};
})();
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

(function () {
	'use strict';

	var code = __webpack_require__(160);

	function isStrictModeReservedWordES6(id) {
		switch (id) {
			case 'implements':
			case 'interface':
			case 'package':
			case 'private':
			case 'protected':
			case 'public':
			case 'static':
			case 'let':
				return true;
			default:
				return false;
		}
	}

	function isKeywordES5(id, strict) {
		if (!strict && id === 'yield') {
			return false;
		}
		return isKeywordES6(id, strict);
	}

	function isKeywordES6(id, strict) {
		if (strict && isStrictModeReservedWordES6(id)) {
			return true;
		}

		switch (id.length) {
			case 2:
				return id === 'if' || id === 'in' || id === 'do';
			case 3:
				return id === 'var' || id === 'for' || id === 'new' || id === 'try';
			case 4:
				return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';
			case 5:
				return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';
			case 6:
				return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';
			case 7:
				return id === 'default' || id === 'finally' || id === 'extends';
			case 8:
				return id === 'function' || id === 'continue' || id === 'debugger';
			case 10:
				return id === 'instanceof';
			default:
				return false;
		}
	}

	function isReservedWordES5(id, strict) {
		return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
	}

	function isReservedWordES6(id, strict) {
		return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
	}

	function isRestrictedWord(id) {
		return id === 'eval' || id === 'arguments';
	}

	function isIdentifierNameES5(id) {
		var i, iz, ch;

		if (id.length === 0) {
			return false;
		}

		ch = id.charCodeAt(0);
		if (!code.isIdentifierStartES5(ch)) {
			return false;
		}

		for (i = 1, iz = id.length; i < iz; ++i) {
			ch = id.charCodeAt(i);
			if (!code.isIdentifierPartES5(ch)) {
				return false;
			}
		}
		return true;
	}

	function decodeUtf16(lead, trail) {
		return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
	}

	function isIdentifierNameES6(id) {
		var i, iz, ch, lowCh, check;

		if (id.length === 0) {
			return false;
		}

		check = code.isIdentifierStartES6;
		for (i = 0, iz = id.length; i < iz; ++i) {
			ch = id.charCodeAt(i);
			if (0xD800 <= ch && ch <= 0xDBFF) {
				++i;
				if (i >= iz) {
					return false;
				}
				lowCh = id.charCodeAt(i);
				if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
					return false;
				}
				ch = decodeUtf16(ch, lowCh);
			}
			if (!check(ch)) {
				return false;
			}
			check = code.isIdentifierPartES6;
		}
		return true;
	}

	function isIdentifierES5(id, strict) {
		return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
	}

	function isIdentifierES6(id, strict) {
		return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
	}

	module.exports = {
		isKeywordES5: isKeywordES5,
		isKeywordES6: isKeywordES6,
		isReservedWordES5: isReservedWordES5,
		isReservedWordES6: isReservedWordES6,
		isRestrictedWord: isRestrictedWord,
		isIdentifierNameES5: isIdentifierNameES5,
		isIdentifierNameES6: isIdentifierNameES6,
		isIdentifierES5: isIdentifierES5,
		isIdentifierES6: isIdentifierES6
	};
})();
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astNodeTypes = __webpack_require__(161);
var extra = {
	trailingComments: [],
	leadingComments: [],
	bottomRightStack: [],
	previousNode: null
};
module.exports = {

	reset: function reset() {
		extra.trailingComments = [];
		extra.leadingComments = [];
		extra.bottomRightStack = [];
		extra.previousNode = null;
	},

	addComment: function addComment(comment) {
		extra.trailingComments.push(comment);
		extra.leadingComments.push(comment);
	},

	processComment: function processComment(node) {
		var lastChild, trailingComments, i, j;

		if (node.type === astNodeTypes.Program) {
			if (node.body.length > 0) {
				return;
			}
		}

		if (extra.trailingComments.length > 0) {
			if (extra.trailingComments[0].range[0] >= node.range[1]) {
				trailingComments = extra.trailingComments;
				extra.trailingComments = [];
			} else {
				extra.trailingComments.length = 0;
			}
		} else {
			if (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments && extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments[0].range[0] >= node.range[1]) {
				trailingComments = extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
				delete extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
			}
		}
		while (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].range[0] >= node.range[0]) {
			lastChild = extra.bottomRightStack.pop();
		}

		if (lastChild) {
			if (lastChild.leadingComments) {
				if (lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= node.range[0]) {
					node.leadingComments = lastChild.leadingComments;
					delete lastChild.leadingComments;
				} else {
					for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {
						if (lastChild.leadingComments[i].range[1] <= node.range[0]) {
							node.leadingComments = lastChild.leadingComments.splice(0, i + 1);
							break;
						}
					}
				}
			}
		} else if (extra.leadingComments.length > 0) {
			if (extra.leadingComments[extra.leadingComments.length - 1].range[1] <= node.range[0]) {
				if (extra.previousNode) {
					for (j = 0; j < extra.leadingComments.length; j++) {
						if (extra.leadingComments[j].end < extra.previousNode.end) {
							extra.leadingComments.splice(j, 1);
							j--;
						}
					}
				}
				if (extra.leadingComments.length > 0) {
					node.leadingComments = extra.leadingComments;
					extra.leadingComments = [];
				}
			} else {
				for (i = 0; i < extra.leadingComments.length; i++) {
					if (extra.leadingComments[i].range[1] > node.range[0]) {
						break;
					}
				}
				node.leadingComments = extra.leadingComments.slice(0, i);
				if (node.leadingComments.length === 0) {
					delete node.leadingComments;
				}
				trailingComments = extra.leadingComments.slice(i);
				if (trailingComments.length === 0) {
					trailingComments = null;
				}
			}
		}

		extra.previousNode = node;

		if (trailingComments) {
			node.trailingComments = trailingComments;
		}

		extra.bottomRightStack.push(node);
	}

};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var Token = {
	Boolean: "Boolean",
	EOF: "<end>",
	Identifier: "Identifier",
	Keyword: "Keyword",
	Null: "Null",
	Numeric: "Numeric",
	Punctuator: "Punctuator",
	String: "String",
	RegularExpression: "RegularExpression",
	Template: "Template",
	JSXIdentifier: "JSXIdentifier",
	JSXText: "JSXText"
};
function convertTemplatePart(tokens, code) {
	var firstToken = tokens[0],
		lastTemplateToken = tokens[tokens.length - 1];

	var token = {
		type: Token.Template,
		value: code.slice(firstToken.start, lastTemplateToken.end)
	};

	if (firstToken.loc) {
		token.loc = {
			start: firstToken.loc.start,
			end: lastTemplateToken.loc.end
		};
	}

	if (firstToken.range) {
		token.start = firstToken.range[0];
		token.end = lastTemplateToken.range[1];
		token.range = [token.start, token.end];
	}

	return token;
}
function TokenTranslator(acornTokTypes, code) {
	this._acornTokTypes = acornTokTypes;
	this._tokens = [];
	this._curlyBrace = null;
	this._code = code;
}

TokenTranslator.prototype = {
	constructor: TokenTranslator,
	translate: function translate(token, extra) {

		var type = token.type,
			tt = this._acornTokTypes;

		if (type === tt.name) {
			token.type = Token.Identifier;
			if (token.value === "static") {
				token.type = Token.Keyword;
			}

			if (extra.ecmaVersion > 5 && (token.value === "yield" || token.value === "let")) {
				token.type = Token.Keyword;
			}
		} else if (type === tt.semi || type === tt.comma || type === tt.parenL || type === tt.parenR || type === tt.braceL || type === tt.braceR || type === tt.dot || type === tt.bracketL || type === tt.colon || type === tt.question || type === tt.bracketR || type === tt.ellipsis || type === tt.arrow || type === tt.jsxTagStart || type === tt.incDec || type === tt.starstar || type === tt.jsxTagEnd || type === tt.prefix || type.binop && !type.keyword || type.isAssign) {

			token.type = Token.Punctuator;
			token.value = this._code.slice(token.start, token.end);
		} else if (type === tt.jsxName) {
			token.type = Token.JSXIdentifier;
		} else if (type.label === "jsxText" || type === tt.jsxAttrValueToken) {
			token.type = Token.JSXText;
		} else if (type.keyword) {
			if (type.keyword === "true" || type.keyword === "false") {
				token.type = Token.Boolean;
			} else if (type.keyword === "null") {
				token.type = Token.Null;
			} else {
				token.type = Token.Keyword;
			}
		} else if (type === tt.num) {
			token.type = Token.Numeric;
			token.value = this._code.slice(token.start, token.end);
		} else if (type === tt.string) {

			if (extra.jsxAttrValueToken) {
				extra.jsxAttrValueToken = false;
				token.type = Token.JSXText;
			} else {
				token.type = Token.String;
			}

			token.value = this._code.slice(token.start, token.end);
		} else if (type === tt.regexp) {
			token.type = Token.RegularExpression;
			var value = token.value;
			token.regex = {
				flags: value.flags,
				pattern: value.pattern
			};
			token.value = "/" + value.pattern + "/" + value.flags;
		}

		return token;
	},
	onToken: function onToken(token, extra) {

		var that = this,
			tt = this._acornTokTypes,
			tokens = extra.tokens,
			templateTokens = this._tokens;
		function translateTemplateTokens() {
			tokens.push(convertTemplatePart(that._tokens, that._code));
			that._tokens = [];
		}

		if (token.type === tt.eof) {
			if (this._curlyBrace) {
				tokens.push(this.translate(this._curlyBrace, extra));
			}

			return;
		}

		if (token.type === tt.backQuote) {
			if (this._curlyBrace) {
				tokens.push(this.translate(this._curlyBrace, extra));
				this._curlyBrace = null;
			}

			templateTokens.push(token);
			if (templateTokens.length > 1) {
				translateTemplateTokens();
			}

			return;
		} else if (token.type === tt.dollarBraceL) {
			templateTokens.push(token);
			translateTemplateTokens();
			return;
		} else if (token.type === tt.braceR) {
			if (this._curlyBrace) {
				tokens.push(this.translate(this._curlyBrace, extra));
			}
			this._curlyBrace = token;
			return;
		} else if (token.type === tt.template || token.type === tt.invalidTemplate) {
			if (this._curlyBrace) {
				templateTokens.push(this._curlyBrace);
				this._curlyBrace = null;
			}

			templateTokens.push(token);
			return;
		}

		if (this._curlyBrace) {
			tokens.push(this.translate(this._curlyBrace, extra));
			this._curlyBrace = null;
		}

		tokens.push(this.translate(token, extra));
	}
};
module.exports = TokenTranslator;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var XHTMLEntities = __webpack_require__(361);

var hexNumber = /^[\da-fA-F]+$/;
var decimalNumber = /^\d+$/;

module.exports = function (acorn) {
  var tt = acorn.tokTypes;
  var tc = acorn.tokContexts;

  tc.j_oTag = new acorn.TokContext('<tag', false);
  tc.j_cTag = new acorn.TokContext('</tag', false);
  tc.j_expr = new acorn.TokContext('<tag>...</tag>', true, true);

  tt.jsxName = new acorn.TokenType('jsxName');
  tt.jsxText = new acorn.TokenType('jsxText', { beforeExpr: true });
  tt.jsxTagStart = new acorn.TokenType('jsxTagStart');
  tt.jsxTagEnd = new acorn.TokenType('jsxTagEnd');

  tt.jsxTagStart.updateContext = function () {
	this.context.push(tc.j_expr); // treat as beginning of JSX expression
	this.context.push(tc.j_oTag); // start opening tag context
	this.exprAllowed = false;
  };
  tt.jsxTagEnd.updateContext = function (prevType) {
	var out = this.context.pop();
	if (out === tc.j_oTag && prevType === tt.slash || out === tc.j_cTag) {
			this.context.pop();
			this.exprAllowed = this.curContext() === tc.j_expr;
	} else {
			this.exprAllowed = true;
	}
  };

  var pp = acorn.Parser.prototype;
  pp.jsx_readToken = function () {
	var out = '',
		chunkStart = this.pos;
	for (;;) {
			if (this.pos >= this.input.length) this.raise(this.start, 'Unterminated JSX contents');
			var ch = this.input.charCodeAt(this.pos);

			switch (ch) {
		case 60: // '<'
		case 123:
					if (this.pos === this.start) {
			if (ch === 60 && this.exprAllowed) {
							++this.pos;
							return this.finishToken(tt.jsxTagStart);
			}
			return this.getTokenFromCode(ch);
					}
					out += this.input.slice(chunkStart, this.pos);
					return this.finishToken(tt.jsxText, out);

		case 38:
					out += this.input.slice(chunkStart, this.pos);
					out += this.jsx_readEntity();
					chunkStart = this.pos;
					break;

		default:
					if (acorn.isNewLine(ch)) {
			out += this.input.slice(chunkStart, this.pos);
			out += this.jsx_readNewLine(true);
			chunkStart = this.pos;
					} else {
			++this.pos;
					}
			}
	}
  };

  pp.jsx_readNewLine = function (normalizeCRLF) {
	var ch = this.input.charCodeAt(this.pos);
	var out;
	++this.pos;
	if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {
			++this.pos;
			out = normalizeCRLF ? '\n' : '\r\n';
	} else {
			out = String.fromCharCode(ch);
	}
	if (this.options.locations) {
			++this.curLine;
			this.lineStart = this.pos;
	}

	return out;
  };

  pp.jsx_readString = function (quote) {
	var out = '',
		chunkStart = ++this.pos;
	for (;;) {
			if (this.pos >= this.input.length) this.raise(this.start, 'Unterminated string constant');
			var ch = this.input.charCodeAt(this.pos);
			if (ch === quote) break;
			if (ch === 38) {
		out += this.input.slice(chunkStart, this.pos);
		out += this.jsx_readEntity();
		chunkStart = this.pos;
			} else if (acorn.isNewLine(ch)) {
		out += this.input.slice(chunkStart, this.pos);
		out += this.jsx_readNewLine(false);
		chunkStart = this.pos;
			} else {
		++this.pos;
			}
	}
	out += this.input.slice(chunkStart, this.pos++);
	return this.finishToken(tt.string, out);
  };

  pp.jsx_readEntity = function () {
	var str = '',
		count = 0,
		entity;
	var ch = this.input[this.pos];
	if (ch !== '&') this.raise(this.pos, 'Entity must start with an ampersand');
	var startPos = ++this.pos;
	while (this.pos < this.input.length && count++ < 10) {
			ch = this.input[this.pos++];
			if (ch === ';') {
		if (str[0] === '#') {
					if (str[1] === 'x') {
			str = str.substr(2);
			if (hexNumber.test(str)) entity = String.fromCharCode(parseInt(str, 16));
					} else {
			str = str.substr(1);
			if (decimalNumber.test(str)) entity = String.fromCharCode(parseInt(str, 10));
					}
		} else {
					entity = XHTMLEntities[str];
		}
		break;
			}
			str += ch;
	}
	if (!entity) {
			this.pos = startPos;
			return '&';
	}
	return entity;
  };
  //
  pp.jsx_readWord = function () {
	var ch,
		start = this.pos;
	do {
			ch = this.input.charCodeAt(++this.pos);
	} while (acorn.isIdentifierChar(ch) || ch === 45); // '-'
	return this.finishToken(tt.jsxName, this.input.slice(start, this.pos));
  };
  function getQualifiedJSXName(object) {
	if (object.type === 'JSXIdentifier') return object.name;

	if (object.type === 'JSXNamespacedName') return object.namespace.name + ':' + object.name.name;

	if (object.type === 'JSXMemberExpression') return getQualifiedJSXName(object.object) + '.' + getQualifiedJSXName(object.property);
  }
  pp.jsx_parseIdentifier = function () {
	var node = this.startNode();
	if (this.type === tt.jsxName) node.name = this.value;else if (this.type.keyword) node.name = this.type.keyword;else this.unexpected();
	this.next();
	return this.finishNode(node, 'JSXIdentifier');
  };
  pp.jsx_parseNamespacedName = function () {
	var startPos = this.start,
		startLoc = this.startLoc;
	var name = this.jsx_parseIdentifier();
	if (!this.options.plugins.jsx.allowNamespaces || !this.eat(tt.colon)) return name;
	var node = this.startNodeAt(startPos, startLoc);
	node.namespace = name;
	node.name = this.jsx_parseIdentifier();
	return this.finishNode(node, 'JSXNamespacedName');
  };
  pp.jsx_parseElementName = function () {
	var startPos = this.start,
		startLoc = this.startLoc;
	var node = this.jsx_parseNamespacedName();
	if (this.type === tt.dot && node.type === 'JSXNamespacedName' && !this.options.plugins.jsx.allowNamespacedObjects) {
			this.unexpected();
	}
	while (this.eat(tt.dot)) {
			var newNode = this.startNodeAt(startPos, startLoc);
			newNode.object = node;
			newNode.property = this.jsx_parseIdentifier();
			node = this.finishNode(newNode, 'JSXMemberExpression');
	}
	return node;
  };
  pp.jsx_parseAttributeValue = function () {
	switch (this.type) {
			case tt.braceL:
		var node = this.jsx_parseExpressionContainer();
		if (node.expression.type === 'JSXEmptyExpression') this.raise(node.start, 'JSX attributes must only be assigned a non-empty expression');
		return node;

			case tt.jsxTagStart:
			case tt.string:
		return this.parseExprAtom();

			default:
		this.raise(this.start, 'JSX value should be either an expression or a quoted JSX text');
	}
  };
  pp.jsx_parseEmptyExpression = function () {
	var node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
	return this.finishNodeAt(node, 'JSXEmptyExpression', this.start, this.startLoc);
  };

  pp.jsx_parseExpressionContainer = function () {
	var node = this.startNode();
	this.next();
	node.expression = this.type === tt.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression();
	this.expect(tt.braceR);
	return this.finishNode(node, 'JSXExpressionContainer');
  };
  pp.jsx_parseAttribute = function () {
	var node = this.startNode();
	if (this.eat(tt.braceL)) {
			this.expect(tt.ellipsis);
			node.argument = this.parseMaybeAssign();
			this.expect(tt.braceR);
			return this.finishNode(node, 'JSXSpreadAttribute');
	}
	node.name = this.jsx_parseNamespacedName();
	node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;
	return this.finishNode(node, 'JSXAttribute');
  };
  pp.jsx_parseOpeningElementAt = function (startPos, startLoc) {
	var node = this.startNodeAt(startPos, startLoc);
	node.attributes = [];
	node.name = this.jsx_parseElementName();
	while (this.type !== tt.slash && this.type !== tt.jsxTagEnd) {
			node.attributes.push(this.jsx_parseAttribute());
	}node.selfClosing = this.eat(tt.slash);
	this.expect(tt.jsxTagEnd);
	return this.finishNode(node, 'JSXOpeningElement');
  };
  pp.jsx_parseClosingElementAt = function (startPos, startLoc) {
	var node = this.startNodeAt(startPos, startLoc);
	node.name = this.jsx_parseElementName();
	this.expect(tt.jsxTagEnd);
	return this.finishNode(node, 'JSXClosingElement');
  };
  pp.jsx_parseElementAt = function (startPos, startLoc) {
	var node = this.startNodeAt(startPos, startLoc);
	var children = [];
	var openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);
	var closingElement = null;

	if (!openingElement.selfClosing) {
			contents: for (;;) {
		switch (this.type) {
					case tt.jsxTagStart:
			startPos = this.start;startLoc = this.startLoc;
			this.next();
			if (this.eat(tt.slash)) {
							closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
							break contents;
			}
			children.push(this.jsx_parseElementAt(startPos, startLoc));
			break;

					case tt.jsxText:
			children.push(this.parseExprAtom());
			break;

					case tt.braceL:
			children.push(this.jsx_parseExpressionContainer());
			break;

					default:
			this.unexpected();
		}
			}
			if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
		this.raise(closingElement.start, 'Expected corresponding JSX closing tag for <' + getQualifiedJSXName(openingElement.name) + '>');
			}
	}

	node.openingElement = openingElement;
	node.closingElement = closingElement;
	node.children = children;
	if (this.type === tt.relational && this.value === "<") {
			this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
	}
	return this.finishNode(node, 'JSXElement');
  };
  pp.jsx_parseElement = function () {
	var startPos = this.start,
		startLoc = this.startLoc;
	this.next();
	return this.jsx_parseElementAt(startPos, startLoc);
  };

  acorn.plugins.jsx = function (instance, opts) {
	if (!opts) {
			return;
	}

	if ((typeof opts === 'undefined' ? 'undefined' : _typeof(opts)) !== 'object') {
			opts = {};
	}

	instance.options.plugins.jsx = {
			allowNamespaces: opts.allowNamespaces !== false,
			allowNamespacedObjects: !!opts.allowNamespacedObjects
	};

	instance.extend('parseExprAtom', function (inner) {
			return function (refShortHandDefaultPos) {
		if (this.type === tt.jsxText) return this.parseLiteral(this.value);else if (this.type === tt.jsxTagStart) return this.jsx_parseElement();else return inner.call(this, refShortHandDefaultPos);
			};
	});

	instance.extend('readToken', function (inner) {
			return function (code) {
		var context = this.curContext();

		if (context === tc.j_expr) return this.jsx_readToken();

		if (context === tc.j_oTag || context === tc.j_cTag) {
					if (acorn.isIdentifierStart(code)) return this.jsx_readWord();

					if (code == 62) {
			++this.pos;
			return this.finishToken(tt.jsxTagEnd);
					}

					if ((code === 34 || code === 39) && context == tc.j_oTag) return this.jsx_readString(code);
		}

		if (code === 60 && this.exprAllowed) {
					++this.pos;
					return this.finishToken(tt.jsxTagStart);
		}
		return inner.call(this, code);
			};
	});

	instance.extend('updateContext', function (inner) {
			return function (prevType) {
		if (this.type == tt.braceL) {
					var curContext = this.curContext();
					if (curContext == tc.j_oTag) this.context.push(tc.b_expr);else if (curContext == tc.j_expr) this.context.push(tc.b_tmpl);else inner.call(this, prevType);
					this.exprAllowed = true;
		} else if (this.type === tt.slash && prevType === tt.jsxTagStart) {
					this.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore
					this.context.push(tc.j_cTag); // reconsider as closing tag context
					this.exprAllowed = false;
		} else {
					return inner.call(this, prevType);
		}
			};
	});
  };

  return acorn;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  quot: '"',
  amp: '&',
  apos: '\'',
  lt: '<',
  gt: '>',
  nbsp: '\xA0',
  iexcl: '\xA1',
  cent: '\xA2',
  pound: '\xA3',
  curren: '\xA4',
  yen: '\xA5',
  brvbar: '\xA6',
  sect: '\xA7',
  uml: '\xA8',
  copy: '\xA9',
  ordf: '\xAA',
  laquo: '\xAB',
  not: '\xAC',
  shy: '\xAD',
  reg: '\xAE',
  macr: '\xAF',
  deg: '\xB0',
  plusmn: '\xB1',
  sup2: '\xB2',
  sup3: '\xB3',
  acute: '\xB4',
  micro: '\xB5',
  para: '\xB6',
  middot: '\xB7',
  cedil: '\xB8',
  sup1: '\xB9',
  ordm: '\xBA',
  raquo: '\xBB',
  frac14: '\xBC',
  frac12: '\xBD',
  frac34: '\xBE',
  iquest: '\xBF',
  Agrave: '\xC0',
  Aacute: '\xC1',
  Acirc: '\xC2',
  Atilde: '\xC3',
  Auml: '\xC4',
  Aring: '\xC5',
  AElig: '\xC6',
  Ccedil: '\xC7',
  Egrave: '\xC8',
  Eacute: '\xC9',
  Ecirc: '\xCA',
  Euml: '\xCB',
  Igrave: '\xCC',
  Iacute: '\xCD',
  Icirc: '\xCE',
  Iuml: '\xCF',
  ETH: '\xD0',
  Ntilde: '\xD1',
  Ograve: '\xD2',
  Oacute: '\xD3',
  Ocirc: '\xD4',
  Otilde: '\xD5',
  Ouml: '\xD6',
  times: '\xD7',
  Oslash: '\xD8',
  Ugrave: '\xD9',
  Uacute: '\xDA',
  Ucirc: '\xDB',
  Uuml: '\xDC',
  Yacute: '\xDD',
  THORN: '\xDE',
  szlig: '\xDF',
  agrave: '\xE0',
  aacute: '\xE1',
  acirc: '\xE2',
  atilde: '\xE3',
  auml: '\xE4',
  aring: '\xE5',
  aelig: '\xE6',
  ccedil: '\xE7',
  egrave: '\xE8',
  eacute: '\xE9',
  ecirc: '\xEA',
  euml: '\xEB',
  igrave: '\xEC',
  iacute: '\xED',
  icirc: '\xEE',
  iuml: '\xEF',
  eth: '\xF0',
  ntilde: '\xF1',
  ograve: '\xF2',
  oacute: '\xF3',
  ocirc: '\xF4',
  otilde: '\xF5',
  ouml: '\xF6',
  divide: '\xF7',
  oslash: '\xF8',
  ugrave: '\xF9',
  uacute: '\xFA',
  ucirc: '\xFB',
  uuml: '\xFC',
  yacute: '\xFD',
  thorn: '\xFE',
  yuml: '\xFF',
  OElig: '\u0152',
  oelig: '\u0153',
  Scaron: '\u0160',
  scaron: '\u0161',
  Yuml: '\u0178',
  fnof: '\u0192',
  circ: '\u02C6',
  tilde: '\u02DC',
  Alpha: '\u0391',
  Beta: '\u0392',
  Gamma: '\u0393',
  Delta: '\u0394',
  Epsilon: '\u0395',
  Zeta: '\u0396',
  Eta: '\u0397',
  Theta: '\u0398',
  Iota: '\u0399',
  Kappa: '\u039A',
  Lambda: '\u039B',
  Mu: '\u039C',
  Nu: '\u039D',
  Xi: '\u039E',
  Omicron: '\u039F',
  Pi: '\u03A0',
  Rho: '\u03A1',
  Sigma: '\u03A3',
  Tau: '\u03A4',
  Upsilon: '\u03A5',
  Phi: '\u03A6',
  Chi: '\u03A7',
  Psi: '\u03A8',
  Omega: '\u03A9',
  alpha: '\u03B1',
  beta: '\u03B2',
  gamma: '\u03B3',
  delta: '\u03B4',
  epsilon: '\u03B5',
  zeta: '\u03B6',
  eta: '\u03B7',
  theta: '\u03B8',
  iota: '\u03B9',
  kappa: '\u03BA',
  lambda: '\u03BB',
  mu: '\u03BC',
  nu: '\u03BD',
  xi: '\u03BE',
  omicron: '\u03BF',
  pi: '\u03C0',
  rho: '\u03C1',
  sigmaf: '\u03C2',
  sigma: '\u03C3',
  tau: '\u03C4',
  upsilon: '\u03C5',
  phi: '\u03C6',
  chi: '\u03C7',
  psi: '\u03C8',
  omega: '\u03C9',
  thetasym: '\u03D1',
  upsih: '\u03D2',
  piv: '\u03D6',
  ensp: '\u2002',
  emsp: '\u2003',
  thinsp: '\u2009',
  zwnj: '\u200C',
  zwj: '\u200D',
  lrm: '\u200E',
  rlm: '\u200F',
  ndash: '\u2013',
  mdash: '\u2014',
  lsquo: '\u2018',
  rsquo: '\u2019',
  sbquo: '\u201A',
  ldquo: '\u201C',
  rdquo: '\u201D',
  bdquo: '\u201E',
  dagger: '\u2020',
  Dagger: '\u2021',
  bull: '\u2022',
  hellip: '\u2026',
  permil: '\u2030',
  prime: '\u2032',
  Prime: '\u2033',
  lsaquo: '\u2039',
  rsaquo: '\u203A',
  oline: '\u203E',
  frasl: '\u2044',
  euro: '\u20AC',
  image: '\u2111',
  weierp: '\u2118',
  real: '\u211C',
  trade: '\u2122',
  alefsym: '\u2135',
  larr: '\u2190',
  uarr: '\u2191',
  rarr: '\u2192',
  darr: '\u2193',
  harr: '\u2194',
  crarr: '\u21B5',
  lArr: '\u21D0',
  uArr: '\u21D1',
  rArr: '\u21D2',
  dArr: '\u21D3',
  hArr: '\u21D4',
  forall: '\u2200',
  part: '\u2202',
  exist: '\u2203',
  empty: '\u2205',
  nabla: '\u2207',
  isin: '\u2208',
  notin: '\u2209',
  ni: '\u220B',
  prod: '\u220F',
  sum: '\u2211',
  minus: '\u2212',
  lowast: '\u2217',
  radic: '\u221A',
  prop: '\u221D',
  infin: '\u221E',
  ang: '\u2220',
  and: '\u2227',
  or: '\u2228',
  cap: '\u2229',
  cup: '\u222A',
  'int': '\u222B',
  there4: '\u2234',
  sim: '\u223C',
  cong: '\u2245',
  asymp: '\u2248',
  ne: '\u2260',
  equiv: '\u2261',
  le: '\u2264',
  ge: '\u2265',
  sub: '\u2282',
  sup: '\u2283',
  nsub: '\u2284',
  sube: '\u2286',
  supe: '\u2287',
  oplus: '\u2295',
  otimes: '\u2297',
  perp: '\u22A5',
  sdot: '\u22C5',
  lceil: '\u2308',
  rceil: '\u2309',
  lfloor: '\u230A',
  rfloor: '\u230B',
  lang: '\u2329',
  rang: '\u232A',
  loz: '\u25CA',
  spades: '\u2660',
  clubs: '\u2663',
  hearts: '\u2665',
  diams: '\u2666'
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

var keywords = {
  5: ecma5AndLessKeywords,
  6: ecma5AndLessKeywords + " const class extends export import super"
};

var keywordRelationalOperator = /^in(stanceof)?$/;
function isIdentifierStart(code, astral) {
  if (code < 65) {
	return code === 36;
  }
  if (code < 91) {
	return true;
  }
  if (code < 97) {
	return code === 95;
  }
  if (code < 123) {
	return true;
  }
  return code >= 0xaa;
}
function isIdentifierChar(code, astral) {
  if (code < 48) {
	return code === 36;
  }
  if (code < 58) {
	return true;
  }
  if (code < 65) {
	return false;
  }
  if (code < 91) {
	return true;
  }
  if (code < 97) {
	return code === 95;
  }
  if (code < 123) {
	return true;
  }
  return code >= 0xaa;
}
//
//
var TokenType = function TokenType(label, conf) {
  if (conf === void 0) conf = {};

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

function binop(name, prec) {
  return new TokenType(name, { beforeExpr: true, binop: prec });
}
var beforeExpr = { beforeExpr: true };
var startsExpr = { startsExpr: true };
var keywords$1 = {};
function kw(name, options) {
  if (options === void 0) options = {};

  options.keyword = name;
  return keywords$1[name] = new TokenType(name, options);
}

var types = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  eof: new TokenType("eof"),
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),

  at: new TokenType("@", { beforeExpr: true, startsExpr: true }),
  //
  //
  //
  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: true }),
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", { isLoop: true, beforeExpr: true }),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", { isLoop: true }),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", { isLoop: true }),
  _with: kw("with"),
  _new: kw("new", { beforeExpr: true, startsExpr: true }),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import"),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", { beforeExpr: true, binop: 7 }),
  _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
  _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
  _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
  _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
};
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");

function isNewLine(code) {
  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029;
}

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString = ref.toString;
function has(obj, propName) {
  return hasOwnProperty.call(obj, propName);
}

var isArray = Array.isArray || function (obj) {
  return toString.call(obj) === "[object Array]";
};
var Position = function Position(line, col) {
  this.line = line;
  this.column = col;
};

Position.prototype.offset = function offset(n) {
  return new Position(this.line, this.column + n);
};

var SourceLocation = function SourceLocation(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) {
	this.source = p.sourceFile;
  }
};
function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
	lineBreakG.lastIndex = cur;
	var match = lineBreakG.exec(input);
	if (match && match.index < offset) {
			++line;
			cur = match.index + match[0].length;
	} else {
			return new Position(line, offset - cur);
	}
  }
}
var defaultOptions = {
  ecmaVersion: 7,
  sourceType: "script",
  onInsertedSemicolon: null,
  onTrailingComma: null,
  allowReserved: null,
  allowReturnOutsideFunction: false,
  allowImportExportEverywhere: false,
  allowHashBang: false,
  locations: false,
  onToken: null,
  onComment: null,
  //
  ranges: false,
  program: null,
  sourceFile: null,
  directSourceFile: null,
  preserveParens: false,
  plugins: {}
};
function getOptions(opts) {
  var options = {};

  for (var opt in defaultOptions) {
	options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt];
  }

  if (options.ecmaVersion >= 2015) {
	options.ecmaVersion -= 2009;
  }

  if (options.allowReserved == null) {
	options.allowReserved = options.ecmaVersion < 5;
  }

  if (isArray(options.onToken)) {
	var tokens = options.onToken;
	options.onToken = function (token) {
			return tokens.push(token);
	};
  }
  if (isArray(options.onComment)) {
	options.onComment = pushComment(options, options.onComment);
  }

  return options;
}

function pushComment(options, array) {
  return function (block, text, start, end, startLoc, endLoc) {
	var comment = {
			type: block ? "Block" : "Line",
			value: text,
			start: start,
			end: end
	};
	if (options.locations) {
			comment.loc = new SourceLocation(this, startLoc, endLoc);
	}
	if (options.ranges) {
			comment.range = [start, end];
	}
	array.push(comment);
  };
}
var plugins = {};

function keywordRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
}

var Parser = function Parser(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);
  var reserved = "";
  if (!options.allowReserved) {
	for (var v = options.ecmaVersion;; v--) {
			if (reserved = reservedWords[v]) {
		break;
			}
	}
	if (options.sourceType == "module") {
			reserved += " await";
	}
  }
  this.reservedWords = keywordRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = keywordRegexp(reservedStrict);
  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);
  this.containsEsc = false;
  this.loadPlugins(options.plugins);
  if (startPos) {
	this.pos = startPos;
	this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
	this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
	this.pos = this.lineStart = 0;
	this.curLine = 1;
  }
  this.type = types.eof;
  this.value = null;
  this.start = this.end = this.pos;
  this.startLoc = this.endLoc = this.curPosition();
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;
  this.context = this.initialContext();
  this.exprAllowed = true;
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);
  this.potentialArrowAt = -1;
  this.inFunction = this.inGenerator = this.inAsync = false;
  this.yieldPos = this.awaitPos = 0;
  this.labels = [];
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
	this.skipLineComment(2);
  }
  this.scopeStack = [];
  this.enterFunctionScope();
};
Parser.prototype.isKeyword = function isKeyword(word) {
  return this.keywords.test(word);
};
Parser.prototype.isReservedWord = function isReservedWord(word) {
  return this.reservedWords.test(word);
};

Parser.prototype.extend = function extend(name, f) {
  this[name] = f(this[name]);
};

Parser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {
  var this$1 = this;

  for (var name in pluginConfigs) {
	var plugin = plugins[name];
	if (!plugin) {
			throw new Error("Plugin '" + name + "' not found");
	}
	plugin(this$1, pluginConfigs[name]);
  }
};

Parser.prototype.parse = function parse() {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node);
};

var pp = Parser.prototype;
var literal = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)"|;)/;
pp.strictDirective = function (start) {
  var this$1 = this;

  for (;;) {
	skipWhiteSpace.lastIndex = start;
	start += skipWhiteSpace.exec(this$1.input)[0].length;
	var match = literal.exec(this$1.input.slice(start));
	if (!match) {
			return false;
	}
	if ((match[1] || match[2]) == "use strict") {
			return true;
	}
	start += match[0].length;
  }
};
pp.eat = function (type) {
  if (this.type === type) {
	this.next();
	return true;
  } else {
	return false;
  }
};
pp.isContextual = function (name) {
  return this.type === types.name && this.value === name;
};
pp.eatContextual = function (name) {
  return this.value === name && this.eat(types.name);
};
pp.expectContextual = function (name) {
  if (!this.eatContextual(name)) {
	this.unexpected();
  }
};
pp.canInsertSemicolon = function () {
  return this.type === types.eof || this.type === types.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};

pp.insertSemicolon = function () {
  if (this.canInsertSemicolon()) {
	if (this.options.onInsertedSemicolon) {
			this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
	}
	return true;
  }
};
pp.semicolon = function () {
  if (!this.eat(types.semi) && !this.insertSemicolon()) {
	this.unexpected();
  }
};

pp.afterTrailingComma = function (tokType, notNext) {
  if (this.type == tokType) {
	if (this.options.onTrailingComma) {
			this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
	}
	if (!notNext) {
			this.next();
	}
	return true;
  }
};
pp.expect = function (type) {
  this.eat(type) || this.unexpected();
};
pp.unexpected = function (pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

function DestructuringErrors() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = -1;
}

pp.checkPatternErrors = function (refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) {
	return;
  }
  if (refDestructuringErrors.trailingComma > -1) {
	this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
  }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) {
	this.raiseRecoverable(parens, "Parenthesized pattern");
  }
};

pp.checkExpressionErrors = function (refDestructuringErrors, andThrow) {
  var pos = refDestructuringErrors ? refDestructuringErrors.shorthandAssign : -1;
  if (!andThrow) {
	return pos >= 0;
  }
  if (pos > -1) {
	this.raise(pos, "Shorthand property assignments are valid only in destructuring patterns");
  }
};

pp.checkYieldAwaitInDefaultParams = function () {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
	this.raise(this.yieldPos, "Yield expression cannot be a default value");
  }
  if (this.awaitPos) {
	this.raise(this.awaitPos, "Await expression cannot be a default value");
  }
};

pp.isSimpleAssignTarget = function (expr) {
  if (expr.type === "ParenthesizedExpression") {
	return this.isSimpleAssignTarget(expr.expression);
  }
  return expr.type === "Identifier" || expr.type === "MemberExpression";
};

var pp$1 = Parser.prototype;
pp$1.parseTopLevel = function (node) {
  var this$1 = this;

  var exports = {};
  if (!node.body) {
	node.body = [];
  }
  while (this.type !== types.eof) {
	var stmt = this$1.parseStatement(true, true, exports);
	node.body.push(stmt);
  }
  this.adaptDirectivePrologue(node.body);
  this.next();
  if (this.options.ecmaVersion >= 6) {
	node.sourceType = this.options.sourceType;
  }
  return this.finishNode(node, "Program");
};

var loopLabel = { kind: "loop" };
var switchLabel = { kind: "switch" };

pp$1.isLet = function () {
  if (this.type !== types.name || this.options.ecmaVersion < 6 || this.value != "let") {
	return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length,
			nextCh = this.input.charCodeAt(next);
  if (nextCh === 91 || nextCh == 123) {
	return true;
  } // '{' and '['
  if (isIdentifierStart(nextCh, true)) {
	var pos = next + 1;
	while (isIdentifierChar(this.input.charCodeAt(pos), true)) {
			++pos;
	}
	var ident = this.input.slice(next, pos);
	if (!keywordRelationalOperator.test(ident)) {
			return true;
	}
  }
  return false;
};
pp$1.isAsyncFunction = function () {
  if (this.type !== types.name || this.options.ecmaVersion < 8 || this.value != "async") {
	return false;
  }

  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length;
  return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 == this.input.length || !isIdentifierChar(this.input.charAt(next + 8)));
};
//
pp$1.parseStatement = function (declaration, topLevel, exports) {
  var starttype = this.type,
			node = this.startNode(),
			kind;

  if (this.isLet()) {
	starttype = types._var;
	kind = "let";
  }
  switch (starttype) {
	case types._break:case types._continue:
			return this.parseBreakContinueStatement(node, starttype.keyword);
	case types._debugger:
			return this.parseDebuggerStatement(node);
	case types._do:
			return this.parseDoStatement(node);
	case types._for:
			return this.parseForStatement(node);
	case types._function:
			if (!declaration && this.options.ecmaVersion >= 6) {
		this.unexpected();
			}
			return this.parseFunctionStatement(node, false);
	case types._class:
			if (!declaration) {
		this.unexpected();
			}
			return this.parseClass(node, true);
	case types._if:
			return this.parseIfStatement(node);
	case types._return:
			return this.parseReturnStatement(node);
	case types._switch:
			return this.parseSwitchStatement(node);
	case types._throw:
			return this.parseThrowStatement(node);
	case types._try:
			return this.parseTryStatement(node);
	case types._const:case types._var:
			kind = kind || this.value;
			if (!declaration && kind != "var") {
		this.unexpected();
			}
			return this.parseVarStatement(node, kind);
	case types._while:
			return this.parseWhileStatement(node);
	case types._with:
			return this.parseWithStatement(node);
	case types.braceL:
			return this.parseBlock();
	case types.semi:
			return this.parseEmptyStatement(node);
	case types._export:
	case types._import:
			if (!this.options.allowImportExportEverywhere) {
		if (!topLevel) {
					this.raise(this.start, "'import' and 'export' may only appear at the top level");
		}
		if (!this.inModule) {
					this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
		}
			}
			return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports);
	case types.at:
			this.next();
			return this.parseExpression();
	default:
			if (this.isAsyncFunction() && declaration) {
		this.next();
		return this.parseFunctionStatement(node, true);
			}

			var maybeName = this.value,
					expr = this.parseExpression();
			if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon)) {
		return this.parseLabeledStatement(node, maybeName, expr);
			} else {
		return this.parseExpressionStatement(node, expr);
			}
  }
};

pp$1.parseBreakContinueStatement = function (node, keyword) {
  var this$1 = this;

  var isBreak = keyword == "break";
  this.next();
  if (this.eat(types.semi) || this.insertSemicolon()) {
	node.label = null;
  } else if (this.type !== types.name) {
	this.unexpected();
  } else {
	node.label = this.parseIdent();
	this.semicolon();
  }
  var i = 0;
  for (; i < this.labels.length; ++i) {
	var lab = this$1.labels[i];
	if (node.label == null || lab.name === node.label.name) {
			if (lab.kind != null && (isBreak || lab.kind === "loop")) {
		break;
			}
			if (node.label && isBreak) {
		break;
			}
	}
  }
  if (i === this.labels.length) {
	this.raise(node.start, "Unsyntactic " + keyword);
  }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};

pp$1.parseDebuggerStatement = function (node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};

pp$1.parseDoStatement = function (node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  this.expect(types._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) {
	this.eat(types.semi);
  } else {
	this.semicolon();
  }
  return this.finishNode(node, "DoWhileStatement");
};
pp$1.parseForStatement = function (node) {
  this.next();
  this.labels.push(loopLabel);
  this.enterLexicalScope();
  this.expect(types.parenL);
  if (this.type === types.semi) {
	return this.parseFor(node, null);
  }
  var isLet = this.isLet();
  if (this.type === types._var || this.type === types._const || isLet) {
	var init$1 = this.startNode(),
		kind = isLet ? "let" : this.value;
	this.next();
	this.parseVar(init$1, true, kind);
	this.finishNode(init$1, "VariableDeclaration");
	if ((this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1 && !(kind !== "var" && init$1.declarations[0].init)) {
			return this.parseForIn(node, init$1);
	}
	return this.parseFor(node, init$1);
  }
  var refDestructuringErrors = new DestructuringErrors();
  var init = this.parseExpression(true, refDestructuringErrors);
  if (this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
	this.toAssignable(init);
	this.checkLVal(init);
	this.checkPatternErrors(refDestructuringErrors, true);
	return this.parseForIn(node, init);
  } else {
	this.checkExpressionErrors(refDestructuringErrors, true);
  }
  return this.parseFor(node, init);
};

pp$1.parseFunctionStatement = function (node, isAsync) {
  this.next();
  return this.parseFunction(node, true, false, isAsync);
};

pp$1.isFunction = function () {
  return this.type === types._function || this.isAsyncFunction();
};

pp$1.parseIfStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  node.consequent = this.parseStatement(!this.strict && this.isFunction());
  node.alternate = this.eat(types._else) ? this.parseStatement(!this.strict && this.isFunction()) : null;
  return this.finishNode(node, "IfStatement");
};

pp$1.parseReturnStatement = function (node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
	this.raise(this.start, "'return' outside of function");
  }
  this.next();
  if (this.eat(types.semi) || this.insertSemicolon()) {
	node.argument = null;
  } else {
	node.argument = this.parseExpression();this.semicolon();
  }
  return this.finishNode(node, "ReturnStatement");
};

pp$1.parseSwitchStatement = function (node) {
  var this$1 = this;

  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types.braceL);
  this.labels.push(switchLabel);
  this.enterLexicalScope();
  var cur;
  for (var sawDefault = false; this.type != types.braceR;) {
	if (this$1.type === types._case || this$1.type === types._default) {
			var isCase = this$1.type === types._case;
			if (cur) {
		this$1.finishNode(cur, "SwitchCase");
			}
			node.cases.push(cur = this$1.startNode());
			cur.consequent = [];
			this$1.next();
			if (isCase) {
		cur.test = this$1.parseExpression();
			} else {
		if (sawDefault) {
					this$1.raiseRecoverable(this$1.lastTokStart, "Multiple default clauses");
		}
		sawDefault = true;
		cur.test = null;
			}
			this$1.expect(types.colon);
	} else {
			if (!cur) {
		this$1.unexpected();
			}
			cur.consequent.push(this$1.parseStatement(true));
	}
  }
  this.exitLexicalScope();
  if (cur) {
	this.finishNode(cur, "SwitchCase");
  }
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};

pp$1.parseThrowStatement = function (node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
	this.raise(this.lastTokEnd, "Illegal newline after throw");
  }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
};
var empty = [];

pp$1.parseTryStatement = function (node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types._catch) {
	var clause = this.startNode();
	this.next();
	this.expect(types.parenL);
	clause.param = this.parseBindingAtom();
	this.enterLexicalScope();
	this.checkLVal(clause.param, "let");
	this.expect(types.parenR);
	clause.body = this.parseBlock(false);
	this.exitLexicalScope();
	node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer) {
	this.raise(node.start, "Missing catch or finally clause");
  }
  return this.finishNode(node, "TryStatement");
};

pp$1.parseVarStatement = function (node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};

pp$1.parseWhileStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "WhileStatement");
};

pp$1.parseWithStatement = function (node) {
  if (this.strict) {
	this.raise(this.start, "'with' in strict mode");
  }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement(false);
  return this.finishNode(node, "WithStatement");
};

pp$1.parseEmptyStatement = function (node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};

pp$1.parseLabeledStatement = function (node, maybeName, expr) {
  var this$1 = this;

  for (var i$1 = 0, list = this$1.labels; i$1 < list.length; i$1 += 1) {
	var label = list[i$1];

	if (label.name === maybeName) {
			this$1.raise(expr.start, "Label '" + maybeName + "' is already declared");
	}
  }
  var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
	var label$1 = this$1.labels[i];
	if (label$1.statementStart == node.start) {
			label$1.statementStart = this$1.start;
			label$1.kind = kind;
	} else {
			break;
	}
  }
  this.labels.push({ name: maybeName, kind: kind, statementStart: this.start });
  node.body = this.parseStatement(true);
  if (node.body.type == "ClassDeclaration" || node.body.type == "VariableDeclaration" && node.body.kind != "var" || node.body.type == "FunctionDeclaration" && (this.strict || node.body.generator)) {
	this.raiseRecoverable(node.body.start, "Invalid labeled declaration");
  }
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};

pp$1.parseExpressionStatement = function (node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
};
pp$1.parseBlock = function (createNewLexicalScope) {
  var this$1 = this;
  if (createNewLexicalScope === void 0) createNewLexicalScope = true;

  var node = this.startNode();
  node.body = [];
  this.expect(types.braceL);
  if (createNewLexicalScope) {
	this.enterLexicalScope();
  }
  while (!this.eat(types.braceR)) {
	var stmt = this$1.parseStatement(true);
	node.body.push(stmt);
  }
  if (createNewLexicalScope) {
	this.exitLexicalScope();
  }
  return this.finishNode(node, "BlockStatement");
};
pp$1.parseFor = function (node, init) {
  node.init = init;
  this.expect(types.semi);
  node.test = this.type === types.semi ? null : this.parseExpression();
  this.expect(types.semi);
  node.update = this.type === types.parenR ? null : this.parseExpression();
  this.expect(types.parenR);
  this.exitLexicalScope();
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "ForStatement");
};
pp$1.parseForIn = function (node, init) {
  var type = this.type === types._in ? "ForInStatement" : "ForOfStatement";
  this.next();
  node.left = init;
  node.right = this.parseExpression();
  this.expect(types.parenR);
  this.exitLexicalScope();
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, type);
};
pp$1.parseVar = function (node, isFor, kind) {
  var this$1 = this;

  node.declarations = [];
  node.kind = kind;
  for (;;) {
	var decl = this$1.startNode();
	this$1.parseVarId(decl, kind);
	if (this$1.eat(types.eq)) {
			decl.init = this$1.parseMaybeAssign(isFor);
	} else if (kind === "const" && !(this$1.type === types._in || this$1.options.ecmaVersion >= 6 && this$1.isContextual("of"))) {
			this$1.unexpected();
	} else if (decl.id.type != "Identifier" && !(isFor && (this$1.type === types._in || this$1.isContextual("of")))) {
			this$1.raise(this$1.lastTokEnd, "Complex binding patterns require an initialization value");
	} else {
			decl.init = null;
	}
	node.declarations.push(this$1.finishNode(decl, "VariableDeclarator"));
	if (!this$1.eat(types.comma)) {
			break;
	}
  }
  return node;
};

pp$1.parseVarId = function (decl, kind) {
  decl.id = this.parseBindingAtom(kind);
  this.checkLVal(decl.id, kind, false);
};
pp$1.parseFunction = function (node, isStatement, allowExpressionBody, isAsync) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 6 && !isAsync) {
	node.generator = this.eat(types.star);
  }
  if (this.options.ecmaVersion >= 8) {
	node.async = !!isAsync;
  }

  if (isStatement) {
	node.id = isStatement === "nullableID" && this.type != types.name ? null : this.parseIdent();
	if (node.id) {
			this.checkLVal(node.id, "var");
	}
  }

  var oldInGen = this.inGenerator,
			oldInAsync = this.inAsync,
			oldYieldPos = this.yieldPos,
			oldAwaitPos = this.awaitPos,
			oldInFunc = this.inFunction;
  this.inGenerator = node.generator;
  this.inAsync = node.async;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.inFunction = true;
  this.enterFunctionScope();

  if (!isStatement) {
	node.id = this.type == types.name ? this.parseIdent() : null;
  }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody);

  this.inGenerator = oldInGen;
  this.inAsync = oldInAsync;
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.inFunction = oldInFunc;
  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
};

pp$1.parseFunctionParams = function (node) {
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};
pp$1.parseClass = function (node, isStatement) {
  var this$1 = this;

  this.next();

  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types.braceL);
  var decorators = [];
  while (!this.eat(types.braceR)) {
	if (this$1.eat(types.semi)) {
			continue;
	}
	if (this$1.type == types.at) {
			this$1.next();
			var expr = this$1.parseMaybeAssign(true);
			decorators.push(expr);
			continue;
	}
	var method = this$1.startNode();
	var isGenerator = this$1.eat(types.star);
	var isAsync = false;
	var isMaybeStatic = this$1.type === types.name && this$1.value === "static";
	this$1.parsePropertyName(method);
	method.static = isMaybeStatic && this$1.type !== types.parenL;
	if (method.static) {
			if (isGenerator) {
		this$1.unexpected();
			}
			isGenerator = this$1.eat(types.star);
			this$1.parsePropertyName(method);
	}
	if (this$1.options.ecmaVersion >= 8 && !isGenerator && !method.computed && method.key.type === "Identifier" && method.key.name === "async" && this$1.type !== types.parenL && !this$1.canInsertSemicolon()) {
			isAsync = true;
			this$1.parsePropertyName(method);
	}
	method.kind = "method";
	var isGetSet = false;
	if (!method.computed) {
			var key = method.key;
			if (!isGenerator && !isAsync && key.type === "Identifier" && this$1.type !== types.parenL && (key.name === "get" || key.name === "set")) {
		isGetSet = true;
		method.kind = key.name;
		key = this$1.parsePropertyName(method);
			}
			if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" || key.type === "Literal" && key.value === "constructor")) {
		if (hadConstructor) {
					this$1.raise(key.start, "Duplicate constructor in the same class");
		}
		if (isGetSet) {
					this$1.raise(key.start, "Constructor can't have get/set modifier");
		}
		if (isGenerator) {
					this$1.raise(key.start, "Constructor can't be a generator");
		}
		if (isAsync) {
					this$1.raise(key.start, "Constructor can't be an async method");
		}
		method.kind = "constructor";
		hadConstructor = true;
			} else if (method.static && key.type === "Identifier" && key.name === "prototype") {
		this$1.raise(key.start, "Classes may not have a static property named prototype");
			}
	}

	if (this$1.type == types.eq) {
			this$1.next();
			method.value = this$1.parseExpression();
	} else if (this$1.type == types.semi || this$1.canInsertSemicolon()) {
			if (this$1.type == types.semi) {
		this$1.next();
			}
			var node$1 = this$1.startNode();
			node$1.body = [];
			method.value = this$1.finishNode(node$1, "BlockStatement");
	}
	if (method.value) {
			method.kind = 'class';
			classBody.body.push(this$1.finishNode(method, "Property"));
			continue;
	}

	this$1.parseClassMethod(classBody, method, isGenerator, isAsync);
	if (decorators.length) {
			var body = method.value.body.body;
			if (body) {
		body.unshift.apply(body, decorators);
			}
			decorators = [];
	}
	if (isGetSet) {
			var paramCount = method.kind === "get" ? 0 : 1;
			if (method.value.params.length !== paramCount) {
		var start = method.value.start;
		if (method.kind === "get") {
					this$1.raiseRecoverable(start, "getter should have no params");
		} else {
					this$1.raiseRecoverable(start, "setter should have exactly one param");
		}
			} else {
		if (method.kind === "set" && method.value.params[0].type === "RestElement") {
					this$1.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params");
		}
			}
	}
  }
  node.body = this.finishNode(classBody, "ClassBody");
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};

pp$1.parseClassMethod = function (classBody, method, isGenerator, isAsync) {
  method.value = this.parseMethod(isGenerator, isAsync);
  classBody.body.push(this.finishNode(method, "MethodDefinition"));
};

pp$1.parseClassId = function (node, isStatement) {
  node.id = this.type === types.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null;
};

pp$1.parseClassSuper = function (node) {
  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
};
pp$1.parseExport = function (node, exports) {
  var this$1 = this;

  this.next();
  if (this.eat(types.star)) {
	this.expectContextual("from");
	if (this.type !== types.string) {
			this.unexpected();
	}
	node.source = this.parseExprAtom();
	this.semicolon();
	return this.finishNode(node, "ExportAllDeclaration");
  }
  if (this.eat(types._default)) {
	this.checkExport(exports, "default", this.lastTokStart);
	var isAsync;
	if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
			var fNode = this.startNode();
			this.next();
			if (isAsync) {
		this.next();
			}
			node.declaration = this.parseFunction(fNode, "nullableID", false, isAsync);
	} else if (this.type === types._class) {
			var cNode = this.startNode();
			node.declaration = this.parseClass(cNode, "nullableID");
	} else {
			node.declaration = this.parseMaybeAssign();
			this.semicolon();
	}
	return this.finishNode(node, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement()) {
	node.declaration = this.parseStatement(true);
	if (node.declaration.type === "VariableDeclaration") {
			this.checkVariableExport(exports, node.declaration.declarations);
	} else {
			this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);
	}
	node.specifiers = [];
	node.source = null;
  } else {
	node.declaration = null;
	node.specifiers = this.parseExportSpecifiers(exports);
	if (this.eatContextual("from")) {
			if (this.type !== types.string) {
		this.unexpected();
			}
			node.source = this.parseExprAtom();
	} else {
			for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
		var spec = list[i];

		this$1.checkUnreserved(spec.local);
			}

			node.source = null;
	}
	this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration");
};

pp$1.checkExport = function (exports, name, pos) {
  if (!exports) {
	return;
  }
  if (has(exports, name)) {
	this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
  }
  exports[name] = true;
};

pp$1.checkPatternExport = function (exports, pat) {
  var this$1 = this;

  var type = pat.type;
  if (type == "Identifier") {
	this.checkExport(exports, pat.name, pat.start);
  } else if (type == "ObjectPattern") {
	for (var i = 0, list = pat.properties; i < list.length; i += 1) {
			var prop = list[i];

			this$1.checkPatternExport(exports, prop.value);
	}
  } else if (type == "ArrayPattern") {
	for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
			var elt = list$1[i$1];

			if (elt) {
		this$1.checkPatternExport(exports, elt);
			}
	}
  } else if (type == "AssignmentPattern") {
	this.checkPatternExport(exports, pat.left);
  } else if (type == "ParenthesizedExpression") {
	this.checkPatternExport(exports, pat.expression);
  }
};

pp$1.checkVariableExport = function (exports, decls) {
  var this$1 = this;

  if (!exports) {
	return;
  }
  for (var i = 0, list = decls; i < list.length; i += 1) {
	var decl = list[i];

	this$1.checkPatternExport(exports, decl.id);
  }
};

pp$1.shouldParseExportStatement = function () {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$1.parseExportSpecifiers = function (exports) {
  var this$1 = this;

  var nodes = [],
			first = true;
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
	if (!first) {
			this$1.expect(types.comma);
			if (this$1.afterTrailingComma(types.braceR)) {
		break;
			}
	} else {
			first = false;
	}

	var node = this$1.startNode();
	node.local = this$1.parseIdent(true);
	node.exported = this$1.eatContextual("as") ? this$1.parseIdent(true) : node.local;
	this$1.checkExport(exports, node.exported.name, node.exported.start);
	nodes.push(this$1.finishNode(node, "ExportSpecifier"));
  }
  return nodes;
};
pp$1.parseImport = function (node) {
  this.next();
  if (this.type === types.string) {
	node.specifiers = empty;
	node.source = this.parseExprAtom();
  } else {
	node.specifiers = this.parseImportSpecifiers();
	this.expectContextual("from");
	node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};
pp$1.parseImportSpecifiers = function () {
  var this$1 = this;

  var nodes = [],
			first = true;
  if (this.type === types.name) {
	var node = this.startNode();
	node.local = this.parseIdent();
	this.checkLVal(node.local, "let");
	nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
	if (!this.eat(types.comma)) {
			return nodes;
	}
  }
  if (this.type === types.star) {
	var node$1 = this.startNode();
	this.next();
	this.expectContextual("as");
	node$1.local = this.parseIdent();
	this.checkLVal(node$1.local, "let");
	nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
	return nodes;
  }
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
	if (!first) {
			this$1.expect(types.comma);
			if (this$1.afterTrailingComma(types.braceR)) {
		break;
			}
	} else {
			first = false;
	}

	var node$2 = this$1.startNode();
	node$2.imported = this$1.parseIdent(true);
	if (this$1.eatContextual("as")) {
			node$2.local = this$1.parseIdent();
	} else {
			this$1.checkUnreserved(node$2.imported);
			node$2.local = node$2.imported;
	}
	this$1.checkLVal(node$2.local, "let");
	nodes.push(this$1.finishNode(node$2, "ImportSpecifier"));
  }
  return nodes;
};
pp$1.adaptDirectivePrologue = function (statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
	statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$1.isDirectiveCandidate = function (statement) {
  return statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (
  this.input[statement.start] === "\"" || this.input[statement.start] === "'");
};

var pp$2 = Parser.prototype;
pp$2.toAssignable = function (node, isBinding) {
  var this$1 = this;

  if (this.options.ecmaVersion >= 6 && node) {
	switch (node.type) {
			case "Identifier":
		if (this.inAsync && node.name === "await") {
					this.raise(node.start, "Can not use 'await' as identifier inside an async function");
		}
		break;

			case "ObjectPattern":
			case "ArrayPattern":
			case "RestElement":
		break;

			case "ObjectExpression":
		node.type = "ObjectPattern";
		for (var i = 0, list = node.properties; i < list.length; i += 1) {
					var prop = list[i];

					this$1.toAssignable(prop, isBinding);
		}
		break;

			case "Property":
		if (node.kind !== "init") {
					this.raise(node.key.start, "Object pattern can't contain getter or setter");
		}
		this.toAssignable(node.value, isBinding);
		break;

			case "ArrayExpression":
		node.type = "ArrayPattern";
		this.toAssignableList(node.elements, isBinding);
		break;

			case "SpreadElement":
		node.type = "RestElement";
		this.toAssignable(node.argument, isBinding);
		if (node.argument.type === "AssignmentPattern") {
					this.raise(node.argument.start, "Rest elements cannot have a default value");
		}
		break;

			case "AssignmentExpression":
		if (node.operator !== "=") {
					this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
		}
		node.type = "AssignmentPattern";
		delete node.operator;
		this.toAssignable(node.left, isBinding);
			case "AssignmentPattern":
		break;

			case "ParenthesizedExpression":
		this.toAssignable(node.expression, isBinding);
		break;

			case "MemberExpression":
		if (!isBinding) {
					break;
		}

			default:
		this.raise(node.start, "Assigning to rvalue");
	}
  }
  return node;
};
pp$2.toAssignableList = function (exprList, isBinding) {
  var this$1 = this;

  var end = exprList.length;
  for (var i = 0; i < end; i++) {
	var elt = exprList[i];
	if (elt) {
			this$1.toAssignable(elt, isBinding);
	}
  }
  if (end) {
	var last = exprList[end - 1];
	if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
			this.unexpected(last.argument.start);
	}
  }
  return exprList;
};
pp$2.parseSpread = function (refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement");
};

pp$2.parseRestBinding = function () {
  var node = this.startNode();
  this.next();
  if (this.options.ecmaVersion === 6 && this.type !== types.name) {
	this.unexpected();
  }

  node.argument = this.parseBindingAtom();

  return this.finishNode(node, "RestElement");
};
pp$2.parseBindingAtom = function () {
  if (this.options.ecmaVersion >= 6) {
	switch (this.type) {
			case types.bracketL:
		var node = this.startNode();
		this.next();
		node.elements = this.parseBindingList(types.bracketR, true, true);
		return this.finishNode(node, "ArrayPattern");

			case types.braceL:
		return this.parseObj(true);
	}
  }
  return this.parseIdent();
};

pp$2.parseBindingList = function (close, allowEmpty, allowTrailingComma) {
  var this$1 = this;

  var elts = [],
			first = true;
  while (!this.eat(close)) {
	if (first) {
			first = false;
	} else {
			this$1.expect(types.comma);
	}
	if (allowEmpty && this$1.type === types.comma) {
			elts.push(null);
	} else if (allowTrailingComma && this$1.afterTrailingComma(close)) {
			break;
	} else if (this$1.type === types.ellipsis) {
			var rest = this$1.parseRestBinding();
			this$1.parseBindingListItem(rest);
			elts.push(rest);
			if (this$1.type === types.comma) {
		this$1.raise(this$1.start, "Comma is not permitted after the rest element");
			}
			this$1.expect(close);
			break;
	} else {
			var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc);
			this$1.parseBindingListItem(elem);
			elts.push(elem);
	}
  }
  return elts;
};

pp$2.parseBindingListItem = function (param) {
  return param;
};
pp$2.parseMaybeDefault = function (startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) {
	return left;
  }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
};
pp$2.checkLVal = function (expr, bindingType, checkClashes) {
  var this$1 = this;

  switch (expr.type) {
	case "Identifier":
			if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
		this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
			}
			if (checkClashes) {
		if (has(checkClashes, expr.name)) {
					this.raiseRecoverable(expr.start, "Argument name clash");
		}
		checkClashes[expr.name] = true;
			}
			if (bindingType && bindingType !== "none") {
		if (bindingType === "var" && !this.canDeclareVarName(expr.name) || bindingType !== "var" && !this.canDeclareLexicalName(expr.name)) {
					this.raiseRecoverable(expr.start, "Identifier '" + expr.name + "' has already been declared");
		}
		if (bindingType === "var") {
					this.declareVarName(expr.name);
		} else {
					this.declareLexicalName(expr.name);
		}
			}
			break;

	case "MemberExpression":
			if (bindingType) {
		this.raiseRecoverable(expr.start, "Binding member expression");
			}
			break;

	case "ObjectPattern":
			for (var i = 0, list = expr.properties; i < list.length; i += 1) {
		var prop = list[i];

		this$1.checkLVal(prop, bindingType, checkClashes);
			}
			break;

	case "Property":
			this.checkLVal(expr.value, bindingType, checkClashes);
			break;

	case "ArrayPattern":
			for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
		var elem = list$1[i$1];

		if (elem) {
					this$1.checkLVal(elem, bindingType, checkClashes);
		}
			}
			break;

	case "AssignmentPattern":
			this.checkLVal(expr.left, bindingType, checkClashes);
			break;

	case "RestElement":
			this.checkLVal(expr.argument, bindingType, checkClashes);
			break;

	case "ParenthesizedExpression":
			this.checkLVal(expr.expression, bindingType, checkClashes);
			break;

	default:
			this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
  }
};
//
//
var pp$3 = Parser.prototype;
pp$3.checkPropClash = function (prop, propHash) {
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
	return;
  }
  var key = prop.key;
  var name;
  switch (key.type) {
	case "Identifier":
			name = key.name;break;
	case "Literal":
			name = String(key.value);break;
	default:
			return;
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
	if (name === "__proto__" && kind === "init") {
			if (propHash.proto) {
		this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
			}
			propHash.proto = true;
	}
	return;
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
	var redefinition;
	if (kind === "init") {
			redefinition = this.strict && other.init || other.get || other.set;
	} else {
			redefinition = other.init || other[kind];
	}
	if (redefinition) {
			this.raiseRecoverable(key.start, "Redefinition of property");
	}
  } else {
	other = propHash[name] = {
			init: false,
			get: false,
			set: false
	};
  }
  other[kind] = true;
};
pp$3.parseExpression = function (noIn, refDestructuringErrors) {
  var this$1 = this;

  var startPos = this.start,
			startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
  if (this.type === types.comma) {
	var node = this.startNodeAt(startPos, startLoc);
	node.expressions = [expr];
	while (this.eat(types.comma)) {
			node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors));
	}
	return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};
pp$3.parseMaybeAssign = function (noIn, refDestructuringErrors, afterLeftParse) {
  if (this.inGenerator && this.isContextual("yield")) {
	return this.parseYield();
  }

  var ownDestructuringErrors = false,
			oldParenAssign = -1,
			oldTrailingComma = -1;
  if (refDestructuringErrors) {
	oldParenAssign = refDestructuringErrors.parenthesizedAssign;
	oldTrailingComma = refDestructuringErrors.trailingComma;
	refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
	refDestructuringErrors = new DestructuringErrors();
	ownDestructuringErrors = true;
  }

  var startPos = this.start,
			startLoc = this.startLoc;
  if (this.type == types.parenL || this.type == types.name) {
	this.potentialArrowAt = this.start;
  }
  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
  if (afterLeftParse) {
	left = afterLeftParse.call(this, left, startPos, startLoc);
  }
  if (this.type.isAssign) {
	this.checkPatternErrors(refDestructuringErrors, true);
	if (!ownDestructuringErrors) {
			DestructuringErrors.call(refDestructuringErrors);
	}
	var node = this.startNodeAt(startPos, startLoc);
	node.operator = this.value;
	node.left = this.type === types.eq ? this.toAssignable(left) : left;
	refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly
	this.checkLVal(left);
	this.next();
	node.right = this.parseMaybeAssign(noIn);
	return this.finishNode(node, "AssignmentExpression");
  } else {
	if (ownDestructuringErrors) {
			this.checkExpressionErrors(refDestructuringErrors, true);
	}
  }
  if (oldParenAssign > -1) {
	refDestructuringErrors.parenthesizedAssign = oldParenAssign;
  }
  if (oldTrailingComma > -1) {
	refDestructuringErrors.trailingComma = oldTrailingComma;
  }
  return left;
};
pp$3.parseMaybeConditional = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
			startLoc = this.startLoc;
  var expr = this.parseExprOps(noIn, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
	return expr;
  }
  if (this.eat(types.question)) {
	var node = this.startNodeAt(startPos, startLoc);
	node.test = expr;
	node.consequent = this.parseMaybeAssign();
	this.expect(types.colon);
	node.alternate = this.parseMaybeAssign(noIn);
	return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};
pp$3.parseExprOps = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
			startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
	return expr;
  }
  return expr.start == startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn);
};
pp$3.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.type.binop;
  if (prec != null && (!noIn || this.type !== types._in)) {
	if (prec > minPrec) {
			var logical = this.type === types.logicalOR || this.type === types.logicalAND;
			var op = this.value;
			this.next();
			var startPos = this.start,
					startLoc = this.startLoc;
			var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
			var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
			return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
	}
  }
  return left;
};

pp$3.buildBinary = function (startPos, startLoc, left, right, op, logical) {
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
};
pp$3.parseMaybeUnary = function (refDestructuringErrors, sawUnary) {
  var this$1 = this;

  var startPos = this.start,
			startLoc = this.startLoc,
			expr;
  if (this.inAsync && this.isContextual("await")) {
	expr = this.parseAwait();
	sawUnary = true;
  } else if (this.type.prefix) {
	var node = this.startNode(),
		update = this.type === types.incDec;
	node.operator = this.value;
	node.prefix = true;
	this.next();
	node.argument = this.parseMaybeUnary(null, true);
	this.checkExpressionErrors(refDestructuringErrors, true);
	if (update) {
			this.checkLVal(node.argument);
	} else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") {
			this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
	} else {
			sawUnary = true;
	}
	expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else {
	expr = this.parseExprSubscripts(refDestructuringErrors);
	if (this.checkExpressionErrors(refDestructuringErrors)) {
			return expr;
	}
	while (this.type.postfix && !this.canInsertSemicolon()) {
			var node$1 = this$1.startNodeAt(startPos, startLoc);
			node$1.operator = this$1.value;
			node$1.prefix = false;
			node$1.argument = expr;
			this$1.checkLVal(expr);
			this$1.next();
			expr = this$1.finishNode(node$1, "UpdateExpression");
	}
  }

  if (!sawUnary && this.eat(types.starstar)) {
	return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false);
  } else {
	return expr;
  }
};
pp$3.parseExprSubscripts = function (refDestructuringErrors) {
  var startPos = this.start,
			startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);
  var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) {
	return expr;
  }
  var result = this.parseSubscripts(expr, startPos, startLoc);
  if (refDestructuringErrors && result.type === "MemberExpression") {
	if (refDestructuringErrors.parenthesizedAssign >= result.start) {
			refDestructuringErrors.parenthesizedAssign = -1;
	}
	if (refDestructuringErrors.parenthesizedBind >= result.start) {
			refDestructuringErrors.parenthesizedBind = -1;
	}
  }
  return result;
};

pp$3.parseSubscripts = function (base, startPos, startLoc, noCalls) {
  var this$1 = this;

  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd == base.end && !this.canInsertSemicolon();
  for (var computed = void 0;;) {
	if ((computed = this$1.eat(types.bracketL)) || this$1.eat(types.dot)) {
			var node$1 = this$1.startNodeAt(startPos, startLoc);
			node$1.object = base;
			node$1.property = computed ? this$1.parseExpression() : this$1.parseIdent(true);
			node$1.computed = !!computed;
			if (computed) {
		this$1.expect(types.bracketR);
			}
			base = this$1.finishNode(node$1, "MemberExpression");
	} else if (!noCalls && this$1.eat(types.parenL)) {
			var refDestructuringErrors = new DestructuringErrors(),
					oldYieldPos = this$1.yieldPos,
					oldAwaitPos = this$1.awaitPos;
			this$1.yieldPos = 0;
			this$1.awaitPos = 0;
			var exprList = this$1.parseExprList(types.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors);
			if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(types.arrow)) {
		this$1.checkPatternErrors(refDestructuringErrors, false);
		this$1.checkYieldAwaitInDefaultParams();
		this$1.yieldPos = oldYieldPos;
		this$1.awaitPos = oldAwaitPos;
		return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true);
			}
			this$1.checkExpressionErrors(refDestructuringErrors, true);
			this$1.yieldPos = oldYieldPos || this$1.yieldPos;
			this$1.awaitPos = oldAwaitPos || this$1.awaitPos;
			var node$2 = this$1.startNodeAt(startPos, startLoc);
			node$2.callee = base;
			node$2.arguments = exprList;
			base = this$1.finishNode(node$2, "CallExpression");
	} else if (this$1.type === types.backQuote) {
			var node$3 = this$1.startNodeAt(startPos, startLoc);
			node$3.tag = base;
			node$3.quasi = this$1.parseTemplate({ isTagged: true });
			base = this$1.finishNode(node$3, "TaggedTemplateExpression");
	} else if (this$1.type == types.colon && this$1.input[this$1.end] == ":" && this$1.options.ecmaVersion >= 7) {
			this$1.next();
			this$1.next();
			var node = this$1.startNodeAt(startPos, startLoc);
			node.expressions = [base];
			var e2 = this$1.parseExpression();
			node.expressions.push(e2);
			base = this$1.finishNode(node, "SequenceExpression");
	} else {
			return base;
	}
  }
};
pp$3.parseExprAtom = function (refDestructuringErrors) {
  var node,
			canBeArrow = this.potentialArrowAt == this.start;
  switch (this.type) {
	case types._super:
			if (!this.inFunction) {
		this.raise(this.start, "'super' outside of function or class");
			}
			node = this.startNode();
			this.next();
			if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL) {
		this.unexpected();
			}
			return this.finishNode(node, "Super");

	case types._this:
			node = this.startNode();
			this.next();
			return this.finishNode(node, "ThisExpression");

	case types.name:
			var startPos = this.start,
					startLoc = this.startLoc;
			var id = this.parseIdent(this.type !== types.name);
			if (this.options.ecmaVersion >= 8 && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function)) {
		return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true);
			}
			if (canBeArrow && !this.canInsertSemicolon()) {
		if (this.eat(types.arrow)) {
					return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false);
		}
		if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name) {
					id = this.parseIdent();
					if (this.canInsertSemicolon() || !this.eat(types.arrow)) {
			this.unexpected();
					}
					return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true);
		}
			}
			return id;

	case types.regexp:
			var value = this.value;
			node = this.parseLiteral(value.value);
			node.regex = { pattern: value.pattern, flags: value.flags };
			return node;

	case types.num:case types.string:
			return this.parseLiteral(this.value);

	case types._null:case types._true:case types._false:
			node = this.startNode();
			node.value = this.type === types._null ? null : this.type === types._true;
			node.raw = this.type.keyword;
			this.next();
			return this.finishNode(node, "Literal");

	case types.parenL:
			var start = this.start,
					expr = this.parseParenAndDistinguishExpression(canBeArrow);
			if (refDestructuringErrors) {
		if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
					refDestructuringErrors.parenthesizedAssign = start;
		}
		if (refDestructuringErrors.parenthesizedBind < 0) {
					refDestructuringErrors.parenthesizedBind = start;
		}
			}
			return expr;

	case types.bracketL:
			node = this.startNode();
			this.next();
			node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
			return this.finishNode(node, "ArrayExpression");

	case types.braceL:
			return this.parseObj(false, refDestructuringErrors);

	case types._function:
			node = this.startNode();
			this.next();
			return this.parseFunction(node, false);

	case types._class:
			return this.parseClass(this.startNode(), false);

	case types._new:
			return this.parseNew();

	case types.backQuote:
			return this.parseTemplate();

	case types._do:
			this.next();
			return this.parseStatement();
	case types.at:
			this.next();
			return this.parseExprAtom();
	case types.colon:
			if (this.input[this.end] == ":") {
		this.next();
		this.next();
		return this.parseExprSubscripts(refDestructuringErrors);
			}

	default:
			this.unexpected();
  }
};

pp$3.parseLiteral = function (value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  this.next();
  return this.finishNode(node, "Literal");
};

pp$3.parseParenExpression = function () {
  this.expect(types.parenL);
  var val = this.parseExpression();
  this.expect(types.parenR);
  return val;
};

pp$3.parseParenAndDistinguishExpression = function (canBeArrow) {
  var this$1 = this;

  var startPos = this.start,
			startLoc = this.startLoc,
			val,
			allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
	this.next();

	var innerStartPos = this.start,
		innerStartLoc = this.startLoc;
	var exprList = [],
		first = true,
		lastIsComma = false;
	var refDestructuringErrors = new DestructuringErrors(),
		oldYieldPos = this.yieldPos,
		oldAwaitPos = this.awaitPos,
		spreadStart;
	this.yieldPos = 0;
	this.awaitPos = 0;
	while (this.type !== types.parenR) {
			first ? first = false : this$1.expect(types.comma);
			if (allowTrailingComma && this$1.afterTrailingComma(types.parenR, true)) {
		lastIsComma = true;
		break;
			} else if (this$1.type === types.ellipsis) {
		spreadStart = this$1.start;
		exprList.push(this$1.parseParenItem(this$1.parseRestBinding()));
		if (this$1.type === types.comma) {
					this$1.raise(this$1.start, "Comma is not permitted after the rest element");
		}
		break;
			} else {
		exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem));
			}
	}
	var innerEndPos = this.start,
		innerEndLoc = this.startLoc;
	this.expect(types.parenR);

	if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
			this.checkPatternErrors(refDestructuringErrors, false);
			this.checkYieldAwaitInDefaultParams();
			this.yieldPos = oldYieldPos;
			this.awaitPos = oldAwaitPos;
			return this.parseParenArrowList(startPos, startLoc, exprList);
	}

	if (!exprList.length || lastIsComma) {
			this.unexpected(this.lastTokStart);
	}
	if (spreadStart) {
			this.unexpected(spreadStart);
	}
	this.checkExpressionErrors(refDestructuringErrors, true);
	this.yieldPos = oldYieldPos || this.yieldPos;
	this.awaitPos = oldAwaitPos || this.awaitPos;

	if (exprList.length > 1) {
			val = this.startNodeAt(innerStartPos, innerStartLoc);
			val.expressions = exprList;
			this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
	} else {
			val = exprList[0];
	}
  } else {
	val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
	var par = this.startNodeAt(startPos, startLoc);
	par.expression = val;
	return this.finishNode(par, "ParenthesizedExpression");
  } else {
	return val;
  }
};

pp$3.parseParenItem = function (item) {
  return item;
};

pp$3.parseParenArrowList = function (startPos, startLoc, exprList) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
};
var empty$1 = [];

pp$3.parseNew = function () {
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
	node.meta = meta;
	node.property = this.parseIdent(true);
	if (node.property.name !== "target") {
			this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target");
	}
	if (!this.inFunction) {
			this.raiseRecoverable(node.start, "new.target can only be used in functions");
	}
	return this.finishNode(node, "MetaProperty");
  }
  var startPos = this.start,
			startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  if (this.eat(types.parenL)) {
	node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false);
  } else {
	node.arguments = empty$1;
  }
  return this.finishNode(node, "NewExpression");
};
pp$3.parseTemplateElement = function (ref) {
  var isTagged = ref.isTagged;

  var elem = this.startNode();
  if (this.type === types.invalidTemplate) {
	if (!isTagged) {
			this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
	}
	elem.value = {
			raw: this.value,
			cooked: null
	};
  } else {
	elem.value = {
			raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
			cooked: this.value
	};
  }
  this.next();
  elem.tail = this.type === types.backQuote;
  return this.finishNode(elem, "TemplateElement");
};

pp$3.parseTemplate = function (ref) {
  var this$1 = this;
  if (ref === void 0) ref = {};
  var isTagged = ref.isTagged;if (isTagged === void 0) isTagged = false;

  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({ isTagged: isTagged });
  node.quasis = [curElt];
  while (!curElt.tail) {
	this$1.expect(types.dollarBraceL);
	node.expressions.push(this$1.parseExpression());
	this$1.expect(types.braceR);
	node.quasis.push(curElt = this$1.parseTemplateElement({ isTagged: isTagged }));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral");
};

pp$3.isAsyncProp = function (prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$3.parseObj = function (isPattern, refDestructuringErrors) {
  var this$1 = this;

  var node = this.startNode(),
			first = true,
			propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types.braceR)) {
	if (!first) {
			this$1.expect(types.comma);
			if (this$1.afterTrailingComma(types.braceR)) {
		break;
			}
	} else {
			first = false;
	}

	var prop = this$1.parseProperty(isPattern, refDestructuringErrors);
	if (!isPattern) {
			this$1.checkPropClash(prop, propHash);
	}
	node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};

pp$3.parseProperty = function (isPattern, refDestructuringErrors) {
  var prop = this.startNode(),
			isGenerator,
			isAsync,
			startPos,
			startLoc;
  if (this.options.ecmaVersion >= 6) {
	prop.method = false;
	prop.shorthand = false;
	if (isPattern || refDestructuringErrors) {
			startPos = this.start;
			startLoc = this.startLoc;
	}
	if (!isPattern) {
			isGenerator = this.eat(types.star);
	}
  }
  this.parsePropertyName(prop);
  if (!isPattern && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
	isAsync = true;
	this.parsePropertyName(prop, refDestructuringErrors);
  } else {
	isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors);
  return this.finishNode(prop, "Property");
};

pp$3.parsePropertyValue = function (prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors) {
  if ((isGenerator || isAsync) && this.type === types.colon) {
	this.unexpected();
  }

  if (this.eat(types.colon)) {
	prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
	prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
	if (isPattern) {
			this.unexpected();
	}
	prop.kind = "init";
	prop.method = true;
	prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && this.type != types.comma && this.type != types.braceR) {
	if (isGenerator || isAsync) {
			this.unexpected();
	}
	prop.kind = prop.key.name;
	this.parsePropertyName(prop);
	prop.value = this.parseMethod(false);
	var paramCount = prop.kind === "get" ? 0 : 1;
	if (prop.value.params.length !== paramCount) {
			var start = prop.value.start;
			if (prop.kind === "get") {
		this.raiseRecoverable(start, "getter should have no params");
			} else {
		this.raiseRecoverable(start, "setter should have exactly one param");
			}
	} else {
			if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
		this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
			}
	}
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
	this.checkUnreserved(prop.key);
	prop.kind = "init";
	if (isPattern) {
			prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
	} else if (this.type === types.eq && refDestructuringErrors) {
			if (refDestructuringErrors.shorthandAssign < 0) {
		refDestructuringErrors.shorthandAssign = this.start;
			}
			prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
	} else {
			prop.value = prop.key;
	}
	prop.shorthand = true;
  } else {
	this.unexpected();
  }
};

pp$3.parsePropertyName = function (prop) {
  if (this.options.ecmaVersion >= 6) {
	if (this.eat(types.bracketL)) {
			prop.computed = true;
			prop.key = this.parseMaybeAssign();
			this.expect(types.bracketR);
			return prop.key;
	} else {
			prop.computed = false;
	}
  }
  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(true);
};
pp$3.initFunction = function (node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) {
	node.generator = false;
	node.expression = false;
  }
  if (this.options.ecmaVersion >= 8) {
	node.async = false;
  }
};
pp$3.parseMethod = function (isGenerator, isAsync) {
  var node = this.startNode(),
			oldInGen = this.inGenerator,
			oldInAsync = this.inAsync,
			oldYieldPos = this.yieldPos,
			oldAwaitPos = this.awaitPos,
			oldInFunc = this.inFunction;

  this.initFunction(node);
  if (this.options.ecmaVersion >= 6) {
	node.generator = isGenerator;
  }
  if (this.options.ecmaVersion >= 8) {
	node.async = !!isAsync;
  }

  this.inGenerator = node.generator;
  this.inAsync = node.async;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.inFunction = true;
  this.enterFunctionScope();

  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false);

  this.inGenerator = oldInGen;
  this.inAsync = oldInAsync;
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.inFunction = oldInFunc;
  return this.finishNode(node, "FunctionExpression");
};
pp$3.parseArrowExpression = function (node, params, isAsync) {
  var oldInGen = this.inGenerator,
			oldInAsync = this.inAsync,
			oldYieldPos = this.yieldPos,
			oldAwaitPos = this.awaitPos,
			oldInFunc = this.inFunction;

  this.enterFunctionScope();
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8) {
	node.async = !!isAsync;
  }

  this.inGenerator = false;
  this.inAsync = node.async;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.inFunction = true;

  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true);

  this.inGenerator = oldInGen;
  this.inAsync = oldInAsync;
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.inFunction = oldInFunc;
  return this.finishNode(node, "ArrowFunctionExpression");
};
pp$3.parseFunctionBody = function (node, isArrowFunction) {
  var isExpression = isArrowFunction && this.type !== types.braceL;
  var oldStrict = this.strict,
			useStrict = false;

  if (isExpression) {
	node.body = this.parseMaybeAssign();
	node.expression = true;
	this.checkParams(node, false);
  } else {
	var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
	if (!oldStrict || nonSimple) {
			useStrict = this.strictDirective(this.end);
			if (useStrict && nonSimple) {
		this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
			}
	}
	var oldLabels = this.labels;
	this.labels = [];
	if (useStrict) {
			this.strict = true;
	}
	this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && this.isSimpleParamList(node.params));
	node.body = this.parseBlock(false);
	node.expression = false;
	this.adaptDirectivePrologue(node.body.body);
	this.labels = oldLabels;
  }
  this.exitFunctionScope();

  if (this.strict && node.id) {
	this.checkLVal(node.id, "none");
  }
  this.strict = oldStrict;
};

pp$3.isSimpleParamList = function (params) {
  for (var i = 0, list = params; i < list.length; i += 1) {
	var param = list[i];

	if (param.type !== "Identifier") {
			return false;
	}
  }
  return true;
};
pp$3.checkParams = function (node, allowDuplicates) {
  var this$1 = this;

  var nameHash = {};
  for (var i = 0, list = node.params; i < list.length; i += 1) {
	var param = list[i];

	this$1.checkLVal(param, "var", allowDuplicates ? null : nameHash);
  }
};
pp$3.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var this$1 = this;

  var elts = [],
			first = true;
  while (!this.eat(close)) {
	if (!first) {
			this$1.expect(types.comma);
			if (allowTrailingComma && this$1.afterTrailingComma(close)) {
		break;
			}
	} else {
			first = false;
	}

	var elt = void 0;
	if (allowEmpty && this$1.type === types.comma) {
			elt = null;
	} else if (this$1.type === types.ellipsis) {
			elt = this$1.parseSpread(refDestructuringErrors);
			if (refDestructuringErrors && this$1.type === types.comma && refDestructuringErrors.trailingComma < 0) {
		refDestructuringErrors.trailingComma = this$1.start;
			}
	} else {
			elt = this$1.parseMaybeAssign(false, refDestructuringErrors);
	}
	elts.push(elt);
  }
  return elts;
};

pp$3.checkUnreserved = function (ref) {
  var start = ref.start;
  var end = ref.end;
  var name = ref.name;

  if (this.inGenerator && name === "yield") {
	this.raiseRecoverable(start, "Can not use 'yield' as identifier inside a generator");
  }
  if (this.inAsync && name === "await") {
	this.raiseRecoverable(start, "Can not use 'await' as identifier inside an async function");
  }
  if (this.isKeyword(name)) {
	this.raise(start, "Unexpected keyword '" + name + "'");
  }
  if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") != -1) {
	return;
  }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
	this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
  }
};
pp$3.parseIdent = function (liberal, isBinding) {
  var node = this.startNode();
  if (liberal && this.options.allowReserved == "never") {
	liberal = false;
  }
  if (this.type === types.name) {
	node.name = this.value;
  } else if (this.type.keyword) {
	node.name = this.type.keyword;
	if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
			this.context.pop();
	}
  } else {
	this.unexpected();
  }
  this.next();
  this.finishNode(node, "Identifier");
  if (!liberal) {
	this.checkUnreserved(node);
  }
  return node;
};
pp$3.parseYield = function () {
  if (!this.yieldPos) {
	this.yieldPos = this.start;
  }

  var node = this.startNode();
  this.next();
  if (this.type == types.semi || this.canInsertSemicolon() || this.type != types.star && !this.type.startsExpr) {
	node.delegate = false;
	node.argument = null;
  } else {
	node.delegate = this.eat(types.star);
	node.argument = this.parseMaybeAssign();
  }
  return this.finishNode(node, "YieldExpression");
};

pp$3.parseAwait = function () {
  if (!this.awaitPos) {
	this.awaitPos = this.start;
  }

  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true);
  return this.finishNode(node, "AwaitExpression");
};

var pp$4 = Parser.prototype;
pp$4.raise = function (pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos;err.loc = loc;err.raisedAt = this.pos;
  throw err;
};

pp$4.raiseRecoverable = pp$4.raise;

pp$4.curPosition = function () {
  if (this.options.locations) {
	return new Position(this.curLine, this.pos - this.lineStart);
  }
};

var pp$5 = Parser.prototype;
var assign = Object.assign || function (target) {
  var sources = [],
			len = arguments.length - 1;
  while (len-- > 0) {
	sources[len] = arguments[len + 1];
  }for (var i = 0, list = sources; i < list.length; i += 1) {
	var source = list[i];

	for (var key in source) {
			if (has(source, key)) {
		target[key] = source[key];
			}
	}
  }
  return target;
};
pp$5.enterFunctionScope = function () {
  this.scopeStack.push({ var: {}, lexical: {}, childVar: {}, parentLexical: {} });
};

pp$5.exitFunctionScope = function () {
  this.scopeStack.pop();
};

pp$5.enterLexicalScope = function () {
  var parentScope = this.scopeStack[this.scopeStack.length - 1];
  var childScope = { var: {}, lexical: {}, childVar: {}, parentLexical: {} };

  this.scopeStack.push(childScope);
  assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical);
};

pp$5.exitLexicalScope = function () {
  var childScope = this.scopeStack.pop();
  var parentScope = this.scopeStack[this.scopeStack.length - 1];

  assign(parentScope.childVar, childScope.var, childScope.childVar);
};
pp$5.canDeclareVarName = function (name) {
  var currentScope = this.scopeStack[this.scopeStack.length - 1];

  return !has(currentScope.lexical, name) && !has(currentScope.parentLexical, name);
};
pp$5.canDeclareLexicalName = function (name) {
  var currentScope = this.scopeStack[this.scopeStack.length - 1];

  return !has(currentScope.lexical, name) && !has(currentScope.var, name) && !has(currentScope.childVar, name);
};

pp$5.declareVarName = function (name) {
  this.scopeStack[this.scopeStack.length - 1].var[name] = true;
};

pp$5.declareLexicalName = function (name) {
  this.scopeStack[this.scopeStack.length - 1].lexical[name] = true;
};

var Node = function Node(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations) {
	this.loc = new SourceLocation(parser, loc);
  }
  if (parser.options.directSourceFile) {
	this.sourceFile = parser.options.directSourceFile;
  }
  if (parser.options.ranges) {
	this.range = [pos, 0];
  }
};
var pp$6 = Parser.prototype;

pp$6.startNode = function () {
  return new Node(this, this.start, this.startLoc);
};

pp$6.startNodeAt = function (pos, loc) {
  return new Node(this, pos, loc);
};
function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations) {
	node.loc.end = loc;
  }
  if (this.options.ranges) {
	node.range[1] = pos;
  }
  return node;
}

pp$6.finishNode = function (node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
};
pp$6.finishNodeAt = function (node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc);
};
var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};

var types$1 = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) {
	return p.tryReadTemplateToken();
  }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};

var pp$7 = Parser.prototype;

pp$7.initialContext = function () {
  return [types$1.b_stat];
};

pp$7.braceIsBlock = function (prevType) {
  var parent = this.curContext();
  if (parent === types$1.f_expr || parent === types$1.f_stat) {
	return true;
  }
  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr)) {
	return !parent.isExpr;
  }
  if (prevType === types._return || prevType == types.name && this.exprAllowed) {
	return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  }
  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType == types.arrow) {
	return true;
  }
  if (prevType == types.braceL) {
	return parent === types$1.b_stat;
  }
  if (prevType == types._var || prevType == types.name) {
	return false;
  }
  return !this.exprAllowed;
};

pp$7.inGeneratorContext = function () {
  var this$1 = this;

  for (var i = this.context.length - 1; i >= 1; i--) {
	var context = this$1.context[i];
	if (context.token === "function") {
			return context.generator;
	}
  }
  return false;
};

pp$7.updateContext = function (prevType) {
  var update,
			type = this.type;
  if (type.keyword && prevType == types.dot) {
	this.exprAllowed = false;
  } else if (update = type.updateContext) {
	update.call(this, prevType);
  } else {
	this.exprAllowed = type.beforeExpr;
  }
};
types.parenR.updateContext = types.braceR.updateContext = function () {
  if (this.context.length == 1) {
	this.exprAllowed = true;
	return;
  }
  var out = this.context.pop();
  if (out === types$1.b_stat && this.curContext().token === "function") {
	out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};

types.braceL.updateContext = function (prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
  this.exprAllowed = true;
};

types.dollarBraceL.updateContext = function () {
  this.context.push(types$1.b_tmpl);
  this.exprAllowed = true;
};

types.parenL.updateContext = function (prevType) {
  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
  this.exprAllowed = true;
};

types.incDec.updateContext = function () {
};

types._function.updateContext = types._class.updateContext = function (prevType) {
  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) {
	this.context.push(types$1.f_expr);
  } else {
	this.context.push(types$1.f_stat);
  }
  this.exprAllowed = false;
};

types.backQuote.updateContext = function () {
  if (this.curContext() === types$1.q_tmpl) {
	this.context.pop();
  } else {
	this.context.push(types$1.q_tmpl);
  }
  this.exprAllowed = false;
};

types.star.updateContext = function (prevType) {
  if (prevType == types._function) {
	var index = this.context.length - 1;
	if (this.context[index] === types$1.f_expr) {
			this.context[index] = types$1.f_expr_gen;
	} else {
			this.context[index] = types$1.f_gen;
	}
  }
  this.exprAllowed = true;
};

types.name.updateContext = function (prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6) {
	if (this.value == "of" && !this.exprAllowed || this.value == "yield" && this.inGeneratorContext()) {
			allowed = true;
	}
  }
  this.exprAllowed = allowed;
};
var Token = function Token(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations) {
	this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
  }
  if (p.options.ranges) {
	this.range = [p.start, p.end];
  }
};
var pp$8 = Parser.prototype;
var isRhino = (typeof Packages === "undefined" ? "undefined" : _typeof(Packages)) == "object" && Object.prototype.toString.call(Packages) == "[object JavaPackage]";
pp$8.next = function () {
  if (this.options.onToken) {
	this.options.onToken(new Token(this));
  }

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};

pp$8.getToken = function () {
  this.next();
  return new Token(this);
};
if (typeof Symbol !== "undefined") {
  pp$8[Symbol.iterator] = function () {
	var this$1 = this;

	return {
			next: function next() {
		var token = this$1.getToken();
		return {
					done: token.type === types.eof,
					value: token
		};
			}
	};
  };
}
pp$8.curContext = function () {
  return this.context[this.context.length - 1];
};
pp$8.nextToken = function () {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) {
	this.skipSpace();
  }

  this.start = this.pos;
  if (this.options.locations) {
	this.startLoc = this.curPosition();
  }
  if (this.pos >= this.input.length) {
	return this.finishToken(types.eof);
  }

  if (curContext.override) {
	return curContext.override(this);
  } else {
	this.readToken(this.fullCharCodeAtPos());
  }
};

pp$8.readToken = function (code) {
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */) {
			return this.readWord();
	}

  return this.getTokenFromCode(code);
};

pp$8.fullCharCodeAtPos = function () {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 0xd7ff || code >= 0xe000) {
	return code;
  }
  var next = this.input.charCodeAt(this.pos + 1);
  return (code << 10) + next - 0x35fdc00;
};

pp$8.skipBlockComment = function () {
  var this$1 = this;

  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos,
			end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) {
	this.raise(this.pos - 2, "Unterminated comment");
  }
  this.pos = end + 2;
  if (this.options.locations) {
	lineBreakG.lastIndex = start;
	var match;
	while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
			++this$1.curLine;
			this$1.lineStart = match.index + match[0].length;
	}
  }
  if (this.options.onComment) {
	this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
  }
};

pp$8.skipLineComment = function (startSkip) {
  var this$1 = this;

  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
	ch = this$1.input.charCodeAt(++this$1.pos);
  }
  if (this.options.onComment) {
	this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
  }
};
pp$8.skipSpace = function () {
  var this$1 = this;

  loop: while (this.pos < this.input.length) {
	var ch = this$1.input.charCodeAt(this$1.pos);
	switch (ch) {
			case 32:case 160:
		++this$1.pos;
		break;
			case 13:
		if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {
					++this$1.pos;
		}
			case 10:case 8232:case 8233:
		++this$1.pos;
		if (this$1.options.locations) {
					++this$1.curLine;
					this$1.lineStart = this$1.pos;
		}
		break;
			case 47:
		switch (this$1.input.charCodeAt(this$1.pos + 1)) {
					case 42:
			this$1.skipBlockComment();
			break;
					case 47:
			this$1.skipLineComment(2);
			break;
					default:
			break loop;
		}
		break;
			default:
		if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
					++this$1.pos;
		} else {
					break loop;
		}
	}
  }
};
pp$8.finishToken = function (type, val) {
  this.end = this.pos;
  if (this.options.locations) {
	this.endLoc = this.curPosition();
  }
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.updateContext(prevType);
};
//
//
pp$8.readToken_dot = function () {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) {
	return this.readNumber(true);
  }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
	this.pos += 3;
	return this.finishToken(types.ellipsis);
  } else {
	++this.pos;
	return this.finishToken(types.dot);
  }
};

pp$8.readToken_slash = function () {
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
	++this.pos;return this.readRegexp();
  }
  if (next === 61) {
	return this.finishOp(types.assign, 2);
  }
  return this.finishOp(types.slash, 1);
};

pp$8.readToken_mult_modulo_exp = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types.star : types.modulo;
  if (this.options.ecmaVersion >= 7 && code == 42 && next === 42) {
	++size;
	tokentype = types.starstar;
	next = this.input.charCodeAt(this.pos + 2);
  }

  if (next === 61) {
	return this.finishOp(types.assign, size + 1);
  }
  return this.finishOp(tokentype, size);
};

pp$8.readToken_pipe_amp = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
	return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);
  }
  if (next === 61) {
	return this.finishOp(types.assign, 2);
  }
  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);
};

pp$8.readToken_caret = function () {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
	return this.finishOp(types.assign, 2);
  }
  return this.finishOp(types.bitwiseXOR, 1);
};

pp$8.readToken_plus_min = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
	if (next == 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) == 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
			this.skipLineComment(3);
			this.skipSpace();
			return this.nextToken();
	}
	return this.finishOp(types.incDec, 2);
  }
  if (next === 61) {
	return this.finishOp(types.assign, 2);
  }
  return this.finishOp(types.plusMin, 1);
};

pp$8.readToken_lt_gt = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
	size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
	if (this.input.charCodeAt(this.pos + size) === 61) {
			return this.finishOp(types.assign, size + 1);
	}
	return this.finishOp(types.bitShift, size);
  }
  if (next == 33 && code == 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) == 45 && this.input.charCodeAt(this.pos + 3) == 45) {
	this.skipLineComment(4);
	this.skipSpace();
	return this.nextToken();
  }
  if (next === 61) {
	size = 2;
  }
  return this.finishOp(types.relational, size);
};

pp$8.readToken_eq_excl = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
	return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  }
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
	this.pos += 2;
	return this.finishToken(types.arrow);
  }
  return this.finishOp(code === 61 ? types.eq : types.prefix, 1);
};

pp$8.getTokenFromCode = function (code) {
  switch (code) {
	case 46:
			return this.readToken_dot();
	case 40:
			++this.pos;return this.finishToken(types.parenL);
	case 41:
			++this.pos;return this.finishToken(types.parenR);
	case 59:
			++this.pos;return this.finishToken(types.semi);
	case 44:
			++this.pos;return this.finishToken(types.comma);
	case 91:
			++this.pos;return this.finishToken(types.bracketL);
	case 93:
			++this.pos;return this.finishToken(types.bracketR);
	case 123:
			++this.pos;return this.finishToken(types.braceL);
	case 125:
			++this.pos;return this.finishToken(types.braceR);
	case 58:
			++this.pos;return this.finishToken(types.colon);
	case 63:
			++this.pos;return this.finishToken(types.question);

	case 96:
			if (this.options.ecmaVersion < 6) {
		break;
			}
			++this.pos;
			return this.finishToken(types.backQuote);

	case 48:
			var next = this.input.charCodeAt(this.pos + 1);
			if (next === 120 || next === 88) {
		return this.readRadixNumber(16);
			} // '0x', '0X' - hex number
			if (this.options.ecmaVersion >= 6) {
		if (next === 111 || next === 79) {
					return this.readRadixNumber(8);
		} // '0o', '0O' - octal number
		if (next === 98 || next === 66) {
					return this.readRadixNumber(2);
		} // '0b', '0B' - binary number
			}
	case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
			return this.readNumber(false);
	case 34:case 39:
			return this.readString(code);
	case 47:
			return this.readToken_slash();

	case 37:case 42:
			return this.readToken_mult_modulo_exp(code);

	case 124:case 38:
			return this.readToken_pipe_amp(code);

	case 94:
			return this.readToken_caret();

	case 43:case 45:
			return this.readToken_plus_min(code);

	case 60:case 62:
			return this.readToken_lt_gt(code);

	case 61:case 33:
			return this.readToken_eq_excl(code);

	case 126:
			return this.finishOp(types.prefix, 1);
	case 64:
			++this.pos;return this.finishToken(types.at);
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};

pp$8.finishOp = function (type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str);
};
function tryCreateRegexp(src, flags, throwErrorAt, parser) {
  try {
	return new RegExp(src, flags);
  } catch (e) {
	if (throwErrorAt !== undefined) {
			if (e instanceof SyntaxError) {
		parser.raise(throwErrorAt, "Error parsing regular expression: " + e.message);
			}
			throw e;
	}
  }
}

var regexpUnicodeSupport = !!tryCreateRegexp("\uFFFF", "u");

pp$8.readRegexp = function () {
  var this$1 = this;

  var escaped,
			inClass,
			start = this.pos;
  for (;;) {
	if (this$1.pos >= this$1.input.length) {
			this$1.raise(start, "Unterminated regular expression");
	}
	var ch = this$1.input.charAt(this$1.pos);
	if (lineBreak.test(ch)) {
			this$1.raise(start, "Unterminated regular expression");
	}
	if (!escaped) {
			if (ch === "[") {
		inClass = true;
			} else if (ch === "]" && inClass) {
		inClass = false;
			} else if (ch === "/" && !inClass) {
		break;
			}
			escaped = ch === "\\";
	} else {
			escaped = false;
	}
	++this$1.pos;
  }
  var content = this.input.slice(start, this.pos);
  ++this.pos;
  var mods = this.readWord1();
  var tmp = content,
			tmpFlags = "";
  if (mods) {
	var validFlags = /^[gim]*$/;
	if (this.options.ecmaVersion >= 6) {
			validFlags = /^[gimuy]*$/;
	}
	if (!validFlags.test(mods)) {
			this.raise(start, "Invalid regular expression flag");
	}
	if (mods.indexOf("u") >= 0) {
			if (regexpUnicodeSupport) {
		tmpFlags = "u";
			} else {
		tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, function (_match, code, offset) {
					code = Number("0x" + code);
					if (code > 0x10FFFF) {
			this$1.raise(start + offset + 3, "Code point out of bounds");
					}
					return "x";
		});
		tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
		tmpFlags = tmpFlags.replace("u", "");
			}
	}
  }
  var value = null;
  if (!isRhino) {
	tryCreateRegexp(tmp, tmpFlags, start, this);
	value = tryCreateRegexp(content, mods);
  }
  return this.finishToken(types.regexp, { pattern: content, flags: mods, value: value });
};
pp$8.readInt = function (radix, len) {
  var this$1 = this;

  var start = this.pos,
			total = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
	var code = this$1.input.charCodeAt(this$1.pos),
		val = void 0;
	if (code >= 97) {
			val = code - 97 + 10;
	} // a
	else if (code >= 65) {
		val = code - 65 + 10;
			} // A
			else if (code >= 48 && code <= 57) {
					val = code - 48;
		} // 0-9
		else {
			val = Infinity;
					}
	if (val >= radix) {
			break;
	}
	++this$1.pos;
	total = total * radix + val;
  }
  if (this.pos === start || len != null && this.pos - start !== len) {
	return null;
  }

  return total;
};

pp$8.readRadixNumber = function (radix) {
  this.pos += 2; // 0x
  var val = this.readInt(radix);
  if (val == null) {
	this.raise(this.start + 2, "Expected number in radix " + radix);
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) {
	this.raise(this.pos, "Identifier directly after number");
  }
  return this.finishToken(types.num, val);
};
pp$8.readNumber = function (startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10) === null) {
	this.raise(start, "Invalid number");
  }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) {
	this.raise(start, "Invalid number");
  }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
	octal = false;
  }
  var next = this.input.charCodeAt(this.pos);
  if (next === 46 && !octal) {
	++this.pos;
	this.readInt(10);
	next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) {
	next = this.input.charCodeAt(++this.pos);
	if (next === 43 || next === 45) {
			++this.pos;
	} // '+-'
	if (this.readInt(10) === null) {
			this.raise(start, "Invalid number");
	}
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) {
	this.raise(this.pos, "Identifier directly after number");
  }

  var str = this.input.slice(start, this.pos);
  var val = octal ? parseInt(str, 8) : parseFloat(str);
  return this.finishToken(types.num, val);
};
pp$8.readCodePoint = function () {
  var ch = this.input.charCodeAt(this.pos),
			code;

  if (ch === 123) {
	if (this.options.ecmaVersion < 6) {
			this.unexpected();
	}
	var codePos = ++this.pos;
	code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
	++this.pos;
	if (code > 0x10FFFF) {
			this.invalidStringToken(codePos, "Code point out of bounds");
	}
  } else {
	code = this.readHexChar(4);
  }
  return code;
};

function codePointToString(code) {
  if (code <= 0xFFFF) {
	return String.fromCharCode(code);
  }
  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);
}

pp$8.readString = function (quote) {
  var this$1 = this;

  var out = "",
			chunkStart = ++this.pos;
  for (;;) {
	if (this$1.pos >= this$1.input.length) {
			this$1.raise(this$1.start, "Unterminated string constant");
	}
	var ch = this$1.input.charCodeAt(this$1.pos);
	if (ch === quote) {
			break;
	}
	if (ch === 92) {
			out += this$1.input.slice(chunkStart, this$1.pos);
			out += this$1.readEscapedChar(false);
			chunkStart = this$1.pos;
	} else {
			if (isNewLine(ch)) {
		this$1.raise(this$1.start, "Unterminated string constant");
			}
			++this$1.pos;
	}
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types.string, out);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};

pp$8.tryReadTemplateToken = function () {
  this.inTemplateElement = true;
  try {
	this.readTmplToken();
  } catch (err) {
	if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
			this.readInvalidTemplateToken();
	} else {
			throw err;
	}
  }

  this.inTemplateElement = false;
};

pp$8.invalidStringToken = function (position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
	throw INVALID_TEMPLATE_ESCAPE_ERROR;
  } else {
	this.raise(position, message);
  }
};

pp$8.readTmplToken = function () {
  var this$1 = this;

  var out = "",
			chunkStart = this.pos;
  for (;;) {
	if (this$1.pos >= this$1.input.length) {
			this$1.raise(this$1.start, "Unterminated template");
	}
	var ch = this$1.input.charCodeAt(this$1.pos);
	if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) {
			if (this$1.pos === this$1.start && (this$1.type === types.template || this$1.type === types.invalidTemplate)) {
		if (ch === 36) {
					this$1.pos += 2;
					return this$1.finishToken(types.dollarBraceL);
		} else {
					++this$1.pos;
					return this$1.finishToken(types.backQuote);
		}
			}
			out += this$1.input.slice(chunkStart, this$1.pos);
			return this$1.finishToken(types.template, out);
	}
	if (ch === 92) {
			out += this$1.input.slice(chunkStart, this$1.pos);
			out += this$1.readEscapedChar(true);
			chunkStart = this$1.pos;
	} else if (isNewLine(ch)) {
			out += this$1.input.slice(chunkStart, this$1.pos);
			++this$1.pos;
			switch (ch) {
		case 13:
					if (this$1.input.charCodeAt(this$1.pos) === 10) {
			++this$1.pos;
					}
		case 10:
					out += "\n";
					break;
		default:
					out += String.fromCharCode(ch);
					break;
			}
			if (this$1.options.locations) {
		++this$1.curLine;
		this$1.lineStart = this$1.pos;
			}
			chunkStart = this$1.pos;
	} else {
			++this$1.pos;
	}
  }
};
pp$8.readInvalidTemplateToken = function () {
  var this$1 = this;

  for (; this.pos < this.input.length; this.pos++) {
	switch (this$1.input[this$1.pos]) {
			case "\\":
		++this$1.pos;
		break;

			case "$":
		if (this$1.input[this$1.pos + 1] !== "{") {
					break;
		}
			case "`":
		return this$1.finishToken(types.invalidTemplate, this$1.input.slice(this$1.start, this$1.pos));
	}
  }
  this.raise(this.start, "Unterminated template");
};
pp$8.readEscapedChar = function (inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
	case 110:
			return "\n"; // 'n' -> '\n'
	case 114:
			return "\r"; // 'r' -> '\r'
	case 120:
			return String.fromCharCode(this.readHexChar(2)); // 'x'
	case 117:
			return codePointToString(this.readCodePoint()); // 'u'
	case 116:
			return "\t"; // 't' -> '\t'
	case 98:
			return "\b"; // 'b' -> '\b'
	case 118:
			return "\x0B"; // 'v' -> '\u000b'
	case 102:
			return "\f"; // 'f' -> '\f'
	case 13:
			if (this.input.charCodeAt(this.pos) === 10) {
		++this.pos;
			} // '\r\n'
	case 10:
			if (this.options.locations) {
		this.lineStart = this.pos;++this.curLine;
			}
			return "";
	default:
			if (ch >= 48 && ch <= 55) {
		var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
		var octal = parseInt(octalStr, 8);
		if (octal > 255) {
					octalStr = octalStr.slice(0, -1);
					octal = parseInt(octalStr, 8);
		}
		if (octalStr !== "0" && (this.strict || inTemplate)) {
					this.invalidStringToken(this.pos - 2, "Octal literal in strict mode");
		}
		this.pos += octalStr.length - 1;
		return String.fromCharCode(octal);
			}
			return String.fromCharCode(ch);
  }
};
pp$8.readHexChar = function (len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) {
	this.invalidStringToken(codePos, "Bad character escape sequence");
  }
  return n;
};
//
pp$8.readWord1 = function () {
  var this$1 = this;

  this.containsEsc = false;
  var word = "",
			first = true,
			chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
	var ch = this$1.fullCharCodeAtPos();
	if (isIdentifierChar(ch, astral)) {
			this$1.pos += ch <= 0xffff ? 1 : 2;
	} else if (ch === 92) {
			this$1.containsEsc = true;
			word += this$1.input.slice(chunkStart, this$1.pos);
			var escStart = this$1.pos;
			if (this$1.input.charCodeAt(++this$1.pos) != 117) // "u"
		{
					this$1.invalidStringToken(this$1.pos, "Expecting Unicode escape sequence \\uXXXX");
		}
			++this$1.pos;
			var esc = this$1.readCodePoint();
			if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
		this$1.invalidStringToken(escStart, "Invalid Unicode escape");
			}
			word += codePointToString(esc);
			chunkStart = this$1.pos;
	} else {
			break;
	}
	first = false;
  }
  return word + this.input.slice(chunkStart, this.pos);
};
pp$8.readWord = function () {
  var word = this.readWord1();
  var type = types.name;
  if (this.keywords.test(word)) {
	if (this.containsEsc) {
			this.raiseRecoverable(this.start, "Escape sequence in keyword " + word);
	}
	type = keywords$1[word];
  }
  return this.finishToken(type, word);
};
//
//
//
//
//
//
//
var version = "5.2.1";
//
function parse(input, options) {
  return new Parser(options, input).parse();
}
function parseExpressionAt(input, pos, options) {
  var p = new Parser(options, input, pos);
  p.nextToken();
  return p.parseExpression();
}
function tokenizer(input, options) {
  return new Parser(options, input);
}
var parse_dammit;
var LooseParser;
var pluginsLoose; // eslint-disable-line camelcase
function addLooseExports(parse, Parser$$1, plugins$$1) {
  exports.parse_dammit = parse_dammit = parse; // eslint-disable-line camelcase
  exports.LooseParser = LooseParser = Parser$$1;
  exports.pluginsLoose = pluginsLoose = plugins$$1;
}

exports.version = version;
exports.parse = parse;
exports.parseExpressionAt = parseExpressionAt;
exports.tokenizer = tokenizer;
exports.parse_dammit = parse_dammit;
exports.LooseParser = LooseParser;
exports.pluginsLoose = pluginsLoose;
exports.addLooseExports = addLooseExports;
exports.Parser = Parser;
exports.plugins = plugins;
exports.defaultOptions = defaultOptions;
exports.Position = Position;
exports.SourceLocation = SourceLocation;
exports.getLineInfo = getLineInfo;
exports.Node = Node;
exports.TokenType = TokenType;
exports.tokTypes = types;
exports.keywordTypes = keywords$1;
exports.TokContext = TokContext;
exports.tokContexts = types$1;
exports.isIdentifierChar = isIdentifierChar;
exports.isIdentifierStart = isIdentifierStart;
exports.Token = Token;
exports.isNewLine = isNewLine;
exports.lineBreak = lineBreak;
exports.lineBreakG = lineBreakG;
exports.nonASCIIwhitespace = nonASCIIwhitespace;
 }),
 (function(module, exports) {

module.exports = {"_from":"espree@^3.5.2","_id":"espree@3.5.2","_inBundle":false,"_integrity":"sha512-sadKeYwaR/aJ3stC2CdvgXu1T16TdYN+qwCpcWbMnGJ8s0zNWemzrvb2GbD4OhmJ/fwpJjudThAlLobGbWZbCQ==","_location":"/espree","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"espree@^3.5.2","name":"espree","escapedName":"espree","rawSpec":"^3.5.2","saveSpec":null,"fetchSpec":"^3.5.2"},"_requiredBy":["/eslint"],"_resolved":"https://registry.npmjs.org/espree/-/espree-3.5.2.tgz","_shasum":"756ada8b979e9dcfcdb30aad8d1a9304a905e1ca","_spec":"espree@^3.5.2","_where":"J:\\Chromium\\newclient\\plugins\\c9.ide.language.javascript.eslint\\packager\\node_modules\\eslint","author":{"name":"Nicholas C. Zakas","email":"nicholas+npm@nczconsulting.com"},"bugs":{"url":"http://github.com/eslint/espree.git"},"bundleDependencies":false,"dependencies":{"acorn":"^5.2.1","acorn-jsx":"^3.0.0"},"deprecated":false,"description":"An Esprima-compatible JavaScript parser built on Acorn","devDependencies":{"browserify":"^7.0.0","chai":"^1.10.0","eslint":"^2.13.1","eslint-config-eslint":"^3.0.0","eslint-release":"^0.10.0","esprima":"latest","esprima-fb":"^8001.2001.0-dev-harmony-fb","istanbul":"~0.2.6","json-diff":"~0.3.1","leche":"^1.0.1","mocha":"^2.0.1","regenerate":"~0.5.4","shelljs":"^0.3.0","shelljs-nodecli":"^0.1.1","unicode-6.3.0":"~0.1.0"},"engines":{"node":">=0.10.0"},"files":["lib","espree.js"],"homepage":"https://github.com/eslint/espree","keywords":["ast","ecmascript","javascript","parser","syntax","acorn"],"license":"BSD-2-Clause","main":"espree.js","name":"espree","repository":{"type":"git","url":"git+https://github.com/eslint/espree.git"},"scripts":{"alpharelease":"eslint-prelease alpha","betarelease":"eslint-prelease beta","browserify":"node Makefile.js browserify","ci-release":"eslint-ci-release","generate-regex":"node tools/generate-identifier-regex.js","gh-release":"eslint-gh-release","lint":"node Makefile.js lint","release":"eslint-release","test":"npm run-script lint && node Makefile.js test"},"version":"3.5.2"}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	AssignmentExpression: ["left", "right"],
	AssignmentPattern: ["left", "right"],
	ArrayExpression: ["elements"],
	ArrayPattern: ["elements"],
	ArrowFunctionExpression: ["params", "body"],
	BlockStatement: ["body"],
	BinaryExpression: ["left", "right"],
	BreakStatement: ["label"],
	CallExpression: ["callee", "arguments"],
	CatchClause: ["param", "body"],
	ClassBody: ["body"],
	ClassDeclaration: ["id", "superClass", "body"],
	ClassExpression: ["id", "superClass", "body"],
	ConditionalExpression: ["test", "consequent", "alternate"],
	ContinueStatement: ["label"],
	DebuggerStatement: [],
	DirectiveStatement: [],
	DoWhileStatement: ["body", "test"],
	EmptyStatement: [],
	ExportAllDeclaration: ["source"],
	ExportDefaultDeclaration: ["declaration"],
	ExportNamedDeclaration: ["declaration", "specifiers", "source"],
	ExportSpecifier: ["exported", "local"],
	ExpressionStatement: ["expression"],
	ForStatement: ["init", "test", "update", "body"],
	ForInStatement: ["left", "right", "body"],
	ForOfStatement: ["left", "right", "body"],
	FunctionDeclaration: ["id", "params", "body"],
	FunctionExpression: ["id", "params", "body"],
	Identifier: [],
	IfStatement: ["test", "consequent", "alternate"],
	ImportDeclaration: ["specifiers", "source"],
	ImportDefaultSpecifier: ["local"],
	ImportNamespaceSpecifier: ["local"],
	ImportSpecifier: ["imported", "local"],
	Literal: [],
	LabeledStatement: ["label", "body"],
	LogicalExpression: ["left", "right"],
	MemberExpression: ["object", "property"],
	MetaProperty: ["meta", "property"],
	MethodDefinition: ["key", "value"],
	ModuleSpecifier: [],
	NewExpression: ["callee", "arguments"],
	ObjectExpression: ["properties"],
	ObjectPattern: ["properties"],
	Program: ["body"],
	Property: ["key", "value"],
	RestElement: ["argument"],
	ReturnStatement: ["argument"],
	SequenceExpression: ["expressions"],
	SpreadElement: ["argument"],
	Super: [],
	SwitchStatement: ["discriminant", "cases"],
	SwitchCase: ["test", "consequent"],
	TaggedTemplateExpression: ["tag", "quasi"],
	TemplateElement: [],
	TemplateLiteral: ["quasis", "expressions"],
	ThisExpression: [],
	ThrowStatement: ["argument"],
	TryStatement: ["block", "handler", "finalizer"],
	UnaryExpression: ["argument"],
	UpdateExpression: ["argument"],
	VariableDeclaration: ["declarations"],
	VariableDeclarator: ["id", "init"],
	WhileStatement: ["test", "body"],
	WithStatement: ["object", "body"],
	YieldExpression: ["argument"],
	JSXIdentifier: [],
	JSXNamespacedName: ["namespace", "name"],
	JSXMemberExpression: ["object", "property"],
	JSXEmptyExpression: [],
	JSXExpressionContainer: ["expression"],
	JSXElement: ["openingElement", "closingElement", "children"],
	JSXClosingElement: ["name"],
	JSXOpeningElement: ["name", "attributes"],
	JSXAttribute: ["name", "value"],
	JSXText: null,
	JSXSpreadAttribute: ["argument"],
	ExperimentalRestProperty: ["argument"],
	ExperimentalSpreadProperty: ["argument"]
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var minimatch = __webpack_require__(366),
	path = __webpack_require__(103);

var debug = __webpack_require__(67)("eslint:config-ops");
var RULE_SEVERITY_STRINGS = ["off", "warn", "error"],
	RULE_SEVERITY = RULE_SEVERITY_STRINGS.reduce(function (map, value, index) {
	map[value] = index;
	return map;
}, {}),
	VALID_SEVERITIES = [0, 1, 2, "off", "warn", "error"];
module.exports = {
	createEmptyConfig: function createEmptyConfig() {
		return {
			globals: {},
			env: {},
			rules: {},
			parserOptions: {}
		};
	},
	createEnvironmentConfig: function createEnvironmentConfig(env, envContext) {

		var envConfig = this.createEmptyConfig();

		if (env) {

			envConfig.env = env;

			Object.keys(env).filter(function (name) {
				return env[name];
			}).forEach(function (name) {
				var environment = envContext.get(name);

				if (environment) {
					debug("Creating config for environment " + name);
					if (environment.globals) {
						Object.assign(envConfig.globals, environment.globals);
					}

					if (environment.parserOptions) {
						Object.assign(envConfig.parserOptions, environment.parserOptions);
					}
				}
			});
		}

		return envConfig;
	},
	applyEnvironments: function applyEnvironments(config, envContent) {
		if (config.env && _typeof(config.env) === "object") {
			debug("Apply environment settings to config");
			return this.merge(this.createEnvironmentConfig(config.env, envContent), config);
		}

		return config;
	},
	merge: function deepmerge(target, src, combine, isRule) {
		var array = Array.isArray(src) || Array.isArray(target);
		var dst = array && [] || {};

		combine = !!combine;
		isRule = !!isRule;
		if (array) {
			target = target || [];
			if (isRule && Array.isArray(src) && src.length > 1) {
				dst = dst.concat(src);
			} else {
				dst = dst.concat(target);
			}
			if ((typeof src === "undefined" ? "undefined" : _typeof(src)) !== "object" && !Array.isArray(src)) {
				src = [src];
			}
			Object.keys(src).forEach(function (e, i) {
				e = src[i];
				if (typeof dst[i] === "undefined") {
					dst[i] = e;
				} else if ((typeof e === "undefined" ? "undefined" : _typeof(e)) === "object") {
					if (isRule) {
						dst[i] = e;
					} else {
						dst[i] = deepmerge(target[i], e, combine, isRule);
					}
				} else {
					if (!combine) {
						dst[i] = e;
					} else {
						if (dst.indexOf(e) === -1) {
							dst.push(e);
						}
					}
				}
			});
		} else {
			if (target && (typeof target === "undefined" ? "undefined" : _typeof(target)) === "object") {
				Object.keys(target).forEach(function (key) {
					dst[key] = target[key];
				});
			}
			Object.keys(src).forEach(function (key) {
				if (key === "overrides") {
					dst[key] = (target[key] || []).concat(src[key] || []);
				} else if (Array.isArray(src[key]) || Array.isArray(target[key])) {
					dst[key] = deepmerge(target[key], src[key], key === "plugins" || key === "extends", isRule);
				} else if (_typeof(src[key]) !== "object" || !src[key] || key === "exported" || key === "astGlobals") {
					dst[key] = src[key];
				} else {
					dst[key] = deepmerge(target[key] || {}, src[key], combine, key === "rules");
				}
			});
		}

		return dst;
	},
	getRuleSeverity: function getRuleSeverity(ruleConfig) {
		var severityValue = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;

		if (typeof severityValue === 'number') {
			return severityValue;
		}

		if (typeof severityValue === "string") {
			return RULE_SEVERITY[severityValue.toLowerCase()] || 0;
		}

		return 0;
	},
	normalizeToStrings: function normalizeToStrings(config) {

		if (config.rules) {
			Object.keys(config.rules).forEach(function (ruleId) {
				var ruleConfig = config.rules[ruleId];

				if (typeof ruleConfig === "number") {
					config.rules[ruleId] = RULE_SEVERITY_STRINGS[ruleConfig] || RULE_SEVERITY_STRINGS[0];
				} else if (Array.isArray(ruleConfig) && typeof ruleConfig[0] === "number") {
					ruleConfig[0] = RULE_SEVERITY_STRINGS[ruleConfig[0]] || RULE_SEVERITY_STRINGS[0];
				}
			});
		}
	},
	isErrorSeverity: function isErrorSeverity(ruleConfig) {

		var severity = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;

		if (typeof severity === "string") {
			severity = RULE_SEVERITY[severity.toLowerCase()] || 0;
		}

		return typeof severity === "number" && severity === 2;
	},
	isValidSeverity: function isValidSeverity(ruleConfig) {
		var severity = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;

		if (typeof severity === "string") {
			severity = severity.toLowerCase();
		}
		return VALID_SEVERITIES.indexOf(severity) !== -1;
	},
	isEverySeverityValid: function isEverySeverityValid(config) {
		var _this = this;

		return Object.keys(config).every(function (ruleId) {
			return _this.isValidSeverity(config[ruleId]);
		});
	},
	getConfigFromVector: function getConfigFromVector(vector, configCache) {

		var cachedConfig = configCache.getMergedVectorConfig(vector);

		if (cachedConfig) {
			return cachedConfig;
		}

		debug("Using config from partial cache");

		var subvector = Array.from(vector);
		var nearestCacheIndex = subvector.length - 1,
			partialCachedConfig = void 0;

		while (nearestCacheIndex >= 0) {
			partialCachedConfig = configCache.getMergedVectorConfig(subvector);
			if (partialCachedConfig) {
				break;
			}
			subvector.pop();
			nearestCacheIndex--;
		}

		if (!partialCachedConfig) {
			partialCachedConfig = {};
		}

		var finalConfig = partialCachedConfig;
		for (var i = nearestCacheIndex + 1; i < vector.length; i++) {
			finalConfig = this.mergeVectorEntry(finalConfig, vector[i], configCache);
			configCache.setMergedVectorConfig(vector.slice(0, i + 1), finalConfig);
		}

		return finalConfig;
	},
	mergeVectorEntry: function mergeVectorEntry(config, vectorEntry, configCache) {
		var _this2 = this;

		var vectorEntryConfig = Object.assign({}, configCache.getConfig(vectorEntry.filePath));
		var mergedConfig = Object.assign({}, config),
			overrides = void 0;

		if (vectorEntryConfig.overrides) {
			overrides = vectorEntryConfig.overrides.filter(function (override, overrideIndex) {
				return vectorEntry.matchingOverrides.indexOf(overrideIndex) !== -1;
			});
		} else {
			overrides = [];
		}

		mergedConfig = this.merge(mergedConfig, vectorEntryConfig);

		delete mergedConfig.overrides;

		mergedConfig = overrides.reduce(function (lastConfig, override) {
			return _this2.merge(lastConfig, override);
		}, mergedConfig);

		if (mergedConfig.filePath) {
			delete mergedConfig.filePath;
			delete mergedConfig.baseDirectory;
		} else if (mergedConfig.files) {
			delete mergedConfig.files;
		}

		return mergedConfig;
	},
	pathMatchesGlobs: function pathMatchesGlobs(filePath, patterns, excludedPatterns) {
		var patternList = [].concat(patterns);
		var excludedPatternList = [].concat(excludedPatterns || []);

		patternList.concat(excludedPatternList).forEach(function (pattern) {
			if (path.isAbsolute(pattern) || pattern.includes("..")) {
				throw new Error("Invalid override pattern (expected relative path not containing '..'): " + pattern);
			}
		});

		var opts = { matchBase: true };

		return patternList.some(function (pattern) {
			return minimatch(filePath, pattern, opts);
		}) && !excludedPatternList.some(function (excludedPattern) {
			return minimatch(filePath, excludedPattern, opts);
		});
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = minimatch;
minimatch.Minimatch = Minimatch;

var path = { sep: '/' };
try {
  path = __webpack_require__(103);
} catch (er) {}

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
var expand = __webpack_require__(367);

var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)' },
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
};var qmark = '[^/]';
var star = qmark + '*?';
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?';
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?';
var reSpecials = charSet('().*{}+?[]^$\\!');
function charSet(s) {
  return s.split('').reduce(function (set, c) {
	set[c] = true;
	return set;
  }, {});
}
var slashSplit = /\/+/;

minimatch.filter = filter;
function filter(pattern, options) {
  options = options || {};
  return function (p, i, list) {
	return minimatch(p, pattern, options);
  };
}

function ext(a, b) {
  a = a || {};
  b = b || {};
  var t = {};
  Object.keys(b).forEach(function (k) {
	t[k] = b[k];
  });
  Object.keys(a).forEach(function (k) {
	t[k] = a[k];
  });
  return t;
}

minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return minimatch;

  var orig = minimatch;

  var m = function minimatch(p, pattern, options) {
	return orig.minimatch(p, pattern, ext(def, options));
  };

  m.Minimatch = function Minimatch(pattern, options) {
	return new orig.Minimatch(pattern, ext(def, options));
  };

  return m;
};

Minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return Minimatch;
  return minimatch.defaults(def).Minimatch;
};

function minimatch(p, pattern, options) {
  if (typeof pattern !== 'string') {
	throw new TypeError('glob pattern string required');
  }

  if (!options) options = {};
  if (!options.nocomment && pattern.charAt(0) === '#') {
	return false;
  }
  if (pattern.trim() === '') return p === '';

  return new Minimatch(pattern, options).match(p);
}

function Minimatch(pattern, options) {
  if (!(this instanceof Minimatch)) {
	return new Minimatch(pattern, options);
  }

  if (typeof pattern !== 'string') {
	throw new TypeError('glob pattern string required');
  }

  if (!options) options = {};
  pattern = pattern.trim();
  if (path.sep !== '/') {
	pattern = pattern.split(path.sep).join('/');
  }

  this.options = options;
  this.set = [];
  this.pattern = pattern;
  this.regexp = null;
  this.negate = false;
  this.comment = false;
  this.empty = false;
  this.make();
}

Minimatch.prototype.debug = function () {};

Minimatch.prototype.make = make;
function make() {
  if (this._made) return;

  var pattern = this.pattern;
  var options = this.options;
  if (!options.nocomment && pattern.charAt(0) === '#') {
	this.comment = true;
	return;
  }
  if (!pattern) {
	this.empty = true;
	return;
  }
  this.parseNegate();
  var set = this.globSet = this.braceExpand();

  if (options.debug) this.debug = console.error;

  this.debug(this.pattern, set);
  set = this.globParts = set.map(function (s) {
	return s.split(slashSplit);
  });

  this.debug(this.pattern, set);
  set = set.map(function (s, si, set) {
	return s.map(this.parse, this);
  }, this);

  this.debug(this.pattern, set);
  set = set.filter(function (s) {
	return s.indexOf(false) === -1;
  });

  this.debug(this.pattern, set);

  this.set = set;
}

Minimatch.prototype.parseNegate = parseNegate;
function parseNegate() {
  var pattern = this.pattern;
  var negate = false;
  var options = this.options;
  var negateOffset = 0;

  if (options.nonegate) return;

  for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === '!'; i++) {
	negate = !negate;
	negateOffset++;
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset);
  this.negate = negate;
}
//
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options);
};

Minimatch.prototype.braceExpand = braceExpand;

function braceExpand(pattern, options) {
  if (!options) {
	if (this instanceof Minimatch) {
			options = this.options;
	} else {
			options = {};
	}
  }

  pattern = typeof pattern === 'undefined' ? this.pattern : pattern;

  if (typeof pattern === 'undefined') {
	throw new TypeError('undefined pattern');
  }

  if (options.nobrace || !pattern.match(/\{.*\}/)) {
	return [pattern];
  }

  return expand(pattern);
}
//
Minimatch.prototype.parse = parse;
var SUBPARSE = {};
function parse(pattern, isSub) {
  if (pattern.length > 1024 * 64) {
	throw new TypeError('pattern is too long');
  }

  var options = this.options;
  if (!options.noglobstar && pattern === '**') return GLOBSTAR;
  if (pattern === '') return '';

  var re = '';
  var hasMagic = !!options.nocase;
  var escaping = false;
  var patternListStack = [];
  var negativeLists = [];
  var stateChar;
  var inClass = false;
  var reClassStart = -1;
  var classStart = -1;
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))' : '(?!\\.)';
  var self = this;

  function clearStateChar() {
	if (stateChar) {
			switch (stateChar) {
		case '*':
					re += star;
					hasMagic = true;
					break;
		case '?':
					re += qmark;
					hasMagic = true;
					break;
		default:
					re += '\\' + stateChar;
					break;
			}
			self.debug('clearStateChar %j %j', stateChar, re);
			stateChar = false;
	}
  }

  for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
	this.debug('%s\t%s %s %j', pattern, i, re, c);
	if (escaping && reSpecials[c]) {
			re += '\\' + c;
			escaping = false;
			continue;
	}

	switch (c) {
			case '/':
		return false;

			case '\\':
		clearStateChar();
		escaping = true;
		continue;
			case '?':
			case '*':
			case '+':
			case '@':
			case '!':
		this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c);
		if (inClass) {
					this.debug('  in class');
					if (c === '!' && i === classStart + 1) c = '^';
					re += c;
					continue;
		}
		self.debug('call clearStateChar %j', stateChar);
		clearStateChar();
		stateChar = c;
		if (options.noext) clearStateChar();
		continue;

			case '(':
		if (inClass) {
					re += '(';
					continue;
		}

		if (!stateChar) {
					re += '\\(';
					continue;
		}

		patternListStack.push({
					type: stateChar,
					start: i - 1,
					reStart: re.length,
					open: plTypes[stateChar].open,
					close: plTypes[stateChar].close
		});
		re += stateChar === '!' ? '(?:(?!(?:' : '(?:';
		this.debug('plType %j %j', stateChar, re);
		stateChar = false;
		continue;

			case ')':
		if (inClass || !patternListStack.length) {
					re += '\\)';
					continue;
		}

		clearStateChar();
		hasMagic = true;
		var pl = patternListStack.pop();
		re += pl.close;
		if (pl.type === '!') {
					negativeLists.push(pl);
		}
		pl.reEnd = re.length;
		continue;

			case '|':
		if (inClass || !patternListStack.length || escaping) {
					re += '\\|';
					escaping = false;
					continue;
		}

		clearStateChar();
		re += '|';
		continue;
			case '[':
		clearStateChar();

		if (inClass) {
					re += '\\' + c;
					continue;
		}

		inClass = true;
		classStart = i;
		reClassStart = re.length;
		re += c;
		continue;

			case ']':
		if (i === classStart + 1 || !inClass) {
					re += '\\' + c;
					escaping = false;
					continue;
		}
		if (inClass) {
					var cs = pattern.substring(classStart + 1, i);
					try {
			RegExp('[' + cs + ']');
					} catch (er) {
			var sp = this.parse(cs, SUBPARSE);
			re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]';
			hasMagic = hasMagic || sp[1];
			inClass = false;
			continue;
					}
		}
		hasMagic = true;
		inClass = false;
		re += c;
		continue;

			default:
		clearStateChar();

		if (escaping) {
					escaping = false;
		} else if (reSpecials[c] && !(c === '^' && inClass)) {
					re += '\\';
		}

		re += c;

	} // switch
  } // for
  if (inClass) {
	cs = pattern.substr(classStart + 1);
	sp = this.parse(cs, SUBPARSE);
	re = re.substr(0, reClassStart) + '\\[' + sp[0];
	hasMagic = hasMagic || sp[1];
  }
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
	var tail = re.slice(pl.reStart + pl.open.length);
	this.debug('setting tail', re, pl);
	tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
			if (!$2) {
		$2 = '\\';
			}
			//
			return $1 + $1 + $2 + '|';
	});

	this.debug('tail=%j\n   %s', tail, tail, pl, re);
	var t = pl.type === '*' ? star : pl.type === '?' ? qmark : '\\' + pl.type;

	hasMagic = true;
	re = re.slice(0, pl.reStart) + t + '\\(' + tail;
  }
  clearStateChar();
  if (escaping) {
	re += '\\\\';
  }
  var addPatternStart = false;
  switch (re.charAt(0)) {
	case '.':
	case '[':
	case '(':
			addPatternStart = true;
  }
  for (var n = negativeLists.length - 1; n > -1; n--) {
	var nl = negativeLists[n];

	var nlBefore = re.slice(0, nl.reStart);
	var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
	var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
	var nlAfter = re.slice(nl.reEnd);

	nlLast += nlAfter;
	var openParensBefore = nlBefore.split('(').length - 1;
	var cleanAfter = nlAfter;
	for (i = 0; i < openParensBefore; i++) {
			cleanAfter = cleanAfter.replace(/\)[+*?]?/, '');
	}
	nlAfter = cleanAfter;

	var dollar = '';
	if (nlAfter === '' && isSub !== SUBPARSE) {
			dollar = '$';
	}
	var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
	re = newRe;
  }
  if (re !== '' && hasMagic) {
	re = '(?=.)' + re;
  }

  if (addPatternStart) {
	re = patternStart + re;
  }
  if (isSub === SUBPARSE) {
	return [re, hasMagic];
  }
  if (!hasMagic) {
	return globUnescape(pattern);
  }

  var flags = options.nocase ? 'i' : '';
  try {
	var regExp = new RegExp('^' + re + '$', flags);
  } catch (er) {
	return new RegExp('$.');
  }

  regExp._glob = pattern;
  regExp._src = re;

  return regExp;
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe();
};

Minimatch.prototype.makeRe = makeRe;
function makeRe() {
  if (this.regexp || this.regexp === false) return this.regexp;
  //
  var set = this.set;

  if (!set.length) {
	this.regexp = false;
	return this.regexp;
  }
  var options = this.options;

  var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
  var flags = options.nocase ? 'i' : '';

  var re = set.map(function (pattern) {
	return pattern.map(function (p) {
			return p === GLOBSTAR ? twoStar : typeof p === 'string' ? regExpEscape(p) : p._src;
	}).join('\\\/');
  }).join('|');
  re = '^(?:' + re + ')$';
  if (this.negate) re = '^(?!' + re + ').*$';

  try {
	this.regexp = new RegExp(re, flags);
  } catch (ex) {
	this.regexp = false;
  }
  return this.regexp;
}

minimatch.match = function (list, pattern, options) {
  options = options || {};
  var mm = new Minimatch(pattern, options);
  list = list.filter(function (f) {
	return mm.match(f);
  });
  if (mm.options.nonull && !list.length) {
	list.push(pattern);
  }
  return list;
};

Minimatch.prototype.match = match;
function match(f, partial) {
  this.debug('match', f, this.pattern);
  if (this.comment) return false;
  if (this.empty) return f === '';

  if (f === '/' && partial) return true;

  var options = this.options;
  if (path.sep !== '/') {
	f = f.split(path.sep).join('/');
  }
  f = f.split(slashSplit);
  this.debug(this.pattern, 'split', f);
  var set = this.set;
  this.debug(this.pattern, 'set', set);
  var filename;
  var i;
  for (i = f.length - 1; i >= 0; i--) {
	filename = f[i];
	if (filename) break;
  }

  for (i = 0; i < set.length; i++) {
	var pattern = set[i];
	var file = f;
	if (options.matchBase && pattern.length === 1) {
			file = [filename];
	}
	var hit = this.matchOne(file, pattern, partial);
	if (hit) {
			if (options.flipNegate) return true;
			return !this.negate;
	}
  }
  if (options.flipNegate) return false;
  return this.negate;
}
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options;

  this.debug('matchOne', { 'this': this, file: file, pattern: pattern });

  this.debug('matchOne', file.length, pattern.length);

  for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
	this.debug('matchOne loop');
	var p = pattern[pi];
	var f = file[fi];

	this.debug(pattern, p, f);
	if (p === false) return false;

	if (p === GLOBSTAR) {
			this.debug('GLOBSTAR', [pattern, p, f]);
			//
			var fr = fi;
			var pr = pi + 1;
			if (pr === pl) {
		this.debug('** at the end');
		for (; fi < fl; fi++) {
					if (file[fi] === '.' || file[fi] === '..' || !options.dot && file[fi].charAt(0) === '.') return false;
		}
		return true;
			}
			while (fr < fl) {
		var swallowee = file[fr];

		this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);
		if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
					this.debug('globstar found match!', fr, fl, swallowee);
					return true;
		} else {
					if (swallowee === '.' || swallowee === '..' || !options.dot && swallowee.charAt(0) === '.') {
			this.debug('dot detected!', file, fr, pattern, pr);
			break;
					}
					this.debug('globstar swallow a segment, and continue');
					fr++;
		}
			}
			if (partial) {
		this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
		if (fr === fl) return true;
			}
			return false;
	}
	var hit;
	if (typeof p === 'string') {
			if (options.nocase) {
		hit = f.toLowerCase() === p.toLowerCase();
			} else {
		hit = f === p;
			}
			this.debug('string match', p, f, hit);
	} else {
			hit = f.match(p);
			this.debug('pattern match', p, f, hit);
	}

	if (!hit) return false;
  }
  if (fi === fl && pi === pl) {
	return true;
  } else if (fi === fl) {
	return partial;
  } else if (pi === pl) {
	var emptyFileEnd = fi === fl - 1 && file[fi] === '';
	return emptyFileEnd;
  }
  throw new Error('wtf?');
};
function globUnescape(s) {
  return s.replace(/\\(.)/g, '$1');
}

function regExpEscape(s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var concatMap = __webpack_require__(368);
var balanced = __webpack_require__(369);

module.exports = expandTop;

var escSlash = '\0SLASH' + Math.random() + '\0';
var escOpen = '\0OPEN' + Math.random() + '\0';
var escClose = '\0CLOSE' + Math.random() + '\0';
var escComma = '\0COMMA' + Math.random() + '\0';
var escPeriod = '\0PERIOD' + Math.random() + '\0';

function numeric(str) {
  return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash).split('\\{').join(escOpen).split('\\}').join(escClose).split('\\,').join(escComma).split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\').split(escOpen).join('{').split(escClose).join('}').split(escComma).join(',').split(escPeriod).join('.');
}
function parseCommaParts(str) {
  if (!str) return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m) return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length - 1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
	p[p.length - 1] += postParts.shift();
	p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str) return [];
  if (str.substr(0, 2) === '{}') {
	str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function identity(e) {
  return e;
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return (/^-?0\d/.test(el)
  );
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions) {
	if (m.post.match(/,.*\}/)) {
			str = m.pre + '{' + m.body + escClose + m.post;
			return expand(str);
	}
	return [str];
  }

  var n;
  if (isSequence) {
	n = m.body.split(/\.\./);
  } else {
	n = parseCommaParts(m.body);
	if (n.length === 1) {
			n = expand(n[0], false).map(embrace);
			if (n.length === 1) {
		var post = m.post.length ? expand(m.post, false) : [''];
		return post.map(function (p) {
					return m.pre + n[0] + p;
		});
			}
	}
  }
  var pre = m.pre;
  var post = m.post.length ? expand(m.post, false) : [''];

  var N;

  if (isSequence) {
	var x = numeric(n[0]);
	var y = numeric(n[1]);
	var width = Math.max(n[0].length, n[1].length);
	var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
	var test = lte;
	var reverse = y < x;
	if (reverse) {
			incr *= -1;
			test = gte;
	}
	var pad = n.some(isPadded);

	N = [];

	for (var i = x; test(i, y); i += incr) {
			var c;
			if (isAlphaSequence) {
		c = String.fromCharCode(i);
		if (c === '\\') c = '';
			} else {
		c = String(i);
		if (pad) {
					var need = width - c.length;
					if (need > 0) {
			var z = new Array(need + 1).join('0');
			if (i < 0) c = '-' + z + c.slice(1);else c = z + c;
					}
		}
			}
			N.push(c);
	}
  } else {
	N = concatMap(n, function (el) {
			return expand(el, false);
	});
  }

  for (var j = 0; j < N.length; j++) {
	for (var k = 0; k < post.length; k++) {
			var expansion = pre + N[j] + post[k];
			if (!isTop || isSequence || expansion) expansions.push(expansion);
	}
  }

  return expansions;
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (xs, fn) {
	var res = [];
	for (var i = 0; i < xs.length; i++) {
		var x = fn(xs[i], i);
		if (isArray(x)) res.push.apply(res, x);else res.push(x);
	}
	return res;
};

var isArray = Array.isArray || function (xs) {
	return Object.prototype.toString.call(xs) === '[object Array]';
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
	start: r[0],
	end: r[1],
	pre: str.slice(0, r[0]),
	body: str.slice(r[0] + a.length, r[1]),
	post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
	begs = [];
	left = str.length;

	while (i >= 0 && !result) {
			if (i == ai) {
		begs.push(i);
		ai = str.indexOf(a, i + 1);
			} else if (begs.length == 1) {
		result = [begs.pop(), bi];
			} else {
		beg = begs.pop();
		if (beg < left) {
					left = beg;
					right = bi;
		}

		bi = str.indexOf(b, i + 1);
			}

			i = ai < bi && ai >= 0 ? ai : bi;
	}

	if (begs.length) {
			result = [left, right];
	}
  }

  return result;
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var envs = __webpack_require__(371);
var Environments = function () {
	function Environments() {
		_classCallCheck(this, Environments);

		this._environments = new Map();

		this.load();
	}


	_createClass(Environments, [{
		key: "load",
		value: function load() {
			var _this = this;

			Object.keys(envs).forEach(function (envName) {
				_this._environments.set(envName, envs[envName]);
			});
		}

	}, {
		key: "get",
		value: function get(name) {
			return this._environments.get(name) || null;
		}

	}, {
		key: "getAll",
		value: function getAll() {
			return Array.from(this._environments).reduce(function (coll, env) {
				coll[env[0]] = env[1];
				return coll;
			}, {});
		}

	}, {
		key: "define",
		value: function define(name, env) {
			this._environments.set(name, env);
		}

	}, {
		key: "importPlugin",
		value: function importPlugin(plugin, pluginName) {
			var _this2 = this;

			if (plugin.environments) {
				Object.keys(plugin.environments).forEach(function (envName) {
					_this2.define(pluginName + "/" + envName, plugin.environments[envName]);
				});
			}
		}
	}]);

	return Environments;
}();

module.exports = Environments;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var globals = __webpack_require__(162);
module.exports = {
	builtin: globals.es5,
	browser: {
		globals: Object.assign({
			AutocompleteErrorEvent: false,
			CDATASection: false,
			ClientRect: false,
			ClientRectList: false,
			CSSAnimation: false,
			CSSTransition: false,
			CSSUnknownRule: false,
			CSSViewportRule: false,
			Debug: false,
			DocumentTimeline: false,
			DOMSettableTokenList: false,
			ElementTimeControl: false,
			FederatedCredential: false,
			FileError: false,
			HTMLAppletElement: false,
			HTMLBlockquoteElement: false,
			HTMLIsIndexElement: false,
			HTMLKeygenElement: false,
			HTMLLayerElement: false,
			IDBEnvironment: false,
			InputMethodContext: false,
			MediaKeyError: false,
			MediaKeyEvent: false,
			MediaKeys: false,
			opera: false,
			PasswordCredential: false,
			ReadableByteStream: false,
			SharedKeyframeList: false,
			showModalDialog: false,
			SiteBoundCredential: false,
			SVGAltGlyphDefElement: false,
			SVGAltGlyphElement: false,
			SVGAltGlyphItemElement: false,
			SVGAnimateColorElement: false,
			SVGAnimatedPathData: false,
			SVGAnimatedPoints: false,
			SVGColor: false,
			SVGColorProfileElement: false,
			SVGColorProfileRule: false,
			SVGCSSRule: false,
			SVGCursorElement: false,
			SVGDocument: false,
			SVGElementInstance: false,
			SVGElementInstanceList: false,
			SVGEvent: false,
			SVGExternalResourcesRequired: false,
			SVGFilterPrimitiveStandardAttributes: false,
			SVGFitToViewBox: false,
			SVGFontElement: false,
			SVGFontFaceElement: false,
			SVGFontFaceFormatElement: false,
			SVGFontFaceNameElement: false,
			SVGFontFaceSrcElement: false,
			SVGFontFaceUriElement: false,
			SVGGlyphElement: false,
			SVGGlyphRefElement: false,
			SVGHKernElement: false,
			SVGICCColor: false,
			SVGLangSpace: false,
			SVGLocatable: false,
			SVGMissingGlyphElement: false,
			SVGPaint: false,
			SVGPathSeg: false,
			SVGPathSegArcAbs: false,
			SVGPathSegArcRel: false,
			SVGPathSegClosePath: false,
			SVGPathSegCurvetoCubicAbs: false,
			SVGPathSegCurvetoCubicRel: false,
			SVGPathSegCurvetoCubicSmoothAbs: false,
			SVGPathSegCurvetoCubicSmoothRel: false,
			SVGPathSegCurvetoQuadraticAbs: false,
			SVGPathSegCurvetoQuadraticRel: false,
			SVGPathSegCurvetoQuadraticSmoothAbs: false,
			SVGPathSegCurvetoQuadraticSmoothRel: false,
			SVGPathSegLinetoAbs: false,
			SVGPathSegLinetoHorizontalAbs: false,
			SVGPathSegLinetoHorizontalRel: false,
			SVGPathSegLinetoRel: false,
			SVGPathSegLinetoVerticalAbs: false,
			SVGPathSegLinetoVerticalRel: false,
			SVGPathSegList: false,
			SVGPathSegMovetoAbs: false,
			SVGPathSegMovetoRel: false,
			SVGRenderingIntent: false,
			SVGStylable: false,
			SVGTests: false,
			SVGTransformable: false,
			SVGTRefElement: false,
			SVGURIReference: false,
			SVGViewSpec: false,
			SVGVKernElement: false,
			SVGZoomAndPan: false,
			SVGZoomEvent: false,
			TimeEvent: false,
			XDomainRequest: false,
			XMLHttpRequestProgressEvent: false,
			XPathException: false,
			XPathNamespace: false,
			XPathNSResolver: false
		}, globals.browser)
	},
	node: {
		globals: Object.assign({ arguments: false, GLOBAL: false, root: false }, globals.node),
		parserOptions: {
			ecmaFeatures: {
				globalReturn: true
			}
		}
	},
	commonjs: {
		globals: globals.commonjs,
		parserOptions: {
			ecmaFeatures: {
				globalReturn: true
			}
		}
	},
	"shared-node-browser": {
		globals: globals["shared-node-browser"]
	},
	worker: {
		globals: globals.worker
	},
	amd: {
		globals: globals.amd
	},
	mocha: {
		globals: globals.mocha
	},
	jasmine: {
		globals: globals.jasmine
	},
	jest: {
		globals: Object.assign({ check: false, gen: false }, globals.jest)
	},
	phantomjs: {
		globals: globals.phantomjs
	},
	jquery: {
		globals: globals.jquery
	},
	qunit: {
		globals: globals.qunit
	},
	prototypejs: {
		globals: globals.prototypejs
	},
	shelljs: {
		globals: globals.shelljs
	},
	meteor: {
		globals: globals.meteor
	},
	mongo: {
		globals: globals.mongo
	},
	protractor: {
		globals: globals.protractor
	},
	applescript: {
		globals: globals.applescript
	},
	nashorn: {
		globals: globals.nashorn
	},
	serviceworker: {
		globals: globals.serviceworker
	},
	atomtest: {
		globals: globals.atomtest
	},
	embertest: {
		globals: globals.embertest
	},
	webextensions: {
		globals: globals.webextensions
	},
	es6: {
		globals: globals.es2015,
		parserOptions: {
			ecmaVersion: 6
		}
	},
	greasemonkey: {
		globals: globals.greasemonkey
	}
};
 }),
 (function(module, exports) {

module.exports = {"builtin":{"Array":false,"ArrayBuffer":false,"Atomics":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es5":{"Array":false,"Boolean":false,"constructor":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"propertyIsEnumerable":false,"RangeError":false,"ReferenceError":false,"RegExp":false,"String":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false},"es2015":{"Array":false,"ArrayBuffer":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es2017":{"Array":false,"ArrayBuffer":false,"Atomics":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"browser":{"addEventListener":false,"alert":false,"AnalyserNode":false,"Animation":false,"AnimationEffectReadOnly":false,"AnimationEffectTiming":false,"AnimationEffectTimingReadOnly":false,"AnimationEvent":false,"AnimationPlaybackEvent":false,"AnimationTimeline":false,"applicationCache":false,"ApplicationCache":false,"ApplicationCacheErrorEvent":false,"atob":false,"Attr":false,"Audio":false,"AudioBuffer":false,"AudioBufferSourceNode":false,"AudioContext":false,"AudioDestinationNode":false,"AudioListener":false,"AudioNode":false,"AudioParam":false,"AudioProcessingEvent":false,"AudioScheduledSourceNode":false,"BarProp":false,"BaseAudioContext":false,"BatteryManager":false,"BeforeUnloadEvent":false,"BiquadFilterNode":false,"Blob":false,"BlobEvent":false,"blur":false,"BroadcastChannel":false,"btoa":false,"BudgetService":false,"ByteLengthQueuingStrategy":false,"Cache":false,"caches":false,"CacheStorage":false,"cancelAnimationFrame":false,"cancelIdleCallback":false,"CanvasCaptureMediaStreamTrack":false,"CanvasGradient":false,"CanvasPattern":false,"CanvasRenderingContext2D":false,"ChannelMergerNode":false,"ChannelSplitterNode":false,"CharacterData":false,"clearInterval":false,"clearTimeout":false,"clientInformation":false,"ClipboardEvent":false,"close":false,"closed":false,"CloseEvent":false,"Comment":false,"CompositionEvent":false,"confirm":false,"console":false,"ConstantSourceNode":false,"ConvolverNode":false,"CountQueuingStrategy":false,"createImageBitmap":false,"Credential":false,"CredentialsContainer":false,"crypto":false,"Crypto":false,"CryptoKey":false,"CSS":false,"CSSConditionRule":false,"CSSFontFaceRule":false,"CSSGroupingRule":false,"CSSImportRule":false,"CSSKeyframeRule":false,"CSSKeyframesRule":false,"CSSMediaRule":false,"CSSNamespaceRule":false,"CSSPageRule":false,"CSSRule":false,"CSSRuleList":false,"CSSStyleDeclaration":false,"CSSStyleRule":false,"CSSStyleSheet":false,"CSSSupportsRule":false,"CustomElementRegistry":false,"customElements":false,"CustomEvent":false,"DataTransfer":false,"DataTransferItem":false,"DataTransferItemList":false,"defaultstatus":false,"defaultStatus":false,"DelayNode":false,"DeviceMotionEvent":false,"DeviceOrientationEvent":false,"devicePixelRatio":false,"dispatchEvent":false,"document":false,"Document":false,"DocumentFragment":false,"DocumentType":false,"DOMError":false,"DOMException":false,"DOMImplementation":false,"DOMMatrix":false,"DOMMatrixReadOnly":false,"DOMParser":false,"DOMPoint":false,"DOMPointReadOnly":false,"DOMQuad":false,"DOMRect":false,"DOMRectReadOnly":false,"DOMStringList":false,"DOMStringMap":false,"DOMTokenList":false,"DragEvent":false,"DynamicsCompressorNode":false,"Element":false,"ErrorEvent":false,"event":false,"Event":false,"EventSource":false,"EventTarget":false,"external":false,"fetch":false,"File":false,"FileList":false,"FileReader":false,"find":false,"focus":false,"FocusEvent":false,"FontFace":false,"FontFaceSetLoadEvent":false,"FormData":false,"frameElement":false,"frames":false,"GainNode":false,"Gamepad":false,"GamepadButton":false,"GamepadEvent":false,"getComputedStyle":false,"getSelection":false,"HashChangeEvent":false,"Headers":false,"history":false,"History":false,"HTMLAllCollection":false,"HTMLAnchorElement":false,"HTMLAreaElement":false,"HTMLAudioElement":false,"HTMLBaseElement":false,"HTMLBodyElement":false,"HTMLBRElement":false,"HTMLButtonElement":false,"HTMLCanvasElement":false,"HTMLCollection":false,"HTMLContentElement":false,"HTMLDataElement":false,"HTMLDataListElement":false,"HTMLDetailsElement":false,"HTMLDialogElement":false,"HTMLDirectoryElement":false,"HTMLDivElement":false,"HTMLDListElement":false,"HTMLDocument":false,"HTMLElement":false,"HTMLEmbedElement":false,"HTMLFieldSetElement":false,"HTMLFontElement":false,"HTMLFormControlsCollection":false,"HTMLFormElement":false,"HTMLFrameElement":false,"HTMLFrameSetElement":false,"HTMLHeadElement":false,"HTMLHeadingElement":false,"HTMLHRElement":false,"HTMLHtmlElement":false,"HTMLIFrameElement":false,"HTMLImageElement":false,"HTMLInputElement":false,"HTMLLabelElement":false,"HTMLLegendElement":false,"HTMLLIElement":false,"HTMLLinkElement":false,"HTMLMapElement":false,"HTMLMarqueeElement":false,"HTMLMediaElement":false,"HTMLMenuElement":false,"HTMLMetaElement":false,"HTMLMeterElement":false,"HTMLModElement":false,"HTMLObjectElement":false,"HTMLOListElement":false,"HTMLOptGroupElement":false,"HTMLOptionElement":false,"HTMLOptionsCollection":false,"HTMLOutputElement":false,"HTMLParagraphElement":false,"HTMLParamElement":false,"HTMLPictureElement":false,"HTMLPreElement":false,"HTMLProgressElement":false,"HTMLQuoteElement":false,"HTMLScriptElement":false,"HTMLSelectElement":false,"HTMLShadowElement":false,"HTMLSlotElement":false,"HTMLSourceElement":false,"HTMLSpanElement":false,"HTMLStyleElement":false,"HTMLTableCaptionElement":false,"HTMLTableCellElement":false,"HTMLTableColElement":false,"HTMLTableElement":false,"HTMLTableRowElement":false,"HTMLTableSectionElement":false,"HTMLTemplateElement":false,"HTMLTextAreaElement":false,"HTMLTimeElement":false,"HTMLTitleElement":false,"HTMLTrackElement":false,"HTMLUListElement":false,"HTMLUnknownElement":false,"HTMLVideoElement":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"IdleDeadline":false,"IIRFilterNode":false,"Image":false,"ImageBitmap":false,"ImageBitmapRenderingContext":false,"ImageCapture":false,"ImageData":false,"indexedDB":false,"innerHeight":false,"innerWidth":false,"InputEvent":false,"IntersectionObserver":false,"IntersectionObserverEntry":false,"Intl":false,"isSecureContext":false,"KeyboardEvent":false,"KeyframeEffect":false,"KeyframeEffectReadOnly":false,"length":false,"localStorage":false,"location":false,"Location":false,"locationbar":false,"matchMedia":false,"MediaDeviceInfo":false,"MediaDevices":false,"MediaElementAudioSourceNode":false,"MediaEncryptedEvent":false,"MediaError":false,"MediaKeyMessageEvent":false,"MediaKeySession":false,"MediaKeyStatusMap":false,"MediaKeySystemAccess":false,"MediaList":false,"MediaQueryList":false,"MediaQueryListEvent":false,"MediaRecorder":false,"MediaSettingsRange":false,"MediaSource":false,"MediaStream":false,"MediaStreamAudioDestinationNode":false,"MediaStreamAudioSourceNode":false,"MediaStreamEvent":false,"MediaStreamTrack":false,"MediaStreamTrackEvent":false,"menubar":false,"MessageChannel":false,"MessageEvent":false,"MessagePort":false,"MIDIAccess":false,"MIDIConnectionEvent":false,"MIDIInput":false,"MIDIInputMap":false,"MIDIMessageEvent":false,"MIDIOutput":false,"MIDIOutputMap":false,"MIDIPort":false,"MimeType":false,"MimeTypeArray":false,"MouseEvent":false,"moveBy":false,"moveTo":false,"MutationEvent":false,"MutationObserver":false,"MutationRecord":false,"name":false,"NamedNodeMap":false,"NavigationPreloadManager":false,"navigator":false,"Navigator":false,"NetworkInformation":false,"Node":false,"NodeFilter":false,"NodeIterator":false,"NodeList":false,"Notification":false,"OfflineAudioCompletionEvent":false,"OfflineAudioContext":false,"offscreenBuffering":false,"OffscreenCanvas":true,"onabort":true,"onafterprint":true,"onanimationend":true,"onanimationiteration":true,"onanimationstart":true,"onappinstalled":true,"onauxclick":true,"onbeforeinstallprompt":true,"onbeforeprint":true,"onbeforeunload":true,"onblur":true,"oncancel":true,"oncanplay":true,"oncanplaythrough":true,"onchange":true,"onclick":true,"onclose":true,"oncontextmenu":true,"oncuechange":true,"ondblclick":true,"ondevicemotion":true,"ondeviceorientation":true,"ondeviceorientationabsolute":true,"ondrag":true,"ondragend":true,"ondragenter":true,"ondragleave":true,"ondragover":true,"ondragstart":true,"ondrop":true,"ondurationchange":true,"onemptied":true,"onended":true,"onerror":true,"onfocus":true,"ongotpointercapture":true,"onhashchange":true,"oninput":true,"oninvalid":true,"onkeydown":true,"onkeypress":true,"onkeyup":true,"onlanguagechange":true,"onload":true,"onloadeddata":true,"onloadedmetadata":true,"onloadstart":true,"onlostpointercapture":true,"onmessage":true,"onmessageerror":true,"onmousedown":true,"onmouseenter":true,"onmouseleave":true,"onmousemove":true,"onmouseout":true,"onmouseover":true,"onmouseup":true,"onmousewheel":true,"onoffline":true,"ononline":true,"onpagehide":true,"onpageshow":true,"onpause":true,"onplay":true,"onplaying":true,"onpointercancel":true,"onpointerdown":true,"onpointerenter":true,"onpointerleave":true,"onpointermove":true,"onpointerout":true,"onpointerover":true,"onpointerup":true,"onpopstate":true,"onprogress":true,"onratechange":true,"onrejectionhandled":true,"onreset":true,"onresize":true,"onscroll":true,"onsearch":true,"onseeked":true,"onseeking":true,"onselect":true,"onstalled":true,"onstorage":true,"onsubmit":true,"onsuspend":true,"ontimeupdate":true,"ontoggle":true,"ontransitionend":true,"onunhandledrejection":true,"onunload":true,"onvolumechange":true,"onwaiting":true,"onwheel":true,"open":false,"openDatabase":false,"opener":false,"Option":false,"origin":false,"OscillatorNode":false,"outerHeight":false,"outerWidth":false,"PageTransitionEvent":false,"pageXOffset":false,"pageYOffset":false,"PannerNode":false,"parent":false,"Path2D":false,"PaymentAddress":false,"PaymentRequest":false,"PaymentRequestUpdateEvent":false,"PaymentResponse":false,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceLongTaskTiming":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceNavigationTiming":false,"PerformanceObserver":false,"PerformanceObserverEntryList":false,"PerformancePaintTiming":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"PeriodicWave":false,"Permissions":false,"PermissionStatus":false,"personalbar":false,"PhotoCapabilities":false,"Plugin":false,"PluginArray":false,"PointerEvent":false,"PopStateEvent":false,"postMessage":false,"Presentation":false,"PresentationAvailability":false,"PresentationConnection":false,"PresentationConnectionAvailableEvent":false,"PresentationConnectionCloseEvent":false,"PresentationConnectionList":false,"PresentationReceiver":false,"PresentationRequest":false,"print":false,"ProcessingInstruction":false,"ProgressEvent":false,"PromiseRejectionEvent":false,"prompt":false,"PushManager":false,"PushSubscription":false,"PushSubscriptionOptions":false,"RadioNodeList":false,"Range":false,"ReadableStream":false,"RemotePlayback":false,"removeEventListener":false,"Request":false,"requestAnimationFrame":false,"requestIdleCallback":false,"resizeBy":false,"ResizeObserver":false,"ResizeObserverEntry":false,"resizeTo":false,"Response":false,"RTCCertificate":false,"RTCDataChannel":false,"RTCDataChannelEvent":false,"RTCIceCandidate":false,"RTCPeerConnection":false,"RTCPeerConnectionIceEvent":false,"RTCRtpContributingSource":false,"RTCRtpReceiver":false,"RTCSessionDescription":false,"RTCStatsReport":false,"screen":false,"Screen":false,"screenLeft":false,"ScreenOrientation":false,"screenTop":false,"screenX":false,"screenY":false,"ScriptProcessorNode":false,"scroll":false,"scrollbars":false,"scrollBy":false,"scrollTo":false,"scrollX":false,"scrollY":false,"SecurityPolicyViolationEvent":false,"Selection":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerRegistration":false,"sessionStorage":false,"setInterval":false,"setTimeout":false,"ShadowRoot":false,"SharedWorker":false,"SourceBuffer":false,"SourceBufferList":false,"speechSynthesis":false,"SpeechSynthesisEvent":false,"SpeechSynthesisUtterance":false,"StaticRange":false,"status":false,"statusbar":false,"StereoPannerNode":false,"stop":false,"Storage":false,"StorageEvent":false,"StorageManager":false,"styleMedia":false,"StyleSheet":false,"StyleSheetList":false,"SubtleCrypto":false,"SVGAElement":false,"SVGAngle":false,"SVGAnimatedAngle":false,"SVGAnimatedBoolean":false,"SVGAnimatedEnumeration":false,"SVGAnimatedInteger":false,"SVGAnimatedLength":false,"SVGAnimatedLengthList":false,"SVGAnimatedNumber":false,"SVGAnimatedNumberList":false,"SVGAnimatedPreserveAspectRatio":false,"SVGAnimatedRect":false,"SVGAnimatedString":false,"SVGAnimatedTransformList":false,"SVGAnimateElement":false,"SVGAnimateMotionElement":false,"SVGAnimateTransformElement":false,"SVGAnimationElement":false,"SVGCircleElement":false,"SVGClipPathElement":false,"SVGComponentTransferFunctionElement":false,"SVGDefsElement":false,"SVGDescElement":false,"SVGDiscardElement":false,"SVGElement":false,"SVGEllipseElement":false,"SVGFEBlendElement":false,"SVGFEColorMatrixElement":false,"SVGFEComponentTransferElement":false,"SVGFECompositeElement":false,"SVGFEConvolveMatrixElement":false,"SVGFEDiffuseLightingElement":false,"SVGFEDisplacementMapElement":false,"SVGFEDistantLightElement":false,"SVGFEDropShadowElement":false,"SVGFEFloodElement":false,"SVGFEFuncAElement":false,"SVGFEFuncBElement":false,"SVGFEFuncGElement":false,"SVGFEFuncRElement":false,"SVGFEGaussianBlurElement":false,"SVGFEImageElement":false,"SVGFEMergeElement":false,"SVGFEMergeNodeElement":false,"SVGFEMorphologyElement":false,"SVGFEOffsetElement":false,"SVGFEPointLightElement":false,"SVGFESpecularLightingElement":false,"SVGFESpotLightElement":false,"SVGFETileElement":false,"SVGFETurbulenceElement":false,"SVGFilterElement":false,"SVGForeignObjectElement":false,"SVGGElement":false,"SVGGeometryElement":false,"SVGGradientElement":false,"SVGGraphicsElement":false,"SVGImageElement":false,"SVGLength":false,"SVGLengthList":false,"SVGLinearGradientElement":false,"SVGLineElement":false,"SVGMarkerElement":false,"SVGMaskElement":false,"SVGMatrix":false,"SVGMetadataElement":false,"SVGMPathElement":false,"SVGNumber":false,"SVGNumberList":false,"SVGPathElement":false,"SVGPatternElement":false,"SVGPoint":false,"SVGPointList":false,"SVGPolygonElement":false,"SVGPolylineElement":false,"SVGPreserveAspectRatio":false,"SVGRadialGradientElement":false,"SVGRect":false,"SVGRectElement":false,"SVGScriptElement":false,"SVGSetElement":false,"SVGStopElement":false,"SVGStringList":false,"SVGStyleElement":false,"SVGSVGElement":false,"SVGSwitchElement":false,"SVGSymbolElement":false,"SVGTextContentElement":false,"SVGTextElement":false,"SVGTextPathElement":false,"SVGTextPositioningElement":false,"SVGTitleElement":false,"SVGTransform":false,"SVGTransformList":false,"SVGTSpanElement":false,"SVGUnitTypes":false,"SVGUseElement":false,"SVGViewElement":false,"TaskAttributionTiming":false,"Text":false,"TextDecoder":false,"TextEncoder":false,"TextEvent":false,"TextMetrics":false,"TextTrack":false,"TextTrackCue":false,"TextTrackCueList":false,"TextTrackList":false,"TimeRanges":false,"toolbar":false,"top":false,"Touch":false,"TouchEvent":false,"TouchList":false,"TrackEvent":false,"TransitionEvent":false,"TreeWalker":false,"UIEvent":false,"URL":false,"URLSearchParams":false,"ValidityState":false,"visualViewport":false,"VisualViewport":false,"VTTCue":false,"WaveShaperNode":false,"WebAssembly":false,"WebGL2RenderingContext":false,"WebGLActiveInfo":false,"WebGLBuffer":false,"WebGLContextEvent":false,"WebGLFramebuffer":false,"WebGLProgram":false,"WebGLQuery":false,"WebGLRenderbuffer":false,"WebGLRenderingContext":false,"WebGLSampler":false,"WebGLShader":false,"WebGLShaderPrecisionFormat":false,"WebGLSync":false,"WebGLTexture":false,"WebGLTransformFeedback":false,"WebGLUniformLocation":false,"WebGLVertexArrayObject":false,"WebSocket":false,"WheelEvent":false,"window":false,"Window":false,"Worker":false,"WritableStream":false,"XMLDocument":false,"XMLHttpRequest":false,"XMLHttpRequestEventTarget":false,"XMLHttpRequestUpload":false,"XMLSerializer":false,"XPathEvaluator":false,"XPathExpression":false,"XPathResult":false,"XSLTProcessor":false},"worker":{"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"clearInterval":false,"clearTimeout":false,"close":true,"console":false,"fetch":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":true,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onlanguagechange":true,"onmessage":true,"onoffline":true,"ononline":true,"onrejectionhandled":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"Request":false,"Response":false,"self":true,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"Worker":false,"XMLHttpRequest":false},"node":{"__dirname":false,"__filename":false,"Buffer":false,"clearImmediate":false,"clearInterval":false,"clearTimeout":false,"console":false,"exports":true,"global":false,"Intl":false,"module":false,"process":false,"require":false,"setImmediate":false,"setInterval":false,"setTimeout":false},"commonjs":{"exports":true,"global":false,"module":false,"require":false},"amd":{"define":false,"require":false},"mocha":{"after":false,"afterEach":false,"before":false,"beforeEach":false,"context":false,"describe":false,"it":false,"mocha":false,"run":false,"setup":false,"specify":false,"suite":false,"suiteSetup":false,"suiteTeardown":false,"teardown":false,"test":false,"xcontext":false,"xdescribe":false,"xit":false,"xspecify":false},"jasmine":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fail":false,"fdescribe":false,"fit":false,"it":false,"jasmine":false,"pending":false,"runs":false,"spyOn":false,"spyOnProperty":false,"waits":false,"waitsFor":false,"xdescribe":false,"xit":false},"jest":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fdescribe":false,"fit":false,"it":false,"jest":false,"pit":false,"require":false,"test":false,"xdescribe":false,"xit":false,"xtest":false},"qunit":{"asyncTest":false,"deepEqual":false,"equal":false,"expect":false,"module":false,"notDeepEqual":false,"notEqual":false,"notOk":false,"notPropEqual":false,"notStrictEqual":false,"ok":false,"propEqual":false,"QUnit":false,"raises":false,"start":false,"stop":false,"strictEqual":false,"test":false,"throws":false},"phantomjs":{"console":true,"exports":true,"phantom":true,"require":true,"WebPage":true},"couch":{"emit":false,"exports":false,"getRow":false,"log":false,"module":false,"provides":false,"require":false,"respond":false,"send":false,"start":false,"sum":false},"rhino":{"defineClass":false,"deserialize":false,"gc":false,"help":false,"importClass":false,"importPackage":false,"java":false,"load":false,"loadClass":false,"Packages":false,"print":false,"quit":false,"readFile":false,"readUrl":false,"runCommand":false,"seal":false,"serialize":false,"spawn":false,"sync":false,"toint32":false,"version":false},"nashorn":{"__DIR__":false,"__FILE__":false,"__LINE__":false,"com":false,"edu":false,"exit":false,"java":false,"Java":false,"javafx":false,"JavaImporter":false,"javax":false,"JSAdapter":false,"load":false,"loadWithNewGlobal":false,"org":false,"Packages":false,"print":false,"quit":false},"wsh":{"ActiveXObject":true,"Enumerator":true,"GetObject":true,"ScriptEngine":true,"ScriptEngineBuildVersion":true,"ScriptEngineMajorVersion":true,"ScriptEngineMinorVersion":true,"VBArray":true,"WScript":true,"WSH":true,"XDomainRequest":true},"jquery":{"$":false,"jQuery":false},"yui":{"Y":false,"YUI":false,"YUI_config":false},"shelljs":{"cat":false,"cd":false,"chmod":false,"config":false,"cp":false,"dirs":false,"echo":false,"env":false,"error":false,"exec":false,"exit":false,"find":false,"grep":false,"ln":false,"ls":false,"mkdir":false,"mv":false,"popd":false,"pushd":false,"pwd":false,"rm":false,"sed":false,"set":false,"target":false,"tempdir":false,"test":false,"touch":false,"which":false},"prototypejs":{"$":false,"$$":false,"$A":false,"$break":false,"$continue":false,"$F":false,"$H":false,"$R":false,"$w":false,"Abstract":false,"Ajax":false,"Autocompleter":false,"Builder":false,"Class":false,"Control":false,"Draggable":false,"Draggables":false,"Droppables":false,"Effect":false,"Element":false,"Enumerable":false,"Event":false,"Field":false,"Form":false,"Hash":false,"Insertion":false,"ObjectRange":false,"PeriodicalExecuter":false,"Position":false,"Prototype":false,"Scriptaculous":false,"Selector":false,"Sortable":false,"SortableObserver":false,"Sound":false,"Template":false,"Toggle":false,"Try":false},"meteor":{"_":false,"$":false,"Accounts":false,"AccountsClient":false,"AccountsCommon":false,"AccountsServer":false,"App":false,"Assets":false,"Blaze":false,"check":false,"Cordova":false,"DDP":false,"DDPRateLimiter":false,"DDPServer":false,"Deps":false,"EJSON":false,"Email":false,"HTTP":false,"Log":false,"Match":false,"Meteor":false,"Mongo":false,"MongoInternals":false,"Npm":false,"Package":false,"Plugin":false,"process":false,"Random":false,"ReactiveDict":false,"ReactiveVar":false,"Router":false,"ServiceConfiguration":false,"Session":false,"share":false,"Spacebars":false,"Template":false,"Tinytest":false,"Tracker":false,"UI":false,"Utils":false,"WebApp":false,"WebAppInternals":false},"mongo":{"_isWindows":false,"_rand":false,"BulkWriteResult":false,"cat":false,"cd":false,"connect":false,"db":false,"getHostName":false,"getMemInfo":false,"hostname":false,"ISODate":false,"listFiles":false,"load":false,"ls":false,"md5sumFile":false,"mkdir":false,"Mongo":false,"NumberInt":false,"NumberLong":false,"ObjectId":false,"PlanCache":false,"print":false,"printjson":false,"pwd":false,"quit":false,"removeFile":false,"rs":false,"sh":false,"UUID":false,"version":false,"WriteResult":false},"applescript":{"$":false,"Application":false,"Automation":false,"console":false,"delay":false,"Library":false,"ObjC":false,"ObjectSpecifier":false,"Path":false,"Progress":false,"Ref":false},"serviceworker":{"Cache":false,"caches":false,"CacheStorage":false,"Client":false,"clients":false,"Clients":false,"ExtendableEvent":false,"ExtendableMessageEvent":false,"FetchEvent":false,"importScripts":false,"registration":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerGlobalScope":false,"ServiceWorkerMessageEvent":false,"ServiceWorkerRegistration":false,"skipWaiting":false,"WindowClient":false},"atomtest":{"advanceClock":false,"fakeClearInterval":false,"fakeClearTimeout":false,"fakeSetInterval":false,"fakeSetTimeout":false,"resetTimeouts":false,"waitsForPromise":false},"embertest":{"andThen":false,"click":false,"currentPath":false,"currentRouteName":false,"currentURL":false,"fillIn":false,"find":false,"findWithAssert":false,"keyEvent":false,"pauseTest":false,"resumeTest":false,"triggerEvent":false,"visit":false,"wait":false},"protractor":{"$":false,"$$":false,"browser":false,"by":false,"By":false,"DartObject":false,"element":false,"protractor":false},"shared-node-browser":{"clearInterval":false,"clearTimeout":false,"console":false,"setInterval":false,"setTimeout":false},"webextensions":{"browser":false,"chrome":false,"opr":false},"greasemonkey":{"GM":false,"GM_addStyle":false,"GM_deleteValue":false,"GM_getResourceText":false,"GM_getResourceURL":false,"GM_getValue":false,"GM_info":false,"GM_listValues":false,"GM_log":false,"GM_openInTab":false,"GM_registerMenuCommand":false,"GM_setClipboard":false,"GM_setValue":false,"GM_xmlhttpRequest":false,"unsafeWindow":false},"devtools":{"$":false,"$_":false,"$$":false,"$0":false,"$1":false,"$2":false,"$3":false,"$4":false,"$x":false,"chrome":false,"clear":false,"copy":false,"debug":false,"dir":false,"dirxml":false,"getEventListeners":false,"inspect":false,"keys":false,"monitor":false,"monitorEvents":false,"profile":false,"profileEnd":false,"queryObjects":false,"table":false,"undebug":false,"unmonitor":false,"unmonitorEvents":false,"values":false}}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var lodash = __webpack_require__(10);
function compareLocations(itemA, itemB) {
	return itemA.line - itemB.line || itemA.column - itemB.column;
}
function applyDirectives(options) {
	var problems = [];
	var nextDirectiveIndex = 0;
	var currentGlobalDisableDirective = null;
	var disabledRuleMap = new Map();
	var enabledRules = new Set();
	var usedDisableDirectives = new Set();

	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = options.problems[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var problem = _step.value;

			while (nextDirectiveIndex < options.directives.length && compareLocations(options.directives[nextDirectiveIndex], problem) <= 0) {
				var directive = options.directives[nextDirectiveIndex++];

				switch (directive.type) {
					case "disable":
						if (directive.ruleId === null) {
							currentGlobalDisableDirective = directive;
							disabledRuleMap.clear();
							enabledRules.clear();
						} else if (currentGlobalDisableDirective) {
							enabledRules.delete(directive.ruleId);
							disabledRuleMap.set(directive.ruleId, directive);
						} else {
							disabledRuleMap.set(directive.ruleId, directive);
						}
						break;

					case "enable":
						if (directive.ruleId === null) {
							currentGlobalDisableDirective = null;
							disabledRuleMap.clear();
						} else if (currentGlobalDisableDirective) {
							enabledRules.add(directive.ruleId);
							disabledRuleMap.delete(directive.ruleId);
						} else {
							disabledRuleMap.delete(directive.ruleId);
						}
						break;
				}
			}

			if (disabledRuleMap.has(problem.ruleId)) {
				usedDisableDirectives.add(disabledRuleMap.get(problem.ruleId));
			} else if (currentGlobalDisableDirective && !enabledRules.has(problem.ruleId)) {
				usedDisableDirectives.add(currentGlobalDisableDirective);
			} else {
				problems.push(problem);
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	var unusedDisableDirectives = options.directives.filter(function (directive) {
		return directive.type === "disable" && !usedDisableDirectives.has(directive);
	}).map(function (directive) {
		return {
			ruleId: null,
			message: directive.ruleId ? "Unused eslint-disable directive (no problems were reported from '" + directive.ruleId + "')." : "Unused eslint-disable directive (no problems were reported).",
			line: directive.unprocessedDirective.line,
			column: directive.unprocessedDirective.column,
			severity: 2,
			source: null,
			nodeType: null
		};
	});

	return { problems: problems, unusedDisableDirectives: unusedDisableDirectives };
}
module.exports = function (options) {
	var blockDirectives = options.directives.filter(function (directive) {
		return directive.type === "disable" || directive.type === "enable";
	}).map(function (directive) {
		return Object.assign({}, directive, { unprocessedDirective: directive });
	}).sort(compareLocations);

	var lineDirectives = lodash.flatMap(options.directives, function (directive) {
		switch (directive.type) {
			case "disable":
			case "enable":
				return [];

			case "disable-line":
				return [{ type: "disable", line: directive.line, column: 1, ruleId: directive.ruleId, unprocessedDirective: directive }, { type: "enable", line: directive.line + 1, column: 0, ruleId: directive.ruleId, unprocessedDirective: directive }];

			case "disable-next-line":
				return [{ type: "disable", line: directive.line + 1, column: 1, ruleId: directive.ruleId, unprocessedDirective: directive }, { type: "enable", line: directive.line + 2, column: 0, ruleId: directive.ruleId, unprocessedDirective: directive }];

			default:
				throw new TypeError("Unrecognized directive type '" + directive.type + "'");
		}
	}).sort(compareLocations);

	var blockDirectivesResult = applyDirectives({ problems: options.problems, directives: blockDirectives });
	var lineDirectivesResult = applyDirectives({ problems: blockDirectivesResult.problems, directives: lineDirectives });

	return options.reportUnusedDisableDirectives ? lineDirectivesResult.problems.concat(blockDirectivesResult.unusedDisableDirectives).concat(lineDirectivesResult.unusedDisableDirectives).sort(compareLocations) : lineDirectivesResult.problems;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function () {
	var listeners = Object.create(null);

	return Object.freeze({
		on: function on(eventName, listener) {
			if (eventName in listeners) {
				listeners[eventName].push(listener);
			} else {
				listeners[eventName] = [listener];
			}
		},
		emit: function emit(eventName, a, b, c) {
			if (eventName in listeners) {
				listeners[eventName].forEach(function (listener) {
					return listener(a, b, c);
				});
			}
		},
		eventNames: function eventNames() {
			return Object.keys(listeners);
		}
	});
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var esquery = __webpack_require__(376);
var lodash = __webpack_require__(10);
function getPossibleTypes(parsedSelector) {
	switch (parsedSelector.type) {
		case "identifier":
			return [parsedSelector.value];

		case "matches":
			{
				var typesForComponents = parsedSelector.selectors.map(getPossibleTypes);

				if (typesForComponents.every(function (typesForComponent) {
					return typesForComponent;
				})) {
					return lodash.union.apply(null, typesForComponents);
				}
				return null;
			}

		case "compound":
			{
				var _typesForComponents = parsedSelector.selectors.map(getPossibleTypes).filter(function (typesForComponent) {
					return typesForComponent;
				});
				if (!_typesForComponents.length) {
					return null;
				}
				return lodash.intersection.apply(null, _typesForComponents);
			}

		case "child":
		case "descendant":
		case "sibling":
		case "adjacent":
			return getPossibleTypes(parsedSelector.right);

		default:
			return null;

	}
}
function countClassAttributes(parsedSelector) {
	switch (parsedSelector.type) {
		case "child":
		case "descendant":
		case "sibling":
		case "adjacent":
			return countClassAttributes(parsedSelector.left) + countClassAttributes(parsedSelector.right);

		case "compound":
		case "not":
		case "matches":
			return parsedSelector.selectors.reduce(function (sum, childSelector) {
				return sum + countClassAttributes(childSelector);
			}, 0);

		case "attribute":
		case "field":
		case "nth-child":
		case "nth-last-child":
			return 1;

		default:
			return 0;
	}
}
function countIdentifiers(parsedSelector) {
	switch (parsedSelector.type) {
		case "child":
		case "descendant":
		case "sibling":
		case "adjacent":
			return countIdentifiers(parsedSelector.left) + countIdentifiers(parsedSelector.right);

		case "compound":
		case "not":
		case "matches":
			return parsedSelector.selectors.reduce(function (sum, childSelector) {
				return sum + countIdentifiers(childSelector);
			}, 0);

		case "identifier":
			return 1;

		default:
			return 0;
	}
}
function compareSpecificity(selectorA, selectorB) {
	return selectorA.attributeCount - selectorB.attributeCount || selectorA.identifierCount - selectorB.identifierCount || (selectorA.rawSelector <= selectorB.rawSelector ? -1 : 1);
}
function tryParseSelector(rawSelector) {
	try {
		return esquery.parse(rawSelector.replace(/:exit$/, ""));
	} catch (err) {
		if (typeof err.offset === "number") {
			throw new SyntaxError("Syntax error in selector \"" + rawSelector + "\" at position " + err.offset + ": " + err.message);
		}
		throw err;
	}
}
var parseSelector = lodash.memoize(function (rawSelector) {
	var parsedSelector = tryParseSelector(rawSelector);

	return {
		rawSelector: rawSelector,
		isExit: rawSelector.endsWith(":exit"),
		parsedSelector: parsedSelector,
		listenerTypes: getPossibleTypes(parsedSelector),
		attributeCount: countClassAttributes(parsedSelector),
		identifierCount: countIdentifiers(parsedSelector)
	};
});

var NodeEventGenerator = function () {
	function NodeEventGenerator(emitter) {
		var _this = this;

		_classCallCheck(this, NodeEventGenerator);

		this.emitter = emitter;
		this.currentAncestry = [];
		this.enterSelectorsByNodeType = new Map();
		this.exitSelectorsByNodeType = new Map();
		this.anyTypeEnterSelectors = [];
		this.anyTypeExitSelectors = [];

		emitter.eventNames().forEach(function (rawSelector) {
			var selector = parseSelector(rawSelector);

			if (selector.listenerTypes) {
				selector.listenerTypes.forEach(function (nodeType) {
					var typeMap = selector.isExit ? _this.exitSelectorsByNodeType : _this.enterSelectorsByNodeType;

					if (!typeMap.has(nodeType)) {
						typeMap.set(nodeType, []);
					}
					typeMap.get(nodeType).push(selector);
				});
			} else {
				(selector.isExit ? _this.anyTypeExitSelectors : _this.anyTypeEnterSelectors).push(selector);
			}
		});

		this.anyTypeEnterSelectors.sort(compareSpecificity);
		this.anyTypeExitSelectors.sort(compareSpecificity);
		this.enterSelectorsByNodeType.forEach(function (selectorList) {
			return selectorList.sort(compareSpecificity);
		});
		this.exitSelectorsByNodeType.forEach(function (selectorList) {
			return selectorList.sort(compareSpecificity);
		});
	}


	_createClass(NodeEventGenerator, [{
		key: "applySelector",
		value: function applySelector(node, selector) {
			if (esquery.matches(node, selector.parsedSelector, this.currentAncestry)) {
				this.emitter.emit(selector.rawSelector, node);
			}
		}

	}, {
		key: "applySelectors",
		value: function applySelectors(node, isExit) {
			var selectorsByNodeType = (isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType).get(node.type) || [];
			var anyTypeSelectors = isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;
			var selectorsByTypeIndex = 0;
			var anyTypeSelectorsIndex = 0;

			while (selectorsByTypeIndex < selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length) {
				if (selectorsByTypeIndex >= selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length && compareSpecificity(anyTypeSelectors[anyTypeSelectorsIndex], selectorsByNodeType[selectorsByTypeIndex]) < 0) {
					this.applySelector(node, anyTypeSelectors[anyTypeSelectorsIndex++]);
				} else {
					this.applySelector(node, selectorsByNodeType[selectorsByTypeIndex++]);
				}
			}
		}

	}, {
		key: "enterNode",
		value: function enterNode(node) {
			if (node.parent) {
				this.currentAncestry.unshift(node.parent);
			}
			this.applySelectors(node, false);
		}

	}, {
		key: "leaveNode",
		value: function leaveNode(node) {
			this.applySelectors(node, true);
			this.currentAncestry.shift();
		}
	}]);

	return NodeEventGenerator;
}();

module.exports = NodeEventGenerator;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
(function () {

	var estraverse = __webpack_require__(50);
	var parser = __webpack_require__(377);

	var isArray = Array.isArray || function isArray(array) {
		return {}.toString.call(array) === '[object Array]';
	};

	var LEFT_SIDE = {};
	var RIGHT_SIDE = {};

	function esqueryModule() {
		function getPath(obj, key) {
			var i,
				keys = key.split(".");
			for (i = 0; i < keys.length; i++) {
				if (obj == null) {
					return obj;
				}
				obj = obj[keys[i]];
			}
			return obj;
		}
		function inPath(node, ancestor, path) {
			var field, remainingPath, i;
			if (path.length === 0) {
				return node === ancestor;
			}
			if (ancestor == null) {
				return false;
			}
			field = ancestor[path[0]];
			remainingPath = path.slice(1);
			if (isArray(field)) {
				for (i = 0, l = field.length; i < l; ++i) {
					if (inPath(node, field[i], remainingPath)) {
						return true;
					}
				}
				return false;
			} else {
				return inPath(node, field, remainingPath);
			}
		}
		function matches(node, selector, ancestry) {
			var path, ancestor, i, l, p;
			if (!selector) {
				return true;
			}
			if (!node) {
				return false;
			}
			if (!ancestry) {
				ancestry = [];
			}

			switch (selector.type) {
				case 'wildcard':
					return true;

				case 'identifier':
					return selector.value.toLowerCase() === node.type.toLowerCase();

				case 'field':
					path = selector.name.split('.');
					ancestor = ancestry[path.length - 1];
					return inPath(node, ancestor, path);

				case 'matches':
					for (i = 0, l = selector.selectors.length; i < l; ++i) {
						if (matches(node, selector.selectors[i], ancestry)) {
							return true;
						}
					}
					return false;

				case 'compound':
					for (i = 0, l = selector.selectors.length; i < l; ++i) {
						if (!matches(node, selector.selectors[i], ancestry)) {
							return false;
						}
					}
					return true;

				case 'not':
					for (i = 0, l = selector.selectors.length; i < l; ++i) {
						if (matches(node, selector.selectors[i], ancestry)) {
							return false;
						}
					}
					return true;

				case 'child':
					if (matches(node, selector.right, ancestry)) {
						return matches(ancestry[0], selector.left, ancestry.slice(1));
					}
					return false;

				case 'descendant':
					if (matches(node, selector.right, ancestry)) {
						for (i = 0, l = ancestry.length; i < l; ++i) {
							if (matches(ancestry[i], selector.left, ancestry.slice(i + 1))) {
								return true;
							}
						}
					}
					return false;

				case 'attribute':
					p = getPath(node, selector.name);
					switch (selector.operator) {
						case null:
						case void 0:
							return p != null;
						case '=':
							switch (selector.value.type) {
								case 'regexp':
									return selector.value.value.test(p);
								case 'literal':
									return '' + selector.value.value === '' + p;
								case 'type':
									return selector.value.value === (typeof p === 'undefined' ? 'undefined' : _typeof(p));
							}
						case '!=':
							switch (selector.value.type) {
								case 'regexp':
									return !selector.value.value.test(p);
								case 'literal':
									return '' + selector.value.value !== '' + p;
								case 'type':
									return selector.value.value !== (typeof p === 'undefined' ? 'undefined' : _typeof(p));
							}
						case '<=':
							return p <= selector.value.value;
						case '<':
							return p < selector.value.value;
						case '>':
							return p > selector.value.value;
						case '>=':
							return p >= selector.value.value;
					}

				case 'sibling':
					return matches(node, selector.right, ancestry) && sibling(node, selector.left, ancestry, LEFT_SIDE) || selector.left.subject && matches(node, selector.left, ancestry) && sibling(node, selector.right, ancestry, RIGHT_SIDE);

				case 'adjacent':
					return matches(node, selector.right, ancestry) && adjacent(node, selector.left, ancestry, LEFT_SIDE) || selector.right.subject && matches(node, selector.left, ancestry) && adjacent(node, selector.right, ancestry, RIGHT_SIDE);

				case 'nth-child':
					return matches(node, selector.right, ancestry) && nthChild(node, ancestry, function (length) {
						return selector.index.value - 1;
					});

				case 'nth-last-child':
					return matches(node, selector.right, ancestry) && nthChild(node, ancestry, function (length) {
						return length - selector.index.value;
					});

				case 'class':
					if (!node.type) return false;
					switch (selector.name.toLowerCase()) {
						case 'statement':
							if (node.type.slice(-9) === 'Statement') return true;
						case 'declaration':
							return node.type.slice(-11) === 'Declaration';
						case 'pattern':
							if (node.type.slice(-7) === 'Pattern') return true;
						case 'expression':
							return node.type.slice(-10) === 'Expression' || node.type === 'Literal' || node.type === 'Identifier';
						case 'function':
							return node.type.slice(0, 8) === 'Function' || node.type === 'ArrowFunctionExpression';
					}
					throw new Error('Unknown class name: ' + selector.name);
			}

			throw new Error('Unknown selector type: ' + selector.type);
		}
		function sibling(node, selector, ancestry, side) {
			var parent = ancestry[0],
				listProp,
				startIndex,
				keys,
				i,
				l,
				k,
				lowerBound,
				upperBound;
			if (!parent) {
				return false;
			}
			keys = estraverse.VisitorKeys[parent.type];
			for (i = 0, l = keys.length; i < l; ++i) {
				listProp = parent[keys[i]];
				if (isArray(listProp)) {
					startIndex = listProp.indexOf(node);
					if (startIndex < 0) {
						continue;
					}
					if (side === LEFT_SIDE) {
						lowerBound = 0;
						upperBound = startIndex;
					} else {
						lowerBound = startIndex + 1;
						upperBound = listProp.length;
					}
					for (k = lowerBound; k < upperBound; ++k) {
						if (matches(listProp[k], selector, ancestry)) {
							return true;
						}
					}
				}
			}
			return false;
		}
		function adjacent(node, selector, ancestry, side) {
			var parent = ancestry[0],
				listProp,
				keys,
				i,
				l,
				idx;
			if (!parent) {
				return false;
			}
			keys = estraverse.VisitorKeys[parent.type];
			for (i = 0, l = keys.length; i < l; ++i) {
				listProp = parent[keys[i]];
				if (isArray(listProp)) {
					idx = listProp.indexOf(node);
					if (idx < 0) {
						continue;
					}
					if (side === LEFT_SIDE && idx > 0 && matches(listProp[idx - 1], selector, ancestry)) {
						return true;
					}
					if (side === RIGHT_SIDE && idx < listProp.length - 1 && matches(listProp[idx + 1], selector, ancestry)) {
						return true;
					}
				}
			}
			return false;
		}
		function nthChild(node, ancestry, idxFn) {
			var parent = ancestry[0],
				listProp,
				keys,
				i,
				l,
				idx;
			if (!parent) {
				return false;
			}
			keys = estraverse.VisitorKeys[parent.type];
			for (i = 0, l = keys.length; i < l; ++i) {
				listProp = parent[keys[i]];
				if (isArray(listProp)) {
					idx = listProp.indexOf(node);
					if (idx >= 0 && idx === idxFn(listProp.length)) {
						return true;
					}
				}
			}
			return false;
		}
		function subjects(selector, ancestor) {
			var results, p;
			if (selector == null || (typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) != 'object') {
				return [];
			}
			if (ancestor == null) {
				ancestor = selector;
			}
			results = selector.subject ? [ancestor] : [];
			for (p in selector) {
				if (!{}.hasOwnProperty.call(selector, p)) {
					continue;
				}
				[].push.apply(results, subjects(selector[p], p === 'left' ? selector[p] : ancestor));
			}
			return results;
		}
		function match(ast, selector) {
			var ancestry = [],
				results = [],
				altSubjects,
				i,
				l,
				k,
				m;
			if (!selector) {
				return results;
			}
			altSubjects = subjects(selector);
			estraverse.traverse(ast, {
				enter: function enter(node, parent) {
					if (parent != null) {
						ancestry.unshift(parent);
					}
					if (matches(node, selector, ancestry)) {
						if (altSubjects.length) {
							for (i = 0, l = altSubjects.length; i < l; ++i) {
								if (matches(node, altSubjects[i], ancestry)) {
									results.push(node);
								}
								for (k = 0, m = ancestry.length; k < m; ++k) {
									if (matches(ancestry[k], altSubjects[i], ancestry.slice(k + 1))) {
										results.push(ancestry[k]);
									}
								}
							}
						} else {
							results.push(node);
						}
					}
				},
				leave: function leave() {
					ancestry.shift();
				}
			});
			return results;
		}
		function parse(selector) {
			return parser.parse(selector);
		}
		function query(ast, selector) {
			return match(ast, parse(selector));
		}

		query.parse = parse;
		query.match = match;
		query.matches = matches;
		return query.query = query;
	}

	if (true) {
		!(__WEBPACK_AMD_DEFINE_FACTORY__ = (esqueryModule),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (typeof module !== 'undefined' && module.exports) {
		module.exports = esqueryModule();
	} else {
		this.esquery = esqueryModule();
	}
})();
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

var result = function () {

  function quote(s) {
	return '"' + s.replace(/\\/g, '\\\\') // backslash
	.replace(/"/g, '\\"') // closing quote character
	.replace(/\x08/g, '\\b') // backspace
	.replace(/\t/g, '\\t') // horizontal tab
	.replace(/\n/g, '\\n') // line feed
	.replace(/\f/g, '\\f') // form feed
	.replace(/\r/g, '\\r') // carriage return
	.replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape) + '"';
  }

  var result = {
	parse: function parse(input, startRule) {
			var parseFunctions = {
		"start": parse_start,
		"_": parse__,
		"identifierName": parse_identifierName,
		"binaryOp": parse_binaryOp,
		"selectors": parse_selectors,
		"selector": parse_selector,
		"sequence": parse_sequence,
		"atom": parse_atom,
		"wildcard": parse_wildcard,
		"identifier": parse_identifier,
		"attr": parse_attr,
		"attrOps": parse_attrOps,
		"attrEqOps": parse_attrEqOps,
		"attrName": parse_attrName,
		"attrValue": parse_attrValue,
		"string": parse_string,
		"number": parse_number,
		"path": parse_path,
		"type": parse_type,
		"regex": parse_regex,
		"field": parse_field,
		"negation": parse_negation,
		"matches": parse_matches,
		"firstChild": parse_firstChild,
		"lastChild": parse_lastChild,
		"nthChild": parse_nthChild,
		"nthLastChild": parse_nthLastChild,
		"class": parse_class
			};

			if (startRule !== undefined) {
		if (parseFunctions[startRule] === undefined) {
					throw new Error("Invalid rule name: " + quote(startRule) + ".");
		}
			} else {
		startRule = "start";
			}

			var pos = 0;
			var reportFailures = 0;
			var rightmostFailuresPos = 0;
			var rightmostFailuresExpected = [];
			var cache = {};

			function padLeft(input, padding, length) {
		var result = input;

		var padLength = length - input.length;
		for (var i = 0; i < padLength; i++) {
					result = padding + result;
		}

		return result;
			}

			function escape(ch) {
		var charCode = ch.charCodeAt(0);
		var escapeChar;
		var length;

		if (charCode <= 0xFF) {
					escapeChar = 'x';
					length = 2;
		} else {
					escapeChar = 'u';
					length = 4;
		}

		return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
			}

			function matchFailed(failure) {
		if (pos < rightmostFailuresPos) {
					return;
		}

		if (pos > rightmostFailuresPos) {
					rightmostFailuresPos = pos;
					rightmostFailuresExpected = [];
		}

		rightmostFailuresExpected.push(failure);
			}

			function parse_start() {
		var cacheKey = "start@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2;
		var pos0, pos1;

		pos0 = pos;
		pos1 = pos;
		result0 = parse__();
		if (result0 !== null) {
					result1 = parse_selectors();
					if (result1 !== null) {
			result2 = parse__();
			if (result2 !== null) {
							result0 = [result0, result1, result2];
			} else {
							result0 = null;
							pos = pos1;
			}
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, ss) {
			return ss.length === 1 ? ss[0] : { type: 'matches', selectors: ss };
					}(pos0, result0[1]);
		}
		if (result0 === null) {
					pos = pos0;
		}
		if (result0 === null) {
					pos0 = pos;
					result0 = parse__();
					if (result0 !== null) {
			result0 = function (offset) {
							return void 0;
			}(pos0);
					}
					if (result0 === null) {
			pos = pos0;
					}
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse__() {
		var cacheKey = "_@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1;

		result0 = [];
		if (input.charCodeAt(pos) === 32) {
					result1 = " ";
					pos++;
		} else {
					result1 = null;
					if (reportFailures === 0) {
			matchFailed("\" \"");
					}
		}
		while (result1 !== null) {
					result0.push(result1);
					if (input.charCodeAt(pos) === 32) {
			result1 = " ";
			pos++;
					} else {
			result1 = null;
			if (reportFailures === 0) {
							matchFailed("\" \"");
			}
					}
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_identifierName() {
		var cacheKey = "identifierName@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1;
		var pos0;

		pos0 = pos;
		if (/^[^ [\],():#!=><~+.]/.test(input.charAt(pos))) {
					result1 = input.charAt(pos);
					pos++;
		} else {
					result1 = null;
					if (reportFailures === 0) {
			matchFailed("[^ [\\],():#!=><~+.]");
					}
		}
		if (result1 !== null) {
					result0 = [];
					while (result1 !== null) {
			result0.push(result1);
			if (/^[^ [\],():#!=><~+.]/.test(input.charAt(pos))) {
							result1 = input.charAt(pos);
							pos++;
			} else {
							result1 = null;
							if (reportFailures === 0) {
				matchFailed("[^ [\\],():#!=><~+.]");
							}
			}
					}
		} else {
					result0 = null;
		}
		if (result0 !== null) {
					result0 = function (offset, i) {
			return i.join('');
					}(pos0, result0);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_binaryOp() {
		var cacheKey = "binaryOp@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2;
		var pos0, pos1;

		pos0 = pos;
		pos1 = pos;
		result0 = parse__();
		if (result0 !== null) {
					if (input.charCodeAt(pos) === 62) {
			result1 = ">";
			pos++;
					} else {
			result1 = null;
			if (reportFailures === 0) {
							matchFailed("\">\"");
			}
					}
					if (result1 !== null) {
			result2 = parse__();
			if (result2 !== null) {
							result0 = [result0, result1, result2];
			} else {
							result0 = null;
							pos = pos1;
			}
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset) {
			return 'child';
					}(pos0);
		}
		if (result0 === null) {
					pos = pos0;
		}
		if (result0 === null) {
					pos0 = pos;
					pos1 = pos;
					result0 = parse__();
					if (result0 !== null) {
			if (input.charCodeAt(pos) === 126) {
							result1 = "~";
							pos++;
			} else {
							result1 = null;
							if (reportFailures === 0) {
				matchFailed("\"~\"");
							}
			}
			if (result1 !== null) {
							result2 = parse__();
							if (result2 !== null) {
				result0 = [result0, result1, result2];
							} else {
				result0 = null;
				pos = pos1;
							}
			} else {
							result0 = null;
							pos = pos1;
			}
					} else {
			result0 = null;
			pos = pos1;
					}
					if (result0 !== null) {
			result0 = function (offset) {
							return 'sibling';
			}(pos0);
					}
					if (result0 === null) {
			pos = pos0;
					}
					if (result0 === null) {
			pos0 = pos;
			pos1 = pos;
			result0 = parse__();
			if (result0 !== null) {
							if (input.charCodeAt(pos) === 43) {
				result1 = "+";
				pos++;
							} else {
				result1 = null;
				if (reportFailures === 0) {
									matchFailed("\"+\"");
				}
							}
							if (result1 !== null) {
				result2 = parse__();
				if (result2 !== null) {
									result0 = [result0, result1, result2];
				} else {
									result0 = null;
									pos = pos1;
				}
							} else {
				result0 = null;
				pos = pos1;
							}
			} else {
							result0 = null;
							pos = pos1;
			}
			if (result0 !== null) {
							result0 = function (offset) {
				return 'adjacent';
							}(pos0);
			}
			if (result0 === null) {
							pos = pos0;
			}
			if (result0 === null) {
							pos0 = pos;
							pos1 = pos;
							if (input.charCodeAt(pos) === 32) {
				result0 = " ";
				pos++;
							} else {
				result0 = null;
				if (reportFailures === 0) {
									matchFailed("\" \"");
				}
							}
							if (result0 !== null) {
				result1 = parse__();
				if (result1 !== null) {
									result0 = [result0, result1];
				} else {
									result0 = null;
									pos = pos1;
				}
							} else {
				result0 = null;
				pos = pos1;
							}
							if (result0 !== null) {
				result0 = function (offset) {
									return 'descendant';
				}(pos0);
							}
							if (result0 === null) {
				pos = pos0;
							}
			}
					}
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_selectors() {
		var cacheKey = "selectors@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2, result3, result4, result5;
		var pos0, pos1, pos2;

		pos0 = pos;
		pos1 = pos;
		result0 = parse_selector();
		if (result0 !== null) {
					result1 = [];
					pos2 = pos;
					result2 = parse__();
					if (result2 !== null) {
			if (input.charCodeAt(pos) === 44) {
							result3 = ",";
							pos++;
			} else {
							result3 = null;
							if (reportFailures === 0) {
				matchFailed("\",\"");
							}
			}
			if (result3 !== null) {
							result4 = parse__();
							if (result4 !== null) {
				result5 = parse_selector();
				if (result5 !== null) {
									result2 = [result2, result3, result4, result5];
				} else {
									result2 = null;
									pos = pos2;
				}
							} else {
				result2 = null;
				pos = pos2;
							}
			} else {
							result2 = null;
							pos = pos2;
			}
					} else {
			result2 = null;
			pos = pos2;
					}
					while (result2 !== null) {
			result1.push(result2);
			pos2 = pos;
			result2 = parse__();
			if (result2 !== null) {
							if (input.charCodeAt(pos) === 44) {
				result3 = ",";
				pos++;
							} else {
				result3 = null;
				if (reportFailures === 0) {
									matchFailed("\",\"");
				}
							}
							if (result3 !== null) {
				result4 = parse__();
				if (result4 !== null) {
									result5 = parse_selector();
									if (result5 !== null) {
					result2 = [result2, result3, result4, result5];
									} else {
					result2 = null;
					pos = pos2;
									}
				} else {
									result2 = null;
									pos = pos2;
				}
							} else {
				result2 = null;
				pos = pos2;
							}
			} else {
							result2 = null;
							pos = pos2;
			}
					}
					if (result1 !== null) {
			result0 = [result0, result1];
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, s, ss) {
			return [s].concat(ss.map(function (s) {
							return s[3];
			}));
					}(pos0, result0[0], result0[1]);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_selector() {
		var cacheKey = "selector@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2, result3;
		var pos0, pos1, pos2;

		pos0 = pos;
		pos1 = pos;
		result0 = parse_sequence();
		if (result0 !== null) {
					result1 = [];
					pos2 = pos;
					result2 = parse_binaryOp();
					if (result2 !== null) {
			result3 = parse_sequence();
			if (result3 !== null) {
							result2 = [result2, result3];
			} else {
							result2 = null;
							pos = pos2;
			}
					} else {
			result2 = null;
			pos = pos2;
					}
					while (result2 !== null) {
			result1.push(result2);
			pos2 = pos;
			result2 = parse_binaryOp();
			if (result2 !== null) {
							result3 = parse_sequence();
							if (result3 !== null) {
				result2 = [result2, result3];
							} else {
				result2 = null;
				pos = pos2;
							}
			} else {
							result2 = null;
							pos = pos2;
			}
					}
					if (result1 !== null) {
			result0 = [result0, result1];
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, a, ops) {
			return ops.reduce(function (memo, rhs) {
							return { type: rhs[0], left: memo, right: rhs[1] };
			}, a);
					}(pos0, result0[0], result0[1]);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_sequence() {
		var cacheKey = "sequence@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2;
		var pos0, pos1;

		pos0 = pos;
		pos1 = pos;
		if (input.charCodeAt(pos) === 33) {
					result0 = "!";
					pos++;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\"!\"");
					}
		}
		result0 = result0 !== null ? result0 : "";
		if (result0 !== null) {
					result2 = parse_atom();
					if (result2 !== null) {
			result1 = [];
			while (result2 !== null) {
							result1.push(result2);
							result2 = parse_atom();
			}
					} else {
			result1 = null;
					}
					if (result1 !== null) {
			result0 = [result0, result1];
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, subject, as) {
			var b = as.length === 1 ? as[0] : { type: 'compound', selectors: as };
			if (subject) b.subject = true;
			return b;
					}(pos0, result0[0], result0[1]);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_atom() {
		var cacheKey = "atom@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0;

		result0 = parse_wildcard();
		if (result0 === null) {
					result0 = parse_identifier();
					if (result0 === null) {
			result0 = parse_attr();
			if (result0 === null) {
							result0 = parse_field();
							if (result0 === null) {
				result0 = parse_negation();
				if (result0 === null) {
									result0 = parse_matches();
									if (result0 === null) {
					result0 = parse_firstChild();
					if (result0 === null) {
											result0 = parse_lastChild();
											if (result0 === null) {
						result0 = parse_nthChild();
						if (result0 === null) {
													result0 = parse_nthLastChild();
													if (result0 === null) {
							result0 = parse_class();
													}
						}
											}
					}
									}
				}
							}
			}
					}
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_wildcard() {
		var cacheKey = "wildcard@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0;
		var pos0;

		pos0 = pos;
		if (input.charCodeAt(pos) === 42) {
					result0 = "*";
					pos++;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\"*\"");
					}
		}
		if (result0 !== null) {
					result0 = function (offset, a) {
			return { type: 'wildcard', value: a };
					}(pos0, result0);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_identifier() {
		var cacheKey = "identifier@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1;
		var pos0, pos1;

		pos0 = pos;
		pos1 = pos;
		if (input.charCodeAt(pos) === 35) {
					result0 = "#";
					pos++;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\"#\"");
					}
		}
		result0 = result0 !== null ? result0 : "";
		if (result0 !== null) {
					result1 = parse_identifierName();
					if (result1 !== null) {
			result0 = [result0, result1];
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, i) {
			return { type: 'identifier', value: i };
					}(pos0, result0[1]);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_attr() {
		var cacheKey = "attr@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2, result3, result4;
		var pos0, pos1;

		pos0 = pos;
		pos1 = pos;
		if (input.charCodeAt(pos) === 91) {
					result0 = "[";
					pos++;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\"[\"");
					}
		}
		if (result0 !== null) {
					result1 = parse__();
					if (result1 !== null) {
			result2 = parse_attrValue();
			if (result2 !== null) {
							result3 = parse__();
							if (result3 !== null) {
				if (input.charCodeAt(pos) === 93) {
									result4 = "]";
									pos++;
				} else {
									result4 = null;
									if (reportFailures === 0) {
					matchFailed("\"]\"");
									}
				}
				if (result4 !== null) {
									result0 = [result0, result1, result2, result3, result4];
				} else {
									result0 = null;
									pos = pos1;
				}
							} else {
				result0 = null;
				pos = pos1;
							}
			} else {
							result0 = null;
							pos = pos1;
			}
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, v) {
			return v;
					}(pos0, result0[2]);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_attrOps() {
		var cacheKey = "attrOps@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1;
		var pos0, pos1;

		pos0 = pos;
		pos1 = pos;
		if (/^[><!]/.test(input.charAt(pos))) {
					result0 = input.charAt(pos);
					pos++;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("[><!]");
					}
		}
		result0 = result0 !== null ? result0 : "";
		if (result0 !== null) {
					if (input.charCodeAt(pos) === 61) {
			result1 = "=";
			pos++;
					} else {
			result1 = null;
			if (reportFailures === 0) {
							matchFailed("\"=\"");
			}
					}
					if (result1 !== null) {
			result0 = [result0, result1];
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, a) {
			return a + '=';
					}(pos0, result0[0]);
		}
		if (result0 === null) {
					pos = pos0;
		}
		if (result0 === null) {
					if (/^[><]/.test(input.charAt(pos))) {
			result0 = input.charAt(pos);
			pos++;
					} else {
			result0 = null;
			if (reportFailures === 0) {
							matchFailed("[><]");
			}
					}
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_attrEqOps() {
		var cacheKey = "attrEqOps@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1;
		var pos0, pos1;

		pos0 = pos;
		pos1 = pos;
		if (input.charCodeAt(pos) === 33) {
					result0 = "!";
					pos++;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\"!\"");
					}
		}
		result0 = result0 !== null ? result0 : "";
		if (result0 !== null) {
					if (input.charCodeAt(pos) === 61) {
			result1 = "=";
			pos++;
					} else {
			result1 = null;
			if (reportFailures === 0) {
							matchFailed("\"=\"");
			}
					}
					if (result1 !== null) {
			result0 = [result0, result1];
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, a) {
			return a + '=';
					}(pos0, result0[0]);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_attrName() {
		var cacheKey = "attrName@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1;
		var pos0;

		pos0 = pos;
		result1 = parse_identifierName();
		if (result1 === null) {
					if (input.charCodeAt(pos) === 46) {
			result1 = ".";
			pos++;
					} else {
			result1 = null;
			if (reportFailures === 0) {
							matchFailed("\".\"");
			}
					}
		}
		if (result1 !== null) {
					result0 = [];
					while (result1 !== null) {
			result0.push(result1);
			result1 = parse_identifierName();
			if (result1 === null) {
							if (input.charCodeAt(pos) === 46) {
				result1 = ".";
				pos++;
							} else {
				result1 = null;
				if (reportFailures === 0) {
									matchFailed("\".\"");
				}
							}
			}
					}
		} else {
					result0 = null;
		}
		if (result0 !== null) {
					result0 = function (offset, i) {
			return i.join('');
					}(pos0, result0);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_attrValue() {
		var cacheKey = "attrValue@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2, result3, result4;
		var pos0, pos1;

		pos0 = pos;
		pos1 = pos;
		result0 = parse_attrName();
		if (result0 !== null) {
					result1 = parse__();
					if (result1 !== null) {
			result2 = parse_attrEqOps();
			if (result2 !== null) {
							result3 = parse__();
							if (result3 !== null) {
				result4 = parse_type();
				if (result4 === null) {
									result4 = parse_regex();
				}
				if (result4 !== null) {
									result0 = [result0, result1, result2, result3, result4];
				} else {
									result0 = null;
									pos = pos1;
				}
							} else {
				result0 = null;
				pos = pos1;
							}
			} else {
							result0 = null;
							pos = pos1;
			}
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, name, op, value) {
			return { type: 'attribute', name: name, operator: op, value: value };
					}(pos0, result0[0], result0[2], result0[4]);
		}
		if (result0 === null) {
					pos = pos0;
		}
		if (result0 === null) {
					pos0 = pos;
					pos1 = pos;
					result0 = parse_attrName();
					if (result0 !== null) {
			result1 = parse__();
			if (result1 !== null) {
							result2 = parse_attrOps();
							if (result2 !== null) {
				result3 = parse__();
				if (result3 !== null) {
									result4 = parse_string();
									if (result4 === null) {
					result4 = parse_number();
					if (result4 === null) {
											result4 = parse_path();
					}
									}
									if (result4 !== null) {
					result0 = [result0, result1, result2, result3, result4];
									} else {
					result0 = null;
					pos = pos1;
									}
				} else {
									result0 = null;
									pos = pos1;
				}
							} else {
				result0 = null;
				pos = pos1;
							}
			} else {
							result0 = null;
							pos = pos1;
			}
					} else {
			result0 = null;
			pos = pos1;
					}
					if (result0 !== null) {
			result0 = function (offset, name, op, value) {
							return { type: 'attribute', name: name, operator: op, value: value };
			}(pos0, result0[0], result0[2], result0[4]);
					}
					if (result0 === null) {
			pos = pos0;
					}
					if (result0 === null) {
			pos0 = pos;
			result0 = parse_attrName();
			if (result0 !== null) {
							result0 = function (offset, name) {
				return { type: 'attribute', name: name };
							}(pos0, result0);
			}
			if (result0 === null) {
							pos = pos0;
			}
					}
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_string() {
		var cacheKey = "string@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2, result3;
		var pos0, pos1, pos2, pos3;

		pos0 = pos;
		pos1 = pos;
		if (input.charCodeAt(pos) === 34) {
					result0 = "\"";
					pos++;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\"\\\"\"");
					}
		}
		if (result0 !== null) {
					result1 = [];
					if (/^[^\\"]/.test(input.charAt(pos))) {
			result2 = input.charAt(pos);
			pos++;
					} else {
			result2 = null;
			if (reportFailures === 0) {
							matchFailed("[^\\\\\"]");
			}
					}
					if (result2 === null) {
			pos2 = pos;
			pos3 = pos;
			if (input.charCodeAt(pos) === 92) {
							result2 = "\\";
							pos++;
			} else {
							result2 = null;
							if (reportFailures === 0) {
				matchFailed("\"\\\\\"");
							}
			}
			if (result2 !== null) {
							if (input.length > pos) {
				result3 = input.charAt(pos);
				pos++;
							} else {
				result3 = null;
				if (reportFailures === 0) {
									matchFailed("any character");
				}
							}
							if (result3 !== null) {
				result2 = [result2, result3];
							} else {
				result2 = null;
				pos = pos3;
							}
			} else {
							result2 = null;
							pos = pos3;
			}
			if (result2 !== null) {
							result2 = function (offset, a, b) {
				return a + b;
							}(pos2, result2[0], result2[1]);
			}
			if (result2 === null) {
							pos = pos2;
			}
					}
					while (result2 !== null) {
			result1.push(result2);
			if (/^[^\\"]/.test(input.charAt(pos))) {
							result2 = input.charAt(pos);
							pos++;
			} else {
							result2 = null;
							if (reportFailures === 0) {
				matchFailed("[^\\\\\"]");
							}
			}
			if (result2 === null) {
							pos2 = pos;
							pos3 = pos;
							if (input.charCodeAt(pos) === 92) {
				result2 = "\\";
				pos++;
							} else {
				result2 = null;
				if (reportFailures === 0) {
									matchFailed("\"\\\\\"");
				}
							}
							if (result2 !== null) {
				if (input.length > pos) {
									result3 = input.charAt(pos);
									pos++;
				} else {
									result3 = null;
									if (reportFailures === 0) {
					matchFailed("any character");
									}
				}
				if (result3 !== null) {
									result2 = [result2, result3];
				} else {
									result2 = null;
									pos = pos3;
				}
							} else {
				result2 = null;
				pos = pos3;
							}
							if (result2 !== null) {
				result2 = function (offset, a, b) {
									return a + b;
				}(pos2, result2[0], result2[1]);
							}
							if (result2 === null) {
				pos = pos2;
							}
			}
					}
					if (result1 !== null) {
			if (input.charCodeAt(pos) === 34) {
							result2 = "\"";
							pos++;
			} else {
							result2 = null;
							if (reportFailures === 0) {
				matchFailed("\"\\\"\"");
							}
			}
			if (result2 !== null) {
							result0 = [result0, result1, result2];
			} else {
							result0 = null;
							pos = pos1;
			}
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, d) {
			return { type: 'literal', value: strUnescape(d.join('')) };
					}(pos0, result0[1]);
		}
		if (result0 === null) {
					pos = pos0;
		}
		if (result0 === null) {
					pos0 = pos;
					pos1 = pos;
					if (input.charCodeAt(pos) === 39) {
			result0 = "'";
			pos++;
					} else {
			result0 = null;
			if (reportFailures === 0) {
							matchFailed("\"'\"");
			}
					}
					if (result0 !== null) {
			result1 = [];
			if (/^[^\\']/.test(input.charAt(pos))) {
							result2 = input.charAt(pos);
							pos++;
			} else {
							result2 = null;
							if (reportFailures === 0) {
				matchFailed("[^\\\\']");
							}
			}
			if (result2 === null) {
							pos2 = pos;
							pos3 = pos;
							if (input.charCodeAt(pos) === 92) {
				result2 = "\\";
				pos++;
							} else {
				result2 = null;
				if (reportFailures === 0) {
									matchFailed("\"\\\\\"");
				}
							}
							if (result2 !== null) {
				if (input.length > pos) {
									result3 = input.charAt(pos);
									pos++;
				} else {
									result3 = null;
									if (reportFailures === 0) {
					matchFailed("any character");
									}
				}
				if (result3 !== null) {
									result2 = [result2, result3];
				} else {
									result2 = null;
									pos = pos3;
				}
							} else {
				result2 = null;
				pos = pos3;
							}
							if (result2 !== null) {
				result2 = function (offset, a, b) {
									return a + b;
				}(pos2, result2[0], result2[1]);
							}
							if (result2 === null) {
				pos = pos2;
							}
			}
			while (result2 !== null) {
							result1.push(result2);
							if (/^[^\\']/.test(input.charAt(pos))) {
				result2 = input.charAt(pos);
				pos++;
							} else {
				result2 = null;
				if (reportFailures === 0) {
									matchFailed("[^\\\\']");
				}
							}
							if (result2 === null) {
				pos2 = pos;
				pos3 = pos;
				if (input.charCodeAt(pos) === 92) {
									result2 = "\\";
									pos++;
				} else {
									result2 = null;
									if (reportFailures === 0) {
					matchFailed("\"\\\\\"");
									}
				}
				if (result2 !== null) {
									if (input.length > pos) {
					result3 = input.charAt(pos);
					pos++;
									} else {
					result3 = null;
					if (reportFailures === 0) {
											matchFailed("any character");
					}
									}
									if (result3 !== null) {
					result2 = [result2, result3];
									} else {
					result2 = null;
					pos = pos3;
									}
				} else {
									result2 = null;
									pos = pos3;
				}
				if (result2 !== null) {
									result2 = function (offset, a, b) {
					return a + b;
									}(pos2, result2[0], result2[1]);
				}
				if (result2 === null) {
									pos = pos2;
				}
							}
			}
			if (result1 !== null) {
							if (input.charCodeAt(pos) === 39) {
				result2 = "'";
				pos++;
							} else {
				result2 = null;
				if (reportFailures === 0) {
									matchFailed("\"'\"");
				}
							}
							if (result2 !== null) {
				result0 = [result0, result1, result2];
							} else {
				result0 = null;
				pos = pos1;
							}
			} else {
							result0 = null;
							pos = pos1;
			}
					} else {
			result0 = null;
			pos = pos1;
					}
					if (result0 !== null) {
			result0 = function (offset, d) {
							return { type: 'literal', value: strUnescape(d.join('')) };
			}(pos0, result0[1]);
					}
					if (result0 === null) {
			pos = pos0;
					}
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_number() {
		var cacheKey = "number@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2;
		var pos0, pos1, pos2;

		pos0 = pos;
		pos1 = pos;
		pos2 = pos;
		result0 = [];
		if (/^[0-9]/.test(input.charAt(pos))) {
					result1 = input.charAt(pos);
					pos++;
		} else {
					result1 = null;
					if (reportFailures === 0) {
			matchFailed("[0-9]");
					}
		}
		while (result1 !== null) {
					result0.push(result1);
					if (/^[0-9]/.test(input.charAt(pos))) {
			result1 = input.charAt(pos);
			pos++;
					} else {
			result1 = null;
			if (reportFailures === 0) {
							matchFailed("[0-9]");
			}
					}
		}
		if (result0 !== null) {
					if (input.charCodeAt(pos) === 46) {
			result1 = ".";
			pos++;
					} else {
			result1 = null;
			if (reportFailures === 0) {
							matchFailed("\".\"");
			}
					}
					if (result1 !== null) {
			result0 = [result0, result1];
					} else {
			result0 = null;
			pos = pos2;
					}
		} else {
					result0 = null;
					pos = pos2;
		}
		result0 = result0 !== null ? result0 : "";
		if (result0 !== null) {
					if (/^[0-9]/.test(input.charAt(pos))) {
			result2 = input.charAt(pos);
			pos++;
					} else {
			result2 = null;
			if (reportFailures === 0) {
							matchFailed("[0-9]");
			}
					}
					if (result2 !== null) {
			result1 = [];
			while (result2 !== null) {
							result1.push(result2);
							if (/^[0-9]/.test(input.charAt(pos))) {
				result2 = input.charAt(pos);
				pos++;
							} else {
				result2 = null;
				if (reportFailures === 0) {
									matchFailed("[0-9]");
				}
							}
			}
					} else {
			result1 = null;
					}
					if (result1 !== null) {
			result0 = [result0, result1];
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, a, b) {
			return { type: 'literal', value: parseFloat((a ? a.join('') : '') + b.join('')) };
					}(pos0, result0[0], result0[1]);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_path() {
		var cacheKey = "path@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0;
		var pos0;

		pos0 = pos;
		result0 = parse_identifierName();
		if (result0 !== null) {
					result0 = function (offset, i) {
			return { type: 'literal', value: i };
					}(pos0, result0);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_type() {
		var cacheKey = "type@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2, result3, result4;
		var pos0, pos1;

		pos0 = pos;
		pos1 = pos;
		if (input.substr(pos, 5) === "type(") {
					result0 = "type(";
					pos += 5;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\"type(\"");
					}
		}
		if (result0 !== null) {
					result1 = parse__();
					if (result1 !== null) {
			if (/^[^ )]/.test(input.charAt(pos))) {
							result3 = input.charAt(pos);
							pos++;
			} else {
							result3 = null;
							if (reportFailures === 0) {
				matchFailed("[^ )]");
							}
			}
			if (result3 !== null) {
							result2 = [];
							while (result3 !== null) {
				result2.push(result3);
				if (/^[^ )]/.test(input.charAt(pos))) {
									result3 = input.charAt(pos);
									pos++;
				} else {
									result3 = null;
									if (reportFailures === 0) {
					matchFailed("[^ )]");
									}
				}
							}
			} else {
							result2 = null;
			}
			if (result2 !== null) {
							result3 = parse__();
							if (result3 !== null) {
				if (input.charCodeAt(pos) === 41) {
									result4 = ")";
									pos++;
				} else {
									result4 = null;
									if (reportFailures === 0) {
					matchFailed("\")\"");
									}
				}
				if (result4 !== null) {
									result0 = [result0, result1, result2, result3, result4];
				} else {
									result0 = null;
									pos = pos1;
				}
							} else {
				result0 = null;
				pos = pos1;
							}
			} else {
							result0 = null;
							pos = pos1;
			}
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, t) {
			return { type: 'type', value: t.join('') };
					}(pos0, result0[2]);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_regex() {
		var cacheKey = "regex@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2;
		var pos0, pos1;

		pos0 = pos;
		pos1 = pos;
		if (input.charCodeAt(pos) === 47) {
					result0 = "/";
					pos++;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\"/\"");
					}
		}
		if (result0 !== null) {
					if (/^[^\/]/.test(input.charAt(pos))) {
			result2 = input.charAt(pos);
			pos++;
					} else {
			result2 = null;
			if (reportFailures === 0) {
							matchFailed("[^\\/]");
			}
					}
					if (result2 !== null) {
			result1 = [];
			while (result2 !== null) {
							result1.push(result2);
							if (/^[^\/]/.test(input.charAt(pos))) {
				result2 = input.charAt(pos);
				pos++;
							} else {
				result2 = null;
				if (reportFailures === 0) {
									matchFailed("[^\\/]");
				}
							}
			}
					} else {
			result1 = null;
					}
					if (result1 !== null) {
			if (input.charCodeAt(pos) === 47) {
							result2 = "/";
							pos++;
			} else {
							result2 = null;
							if (reportFailures === 0) {
				matchFailed("\"/\"");
							}
			}
			if (result2 !== null) {
							result0 = [result0, result1, result2];
			} else {
							result0 = null;
							pos = pos1;
			}
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, d) {
			return { type: 'regexp', value: new RegExp(d.join('')) };
					}(pos0, result0[1]);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_field() {
		var cacheKey = "field@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2, result3, result4;
		var pos0, pos1, pos2;

		pos0 = pos;
		pos1 = pos;
		if (input.charCodeAt(pos) === 46) {
					result0 = ".";
					pos++;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\".\"");
					}
		}
		if (result0 !== null) {
					result1 = parse_identifierName();
					if (result1 !== null) {
			result2 = [];
			pos2 = pos;
			if (input.charCodeAt(pos) === 46) {
							result3 = ".";
							pos++;
			} else {
							result3 = null;
							if (reportFailures === 0) {
				matchFailed("\".\"");
							}
			}
			if (result3 !== null) {
							result4 = parse_identifierName();
							if (result4 !== null) {
				result3 = [result3, result4];
							} else {
				result3 = null;
				pos = pos2;
							}
			} else {
							result3 = null;
							pos = pos2;
			}
			while (result3 !== null) {
							result2.push(result3);
							pos2 = pos;
							if (input.charCodeAt(pos) === 46) {
				result3 = ".";
				pos++;
							} else {
				result3 = null;
				if (reportFailures === 0) {
									matchFailed("\".\"");
				}
							}
							if (result3 !== null) {
				result4 = parse_identifierName();
				if (result4 !== null) {
									result3 = [result3, result4];
				} else {
									result3 = null;
									pos = pos2;
				}
							} else {
				result3 = null;
				pos = pos2;
							}
			}
			if (result2 !== null) {
							result0 = [result0, result1, result2];
			} else {
							result0 = null;
							pos = pos1;
			}
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, i, is) {
			return { type: 'field', name: is.reduce(function (memo, p) {
				return memo + p[0] + p[1];
							}, i) };
					}(pos0, result0[1], result0[2]);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_negation() {
		var cacheKey = "negation@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2, result3, result4;
		var pos0, pos1;

		pos0 = pos;
		pos1 = pos;
		if (input.substr(pos, 5) === ":not(") {
					result0 = ":not(";
					pos += 5;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\":not(\"");
					}
		}
		if (result0 !== null) {
					result1 = parse__();
					if (result1 !== null) {
			result2 = parse_selectors();
			if (result2 !== null) {
							result3 = parse__();
							if (result3 !== null) {
				if (input.charCodeAt(pos) === 41) {
									result4 = ")";
									pos++;
				} else {
									result4 = null;
									if (reportFailures === 0) {
					matchFailed("\")\"");
									}
				}
				if (result4 !== null) {
									result0 = [result0, result1, result2, result3, result4];
				} else {
									result0 = null;
									pos = pos1;
				}
							} else {
				result0 = null;
				pos = pos1;
							}
			} else {
							result0 = null;
							pos = pos1;
			}
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, ss) {
			return { type: 'not', selectors: ss };
					}(pos0, result0[2]);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_matches() {
		var cacheKey = "matches@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2, result3, result4;
		var pos0, pos1;

		pos0 = pos;
		pos1 = pos;
		if (input.substr(pos, 9) === ":matches(") {
					result0 = ":matches(";
					pos += 9;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\":matches(\"");
					}
		}
		if (result0 !== null) {
					result1 = parse__();
					if (result1 !== null) {
			result2 = parse_selectors();
			if (result2 !== null) {
							result3 = parse__();
							if (result3 !== null) {
				if (input.charCodeAt(pos) === 41) {
									result4 = ")";
									pos++;
				} else {
									result4 = null;
									if (reportFailures === 0) {
					matchFailed("\")\"");
									}
				}
				if (result4 !== null) {
									result0 = [result0, result1, result2, result3, result4];
				} else {
									result0 = null;
									pos = pos1;
				}
							} else {
				result0 = null;
				pos = pos1;
							}
			} else {
							result0 = null;
							pos = pos1;
			}
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, ss) {
			return { type: 'matches', selectors: ss };
					}(pos0, result0[2]);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_firstChild() {
		var cacheKey = "firstChild@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0;
		var pos0;

		pos0 = pos;
		if (input.substr(pos, 12) === ":first-child") {
					result0 = ":first-child";
					pos += 12;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\":first-child\"");
					}
		}
		if (result0 !== null) {
					result0 = function (offset) {
			return nth(1);
					}(pos0);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_lastChild() {
		var cacheKey = "lastChild@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0;
		var pos0;

		pos0 = pos;
		if (input.substr(pos, 11) === ":last-child") {
					result0 = ":last-child";
					pos += 11;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\":last-child\"");
					}
		}
		if (result0 !== null) {
					result0 = function (offset) {
			return nthLast(1);
					}(pos0);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_nthChild() {
		var cacheKey = "nthChild@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2, result3, result4;
		var pos0, pos1;

		pos0 = pos;
		pos1 = pos;
		if (input.substr(pos, 11) === ":nth-child(") {
					result0 = ":nth-child(";
					pos += 11;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\":nth-child(\"");
					}
		}
		if (result0 !== null) {
					result1 = parse__();
					if (result1 !== null) {
			if (/^[0-9]/.test(input.charAt(pos))) {
							result3 = input.charAt(pos);
							pos++;
			} else {
							result3 = null;
							if (reportFailures === 0) {
				matchFailed("[0-9]");
							}
			}
			if (result3 !== null) {
							result2 = [];
							while (result3 !== null) {
				result2.push(result3);
				if (/^[0-9]/.test(input.charAt(pos))) {
									result3 = input.charAt(pos);
									pos++;
				} else {
									result3 = null;
									if (reportFailures === 0) {
					matchFailed("[0-9]");
									}
				}
							}
			} else {
							result2 = null;
			}
			if (result2 !== null) {
							result3 = parse__();
							if (result3 !== null) {
				if (input.charCodeAt(pos) === 41) {
									result4 = ")";
									pos++;
				} else {
									result4 = null;
									if (reportFailures === 0) {
					matchFailed("\")\"");
									}
				}
				if (result4 !== null) {
									result0 = [result0, result1, result2, result3, result4];
				} else {
									result0 = null;
									pos = pos1;
				}
							} else {
				result0 = null;
				pos = pos1;
							}
			} else {
							result0 = null;
							pos = pos1;
			}
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, n) {
			return nth(parseInt(n.join(''), 10));
					}(pos0, result0[2]);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_nthLastChild() {
		var cacheKey = "nthLastChild@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1, result2, result3, result4;
		var pos0, pos1;

		pos0 = pos;
		pos1 = pos;
		if (input.substr(pos, 16) === ":nth-last-child(") {
					result0 = ":nth-last-child(";
					pos += 16;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\":nth-last-child(\"");
					}
		}
		if (result0 !== null) {
					result1 = parse__();
					if (result1 !== null) {
			if (/^[0-9]/.test(input.charAt(pos))) {
							result3 = input.charAt(pos);
							pos++;
			} else {
							result3 = null;
							if (reportFailures === 0) {
				matchFailed("[0-9]");
							}
			}
			if (result3 !== null) {
							result2 = [];
							while (result3 !== null) {
				result2.push(result3);
				if (/^[0-9]/.test(input.charAt(pos))) {
									result3 = input.charAt(pos);
									pos++;
				} else {
									result3 = null;
									if (reportFailures === 0) {
					matchFailed("[0-9]");
									}
				}
							}
			} else {
							result2 = null;
			}
			if (result2 !== null) {
							result3 = parse__();
							if (result3 !== null) {
				if (input.charCodeAt(pos) === 41) {
									result4 = ")";
									pos++;
				} else {
									result4 = null;
									if (reportFailures === 0) {
					matchFailed("\")\"");
									}
				}
				if (result4 !== null) {
									result0 = [result0, result1, result2, result3, result4];
				} else {
									result0 = null;
									pos = pos1;
				}
							} else {
				result0 = null;
				pos = pos1;
							}
			} else {
							result0 = null;
							pos = pos1;
			}
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, n) {
			return nthLast(parseInt(n.join(''), 10));
					}(pos0, result0[2]);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function parse_class() {
		var cacheKey = "class@" + pos;
		var cachedResult = cache[cacheKey];
		if (cachedResult) {
					pos = cachedResult.nextPos;
					return cachedResult.result;
		}

		var result0, result1;
		var pos0, pos1;

		pos0 = pos;
		pos1 = pos;
		if (input.charCodeAt(pos) === 58) {
					result0 = ":";
					pos++;
		} else {
					result0 = null;
					if (reportFailures === 0) {
			matchFailed("\":\"");
					}
		}
		if (result0 !== null) {
					if (input.substr(pos, 9).toLowerCase() === "statement") {
			result1 = input.substr(pos, 9);
			pos += 9;
					} else {
			result1 = null;
			if (reportFailures === 0) {
							matchFailed("\"statement\"");
			}
					}
					if (result1 === null) {
			if (input.substr(pos, 10).toLowerCase() === "expression") {
							result1 = input.substr(pos, 10);
							pos += 10;
			} else {
							result1 = null;
							if (reportFailures === 0) {
				matchFailed("\"expression\"");
							}
			}
			if (result1 === null) {
							if (input.substr(pos, 11).toLowerCase() === "declaration") {
				result1 = input.substr(pos, 11);
				pos += 11;
							} else {
				result1 = null;
				if (reportFailures === 0) {
									matchFailed("\"declaration\"");
				}
							}
							if (result1 === null) {
				if (input.substr(pos, 8).toLowerCase() === "function") {
									result1 = input.substr(pos, 8);
									pos += 8;
				} else {
									result1 = null;
									if (reportFailures === 0) {
					matchFailed("\"function\"");
									}
				}
				if (result1 === null) {
									if (input.substr(pos, 7).toLowerCase() === "pattern") {
					result1 = input.substr(pos, 7);
					pos += 7;
									} else {
					result1 = null;
					if (reportFailures === 0) {
											matchFailed("\"pattern\"");
					}
									}
				}
							}
			}
					}
					if (result1 !== null) {
			result0 = [result0, result1];
					} else {
			result0 = null;
			pos = pos1;
					}
		} else {
					result0 = null;
					pos = pos1;
		}
		if (result0 !== null) {
					result0 = function (offset, c) {
			return { type: 'class', name: c };
					}(pos0, result0[1]);
		}
		if (result0 === null) {
					pos = pos0;
		}

		cache[cacheKey] = {
					nextPos: pos,
					result: result0
		};
		return result0;
			}

			function cleanupExpected(expected) {
		expected.sort();

		var lastExpected = null;
		var cleanExpected = [];
		for (var i = 0; i < expected.length; i++) {
					if (expected[i] !== lastExpected) {
			cleanExpected.push(expected[i]);
			lastExpected = expected[i];
					}
		}
		return cleanExpected;
			}

			function computeErrorPosition() {

		var line = 1;
		var column = 1;
		var seenCR = false;

		for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
					var ch = input.charAt(i);
					if (ch === "\n") {
			if (!seenCR) {
							line++;
			}
			column = 1;
			seenCR = false;
					} else if (ch === "\r" || ch === '\u2028' || ch === '\u2029') {
			line++;
			column = 1;
			seenCR = true;
					} else {
			column++;
			seenCR = false;
					}
		}

		return { line: line, column: column };
			}

			function nth(n) {
		return { type: 'nth-child', index: { type: 'literal', value: n } };
			}
			function nthLast(n) {
		return { type: 'nth-last-child', index: { type: 'literal', value: n } };
			}
			function strUnescape(s) {
		return s.replace(/\\(.)/g, function (match, ch) {
					switch (ch) {
			case 'a':
							return '\a';
			case 'b':
							return '\b';
			case 'f':
							return '\f';
			case 'n':
							return '\n';
			case 'r':
							return '\r';
			case 't':
							return '\t';
			case 'v':
							return '\v';
			default:
							return ch;
					}
		});
			}

			var result = parseFunctions[startRule]();
			if (result === null || pos !== input.length) {
		var offset = Math.max(pos, rightmostFailuresPos);
		var found = offset < input.length ? input.charAt(offset) : null;
		var errorPosition = computeErrorPosition();

		throw new this.SyntaxError(cleanupExpected(rightmostFailuresExpected), found, offset, errorPosition.line, errorPosition.column);
			}

			return result;
	},
	toSource: function toSource() {
			return this._source;
	}
  };

  result.SyntaxError = function (expected, found, offset, line, column) {
	function buildMessage(expected, found) {
			var expectedHumanized, foundHumanized;

			switch (expected.length) {
		case 0:
					expectedHumanized = "end of input";
					break;
		case 1:
					expectedHumanized = expected[0];
					break;
		default:
					expectedHumanized = expected.slice(0, expected.length - 1).join(", ") + " or " + expected[expected.length - 1];
			}

			foundHumanized = found ? quote(found) : "end of input";

			return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
	}

	this.name = "SyntaxError";
	this.expected = expected;
	this.found = found;
	this.message = buildMessage(expected, found);
	this.offset = offset;
	this.line = line;
	this.column = column;
  };

  result.SyntaxError.prototype = Error.prototype;

  return result;
}();
if (true) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
	return result;
  }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else if (typeof module !== "undefined" && module.exports) {
  module.exports = result;
} else {
  undefined.esquery = result;
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TokenStore = __webpack_require__(379),
	Traverser = __webpack_require__(106),
	astUtils = __webpack_require__(0),
	lodash = __webpack_require__(10);
function validate(ast) {
	if (!ast.tokens) {
		throw new Error("AST is missing the tokens array.");
	}

	if (!ast.comments) {
		throw new Error("AST is missing the comments array.");
	}

	if (!ast.loc) {
		throw new Error("AST is missing location information.");
	}

	if (!ast.range) {
		throw new Error("AST is missing range information");
	}
}
function looksLikeExport(astNode) {
	return astNode.type === "ExportDefaultDeclaration" || astNode.type === "ExportNamedDeclaration" || astNode.type === "ExportAllDeclaration" || astNode.type === "ExportSpecifier";
}
function sortedMerge(tokens, comments) {
	var result = [];
	var tokenIndex = 0;
	var commentIndex = 0;

	while (tokenIndex < tokens.length || commentIndex < comments.length) {
		if (commentIndex >= comments.length || tokenIndex < tokens.length && tokens[tokenIndex].range[0] < comments[commentIndex].range[0]) {
			result.push(tokens[tokenIndex++]);
		} else {
			result.push(comments[commentIndex++]);
		}
	}

	return result;
}
var SourceCode = function (_TokenStore) {
	_inherits(SourceCode, _TokenStore);
	function SourceCode(text, ast) {
		_classCallCheck(this, SourceCode);

		validate(ast);
		var _this = _possibleConstructorReturn(this, (SourceCode.__proto__ || Object.getPrototypeOf(SourceCode)).call(this, ast.tokens, ast.comments));

		_this.hasBOM = text.charCodeAt(0) === 0xFEFF;
		_this.text = _this.hasBOM ? text.slice(1) : text;
		_this.ast = ast;
		var shebangMatched = _this.text.match(astUtils.SHEBANG_MATCHER);
		var hasShebang = shebangMatched && ast.comments.length && ast.comments[0].value === shebangMatched[1];

		if (hasShebang) {
			ast.comments[0].type = "Shebang";
		}

		_this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);
		_this.lines = [];
		_this.lineStartIndices = [0];

		var lineEndingPattern = astUtils.createGlobalLinebreakMatcher();
		var match = void 0;
		while (match = lineEndingPattern.exec(_this.text)) {
			_this.lines.push(_this.text.slice(_this.lineStartIndices[_this.lineStartIndices.length - 1], match.index));
			_this.lineStartIndices.push(match.index + match[0].length);
		}
		_this.lines.push(_this.text.slice(_this.lineStartIndices[_this.lineStartIndices.length - 1]));
		_this._commentCache = new WeakMap();
		Object.freeze(_this);
		Object.freeze(_this.lines);
		return _this;
	}


	_createClass(SourceCode, [{
		key: "getText",
		value: function getText(node, beforeCount, afterCount) {
			if (node) {
				return this.text.slice(Math.max(node.range[0] - (beforeCount || 0), 0), node.range[1] + (afterCount || 0));
			}
			return this.text;
		}

	}, {
		key: "getLines",
		value: function getLines() {
			return this.lines;
		}

	}, {
		key: "getAllComments",
		value: function getAllComments() {
			return this.ast.comments;
		}

	}, {
		key: "getComments",
		value: function getComments(node) {
			if (this._commentCache.has(node)) {
				return this._commentCache.get(node);
			}

			var comments = {
				leading: [],
				trailing: []
			};
			if (node.type === "Program") {
				if (node.body.length === 0) {
					comments.leading = node.comments;
				}
			} else {
				if ((node.type === "BlockStatement" || node.type === "ClassBody") && node.body.length === 0 || node.type === "ObjectExpression" && node.properties.length === 0 || node.type === "ArrayExpression" && node.elements.length === 0 || node.type === "SwitchStatement" && node.cases.length === 0) {
					comments.trailing = this.getTokens(node, {
						includeComments: true,
						filter: astUtils.isCommentToken
					});
				}
				var currentToken = this.getTokenBefore(node, { includeComments: true });

				while (currentToken && astUtils.isCommentToken(currentToken)) {
					if (node.parent && currentToken.start < node.parent.start) {
						break;
					}
					comments.leading.push(currentToken);
					currentToken = this.getTokenBefore(currentToken, { includeComments: true });
				}

				comments.leading.reverse();

				currentToken = this.getTokenAfter(node, { includeComments: true });

				while (currentToken && astUtils.isCommentToken(currentToken)) {
					if (node.parent && currentToken.end > node.parent.end) {
						break;
					}
					comments.trailing.push(currentToken);
					currentToken = this.getTokenAfter(currentToken, { includeComments: true });
				}
			}

			this._commentCache.set(node, comments);
			return comments;
		}

	}, {
		key: "getJSDocComment",
		value: function getJSDocComment(node) {
			var _this2 = this;
			var findJSDocComment = function findJSDocComment(astNode) {
				var tokenBefore = _this2.getTokenBefore(astNode, { includeComments: true });

				if (tokenBefore && astUtils.isCommentToken(tokenBefore) && tokenBefore.type === "Block" && tokenBefore.value.charAt(0) === "*" && astNode.loc.start.line - tokenBefore.loc.end.line <= 1) {
					return tokenBefore;
				}

				return null;
			};
			var parent = node.parent;

			switch (node.type) {
				case "ClassDeclaration":
				case "FunctionDeclaration":
					return findJSDocComment(looksLikeExport(parent) ? parent : node);

				case "ClassExpression":
					return findJSDocComment(parent.parent);

				case "ArrowFunctionExpression":
				case "FunctionExpression":
					if (parent.type !== "CallExpression" && parent.type !== "NewExpression") {
						while (!this.getCommentsBefore(parent).length && !/Function/.test(parent.type) && parent.type !== "MethodDefinition" && parent.type !== "Property") {
							parent = parent.parent;

							if (!parent) {
								break;
							}
						}

						if (parent && parent.type !== "FunctionDeclaration" && parent.type !== "Program") {
							return findJSDocComment(parent);
						}
					}

					return findJSDocComment(node);
				default:
					return null;
			}
		}

	}, {
		key: "getNodeByRangeIndex",
		value: function getNodeByRangeIndex(index) {
			var result = null,
				resultParent = null;
			var traverser = new Traverser();

			traverser.traverse(this.ast, {
				enter: function enter(node, parent) {
					if (node.range[0] <= index && index < node.range[1]) {
						result = node;
						resultParent = parent;
					} else {
						this.skip();
					}
				},
				leave: function leave(node) {
					if (node === result) {
						this.break();
					}
				}
			});

			return result ? Object.assign({ parent: resultParent }, result) : null;
		}

	}, {
		key: "isSpaceBetweenTokens",
		value: function isSpaceBetweenTokens(first, second) {
			var text = this.text.slice(first.range[1], second.range[0]);

			return (/\s/.test(text.replace(/\/\*.*?\*\//g, ""))
			);
		}

	}, {
		key: "getLocFromIndex",
		value: function getLocFromIndex(index) {
			if (typeof index !== "number") {
				throw new TypeError("Expected `index` to be a number.");
			}

			if (index < 0 || index > this.text.length) {
				throw new RangeError("Index out of range (requested index " + index + ", but source text has length " + this.text.length + ").");
			}
			if (index === this.text.length) {
				return { line: this.lines.length, column: this.lines[this.lines.length - 1].length };
			}
			var lineNumber = lodash.sortedLastIndex(this.lineStartIndices, index);

			return { line: lineNumber, column: index - this.lineStartIndices[lineNumber - 1] };
		}

	}, {
		key: "getIndexFromLoc",
		value: function getIndexFromLoc(loc) {
			if ((typeof loc === "undefined" ? "undefined" : _typeof(loc)) !== "object" || typeof loc.line !== "number" || typeof loc.column !== "number") {
				throw new TypeError("Expected `loc` to be an object with numeric `line` and `column` properties.");
			}

			if (loc.line <= 0) {
				throw new RangeError("Line number out of range (line " + loc.line + " requested). Line numbers should be 1-based.");
			}

			if (loc.line > this.lineStartIndices.length) {
				throw new RangeError("Line number out of range (line " + loc.line + " requested, but only " + this.lineStartIndices.length + " lines present).");
			}

			var lineStartIndex = this.lineStartIndices[loc.line - 1];
			var lineEndIndex = loc.line === this.lineStartIndices.length ? this.text.length : this.lineStartIndices[loc.line];
			var positionIndex = lineStartIndex + loc.column;
			if (loc.line === this.lineStartIndices.length && positionIndex > lineEndIndex || loc.line < this.lineStartIndices.length && positionIndex >= lineEndIndex) {
				throw new RangeError("Column number out of range (column " + loc.column + " requested, but the length of line " + loc.line + " is " + (lineEndIndex - lineStartIndex) + ").");
			}

			return positionIndex;
		}
	}], [{
		key: "splitLines",
		value: function splitLines(text) {
			return text.split(astUtils.createGlobalLinebreakMatcher());
		}
	}]);

	return SourceCode;
}(TokenStore);

module.exports = SourceCode;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var cursors = __webpack_require__(380);
var ForwardTokenCursor = __webpack_require__(105);
var PaddedTokenCursor = __webpack_require__(387);
var utils = __webpack_require__(56);
var astUtils = __webpack_require__(0);
var TOKENS = Symbol("tokens");
var COMMENTS = Symbol("comments");
var INDEX_MAP = Symbol("indexMap");
function createIndexMap(tokens, comments) {
	var map = Object.create(null);
	var tokenIndex = 0;
	var commentIndex = 0;
	var nextStart = 0;
	var range = null;

	while (tokenIndex < tokens.length || commentIndex < comments.length) {
		nextStart = commentIndex < comments.length ? comments[commentIndex].range[0] : Number.MAX_SAFE_INTEGER;
		while (tokenIndex < tokens.length && (range = tokens[tokenIndex].range)[0] < nextStart) {
			map[range[0]] = tokenIndex;
			map[range[1] - 1] = tokenIndex;
			tokenIndex += 1;
		}

		nextStart = tokenIndex < tokens.length ? tokens[tokenIndex].range[0] : Number.MAX_SAFE_INTEGER;
		while (commentIndex < comments.length && (range = comments[commentIndex].range)[0] < nextStart) {
			map[range[0]] = tokenIndex;
			map[range[1] - 1] = tokenIndex;
			commentIndex += 1;
		}
	}

	return map;
}
function createCursorWithSkip(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {
	var includeComments = false;
	var skip = 0;
	var filter = null;

	if (typeof opts === "number") {
		skip = opts | 0;
	} else if (typeof opts === "function") {
		filter = opts;
	} else if (opts) {
		includeComments = !!opts.includeComments;
		skip = opts.skip | 0;
		filter = opts.filter || null;
	}


	return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, -1);
}
function createCursorWithCount(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {
	var includeComments = false;
	var count = 0;
	var countExists = false;
	var filter = null;

	if (typeof opts === "number") {
		count = opts | 0;
		countExists = true;
	} else if (typeof opts === "function") {
		filter = opts;
	} else if (opts) {
		includeComments = !!opts.includeComments;
		count = opts.count | 0;
		countExists = typeof opts.count === "number";
		filter = opts.filter || null;
	}


	return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, 0, countExists ? count : -1);
}
function createCursorWithPadding(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {
	if (typeof beforeCount === "undefined" && typeof afterCount === "undefined") {
		return new ForwardTokenCursor(tokens, comments, indexMap, startLoc, endLoc);
	}
	if (typeof beforeCount === "number" || typeof beforeCount === "undefined") {
		return new PaddedTokenCursor(tokens, comments, indexMap, startLoc, endLoc, beforeCount | 0, afterCount | 0);
	}
	return createCursorWithCount(cursors.forward, tokens, comments, indexMap, startLoc, endLoc, beforeCount);
}
function getAdjacentCommentTokensFromCursor(cursor) {
	var tokens = [];
	var currentToken = cursor.getOneToken();

	while (currentToken && astUtils.isCommentToken(currentToken)) {
		tokens.push(currentToken);
		currentToken = cursor.getOneToken();
	}

	return tokens;
}
module.exports = function () {
	function TokenStore(tokens, comments) {
		_classCallCheck(this, TokenStore);

		this[TOKENS] = tokens;
		this[COMMENTS] = comments;
		this[INDEX_MAP] = createIndexMap(tokens, comments);
	}


	_createClass(TokenStore, [{
		key: "getTokenByRangeStart",
		value: function getTokenByRangeStart(offset, options) {
			var includeComments = options && options.includeComments;
			var token = cursors.forward.createBaseCursor(this[TOKENS], this[COMMENTS], this[INDEX_MAP], offset, -1, includeComments).getOneToken();

			if (token && token.range[0] === offset) {
				return token;
			}
			return null;
		}

	}, {
		key: "getFirstToken",
		value: function getFirstToken(node, options) {
			return createCursorWithSkip(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getOneToken();
		}

	}, {
		key: "getLastToken",
		value: function getLastToken(node, options) {
			return createCursorWithSkip(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getOneToken();
		}

	}, {
		key: "getTokenBefore",
		value: function getTokenBefore(node, options) {
			return createCursorWithSkip(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], -1, node.range[0], options).getOneToken();
		}

	}, {
		key: "getTokenAfter",
		value: function getTokenAfter(node, options) {
			return createCursorWithSkip(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[1], -1, options).getOneToken();
		}

	}, {
		key: "getFirstTokenBetween",
		value: function getFirstTokenBetween(left, right, options) {
			return createCursorWithSkip(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getOneToken();
		}

	}, {
		key: "getLastTokenBetween",
		value: function getLastTokenBetween(left, right, options) {
			return createCursorWithSkip(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getOneToken();
		}

	}, {
		key: "getTokenOrCommentBefore",
		value: function getTokenOrCommentBefore(node, skip) {
			return this.getTokenBefore(node, { includeComments: true, skip: skip });
		}

	}, {
		key: "getTokenOrCommentAfter",
		value: function getTokenOrCommentAfter(node, skip) {
			return this.getTokenAfter(node, { includeComments: true, skip: skip });
		}

	}, {
		key: "getFirstTokens",
		value: function getFirstTokens(node, options) {
			return createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getAllTokens();
		}

	}, {
		key: "getLastTokens",
		value: function getLastTokens(node, options) {
			return createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getAllTokens().reverse();
		}

	}, {
		key: "getTokensBefore",
		value: function getTokensBefore(node, options) {
			return createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], -1, node.range[0], options).getAllTokens().reverse();
		}

	}, {
		key: "getTokensAfter",
		value: function getTokensAfter(node, options) {
			return createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[1], -1, options).getAllTokens();
		}

	}, {
		key: "getFirstTokensBetween",
		value: function getFirstTokensBetween(left, right, options) {
			return createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getAllTokens();
		}

	}, {
		key: "getLastTokensBetween",
		value: function getLastTokensBetween(left, right, options) {
			return createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getAllTokens().reverse();
		}

	}, {
		key: "getTokens",
		value: function getTokens(node, beforeCount, afterCount) {
			return createCursorWithPadding(this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], beforeCount, afterCount).getAllTokens();
		}

	}, {
		key: "getTokensBetween",
		value: function getTokensBetween(left, right, padding) {
			return createCursorWithPadding(this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], padding, padding).getAllTokens();
		}

	}, {
		key: "commentsExistBetween",
		value: function commentsExistBetween(left, right) {
			var index = utils.search(this[COMMENTS], left.range[1]);

			return index < this[COMMENTS].length && this[COMMENTS][index].range[1] <= right.range[0];
		}

	}, {
		key: "getCommentsBefore",
		value: function getCommentsBefore(nodeOrToken) {
			var cursor = createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], -1, nodeOrToken.range[0], { includeComments: true });

			return getAdjacentCommentTokensFromCursor(cursor).reverse();
		}

	}, {
		key: "getCommentsAfter",
		value: function getCommentsAfter(nodeOrToken) {
			var cursor = createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], nodeOrToken.range[1], -1, { includeComments: true });

			return getAdjacentCommentTokensFromCursor(cursor);
		}

	}, {
		key: "getCommentsInside",
		value: function getCommentsInside(node) {
			return this.getTokens(node, {
				includeComments: true,
				filter: astUtils.isCommentToken
			});
		}
	}]);

	return TokenStore;
}();
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BackwardTokenCommentCursor = __webpack_require__(381);
var BackwardTokenCursor = __webpack_require__(382);
var FilterCursor = __webpack_require__(383);
var ForwardTokenCommentCursor = __webpack_require__(384);
var ForwardTokenCursor = __webpack_require__(105);
var LimitCursor = __webpack_require__(385);
var SkipCursor = __webpack_require__(386);

var CursorFactory = function () {
	function CursorFactory(TokenCursor, TokenCommentCursor) {
		_classCallCheck(this, CursorFactory);

		this.TokenCursor = TokenCursor;
		this.TokenCommentCursor = TokenCommentCursor;
	}


	_createClass(CursorFactory, [{
		key: "createBaseCursor",
		value: function createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments) {
			var Cursor = includeComments ? this.TokenCommentCursor : this.TokenCursor;

			return new Cursor(tokens, comments, indexMap, startLoc, endLoc);
		}

	}, {
		key: "createCursor",
		value: function createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, count) {
			var cursor = this.createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments);

			if (filter) {
				cursor = new FilterCursor(cursor, filter);
			}
			if (skip >= 1) {
				cursor = new SkipCursor(cursor, skip);
			}
			if (count >= 0) {
				cursor = new LimitCursor(cursor, count);
			}

			return cursor;
		}
	}]);

	return CursorFactory;
}();
exports.forward = new CursorFactory(ForwardTokenCursor, ForwardTokenCommentCursor);
exports.backward = new CursorFactory(BackwardTokenCursor, BackwardTokenCommentCursor);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Cursor = __webpack_require__(55);
var utils = __webpack_require__(56);
module.exports = function (_Cursor) {
	_inherits(BackwardTokenCommentCursor, _Cursor);
	function BackwardTokenCommentCursor(tokens, comments, indexMap, startLoc, endLoc) {
		_classCallCheck(this, BackwardTokenCommentCursor);

		var _this = _possibleConstructorReturn(this, (BackwardTokenCommentCursor.__proto__ || Object.getPrototypeOf(BackwardTokenCommentCursor)).call(this));

		_this.tokens = tokens;
		_this.comments = comments;
		_this.tokenIndex = utils.getLastIndex(tokens, indexMap, endLoc);
		_this.commentIndex = utils.search(comments, endLoc) - 1;
		_this.border = startLoc;
		return _this;
	}


	_createClass(BackwardTokenCommentCursor, [{
		key: "moveNext",
		value: function moveNext() {
			var token = this.tokenIndex >= 0 ? this.tokens[this.tokenIndex] : null;
			var comment = this.commentIndex >= 0 ? this.comments[this.commentIndex] : null;

			if (token && (!comment || token.range[1] > comment.range[1])) {
				this.current = token;
				this.tokenIndex -= 1;
			} else if (comment) {
				this.current = comment;
				this.commentIndex -= 1;
			} else {
				this.current = null;
			}

			return Boolean(this.current) && (this.border === -1 || this.current.range[0] >= this.border);
		}
	}]);

	return BackwardTokenCommentCursor;
}(Cursor);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Cursor = __webpack_require__(55);
var utils = __webpack_require__(56);
module.exports = function (_Cursor) {
	_inherits(BackwardTokenCursor, _Cursor);
	function BackwardTokenCursor(tokens, comments, indexMap, startLoc, endLoc) {
		_classCallCheck(this, BackwardTokenCursor);

		var _this = _possibleConstructorReturn(this, (BackwardTokenCursor.__proto__ || Object.getPrototypeOf(BackwardTokenCursor)).call(this));

		_this.tokens = tokens;
		_this.index = utils.getLastIndex(tokens, indexMap, endLoc);
		_this.indexEnd = utils.getFirstIndex(tokens, indexMap, startLoc);
		return _this;
	}


	_createClass(BackwardTokenCursor, [{
		key: "moveNext",
		value: function moveNext() {
			if (this.index >= this.indexEnd) {
				this.current = this.tokens[this.index];
				this.index -= 1;
				return true;
			}
			return false;
		}

	}, {
		key: "getOneToken",
		value: function getOneToken() {
			return this.index >= this.indexEnd ? this.tokens[this.index] : null;
		}
	}]);

	return BackwardTokenCursor;
}(Cursor);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DecorativeCursor = __webpack_require__(104);
module.exports = function (_DecorativeCursor) {
	_inherits(FilterCursor, _DecorativeCursor);
	function FilterCursor(cursor, predicate) {
		_classCallCheck(this, FilterCursor);

		var _this = _possibleConstructorReturn(this, (FilterCursor.__proto__ || Object.getPrototypeOf(FilterCursor)).call(this, cursor));

		_this.predicate = predicate;
		return _this;
	}


	_createClass(FilterCursor, [{
		key: "moveNext",
		value: function moveNext() {
			var predicate = this.predicate;

			while (_get(FilterCursor.prototype.__proto__ || Object.getPrototypeOf(FilterCursor.prototype), "moveNext", this).call(this)) {
				if (predicate(this.current)) {
					return true;
				}
			}
			return false;
		}
	}]);

	return FilterCursor;
}(DecorativeCursor);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Cursor = __webpack_require__(55);
var utils = __webpack_require__(56);
module.exports = function (_Cursor) {
	_inherits(ForwardTokenCommentCursor, _Cursor);
	function ForwardTokenCommentCursor(tokens, comments, indexMap, startLoc, endLoc) {
		_classCallCheck(this, ForwardTokenCommentCursor);

		var _this = _possibleConstructorReturn(this, (ForwardTokenCommentCursor.__proto__ || Object.getPrototypeOf(ForwardTokenCommentCursor)).call(this));

		_this.tokens = tokens;
		_this.comments = comments;
		_this.tokenIndex = utils.getFirstIndex(tokens, indexMap, startLoc);
		_this.commentIndex = utils.search(comments, startLoc);
		_this.border = endLoc;
		return _this;
	}


	_createClass(ForwardTokenCommentCursor, [{
		key: "moveNext",
		value: function moveNext() {
			var token = this.tokenIndex < this.tokens.length ? this.tokens[this.tokenIndex] : null;
			var comment = this.commentIndex < this.comments.length ? this.comments[this.commentIndex] : null;

			if (token && (!comment || token.range[0] < comment.range[0])) {
				this.current = token;
				this.tokenIndex += 1;
			} else if (comment) {
				this.current = comment;
				this.commentIndex += 1;
			} else {
				this.current = null;
			}

			return Boolean(this.current) && (this.border === -1 || this.current.range[1] <= this.border);
		}
	}]);

	return ForwardTokenCommentCursor;
}(Cursor);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DecorativeCursor = __webpack_require__(104);
module.exports = function (_DecorativeCursor) {
	_inherits(LimitCursor, _DecorativeCursor);
	function LimitCursor(cursor, count) {
		_classCallCheck(this, LimitCursor);

		var _this = _possibleConstructorReturn(this, (LimitCursor.__proto__ || Object.getPrototypeOf(LimitCursor)).call(this, cursor));

		_this.count = count;
		return _this;
	}


	_createClass(LimitCursor, [{
		key: "moveNext",
		value: function moveNext() {
			if (this.count > 0) {
				this.count -= 1;
				return _get(LimitCursor.prototype.__proto__ || Object.getPrototypeOf(LimitCursor.prototype), "moveNext", this).call(this);
			}
			return false;
		}
	}]);

	return LimitCursor;
}(DecorativeCursor);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DecorativeCursor = __webpack_require__(104);
module.exports = function (_DecorativeCursor) {
	_inherits(SkipCursor, _DecorativeCursor);
	function SkipCursor(cursor, count) {
		_classCallCheck(this, SkipCursor);

		var _this = _possibleConstructorReturn(this, (SkipCursor.__proto__ || Object.getPrototypeOf(SkipCursor)).call(this, cursor));

		_this.count = count;
		return _this;
	}


	_createClass(SkipCursor, [{
		key: "moveNext",
		value: function moveNext() {
			while (this.count > 0) {
				this.count -= 1;
				if (!_get(SkipCursor.prototype.__proto__ || Object.getPrototypeOf(SkipCursor.prototype), "moveNext", this).call(this)) {
					return false;
				}
			}
			return _get(SkipCursor.prototype.__proto__ || Object.getPrototypeOf(SkipCursor.prototype), "moveNext", this).call(this);
		}
	}]);

	return SkipCursor;
}(DecorativeCursor);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ForwardTokenCursor = __webpack_require__(105);
module.exports = function (_ForwardTokenCursor) {
  _inherits(PaddedTokenCursor, _ForwardTokenCursor);
  function PaddedTokenCursor(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {
	_classCallCheck(this, PaddedTokenCursor);

	var _this = _possibleConstructorReturn(this, (PaddedTokenCursor.__proto__ || Object.getPrototypeOf(PaddedTokenCursor)).call(this, tokens, comments, indexMap, startLoc, endLoc));

	_this.index = Math.max(0, _this.index - beforeCount);
	_this.indexEnd = Math.min(tokens.length - 1, _this.indexEnd + afterCount);
	return _this;
  }

  return PaddedTokenCursor;
}(ForwardTokenCursor);
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var ruleFixer = __webpack_require__(389);
function normalizeMultiArgReportCall() {
	if (arguments.length === 1) {
		return arguments[0];
	}
	if (typeof arguments[1] === "string") {
		return {
			node: arguments[0],
			message: arguments[1],
			data: arguments[2],
			fix: arguments[3]
		};
	}
	return {
		node: arguments[0],
		loc: arguments[1],
		message: arguments[2],
		data: arguments[3],
		fix: arguments[4]
	};
}
function assertValidNodeInfo(descriptor) {
	if (descriptor.node) {} else {}
}
function normalizeReportLoc(descriptor) {
	if (descriptor.loc) {
		if (descriptor.loc.start) {
			return descriptor.loc;
		}
		return { start: descriptor.loc, end: null };
	}
	return descriptor.node.loc;
}
function normalizeMessagePlaceholders(descriptor) {
	if (!descriptor.data) {
		return descriptor.message;
	}
	return descriptor.message.replace(/\{\{\s*([^{}]+?)\s*\}\}/g, function (fullMatch, term) {
		if (term in descriptor.data) {
			return descriptor.data[term];
		}

		return fullMatch;
	});
}
function compareFixesByRange(a, b) {
	return a.range[0] - b.range[0] || a.range[1] - b.range[1];
}
function mergeFixes(fixes, sourceCode) {
	if (fixes.length === 0) {
		return null;
	}
	if (fixes.length === 1) {
		return fixes[0];
	}

	fixes.sort(compareFixesByRange);

	var originalText = sourceCode.text;
	var start = fixes[0].range[0];
	var end = fixes[fixes.length - 1].range[1];
	var text = "";
	var lastPos = Number.MIN_SAFE_INTEGER;

	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = fixes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var fix = _step.value;


			if (fix.range[0] >= 0) {
				text += originalText.slice(Math.max(0, start, lastPos), fix.range[0]);
			}
			text += fix.text;
			lastPos = fix.range[1];
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	text += originalText.slice(Math.max(0, start, lastPos), end);

	return { range: [start, end], text: text };
}
function normalizeFixes(descriptor, sourceCode) {
	if (typeof descriptor.fix !== "function") {
		return null;
	}
	var fix = descriptor.fix(ruleFixer);
	if (fix && Symbol.iterator in fix) {
		return mergeFixes(Array.from(fix), sourceCode);
	}
	return fix;
}
function createProblem(options) {
	var problem = {
		ruleId: options.ruleId,
		severity: options.severity,
		message: options.message,
		line: options.loc.start.line,
		column: options.loc.start.column + 1,
		nodeType: options.node && options.node.type || null,
		source: options.sourceLines[options.loc.start.line - 1] || ""
	};

	if (options.loc.end) {
		problem.endLine = options.loc.end.line;
		problem.endColumn = options.loc.end.column + 1;
	}

	if (options.fix) {
		problem.fix = options.fix;
	}

	return problem;
}

module.exports = function createReportTranslator(metadata) {
	return function () {
		var descriptor = normalizeMultiArgReportCall.apply(null, arguments);

		assertValidNodeInfo(descriptor);

		return createProblem({
			ruleId: metadata.ruleId,
			severity: metadata.severity,
			node: descriptor.node,
			message: normalizeMessagePlaceholders(descriptor),
			loc: normalizeReportLoc(descriptor),
			fix: normalizeFixes(descriptor, metadata.sourceCode),
			sourceLines: metadata.sourceCode.lines
		});
	};
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function insertTextAt(index, text) {
	return {
		range: [index, index],
		text: text
	};
}

var ruleFixer = Object.freeze({
	insertTextAfter: function insertTextAfter(nodeOrToken, text) {
		return this.insertTextAfterRange(nodeOrToken.range, text);
	},
	insertTextAfterRange: function insertTextAfterRange(range, text) {
		return insertTextAt(range[1], text);
	},
	insertTextBefore: function insertTextBefore(nodeOrToken, text) {
		return this.insertTextBeforeRange(nodeOrToken.range, text);
	},
	insertTextBeforeRange: function insertTextBeforeRange(range, text) {
		return insertTextAt(range[0], text);
	},
	replaceText: function replaceText(nodeOrToken, text) {
		return this.replaceTextRange(nodeOrToken.range, text);
	},
	replaceTextRange: function replaceTextRange(range, text) {
		return {
			range: range,
			text: text
		};
	},
	remove: function remove(nodeOrToken) {
		return this.removeRange(nodeOrToken.range);
	},
	removeRange: function removeRange(range) {
		return {
			range: range,
			text: ""
		};
	}
});

module.exports = ruleFixer;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var lodash = __webpack_require__(10);
var loadRules = __webpack_require__(391);
var ruleReplacements = __webpack_require__(752).rules;
var createMissingRule = lodash.memoize(function (ruleId) {
	var message = Object.prototype.hasOwnProperty.call(ruleReplacements, ruleId) ? "Rule '" + ruleId + "' was removed and replaced by: " + ruleReplacements[ruleId].join(", ") : "Definition for rule '" + ruleId + "' was not found";

	return {
		create: function create(context) {
			return {
				Program: function Program() {
					context.report({
						loc: { line: 1, column: 0 },
						message: message
					});
				}
			};
		}
	};
});
function normalizeRule(rule) {
	return typeof rule === "function" ? Object.assign({ create: rule }, rule) : rule;
}
var Rules = function () {
	function Rules() {
		_classCallCheck(this, Rules);

		this._rules = Object.create(null);

		this.load();
	}


	_createClass(Rules, [{
		key: "define",
		value: function define(ruleId, ruleModule) {
			this._rules[ruleId] = normalizeRule(ruleModule);
		}

	}, {
		key: "load",
		value: function load(rulesDir, cwd) {
			var _this = this;

			var newRules = loadRules(rulesDir, cwd);

			Object.keys(newRules).forEach(function (ruleId) {
				_this.define(ruleId, newRules[ruleId]);
			});
		}

	}, {
		key: "importPlugin",
		value: function importPlugin(plugin, pluginName) {
			var _this2 = this;

			if (plugin.rules) {
				Object.keys(plugin.rules).forEach(function (ruleId) {
					var qualifiedRuleId = pluginName + "/" + ruleId,
						rule = plugin.rules[ruleId];

					_this2.define(qualifiedRuleId, rule);
				});
			}
		}

	}, {
		key: "get",
		value: function get(ruleId) {
			if (!Object.prototype.hasOwnProperty.call(this._rules, ruleId)) {
				return createMissingRule(ruleId);
			}
			if (typeof this._rules[ruleId] === "string") {
				return normalizeRule(!(function webpackMissingModule() { var e = new Error("Cannot find module \".\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
			}
			return this._rules[ruleId];
		}

	}, {
		key: "getAllLoadedRules",
		value: function getAllLoadedRules() {
			var _this3 = this;

			var allRules = new Map();

			Object.keys(this._rules).forEach(function (name) {
				var rule = _this3.get(name);

				allRules.set(name, rule);
			});
			return allRules;
		}
	}]);

	return Rules;
}();

module.exports = Rules;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function () {
	var rules = { "accessor-pairs": __webpack_require__(392),
		"array-bracket-newline": __webpack_require__(393),
		"array-bracket-spacing": __webpack_require__(394),
		"array-callback-return": __webpack_require__(395),
		"array-element-newline": __webpack_require__(396),
		"arrow-body-style": __webpack_require__(397),
		"arrow-parens": __webpack_require__(398),
		"arrow-spacing": __webpack_require__(399),
		"block-scoped-var": __webpack_require__(400),
		"block-spacing": __webpack_require__(401),
		"brace-style": __webpack_require__(402),
		"callback-return": __webpack_require__(403),
		"camelcase": __webpack_require__(404),
		"capitalized-comments": __webpack_require__(405),
		"class-methods-use-this": __webpack_require__(407),
		"comma-dangle": __webpack_require__(408),
		"comma-spacing": __webpack_require__(409),
		"comma-style": __webpack_require__(410),
		"complexity": __webpack_require__(411),
		"computed-property-spacing": __webpack_require__(412),
		"consistent-return": __webpack_require__(413),
		"consistent-this": __webpack_require__(414),
		"constructor-super": __webpack_require__(415),
		"curly": __webpack_require__(416),
		"default-case": __webpack_require__(417),
		"dot-location": __webpack_require__(418),
		"dot-notation": __webpack_require__(419),
		"eol-last": __webpack_require__(420),
		"eqeqeq": __webpack_require__(421),
		"for-direction": __webpack_require__(422),
		"func-call-spacing": __webpack_require__(423),
		"func-name-matching": __webpack_require__(424),
		"func-names": __webpack_require__(425),
		"func-style": __webpack_require__(426),
		"function-paren-newline": __webpack_require__(427),
		"generator-star-spacing": __webpack_require__(428),
		"getter-return": __webpack_require__(429),
		"global-require": __webpack_require__(430),
		"guard-for-in": __webpack_require__(431),
		"handle-callback-err": __webpack_require__(432),
		"id-blacklist": __webpack_require__(433),
		"id-length": __webpack_require__(434),
		"id-match": __webpack_require__(435),
		"implicit-arrow-linebreak": __webpack_require__(436),
		"indent-legacy": __webpack_require__(437),
		"indent": __webpack_require__(438),
		"init-declarations": __webpack_require__(440),
		"jsx-quotes": __webpack_require__(441),
		"key-spacing": __webpack_require__(442),
		"keyword-spacing": __webpack_require__(443),
		"line-comment-position": __webpack_require__(444),
		"linebreak-style": __webpack_require__(445),
		"lines-around-comment": __webpack_require__(446),
		"lines-around-directive": __webpack_require__(447),
		"lines-between-class-members": __webpack_require__(448),
		"max-depth": __webpack_require__(449),
		"max-len": __webpack_require__(450),
		"max-lines": __webpack_require__(451),
		"max-nested-callbacks": __webpack_require__(452),
		"max-params": __webpack_require__(453),
		"max-statements-per-line": __webpack_require__(454),
		"max-statements": __webpack_require__(455),
		"multiline-comment-style": __webpack_require__(456),
		"multiline-ternary": __webpack_require__(457),
		"new-cap": __webpack_require__(458),
		"new-parens": __webpack_require__(459),
		"newline-after-var": __webpack_require__(460),
		"newline-before-return": __webpack_require__(461),
		"newline-per-chained-call": __webpack_require__(462),
		"no-alert": __webpack_require__(463),
		"no-array-constructor": __webpack_require__(464),
		"no-await-in-loop": __webpack_require__(465),
		"no-bitwise": __webpack_require__(466),
		"no-buffer-constructor": __webpack_require__(467),
		"no-caller": __webpack_require__(468),
		"no-case-declarations": __webpack_require__(469),
		"no-catch-shadow": __webpack_require__(470),
		"no-class-assign": __webpack_require__(471),
		"no-compare-neg-zero": __webpack_require__(472),
		"no-cond-assign": __webpack_require__(473),
		"no-confusing-arrow": __webpack_require__(474),
		"no-console": __webpack_require__(475),
		"no-const-assign": __webpack_require__(476),
		"no-constant-condition": __webpack_require__(477),
		"no-continue": __webpack_require__(478),
		"no-control-regex": __webpack_require__(479),
		"no-debugger": __webpack_require__(480),
		"no-delete-var": __webpack_require__(481),
		"no-div-regex": __webpack_require__(482),
		"no-dupe-args": __webpack_require__(483),
		"no-dupe-class-members": __webpack_require__(484),
		"no-dupe-keys": __webpack_require__(485),
		"no-duplicate-case": __webpack_require__(486),
		"no-duplicate-imports": __webpack_require__(487),
		"no-else-return": __webpack_require__(488),
		"no-empty-character-class": __webpack_require__(489),
		"no-empty-function": __webpack_require__(490),
		"no-empty-pattern": __webpack_require__(491),
		"no-empty": __webpack_require__(492),
		"no-eq-null": __webpack_require__(493),
		"no-eval": __webpack_require__(494),
		"no-ex-assign": __webpack_require__(495),
		"no-extend-native": __webpack_require__(496),
		"no-extra-bind": __webpack_require__(497),
		"no-extra-boolean-cast": __webpack_require__(498),
		"no-extra-label": __webpack_require__(499),
		"no-extra-parens": __webpack_require__(500),
		"no-extra-semi": __webpack_require__(501),
		"no-fallthrough": __webpack_require__(502),
		"no-floating-decimal": __webpack_require__(503),
		"no-func-assign": __webpack_require__(504),
		"no-global-assign": __webpack_require__(505),
		"no-implicit-coercion": __webpack_require__(506),
		"no-implicit-globals": __webpack_require__(507),
		"no-implied-eval": __webpack_require__(508),
		"no-inline-comments": __webpack_require__(509),
		"no-inner-declarations": __webpack_require__(510),
		"no-invalid-regexp": __webpack_require__(511),
		"no-invalid-this": __webpack_require__(512),
		"no-irregular-whitespace": __webpack_require__(513),
		"no-iterator": __webpack_require__(514),
		"no-label-var": __webpack_require__(515),
		"no-labels": __webpack_require__(516),
		"no-lone-blocks": __webpack_require__(517),
		"no-lonely-if": __webpack_require__(518),
		"no-loop-func": __webpack_require__(519),
		"no-magic-numbers": __webpack_require__(520),
		"no-mixed-operators": __webpack_require__(521),
		"no-mixed-requires": __webpack_require__(522),
		"no-mixed-spaces-and-tabs": __webpack_require__(523),
		"no-multi-assign": __webpack_require__(524),
		"no-multi-spaces": __webpack_require__(525),
		"no-multi-str": __webpack_require__(526),
		"no-multiple-empty-lines": __webpack_require__(527),
		"no-native-reassign": __webpack_require__(528),
		"no-negated-condition": __webpack_require__(529),
		"no-negated-in-lhs": __webpack_require__(530),
		"no-nested-ternary": __webpack_require__(531),
		"no-new-func": __webpack_require__(532),
		"no-new-object": __webpack_require__(533),
		"no-new-require": __webpack_require__(534),
		"no-new-symbol": __webpack_require__(535),
		"no-new-wrappers": __webpack_require__(536),
		"no-new": __webpack_require__(537),
		"no-obj-calls": __webpack_require__(538),
		"no-octal-escape": __webpack_require__(539),
		"no-octal": __webpack_require__(540),
		"no-param-reassign": __webpack_require__(541),
		"no-path-concat": __webpack_require__(542),
		"no-plusplus": __webpack_require__(543),
		"no-process-env": __webpack_require__(544),
		"no-process-exit": __webpack_require__(545),
		"no-proto": __webpack_require__(546),
		"no-prototype-builtins": __webpack_require__(547),
		"no-redeclare": __webpack_require__(548),
		"no-regex-spaces": __webpack_require__(549),
		"no-restricted-globals": __webpack_require__(550),
		"no-restricted-imports": __webpack_require__(551),
		"no-restricted-modules": __webpack_require__(552),
		"no-restricted-properties": __webpack_require__(553),
		"no-restricted-syntax": __webpack_require__(554),
		"no-return-assign": __webpack_require__(555),
		"no-return-await": __webpack_require__(556),
		"no-script-url": __webpack_require__(557),
		"no-self-assign": __webpack_require__(558),
		"no-self-compare": __webpack_require__(559),
		"no-sequences": __webpack_require__(560),
		"no-shadow-restricted-names": __webpack_require__(561),
		"no-shadow": __webpack_require__(562),
		"no-spaced-func": __webpack_require__(563),
		"no-sparse-arrays": __webpack_require__(564),
		"no-sync": __webpack_require__(565),
		"no-tabs": __webpack_require__(566),
		"no-template-curly-in-string": __webpack_require__(567),
		"no-ternary": __webpack_require__(568),
		"no-this-before-super": __webpack_require__(569),
		"no-throw-literal": __webpack_require__(570),
		"no-trailing-spaces": __webpack_require__(571),
		"no-undef-init": __webpack_require__(572),
		"no-undef": __webpack_require__(573),
		"no-undefined": __webpack_require__(574),
		"no-underscore-dangle": __webpack_require__(575),
		"no-unexpected-multiline": __webpack_require__(576),
		"no-unmodified-loop-condition": __webpack_require__(577),
		"no-unneeded-ternary": __webpack_require__(578),
		"no-unreachable": __webpack_require__(579),
		"no-unsafe-finally": __webpack_require__(580),
		"no-unsafe-negation": __webpack_require__(581),
		"no-unused-expressions": __webpack_require__(582),
		"no-unused-labels": __webpack_require__(583),
		"no-unused-vars": __webpack_require__(584),
		"no-use-before-define": __webpack_require__(585),
		"no-useless-call": __webpack_require__(586),
		"no-useless-computed-key": __webpack_require__(587),
		"no-useless-concat": __webpack_require__(588),
		"no-useless-constructor": __webpack_require__(589),
		"no-useless-escape": __webpack_require__(590),
		"no-useless-rename": __webpack_require__(591),
		"no-useless-return": __webpack_require__(592),
		"no-var": __webpack_require__(593),
		"no-void": __webpack_require__(594),
		"no-warning-comments": __webpack_require__(595),
		"no-whitespace-before-property": __webpack_require__(596),
		"no-with": __webpack_require__(597),
		"nonblock-statement-body-position": __webpack_require__(598),
		"object-curly-newline": __webpack_require__(599),
		"object-curly-spacing": __webpack_require__(600),
		"object-property-newline": __webpack_require__(601),
		"object-shorthand": __webpack_require__(602),
		"one-var-declaration-per-line": __webpack_require__(603),
		"one-var": __webpack_require__(604),
		"operator-assignment": __webpack_require__(605),
		"operator-linebreak": __webpack_require__(606),
		"padded-blocks": __webpack_require__(607),
		"padding-line-between-statements": __webpack_require__(608),
		"prefer-arrow-callback": __webpack_require__(609),
		"prefer-const": __webpack_require__(610),
		"prefer-destructuring": __webpack_require__(611),
		"prefer-numeric-literals": __webpack_require__(612),
		"prefer-promise-reject-errors": __webpack_require__(613),
		"prefer-reflect": __webpack_require__(614),
		"prefer-rest-params": __webpack_require__(615),
		"prefer-spread": __webpack_require__(616),
		"prefer-template": __webpack_require__(617),
		"quote-props": __webpack_require__(618),
		"quotes": __webpack_require__(619),
		"radix": __webpack_require__(620),
		"require-await": __webpack_require__(621),
		"require-jsdoc": __webpack_require__(622),
		"require-yield": __webpack_require__(623),
		"rest-spread-spacing": __webpack_require__(624),
		"semi-spacing": __webpack_require__(625),
		"semi-style": __webpack_require__(626),
		"semi": __webpack_require__(627),
		"sort-imports": __webpack_require__(628),
		"sort-keys": __webpack_require__(629),
		"sort-vars": __webpack_require__(631),
		"space-before-blocks": __webpack_require__(632),
		"space-before-function-paren": __webpack_require__(633),
		"space-in-parens": __webpack_require__(634),
		"space-infix-ops": __webpack_require__(635),
		"space-unary-ops": __webpack_require__(636),
		"spaced-comment": __webpack_require__(637),
		"strict": __webpack_require__(638),
		"switch-colon-spacing": __webpack_require__(639),
		"symbol-description": __webpack_require__(640),
		"template-curly-spacing": __webpack_require__(641),
		"template-tag-spacing": __webpack_require__(642),
		"unicode-bom": __webpack_require__(643),
		"use-isnan": __webpack_require__(644),
		"valid-jsdoc": __webpack_require__(645),
		"valid-typeof": __webpack_require__(651),
		"vars-on-top": __webpack_require__(652),
		"wrap-iife": __webpack_require__(653),
		"wrap-regex": __webpack_require__(654),
		"yield-star-spacing": __webpack_require__(655),
		"yoda": __webpack_require__(656)
	};

	var jsxRules = __webpack_require__(657).rules;
	Object.keys(jsxRules).forEach(function (key) {
		rules["react/" + key] = jsxRules[key];
	});
	return rules;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function isIdentifier(node, name) {
	return node.type === "Identifier" && node.name === name;
}
function isArgumentOfMethodCall(node, index, object, property) {
	var parent = node.parent;

	return parent.type === "CallExpression" && parent.callee.type === "MemberExpression" && parent.callee.computed === false && isIdentifier(parent.callee.object, object) && isIdentifier(parent.callee.property, property) && parent.arguments[index] === node;
}
function isPropertyDescriptor(node) {
	if (isArgumentOfMethodCall(node, 2, "Object", "defineProperty") || isArgumentOfMethodCall(node, 2, "Reflect", "defineProperty")) {
		return true;
	}
	node = node.parent.parent;

	return node.type === "ObjectExpression" && (isArgumentOfMethodCall(node, 1, "Object", "create") || isArgumentOfMethodCall(node, 1, "Object", "defineProperties"));
}
module.exports = {
	meta: {
		docs: {
			description: "enforce getter and setter pairs in objects",
			category: "Best Practices",
			recommended: false
		},
		schema: [{
			type: "object",
			properties: {
				getWithoutSet: {
					type: "boolean"
				},
				setWithoutGet: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},
	create: function create(context) {
		var config = context.options[0] || {};
		var checkGetWithoutSet = config.getWithoutSet === true;
		var checkSetWithoutGet = config.setWithoutGet !== false;
		function checkLonelySetGet(node) {
			var isSetPresent = false;
			var isGetPresent = false;
			var isDescriptor = isPropertyDescriptor(node);

			for (var i = 0, end = node.properties.length; i < end; i++) {
				var property = node.properties[i];

				var propToCheck = "";

				if (property.kind === "init") {
					if (isDescriptor && !property.computed) {
						propToCheck = property.key.name;
					}
				} else {
					propToCheck = property.kind;
				}

				switch (propToCheck) {
					case "set":
						isSetPresent = true;
						break;

					case "get":
						isGetPresent = true;
						break;

					default:
				}

				if (isSetPresent && isGetPresent) {
					break;
				}
			}

			if (checkSetWithoutGet && isSetPresent && !isGetPresent) {
				context.report({ node: node, message: "Getter is not present." });
			} else if (checkGetWithoutSet && isGetPresent && !isSetPresent) {
				context.report({ node: node, message: "Setter is not present." });
			}
		}

		return {
			ObjectExpression: function ObjectExpression(node) {
				if (checkSetWithoutGet || checkGetWithoutSet) {
					checkLonelySetGet(node);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce linebreaks after opening and before closing array brackets",
			category: "Stylistic Issues",
			recommended: false
		},
		fixable: "whitespace",
		schema: [{
			oneOf: [{
				enum: ["always", "never", "consistent"]
			}, {
				type: "object",
				properties: {
					multiline: {
						type: "boolean"
					},
					minItems: {
						type: ["integer", "null"],
						minimum: 0
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		function normalizeOptionValue(option) {
			var consistent = false;
			var multiline = false;
			var minItems = 0;

			if (option) {
				if (option === "consistent") {
					consistent = true;
					minItems = Number.POSITIVE_INFINITY;
				} else if (option === "always" || option.minItems === 0) {
					minItems = 0;
				} else if (option === "never") {
					minItems = Number.POSITIVE_INFINITY;
				} else {
					multiline = Boolean(option.multiline);
					minItems = option.minItems || Number.POSITIVE_INFINITY;
				}
			} else {
				consistent = false;
				multiline = true;
				minItems = Number.POSITIVE_INFINITY;
			}

			return { consistent: consistent, multiline: multiline, minItems: minItems };
		}
		function normalizeOptions(options) {
			var value = normalizeOptionValue(options);

			return { ArrayExpression: value, ArrayPattern: value };
		}
		function reportNoBeginningLinebreak(node, token) {
			context.report({
				node: node,
				loc: token.loc,
				message: "There should be no linebreak after '['.",
				fix: function fix(fixer) {
					var nextToken = sourceCode.getTokenAfter(token, { includeComments: true });

					if (astUtils.isCommentToken(nextToken)) {
						return null;
					}

					return fixer.removeRange([token.range[1], nextToken.range[0]]);
				}
			});
		}
		function reportNoEndingLinebreak(node, token) {
			context.report({
				node: node,
				loc: token.loc,
				message: "There should be no linebreak before ']'.",
				fix: function fix(fixer) {
					var previousToken = sourceCode.getTokenBefore(token, { includeComments: true });

					if (astUtils.isCommentToken(previousToken)) {
						return null;
					}

					return fixer.removeRange([previousToken.range[1], token.range[0]]);
				}
			});
		}
		function reportRequiredBeginningLinebreak(node, token) {
			context.report({
				node: node,
				loc: token.loc,
				message: "A linebreak is required after '['.",
				fix: function fix(fixer) {
					return fixer.insertTextAfter(token, "\n");
				}
			});
		}
		function reportRequiredEndingLinebreak(node, token) {
			context.report({
				node: node,
				loc: token.loc,
				message: "A linebreak is required before ']'.",
				fix: function fix(fixer) {
					return fixer.insertTextBefore(token, "\n");
				}
			});
		}
		function check(node) {
			var elements = node.elements;
			var normalizedOptions = normalizeOptions(context.options[0]);
			var options = normalizedOptions[node.type];
			var openBracket = sourceCode.getFirstToken(node);
			var closeBracket = sourceCode.getLastToken(node);
			var firstIncComment = sourceCode.getTokenAfter(openBracket, { includeComments: true });
			var lastIncComment = sourceCode.getTokenBefore(closeBracket, { includeComments: true });
			var first = sourceCode.getTokenAfter(openBracket);
			var last = sourceCode.getTokenBefore(closeBracket);

			var needsLinebreaks = elements.length >= options.minItems || options.multiline && elements.length > 0 && firstIncComment.loc.start.line !== lastIncComment.loc.end.line || elements.length === 0 && firstIncComment.type === "Block" && firstIncComment.loc.start.line !== lastIncComment.loc.end.line && firstIncComment === lastIncComment || options.consistent && firstIncComment.loc.start.line !== openBracket.loc.end.line;

			if (needsLinebreaks) {
				if (astUtils.isTokenOnSameLine(openBracket, first)) {
					reportRequiredBeginningLinebreak(node, openBracket);
				}
				if (astUtils.isTokenOnSameLine(last, closeBracket)) {
					reportRequiredEndingLinebreak(node, closeBracket);
				}
			} else {
				if (!astUtils.isTokenOnSameLine(openBracket, first)) {
					reportNoBeginningLinebreak(node, openBracket);
				}
				if (!astUtils.isTokenOnSameLine(last, closeBracket)) {
					reportNoEndingLinebreak(node, closeBracket);
				}
			}
		}
		return {
			ArrayPattern: check,
			ArrayExpression: check
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent spacing inside array brackets",
			category: "Stylistic Issues",
			recommended: false
		},
		fixable: "whitespace",
		schema: [{
			enum: ["always", "never"]
		}, {
			type: "object",
			properties: {
				singleValue: {
					type: "boolean"
				},
				objectsInArrays: {
					type: "boolean"
				},
				arraysInArrays: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},
	create: function create(context) {
		var spaced = context.options[0] === "always",
			sourceCode = context.getSourceCode();
		function isOptionSet(option) {
			return context.options[1] ? context.options[1][option] === !spaced : false;
		}

		var options = {
			spaced: spaced,
			singleElementException: isOptionSet("singleValue"),
			objectsInArraysException: isOptionSet("objectsInArrays"),
			arraysInArraysException: isOptionSet("arraysInArrays")
		};
		function reportNoBeginningSpace(node, token) {
			context.report({
				node: node,
				loc: token.loc.start,
				message: "There should be no space after '{{tokenValue}}'.",
				data: {
					tokenValue: token.value
				},
				fix: function fix(fixer) {
					var nextToken = sourceCode.getTokenAfter(token);

					return fixer.removeRange([token.range[1], nextToken.range[0]]);
				}
			});
		}
		function reportNoEndingSpace(node, token) {
			context.report({
				node: node,
				loc: token.loc.start,
				message: "There should be no space before '{{tokenValue}}'.",
				data: {
					tokenValue: token.value
				},
				fix: function fix(fixer) {
					var previousToken = sourceCode.getTokenBefore(token);

					return fixer.removeRange([previousToken.range[1], token.range[0]]);
				}
			});
		}
		function reportRequiredBeginningSpace(node, token) {
			context.report({
				node: node,
				loc: token.loc.start,
				message: "A space is required after '{{tokenValue}}'.",
				data: {
					tokenValue: token.value
				},
				fix: function fix(fixer) {
					return fixer.insertTextAfter(token, " ");
				}
			});
		}
		function reportRequiredEndingSpace(node, token) {
			context.report({
				node: node,
				loc: token.loc.start,
				message: "A space is required before '{{tokenValue}}'.",
				data: {
					tokenValue: token.value
				},
				fix: function fix(fixer) {
					return fixer.insertTextBefore(token, " ");
				}
			});
		}
		function isObjectType(node) {
			return node && (node.type === "ObjectExpression" || node.type === "ObjectPattern");
		}
		function isArrayType(node) {
			return node && (node.type === "ArrayExpression" || node.type === "ArrayPattern");
		}
		function validateArraySpacing(node) {
			if (options.spaced && node.elements.length === 0) {
				return;
			}

			var first = sourceCode.getFirstToken(node),
				second = sourceCode.getFirstToken(node, 1),
				last = node.typeAnnotation ? sourceCode.getTokenBefore(node.typeAnnotation) : sourceCode.getLastToken(node),
				penultimate = sourceCode.getTokenBefore(last),
				firstElement = node.elements[0],
				lastElement = node.elements[node.elements.length - 1];

			var openingBracketMustBeSpaced = options.objectsInArraysException && isObjectType(firstElement) || options.arraysInArraysException && isArrayType(firstElement) || options.singleElementException && node.elements.length === 1 ? !options.spaced : options.spaced;

			var closingBracketMustBeSpaced = options.objectsInArraysException && isObjectType(lastElement) || options.arraysInArraysException && isArrayType(lastElement) || options.singleElementException && node.elements.length === 1 ? !options.spaced : options.spaced;

			if (astUtils.isTokenOnSameLine(first, second)) {
				if (openingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(first, second)) {
					reportRequiredBeginningSpace(node, first);
				}
				if (!openingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(first, second)) {
					reportNoBeginningSpace(node, first);
				}
			}

			if (first !== penultimate && astUtils.isTokenOnSameLine(penultimate, last)) {
				if (closingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(penultimate, last)) {
					reportRequiredEndingSpace(node, last);
				}
				if (!closingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(penultimate, last)) {
					reportNoEndingSpace(node, last);
				}
			}
		}
		return {
			ArrayPattern: validateArraySpacing,
			ArrayExpression: validateArraySpacing
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var lodash = __webpack_require__(10);

var astUtils = __webpack_require__(0);
var TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/;
var TARGET_METHODS = /^(?:every|filter|find(?:Index)?|map|reduce(?:Right)?|some|sort)$/;
function isReachable(segment) {
	return segment.reachable;
}
function getLocation(node, sourceCode) {
	if (node.type === "ArrowFunctionExpression") {
		return sourceCode.getTokenBefore(node.body);
	}
	return node.id || node;
}
function isTargetMethod(node) {
	return node.type === "MemberExpression" && TARGET_METHODS.test(astUtils.getStaticPropertyName(node) || "");
}
function isCallbackOfArrayMethod(node) {
	while (node) {
		var parent = node.parent;

		switch (parent.type) {
			case "LogicalExpression":
			case "ConditionalExpression":
				node = parent;
				break;
			case "ReturnStatement":
				{
					var func = astUtils.getUpperFunction(parent);

					if (func === null || !astUtils.isCallee(func)) {
						return false;
					}
					node = func.parent;
					break;
				}
			case "CallExpression":
				if (astUtils.isArrayFromMethod(parent.callee)) {
					return parent.arguments.length >= 2 && parent.arguments[1] === node;
				}
				if (isTargetMethod(parent.callee)) {
					return parent.arguments.length >= 1 && parent.arguments[0] === node;
				}
				return false;
			default:
				return false;
		}
	}
	return false;
}
module.exports = {
	meta: {
		docs: {
			description: "enforce `return` statements in callbacks of array methods",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		var funcInfo = {
			upper: null,
			codePath: null,
			hasReturn: false,
			shouldCheck: false,
			node: null
		};
		function checkLastSegment(node) {
			if (funcInfo.shouldCheck && funcInfo.codePath.currentSegments.some(isReachable)) {
				context.report({
					node: node,
					loc: getLocation(node, context.getSourceCode()).loc.start,
					message: funcInfo.hasReturn ? "Expected to return a value at the end of {{name}}." : "Expected to return a value in {{name}}.",
					data: {
						name: astUtils.getFunctionNameWithKind(funcInfo.node)
					}
				});
			}
		}

		return {
			onCodePathStart: function onCodePathStart(codePath, node) {
				funcInfo = {
					upper: funcInfo,
					codePath: codePath,
					hasReturn: false,
					shouldCheck: TARGET_NODE_TYPE.test(node.type) && node.body.type === "BlockStatement" && isCallbackOfArrayMethod(node) && !node.async && !node.generator,
					node: node
				};
			},
			onCodePathEnd: function onCodePathEnd() {
				funcInfo = funcInfo.upper;
			},
			ReturnStatement: function ReturnStatement(node) {
				if (funcInfo.shouldCheck) {
					funcInfo.hasReturn = true;

					if (!node.argument) {
						context.report({
							node: node,
							message: "{{name}} expected a return value.",
							data: {
								name: lodash.upperFirst(astUtils.getFunctionNameWithKind(funcInfo.node))
							}
						});
					}
				}
			},
			"FunctionExpression:exit": checkLastSegment,
			"ArrowFunctionExpression:exit": checkLastSegment
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce line breaks after each array element",
			category: "Stylistic Issues",
			recommended: false
		},
		fixable: "whitespace",
		schema: [{
			oneOf: [{
				enum: ["always", "never"]
			}, {
				type: "object",
				properties: {
					multiline: {
						type: "boolean"
					},
					minItems: {
						type: ["integer", "null"],
						minimum: 0
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		function normalizeOptionValue(option) {
			var multiline = false;
			var minItems = void 0;

			option = option || "always";

			if (option === "always" || option.minItems === 0) {
				minItems = 0;
			} else if (option === "never") {
				minItems = Number.POSITIVE_INFINITY;
			} else {
				multiline = Boolean(option.multiline);
				minItems = option.minItems || Number.POSITIVE_INFINITY;
			}

			return { multiline: multiline, minItems: minItems };
		}
		function normalizeOptions(options) {
			var value = normalizeOptionValue(options);

			return { ArrayExpression: value, ArrayPattern: value };
		}
		function reportNoLineBreak(token) {
			var tokenBefore = sourceCode.getTokenBefore(token, { includeComments: true });

			context.report({
				loc: {
					start: tokenBefore.loc.end,
					end: token.loc.start
				},
				message: "There should be no linebreak here.",
				fix: function fix(fixer) {
					if (astUtils.isCommentToken(tokenBefore)) {
						return null;
					}

					if (!astUtils.isTokenOnSameLine(tokenBefore, token)) {
						return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], " ");
					}
					var twoTokensBefore = sourceCode.getTokenBefore(tokenBefore, { includeComments: true });

					if (astUtils.isCommentToken(twoTokensBefore)) {
						return null;
					}

					return fixer.replaceTextRange([twoTokensBefore.range[1], tokenBefore.range[0]], "");
				}
			});
		}
		function reportRequiredLineBreak(token) {
			var tokenBefore = sourceCode.getTokenBefore(token, { includeComments: true });

			context.report({
				loc: {
					start: tokenBefore.loc.end,
					end: token.loc.start
				},
				message: "There should be a linebreak after this element.",
				fix: function fix(fixer) {
					return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], "\n");
				}
			});
		}
		function check(node) {
			var elements = node.elements;
			var normalizedOptions = normalizeOptions(context.options[0]);
			var options = normalizedOptions[node.type];

			var elementBreak = false;
			if (options.multiline) {
				elementBreak = elements.filter(function (element) {
					return element !== null;
				}).some(function (element) {
					return element.loc.start.line !== element.loc.end.line;
				});
			}

			var needsLinebreaks = elements.length >= options.minItems || options.multiline && elementBreak;

			elements.forEach(function (element, i) {
				var previousElement = elements[i - 1];

				if (i === 0 || element === null || previousElement === null) {
					return;
				}

				var commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);
				var lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);
				var firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);

				if (needsLinebreaks) {
					if (astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {
						reportRequiredLineBreak(firstTokenOfCurrentElement);
					}
				} else {
					if (!astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {
						reportNoLineBreak(firstTokenOfCurrentElement);
					}
				}
			});
		}
		return {
			ArrayPattern: check,
			ArrayExpression: check
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "require braces around arrow function bodies",
			category: "ECMAScript 6",
			recommended: false
		},

		schema: {
			anyOf: [{
				type: "array",
				items: [{
					enum: ["always", "never"]
				}],
				minItems: 0,
				maxItems: 1
			}, {
				type: "array",
				items: [{
					enum: ["as-needed"]
				}, {
					type: "object",
					properties: {
						requireReturnForObjectLiteral: { type: "boolean" }
					},
					additionalProperties: false
				}],
				minItems: 0,
				maxItems: 2
			}]
		},

		fixable: "code"
	},

	create: function create(context) {
		var options = context.options;
		var always = options[0] === "always";
		var asNeeded = !options[0] || options[0] === "as-needed";
		var never = options[0] === "never";
		var requireReturnForObjectLiteral = options[1] && options[1].requireReturnForObjectLiteral;
		var sourceCode = context.getSourceCode();
		function hasASIProblem(token) {
			return token && token.type === "Punctuator" && /^[([/`+-]/.test(token.value);
		}
		function findClosingParen(token) {
			var node = sourceCode.getNodeByRangeIndex(token.range[1]);

			while (!astUtils.isParenthesised(sourceCode, node)) {
				node = node.parent;
			}
			return sourceCode.getTokenAfter(node);
		}
		function validate(node) {
			var arrowBody = node.body;

			if (arrowBody.type === "BlockStatement") {
				var blockBody = arrowBody.body;

				if (blockBody.length !== 1 && !never) {
					return;
				}

				if (asNeeded && requireReturnForObjectLiteral && blockBody[0].type === "ReturnStatement" && blockBody[0].argument && blockBody[0].argument.type === "ObjectExpression") {
					return;
				}

				if (never || asNeeded && blockBody[0].type === "ReturnStatement") {
					context.report({
						node: node,
						loc: arrowBody.loc.start,
						message: "Unexpected block statement surrounding arrow body.",
						fix: function fix(fixer) {
							var fixes = [];

							if (blockBody.length !== 1 || blockBody[0].type !== "ReturnStatement" || !blockBody[0].argument || hasASIProblem(sourceCode.getTokenAfter(arrowBody))) {
								return fixes;
							}

							var openingBrace = sourceCode.getFirstToken(arrowBody);
							var closingBrace = sourceCode.getLastToken(arrowBody);
							var firstValueToken = sourceCode.getFirstToken(blockBody[0], 1);
							var lastValueToken = sourceCode.getLastToken(blockBody[0]);
							var commentsExist = sourceCode.commentsExistBetween(openingBrace, firstValueToken) || sourceCode.commentsExistBetween(lastValueToken, closingBrace);
							if (commentsExist) {
								fixes.push(fixer.remove(openingBrace), fixer.remove(closingBrace), fixer.remove(sourceCode.getTokenAfter(openingBrace)) // return keyword
								);
							} else {
								fixes.push(fixer.removeRange([openingBrace.range[0], firstValueToken.range[0]]), fixer.removeRange([lastValueToken.range[1], closingBrace.range[1]]));
							}
							if (astUtils.isOpeningBraceToken(firstValueToken)) {
								fixes.push(fixer.insertTextBefore(firstValueToken, "("), fixer.insertTextAfter(lastValueToken, ")"));
							}
							if (astUtils.isSemicolonToken(lastValueToken)) {
								fixes.push(fixer.remove(lastValueToken));
							}

							return fixes;
						}
					});
				}
			} else {
				if (always || asNeeded && requireReturnForObjectLiteral && arrowBody.type === "ObjectExpression") {
					context.report({
						node: node,
						loc: arrowBody.loc.start,
						message: "Expected block statement surrounding arrow body.",
						fix: function fix(fixer) {
							var fixes = [];
							var arrowToken = sourceCode.getTokenBefore(arrowBody, astUtils.isArrowToken);
							var firstBodyToken = sourceCode.getTokenAfter(arrowToken);
							var lastBodyToken = sourceCode.getLastToken(node);
							var isParenthesisedObjectLiteral = astUtils.isOpeningParenToken(firstBodyToken) && astUtils.isOpeningBraceToken(sourceCode.getTokenAfter(firstBodyToken));
							fixes.push(fixer.insertTextBefore(firstBodyToken, "{return "), fixer.insertTextAfter(lastBodyToken, "}"));
							if (isParenthesisedObjectLiteral) {
								fixes.push(fixer.remove(firstBodyToken), fixer.remove(findClosingParen(firstBodyToken)));
							}

							return fixes;
						}
					});
				}
			}
		}

		return {
			"ArrowFunctionExpression:exit": validate
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "require parentheses around arrow function arguments",
			category: "ECMAScript 6",
			recommended: false
		},

		fixable: "code",

		schema: [{
			enum: ["always", "as-needed"]
		}, {
			type: "object",
			properties: {
				requireForBlockBody: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var message = "Expected parentheses around arrow function argument.";
		var asNeededMessage = "Unexpected parentheses around single function argument.";
		var asNeeded = context.options[0] === "as-needed";
		var requireForBlockBodyMessage = "Unexpected parentheses around single function argument having a body with no curly braces";
		var requireForBlockBodyNoParensMessage = "Expected parentheses around arrow function argument having a body with curly braces.";
		var requireForBlockBody = asNeeded && context.options[1] && context.options[1].requireForBlockBody === true;

		var sourceCode = context.getSourceCode();
		function parens(node) {
			var isAsync = node.async;
			var firstTokenOfParam = sourceCode.getFirstToken(node, isAsync ? 1 : 0);
			function fixParamsWithParenthesis(fixer) {
				var paramToken = sourceCode.getTokenAfter(firstTokenOfParam);
				var closingParenToken = sourceCode.getTokenAfter(paramToken, astUtils.isClosingParenToken);
				var asyncToken = isAsync ? sourceCode.getTokenBefore(firstTokenOfParam) : null;
				var shouldAddSpaceForAsync = asyncToken && asyncToken.range[1] === firstTokenOfParam.range[0];

				return fixer.replaceTextRange([firstTokenOfParam.range[0], closingParenToken.range[1]], "" + (shouldAddSpaceForAsync ? " " : "") + paramToken.value);
			}
			if (requireForBlockBody && node.params.length === 1 && node.params[0].type === "Identifier" && !node.params[0].typeAnnotation && node.body.type !== "BlockStatement" && !node.returnType) {
				if (astUtils.isOpeningParenToken(firstTokenOfParam)) {
					context.report({
						node: node,
						message: requireForBlockBodyMessage,
						fix: fixParamsWithParenthesis
					});
				}
				return;
			}

			if (requireForBlockBody && node.body.type === "BlockStatement") {
				if (!astUtils.isOpeningParenToken(firstTokenOfParam)) {
					context.report({
						node: node,
						message: requireForBlockBodyNoParensMessage,
						fix: function fix(fixer) {
							return fixer.replaceText(firstTokenOfParam, "(" + firstTokenOfParam.value + ")");
						}
					});
				}
				return;
			}
			if (asNeeded && node.params.length === 1 && node.params[0].type === "Identifier" && !node.params[0].typeAnnotation && !node.returnType) {
				if (astUtils.isOpeningParenToken(firstTokenOfParam)) {
					context.report({
						node: node,
						message: asNeededMessage,
						fix: fixParamsWithParenthesis
					});
				}
				return;
			}

			if (firstTokenOfParam.type === "Identifier") {
				var after = sourceCode.getTokenAfter(firstTokenOfParam);
				if (after.value !== ")") {
					context.report({
						node: node,
						message: message,
						fix: function fix(fixer) {
							return fixer.replaceText(firstTokenOfParam, "(" + firstTokenOfParam.value + ")");
						}
					});
				}
			}
		}

		return {
			ArrowFunctionExpression: parens
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent spacing before and after the arrow in arrow functions",
			category: "ECMAScript 6",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			type: "object",
			properties: {
				before: {
					type: "boolean"
				},
				after: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var rule = { before: true, after: true },
			option = context.options[0] || {};

		rule.before = option.before !== false;
		rule.after = option.after !== false;

		var sourceCode = context.getSourceCode();
		function getTokens(node) {
			var arrow = sourceCode.getTokenBefore(node.body, astUtils.isArrowToken);

			return {
				before: sourceCode.getTokenBefore(arrow),
				arrow: arrow,
				after: sourceCode.getTokenAfter(arrow)
			};
		}
		function countSpaces(tokens) {
			var before = tokens.arrow.range[0] - tokens.before.range[1];
			var after = tokens.after.range[0] - tokens.arrow.range[1];

			return { before: before, after: after };
		}
		function spaces(node) {
			var tokens = getTokens(node);
			var countSpace = countSpaces(tokens);

			if (rule.before) {
				if (countSpace.before === 0) {
					context.report({
						node: tokens.before,
						message: "Missing space before =>.",
						fix: function fix(fixer) {
							return fixer.insertTextBefore(tokens.arrow, " ");
						}
					});
				}
			} else {
				if (countSpace.before > 0) {
					context.report({
						node: tokens.before,
						message: "Unexpected space before =>.",
						fix: function fix(fixer) {
							return fixer.removeRange([tokens.before.range[1], tokens.arrow.range[0]]);
						}
					});
				}
			}

			if (rule.after) {
				if (countSpace.after === 0) {
					context.report({
						node: tokens.after,
						message: "Missing space after =>.",
						fix: function fix(fixer) {
							return fixer.insertTextAfter(tokens.arrow, " ");
						}
					});
				}
			} else {
				if (countSpace.after > 0) {
					context.report({
						node: tokens.after,
						message: "Unexpected space after =>.",
						fix: function fix(fixer) {
							return fixer.removeRange([tokens.arrow.range[1], tokens.after.range[0]]);
						}
					});
				}
			}
		}

		return {
			ArrowFunctionExpression: spaces
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "enforce the use of variables within the scope they are defined",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		var stack = [];
		function enterScope(node) {
			stack.push(node.range);
		}
		function exitScope() {
			stack.pop();
		}
		function report(reference) {
			var identifier = reference.identifier;

			context.report({ node: identifier, message: "'{{name}}' used outside of binding context.", data: { name: identifier.name } });
		}
		function checkForVariables(node) {
			if (node.kind !== "var") {
				return;
			}
			var scopeRange = stack[stack.length - 1];
			function isOutsideOfScope(reference) {
				var idRange = reference.identifier.range;

				return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];
			}
			var variables = context.getDeclaredVariables(node);

			for (var i = 0; i < variables.length; ++i) {
				variables[i].references.filter(isOutsideOfScope).forEach(report);
			}
		}

		return {
			Program: function Program(node) {
				stack = [node.range];
			},
			BlockStatement: enterScope,
			"BlockStatement:exit": exitScope,
			ForStatement: enterScope,
			"ForStatement:exit": exitScope,
			ForInStatement: enterScope,
			"ForInStatement:exit": exitScope,
			ForOfStatement: enterScope,
			"ForOfStatement:exit": exitScope,
			SwitchStatement: enterScope,
			"SwitchStatement:exit": exitScope,
			CatchClause: enterScope,
			"CatchClause:exit": exitScope,
			VariableDeclaration: checkForVariables
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var util = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow or enforce spaces inside of blocks after opening block and before closing block",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{ enum: ["always", "never"] }]
	},

	create: function create(context) {
		var always = context.options[0] !== "never",
			message = always ? "Requires a space" : "Unexpected space(s)",
			sourceCode = context.getSourceCode();
		function getOpenBrace(node) {
			if (node.type === "SwitchStatement") {
				if (node.cases.length > 0) {
					return sourceCode.getTokenBefore(node.cases[0]);
				}
				return sourceCode.getLastToken(node, 1);
			}
			return sourceCode.getFirstToken(node);
		}
		function isValid(left, right) {
			return !util.isTokenOnSameLine(left, right) || sourceCode.isSpaceBetweenTokens(left, right) === always;
		}
		function checkSpacingInsideBraces(node) {
			var openBrace = getOpenBrace(node);
			var closeBrace = sourceCode.getLastToken(node);
			var firstToken = sourceCode.getTokenAfter(openBrace, { includeComments: true });
			var lastToken = sourceCode.getTokenBefore(closeBrace, { includeComments: true });
			if (openBrace.type !== "Punctuator" || openBrace.value !== "{" || closeBrace.type !== "Punctuator" || closeBrace.value !== "}" || firstToken === closeBrace) {
				return;
			}
			if (!always && firstToken.type === "Line") {
				return;
			}
			if (!isValid(openBrace, firstToken)) {
				context.report({
					node: node,
					loc: openBrace.loc.start,
					message: "{{message}} after '{'.",
					data: {
						message: message
					},
					fix: function fix(fixer) {
						if (always) {
							return fixer.insertTextBefore(firstToken, " ");
						}

						return fixer.removeRange([openBrace.range[1], firstToken.range[0]]);
					}
				});
			}
			if (!isValid(lastToken, closeBrace)) {
				context.report({
					node: node,
					loc: closeBrace.loc.start,
					message: "{{message}} before '}'.",
					data: {
						message: message
					},
					fix: function fix(fixer) {
						if (always) {
							return fixer.insertTextAfter(lastToken, " ");
						}

						return fixer.removeRange([lastToken.range[1], closeBrace.range[0]]);
					}
				});
			}
		}

		return {
			BlockStatement: checkSpacingInsideBraces,
			SwitchStatement: checkSpacingInsideBraces
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent brace style for blocks",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			enum: ["1tbs", "stroustrup", "allman"]
		}, {
			type: "object",
			properties: {
				allowSingleLine: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}],

		fixable: "whitespace"
	},

	create: function create(context) {
		var style = context.options[0] || "1tbs",
			params = context.options[1] || {},
			sourceCode = context.getSourceCode();

		var OPEN_MESSAGE = "Opening curly brace does not appear on the same line as controlling statement.",
			OPEN_MESSAGE_ALLMAN = "Opening curly brace appears on the same line as controlling statement.",
			BODY_MESSAGE = "Statement inside of curly braces should be on next line.",
			CLOSE_MESSAGE = "Closing curly brace does not appear on the same line as the subsequent block.",
			CLOSE_MESSAGE_SINGLE = "Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.",
			CLOSE_MESSAGE_STROUSTRUP_ALLMAN = "Closing curly brace appears on the same line as the subsequent block.";
		function removeNewlineBetween(firstToken, secondToken) {
			var textRange = [firstToken.range[1], secondToken.range[0]];
			var textBetween = sourceCode.text.slice(textRange[0], textRange[1]);
			if (textBetween.trim()) {
				return null;
			}
			return function (fixer) {
				return fixer.replaceTextRange(textRange, " ");
			};
		}
		function validateCurlyPair(openingCurly, closingCurly) {
			var tokenBeforeOpeningCurly = sourceCode.getTokenBefore(openingCurly);
			var tokenAfterOpeningCurly = sourceCode.getTokenAfter(openingCurly);
			var tokenBeforeClosingCurly = sourceCode.getTokenBefore(closingCurly);
			var singleLineException = params.allowSingleLine && astUtils.isTokenOnSameLine(openingCurly, closingCurly);

			if (style !== "allman" && !astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly)) {
				context.report({
					node: openingCurly,
					message: OPEN_MESSAGE,
					fix: removeNewlineBetween(tokenBeforeOpeningCurly, openingCurly)
				});
			}

			if (style === "allman" && astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly) && !singleLineException) {
				context.report({
					node: openingCurly,
					message: OPEN_MESSAGE_ALLMAN,
					fix: function fix(fixer) {
						return fixer.insertTextBefore(openingCurly, "\n");
					}
				});
			}

			if (astUtils.isTokenOnSameLine(openingCurly, tokenAfterOpeningCurly) && tokenAfterOpeningCurly !== closingCurly && !singleLineException) {
				context.report({
					node: openingCurly,
					message: BODY_MESSAGE,
					fix: function fix(fixer) {
						return fixer.insertTextAfter(openingCurly, "\n");
					}
				});
			}

			if (tokenBeforeClosingCurly !== openingCurly && !singleLineException && astUtils.isTokenOnSameLine(tokenBeforeClosingCurly, closingCurly)) {
				context.report({
					node: closingCurly,
					message: CLOSE_MESSAGE_SINGLE,
					fix: function fix(fixer) {
						return fixer.insertTextBefore(closingCurly, "\n");
					}
				});
			}
		}
		function validateCurlyBeforeKeyword(curlyToken) {
			var keywordToken = sourceCode.getTokenAfter(curlyToken);

			if (style === "1tbs" && !astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {
				context.report({
					node: curlyToken,
					message: CLOSE_MESSAGE,
					fix: removeNewlineBetween(curlyToken, keywordToken)
				});
			}

			if (style !== "1tbs" && astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {
				context.report({
					node: curlyToken,
					message: CLOSE_MESSAGE_STROUSTRUP_ALLMAN,
					fix: function fix(fixer) {
						return fixer.insertTextAfter(curlyToken, "\n");
					}
				});
			}
		}
		return {
			BlockStatement: function BlockStatement(node) {
				if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {
					validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));
				}
			},
			ClassBody: function ClassBody(node) {
				validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));
			},
			SwitchStatement: function SwitchStatement(node) {
				var closingCurly = sourceCode.getLastToken(node);
				var openingCurly = sourceCode.getTokenBefore(node.cases.length ? node.cases[0] : closingCurly);

				validateCurlyPair(openingCurly, closingCurly);
			},
			IfStatement: function IfStatement(node) {
				if (node.consequent.type === "BlockStatement" && node.alternate) {
					validateCurlyBeforeKeyword(sourceCode.getLastToken(node.consequent));
				}
			},
			TryStatement: function TryStatement(node) {
				validateCurlyBeforeKeyword(sourceCode.getLastToken(node.block));

				if (node.handler && node.finalizer) {
					validateCurlyBeforeKeyword(sourceCode.getLastToken(node.handler.body));
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require `return` statements after callbacks",
			category: "Node.js and CommonJS",
			recommended: false
		},

		schema: [{
			type: "array",
			items: { type: "string" }
		}]
	},

	create: function create(context) {

		var callbacks = context.options[0] || ["callback", "cb", "next"],
			sourceCode = context.getSourceCode();
		function findClosestParentOfType(node, types) {
			if (!node.parent) {
				return null;
			}
			if (types.indexOf(node.parent.type) === -1) {
				return findClosestParentOfType(node.parent, types);
			}
			return node.parent;
		}
		function containsOnlyIdentifiers(node) {
			if (node.type === "Identifier") {
				return true;
			}

			if (node.type === "MemberExpression") {
				if (node.object.type === "Identifier") {
					return true;
				}
				if (node.object.type === "MemberExpression") {
					return containsOnlyIdentifiers(node.object);
				}
			}

			return false;
		}
		function isCallback(node) {
			return containsOnlyIdentifiers(node.callee) && callbacks.indexOf(sourceCode.getText(node.callee)) > -1;
		}
		function isCallbackExpression(node, parentNode) {
			if (!parentNode || parentNode.type !== "ExpressionStatement") {
				return false;
			}
			if (parentNode.expression === node) {
				return true;
			}
			if (parentNode.expression.type === "BinaryExpression" || parentNode.expression.type === "LogicalExpression") {
				if (parentNode.expression.right === node) {
					return true;
				}
			}

			return false;
		}
		return {
			CallExpression: function CallExpression(node) {
				if (!isCallback(node)) {
					return;
				}
				var closestBlock = findClosestParentOfType(node, ["BlockStatement", "ReturnStatement", "ArrowFunctionExpression"]) || {};
				if (closestBlock.type === "ReturnStatement") {
					return;
				}
				if (closestBlock.type === "ArrowFunctionExpression") {
					return;
				}
				if (closestBlock.type === "BlockStatement") {
					var lastItem = closestBlock.body[closestBlock.body.length - 1];
					if (isCallbackExpression(node, lastItem)) {

						var parentType = closestBlock.parent.type;
						if (parentType === "FunctionExpression" || parentType === "FunctionDeclaration" || parentType === "ArrowFunctionExpression") {
							return;
						}
					}
					if (lastItem.type === "ReturnStatement") {
						if (isCallbackExpression(node, closestBlock.body[closestBlock.body.length - 2])) {
							return;
						}
					}
				}
				if (findClosestParentOfType(node, ["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"])) {
					context.report({ node: node, message: "Expected return with your callback function." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "enforce camelcase naming convention",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				properties: {
					enum: ["always", "never"]
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var reported = [];
		var ALLOWED_PARENT_TYPES = new Set(["CallExpression", "NewExpression"]);
		function isUnderscored(name) {
			return name.indexOf("_") > -1 && name !== name.toUpperCase();
		}
		function report(node) {
			if (reported.indexOf(node) < 0) {
				reported.push(node);
				context.report({ node: node, message: "Identifier '{{name}}' is not in camel case.", data: { name: node.name } });
			}
		}

		var options = context.options[0] || {};
		var properties = options.properties || "";

		if (properties !== "always" && properties !== "never") {
			properties = "always";
		}

		return {
			Identifier: function Identifier(node) {
				var name = node.name.replace(/^_+|_+$/g, ""),
					effectiveParent = node.parent.type === "MemberExpression" ? node.parent.parent : node.parent;
				if (node.parent.type === "MemberExpression") {
					if (properties === "never") {
						return;
					}
					if (node.parent.object.type === "Identifier" && node.parent.object.name === node.name && isUnderscored(name)) {
						report(node);
					} else if (effectiveParent.type === "AssignmentExpression" && isUnderscored(name) && (effectiveParent.right.type !== "MemberExpression" || effectiveParent.left.type === "MemberExpression" && effectiveParent.left.property.name === node.name)) {
						report(node);
					}
				} else if (node.parent.type === "Property" || node.parent.type === "AssignmentPattern") {

					if (node.parent.parent && node.parent.parent.type === "ObjectPattern") {

						if (node.parent.shorthand && node.parent.value.left && isUnderscored(name)) {

							report(node);
						}
						if (node.parent.key === node && node.parent.value !== node) {
							return;
						}

						if (node.parent.value.name && isUnderscored(name)) {
							report(node);
						}
					}
					if (properties === "never") {
						return;
					}
					if (isUnderscored(name) && !ALLOWED_PARENT_TYPES.has(effectiveParent.type) && !(node.parent.right === node)) {
						report(node);
					}
				} else if (["ImportSpecifier", "ImportNamespaceSpecifier", "ImportDefaultSpecifier"].indexOf(node.parent.type) >= 0) {
					if (node.parent.local && node.parent.local.name === node.name && isUnderscored(name)) {
						report(node);
					}
				} else if (isUnderscored(name) && !ALLOWED_PARENT_TYPES.has(effectiveParent.type)) {
					report(node);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var LETTER_PATTERN = __webpack_require__(406);
var astUtils = __webpack_require__(0);
var ALWAYS_MESSAGE = "Comments should not begin with a lowercase character",
	NEVER_MESSAGE = "Comments should not begin with an uppercase character",
	DEFAULT_IGNORE_PATTERN = astUtils.COMMENTS_IGNORE_PATTERN,
	WHITESPACE = /\s/g,
	MAYBE_URL = /^\s*[^:/?#\s]+:\/\/[^?#]/,
DEFAULTS = {
	ignorePattern: null,
	ignoreInlineComments: false,
	ignoreConsecutiveComments: false
};
var SCHEMA_BODY = {
	type: "object",
	properties: {
		ignorePattern: {
			type: "string"
		},
		ignoreInlineComments: {
			type: "boolean"
		},
		ignoreConsecutiveComments: {
			type: "boolean"
		}
	},
	additionalProperties: false
};
function getNormalizedOptions(rawOptions, which) {
	if (!rawOptions) {
		return Object.assign({}, DEFAULTS);
	}

	return Object.assign({}, DEFAULTS, rawOptions[which] || rawOptions);
}
function getAllNormalizedOptions(rawOptions) {
	return {
		Line: getNormalizedOptions(rawOptions, "line"),
		Block: getNormalizedOptions(rawOptions, "block")
	};
}
function createRegExpForIgnorePatterns(normalizedOptions) {
	Object.keys(normalizedOptions).forEach(function (key) {
		var ignorePatternStr = normalizedOptions[key].ignorePattern;

		if (ignorePatternStr) {
			var regExp = RegExp("^\\s*(?:" + ignorePatternStr + ")");

			normalizedOptions[key].ignorePatternRegExp = regExp;
		}
	});
}
module.exports = {
	meta: {
		docs: {
			description: "enforce or disallow capitalization of the first letter of a comment",
			category: "Stylistic Issues",
			recommended: false
		},
		fixable: "code",
		schema: [{ enum: ["always", "never"] }, {
			oneOf: [SCHEMA_BODY, {
				type: "object",
				properties: {
					line: SCHEMA_BODY,
					block: SCHEMA_BODY
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {

		var capitalize = context.options[0] || "always",
			normalizedOptions = getAllNormalizedOptions(context.options[1]),
			sourceCode = context.getSourceCode();

		createRegExpForIgnorePatterns(normalizedOptions);
		function isInlineComment(comment) {
			var previousToken = sourceCode.getTokenBefore(comment, { includeComments: true }),
				nextToken = sourceCode.getTokenAfter(comment, { includeComments: true });

			return Boolean(previousToken && nextToken && comment.loc.start.line === previousToken.loc.end.line && comment.loc.end.line === nextToken.loc.start.line);
		}
		function isConsecutiveComment(comment) {
			var previousTokenOrComment = sourceCode.getTokenBefore(comment, { includeComments: true });

			return Boolean(previousTokenOrComment && ["Block", "Line"].indexOf(previousTokenOrComment.type) !== -1);
		}
		function isCommentValid(comment, options) {
			if (DEFAULT_IGNORE_PATTERN.test(comment.value)) {
				return true;
			}
			var commentWithoutAsterisks = comment.value.replace(/\*/g, "");

			if (options.ignorePatternRegExp && options.ignorePatternRegExp.test(commentWithoutAsterisks)) {
				return true;
			}
			if (options.ignoreInlineComments && isInlineComment(comment)) {
				return true;
			}
			if (options.ignoreConsecutiveComments && isConsecutiveComment(comment)) {
				return true;
			}
			if (MAYBE_URL.test(commentWithoutAsterisks)) {
				return true;
			}
			var commentWordCharsOnly = commentWithoutAsterisks.replace(WHITESPACE, "");

			if (commentWordCharsOnly.length === 0) {
				return true;
			}

			var firstWordChar = commentWordCharsOnly[0];

			if (!LETTER_PATTERN.test(firstWordChar)) {
				return true;
			}
			var isUppercase = firstWordChar !== firstWordChar.toLocaleLowerCase(),
				isLowercase = firstWordChar !== firstWordChar.toLocaleUpperCase();

			if (capitalize === "always" && isLowercase) {
				return false;
			}
			if (capitalize === "never" && isUppercase) {
				return false;
			}

			return true;
		}
		function processComment(comment) {
			var options = normalizedOptions[comment.type],
				commentValid = isCommentValid(comment, options);

			if (!commentValid) {
				var message = capitalize === "always" ? ALWAYS_MESSAGE : NEVER_MESSAGE;

				context.report({
					node: null, // Intentionally using loc instead
					loc: comment.loc,
					message: message,
					fix: function fix(fixer) {
						var match = comment.value.match(LETTER_PATTERN);

						return fixer.replaceTextRange(
						[comment.range[0] + match.index + 2, comment.range[0] + match.index + 3], capitalize === "always" ? match[0].toLocaleUpperCase() : match[0].toLocaleLowerCase());
					}
				});
			}
		}
		return {
			Program: function Program() {
				var comments = sourceCode.getAllComments();

				comments.filter(function (token) {
					return token.type !== "Shebang";
				}).forEach(processComment);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



module.exports = /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "enforce that class methods utilize `this`",
			category: "Best Practices",
			recommended: false
		},
		schema: [{
			type: "object",
			properties: {
				exceptMethods: {
					type: "array",
					items: {
						type: "string"
					}
				}
			},
			additionalProperties: false
		}]
	},
	create: function create(context) {
		var config = context.options[0] ? Object.assign({}, context.options[0]) : {};
		var exceptMethods = new Set(config.exceptMethods || []);

		var stack = [];
		function enterFunction() {
			stack.push(false);
		}
		function isInstanceMethod(node) {
			return !node.static && node.kind !== "constructor" && node.type === "MethodDefinition";
		}
		function isIncludedInstanceMethod(node) {
			return isInstanceMethod(node) && !exceptMethods.has(node.key.name);
		}
		function exitFunction(node) {
			var methodUsesThis = stack.pop();

			if (isIncludedInstanceMethod(node.parent) && !methodUsesThis) {
				context.report({
					node: node,
					message: "Expected 'this' to be used by class method '{{classMethod}}'.",
					data: {
						classMethod: node.parent.key.name
					}
				});
			}
		}
		function markThisUsed() {
			if (stack.length) {
				stack[stack.length - 1] = true;
			}
		}

		return {
			FunctionDeclaration: enterFunction,
			"FunctionDeclaration:exit": exitFunction,
			FunctionExpression: enterFunction,
			"FunctionExpression:exit": exitFunction,
			ThisExpression: markThisUsed,
			Super: markThisUsed
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var lodash = __webpack_require__(10);
var astUtils = __webpack_require__(0);
var DEFAULT_OPTIONS = Object.freeze({
	arrays: "never",
	objects: "never",
	imports: "never",
	exports: "never",
	functions: "ignore"
});
function isTrailingCommaAllowed(lastItem) {
	return !(lastItem.type === "RestElement" || lastItem.type === "RestProperty" || lastItem.type === "ExperimentalRestProperty");
}
function normalizeOptions(optionValue) {
	if (typeof optionValue === "string") {
		return {
			arrays: optionValue,
			objects: optionValue,
			imports: optionValue,
			exports: optionValue,
			functions: "ignore"
		};
	}
	if ((typeof optionValue === "undefined" ? "undefined" : _typeof(optionValue)) === "object" && optionValue !== null) {
		return {
			arrays: optionValue.arrays || DEFAULT_OPTIONS.arrays,
			objects: optionValue.objects || DEFAULT_OPTIONS.objects,
			imports: optionValue.imports || DEFAULT_OPTIONS.imports,
			exports: optionValue.exports || DEFAULT_OPTIONS.exports,
			functions: optionValue.functions || DEFAULT_OPTIONS.functions
		};
	}

	return DEFAULT_OPTIONS;
}
module.exports = {
	meta: {
		docs: {
			description: "require or disallow trailing commas",
			category: "Stylistic Issues",
			recommended: false
		},
		fixable: "code",
		schema: {
			definitions: {
				value: {
					enum: ["always-multiline", "always", "never", "only-multiline"]
				},
				valueWithIgnore: {
					enum: ["always-multiline", "always", "ignore", "never", "only-multiline"]
				}
			},
			type: "array",
			items: [{
				oneOf: [{
					$ref: "#/definitions/value"
				}, {
					type: "object",
					properties: {
						arrays: { $ref: "#/definitions/valueWithIgnore" },
						objects: { $ref: "#/definitions/valueWithIgnore" },
						imports: { $ref: "#/definitions/valueWithIgnore" },
						exports: { $ref: "#/definitions/valueWithIgnore" },
						functions: { $ref: "#/definitions/valueWithIgnore" }
					},
					additionalProperties: false
				}]
			}]
		}
	},

	create: function create(context) {
		var options = normalizeOptions(context.options[0]);
		var sourceCode = context.getSourceCode();
		var UNEXPECTED_MESSAGE = "Unexpected trailing comma.";
		var MISSING_MESSAGE = "Missing trailing comma.";
		function getLastItem(node) {
			switch (node.type) {
				case "ObjectExpression":
				case "ObjectPattern":
					return lodash.last(node.properties);
				case "ArrayExpression":
				case "ArrayPattern":
					return lodash.last(node.elements);
				case "ImportDeclaration":
				case "ExportNamedDeclaration":
					return lodash.last(node.specifiers);
				case "FunctionDeclaration":
				case "FunctionExpression":
				case "ArrowFunctionExpression":
					return lodash.last(node.params);
				case "CallExpression":
				case "NewExpression":
					return lodash.last(node.arguments);
				default:
					return null;
			}
		}
		function getTrailingToken(node, lastItem) {
			switch (node.type) {
				case "ObjectExpression":
				case "ArrayExpression":
				case "CallExpression":
				case "NewExpression":
					return sourceCode.getLastToken(node, 1);
				default:
					{
						var nextToken = sourceCode.getTokenAfter(lastItem);

						if (astUtils.isCommaToken(nextToken)) {
							return nextToken;
						}
						return sourceCode.getLastToken(lastItem);
					}
			}
		}
		function isMultiline(node) {
			var lastItem = getLastItem(node);

			if (!lastItem) {
				return false;
			}

			var penultimateToken = getTrailingToken(node, lastItem);
			var lastToken = sourceCode.getTokenAfter(penultimateToken);

			return lastToken.loc.end.line !== penultimateToken.loc.end.line;
		}
		function forbidTrailingComma(node) {
			var lastItem = getLastItem(node);

			if (!lastItem || node.type === "ImportDeclaration" && lastItem.type !== "ImportSpecifier") {
				return;
			}

			var trailingToken = getTrailingToken(node, lastItem);

			if (astUtils.isCommaToken(trailingToken)) {
				context.report({
					node: lastItem,
					loc: trailingToken.loc.start,
					message: UNEXPECTED_MESSAGE,
					fix: function fix(fixer) {
						return fixer.remove(trailingToken);
					}
				});
			}
		}
		function forceTrailingComma(node) {
			var lastItem = getLastItem(node);

			if (!lastItem || node.type === "ImportDeclaration" && lastItem.type !== "ImportSpecifier") {
				return;
			}
			if (!isTrailingCommaAllowed(lastItem)) {
				forbidTrailingComma(node);
				return;
			}

			var trailingToken = getTrailingToken(node, lastItem);

			if (trailingToken.value !== ",") {
				context.report({
					node: lastItem,
					loc: trailingToken.loc.end,
					message: MISSING_MESSAGE,
					fix: function fix(fixer) {
						return fixer.insertTextAfter(trailingToken, ",");
					}
				});
			}
		}
		function forceTrailingCommaIfMultiline(node) {
			if (isMultiline(node)) {
				forceTrailingComma(node);
			} else {
				forbidTrailingComma(node);
			}
		}
		function allowTrailingCommaIfMultiline(node) {
			if (!isMultiline(node)) {
				forbidTrailingComma(node);
			}
		}

		var predicate = {
			always: forceTrailingComma,
			"always-multiline": forceTrailingCommaIfMultiline,
			"only-multiline": allowTrailingCommaIfMultiline,
			never: forbidTrailingComma,
			ignore: lodash.noop
		};

		return {
			ObjectExpression: predicate[options.objects],
			ObjectPattern: predicate[options.objects],

			ArrayExpression: predicate[options.arrays],
			ArrayPattern: predicate[options.arrays],

			ImportDeclaration: predicate[options.imports],

			ExportNamedDeclaration: predicate[options.exports],

			FunctionDeclaration: predicate[options.functions],
			FunctionExpression: predicate[options.functions],
			ArrowFunctionExpression: predicate[options.functions],
			CallExpression: predicate[options.functions],
			NewExpression: predicate[options.functions]
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent spacing before and after commas",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			type: "object",
			properties: {
				before: {
					type: "boolean"
				},
				after: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var sourceCode = context.getSourceCode();
		var tokensAndComments = sourceCode.tokensAndComments;

		var options = {
			before: context.options[0] ? !!context.options[0].before : false,
			after: context.options[0] ? !!context.options[0].after : true
		};
		var commaTokensToIgnore = [];
		function report(node, dir, otherNode) {
			context.report({
				node: node,
				fix: function fix(fixer) {
					if (options[dir]) {
						if (dir === "before") {
							return fixer.insertTextBefore(node, " ");
						}
						return fixer.insertTextAfter(node, " ");
					}
					var start = void 0,
						end = void 0;
					var newText = "";

					if (dir === "before") {
						start = otherNode.range[1];
						end = node.range[0];
					} else {
						start = node.range[1];
						end = otherNode.range[0];
					}

					return fixer.replaceTextRange([start, end], newText);
				},

				message: options[dir] ? "A space is required {{dir}} ','." : "There should be no space {{dir}} ','.",
				data: {
					dir: dir
				}
			});
		}
		function validateCommaItemSpacing(tokens, reportItem) {
			if (tokens.left && astUtils.isTokenOnSameLine(tokens.left, tokens.comma) && options.before !== sourceCode.isSpaceBetweenTokens(tokens.left, tokens.comma)) {
				report(reportItem, "before", tokens.left);
			}

			if (tokens.right && !options.after && tokens.right.type === "Line") {
				return;
			}

			if (tokens.right && astUtils.isTokenOnSameLine(tokens.comma, tokens.right) && options.after !== sourceCode.isSpaceBetweenTokens(tokens.comma, tokens.right)) {
				report(reportItem, "after", tokens.right);
			}
		}
		function addNullElementsToIgnoreList(node) {
			var previousToken = sourceCode.getFirstToken(node);

			node.elements.forEach(function (element) {
				var token = void 0;

				if (element === null) {
					token = sourceCode.getTokenAfter(previousToken);

					if (astUtils.isCommaToken(token)) {
						commaTokensToIgnore.push(token);
					}
				} else {
					token = sourceCode.getTokenAfter(element);
				}

				previousToken = token;
			});
		}
		return {
			"Program:exit": function ProgramExit() {
				tokensAndComments.forEach(function (token, i) {

					if (!astUtils.isCommaToken(token)) {
						return;
					}

					if (token && token.type === "JSXText") {
						return;
					}

					var previousToken = tokensAndComments[i - 1];
					var nextToken = tokensAndComments[i + 1];

					validateCommaItemSpacing({
						comma: token,
						left: astUtils.isCommaToken(previousToken) || commaTokensToIgnore.indexOf(token) > -1 ? null : previousToken,
						right: astUtils.isCommaToken(nextToken) ? null : nextToken
					}, token);
				});
			},

			ArrayExpression: addNullElementsToIgnoreList,
			ArrayPattern: addNullElementsToIgnoreList

		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent comma style",
			category: "Stylistic Issues",
			recommended: false
		},
		fixable: "code",
		schema: [{
			enum: ["first", "last"]
		}, {
			type: "object",
			properties: {
				exceptions: {
					type: "object",
					additionalProperties: {
						type: "boolean"
					}
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var style = context.options[0] || "last",
			sourceCode = context.getSourceCode();
		var exceptions = {
			ArrayPattern: true,
			ArrowFunctionExpression: true,
			CallExpression: true,
			FunctionDeclaration: true,
			FunctionExpression: true,
			ImportDeclaration: true,
			ObjectPattern: true
		};

		if (context.options.length === 2 && context.options[1].hasOwnProperty("exceptions")) {
			var keys = Object.keys(context.options[1].exceptions);

			for (var i = 0; i < keys.length; i++) {
				exceptions[keys[i]] = context.options[1].exceptions[keys[i]];
			}
		}
		function getReplacedText(styleType, text) {
			switch (styleType) {
				case "between":
					return "," + text.replace("\n", "");

				case "first":
					return text + ",";

				case "last":
					return "," + text;

				default:
					return "";
			}
		}
		function getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken) {
			var text = sourceCode.text.slice(previousItemToken.range[1], commaToken.range[0]) + sourceCode.text.slice(commaToken.range[1], currentItemToken.range[0]);
			var range = [previousItemToken.range[1], currentItemToken.range[0]];

			return function (fixer) {
				return fixer.replaceTextRange(range, getReplacedText(styleType, text));
			};
		}
		function validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem) {
			if (astUtils.isTokenOnSameLine(commaToken, currentItemToken) && astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {
			} else if (!astUtils.isTokenOnSameLine(commaToken, currentItemToken) && !astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {
				context.report({
					node: reportItem,
					loc: {
						line: commaToken.loc.end.line,
						column: commaToken.loc.start.column
					},
					message: "Bad line breaking before and after ','.",
					fix: getFixerFunction("between", previousItemToken, commaToken, currentItemToken)
				});
			} else if (style === "first" && !astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {

				context.report({
					node: reportItem,
					message: "',' should be placed first.",
					fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)
				});
			} else if (style === "last" && astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {

				context.report({
					node: reportItem,
					loc: {
						line: commaToken.loc.end.line,
						column: commaToken.loc.end.column
					},
					message: "',' should be placed last.",
					fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)
				});
			}
		}
		function validateComma(node, property) {
			var items = node[property],
				arrayLiteral = node.type === "ArrayExpression" || node.type === "ArrayPattern";

			if (items.length > 1 || arrayLiteral) {
				var previousItemToken = sourceCode.getFirstToken(node);

				items.forEach(function (item) {
					var commaToken = item ? sourceCode.getTokenBefore(item) : previousItemToken,
						currentItemToken = item ? sourceCode.getFirstToken(item) : sourceCode.getTokenAfter(commaToken),
						reportItem = item || currentItemToken,
						tokenBeforeComma = sourceCode.getTokenBefore(commaToken);
					if (tokenBeforeComma && astUtils.isClosingParenToken(tokenBeforeComma)) {
						previousItemToken = tokenBeforeComma;
					}
					if (astUtils.isCommaToken(commaToken)) {
						validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem);
					}

					if (item) {
						var tokenAfterItem = sourceCode.getTokenAfter(item, astUtils.isNotClosingParenToken);

						previousItemToken = tokenAfterItem ? sourceCode.getTokenBefore(tokenAfterItem) : sourceCode.ast.tokens[sourceCode.ast.tokens.length - 1];
					}
				});
				if (arrayLiteral) {

					var lastToken = sourceCode.getLastToken(node),
						nextToLastToken = sourceCode.getTokenBefore(lastToken);

					if (astUtils.isCommaToken(nextToLastToken)) {
						validateCommaItemSpacing(sourceCode.getTokenBefore(nextToLastToken), nextToLastToken, lastToken, lastToken);
					}
				}
			}
		}
		var nodes = {};

		if (!exceptions.VariableDeclaration) {
			nodes.VariableDeclaration = function (node) {
				validateComma(node, "declarations");
			};
		}
		if (!exceptions.ObjectExpression) {
			nodes.ObjectExpression = function (node) {
				validateComma(node, "properties");
			};
		}
		if (!exceptions.ObjectPattern) {
			nodes.ObjectPattern = function (node) {
				validateComma(node, "properties");
			};
		}
		if (!exceptions.ArrayExpression) {
			nodes.ArrayExpression = function (node) {
				validateComma(node, "elements");
			};
		}
		if (!exceptions.ArrayPattern) {
			nodes.ArrayPattern = function (node) {
				validateComma(node, "elements");
			};
		}
		if (!exceptions.FunctionDeclaration) {
			nodes.FunctionDeclaration = function (node) {
				validateComma(node, "params");
			};
		}
		if (!exceptions.FunctionExpression) {
			nodes.FunctionExpression = function (node) {
				validateComma(node, "params");
			};
		}
		if (!exceptions.ArrowFunctionExpression) {
			nodes.ArrowFunctionExpression = function (node) {
				validateComma(node, "params");
			};
		}
		if (!exceptions.CallExpression) {
			nodes.CallExpression = function (node) {
				validateComma(node, "arguments");
			};
		}
		if (!exceptions.ImportDeclaration) {
			nodes.ImportDeclaration = function (node) {
				validateComma(node, "specifiers");
			};
		}

		return nodes;
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var lodash = __webpack_require__(10);

var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce a maximum cyclomatic complexity allowed in a program",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			oneOf: [{
				type: "integer",
				minimum: 0
			}, {
				type: "object",
				properties: {
					maximum: {
						type: "integer",
						minimum: 0
					},
					max: {
						type: "integer",
						minimum: 0
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {
		var option = context.options[0];
		var THRESHOLD = 20;

		if ((typeof option === "undefined" ? "undefined" : _typeof(option)) === "object" && option.hasOwnProperty("maximum") && typeof option.maximum === "number") {
			THRESHOLD = option.maximum;
		}
		if ((typeof option === "undefined" ? "undefined" : _typeof(option)) === "object" && option.hasOwnProperty("max") && typeof option.max === "number") {
			THRESHOLD = option.max;
		}
		if (typeof option === "number") {
			THRESHOLD = option;
		}
		var fns = [];
		function startFunction() {
			fns.push(1);
		}
		function endFunction(node) {
			var name = lodash.upperFirst(astUtils.getFunctionNameWithKind(node));
			var complexity = fns.pop();

			if (complexity > THRESHOLD) {
				context.report({
					node: node,
					message: "{{name}} has a complexity of {{complexity}}.",
					data: { name: name, complexity: complexity }
				});
			}
		}
		function increaseComplexity() {
			if (fns.length) {
				fns[fns.length - 1]++;
			}
		}
		function increaseSwitchComplexity(node) {
			if (node.test) {
				increaseComplexity();
			}
		}
		function increaseLogicalComplexity(node) {
			if (node.operator === "||") {
				increaseComplexity();
			}
		}
		return {
			FunctionDeclaration: startFunction,
			FunctionExpression: startFunction,
			ArrowFunctionExpression: startFunction,
			"FunctionDeclaration:exit": endFunction,
			"FunctionExpression:exit": endFunction,
			"ArrowFunctionExpression:exit": endFunction,

			CatchClause: increaseComplexity,
			ConditionalExpression: increaseComplexity,
			LogicalExpression: increaseLogicalComplexity,
			ForStatement: increaseComplexity,
			ForInStatement: increaseComplexity,
			ForOfStatement: increaseComplexity,
			IfStatement: increaseComplexity,
			SwitchCase: increaseSwitchComplexity,
			WhileStatement: increaseComplexity,
			DoWhileStatement: increaseComplexity
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent spacing inside computed property brackets",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			enum: ["always", "never"]
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var propertyNameMustBeSpaced = context.options[0] === "always"; // default is "never"
		function reportNoBeginningSpace(node, token, tokenAfter) {
			context.report({
				node: node,
				loc: token.loc.start,
				message: "There should be no space after '{{tokenValue}}'.",
				data: {
					tokenValue: token.value
				},
				fix: function fix(fixer) {
					return fixer.removeRange([token.range[1], tokenAfter.range[0]]);
				}
			});
		}
		function reportNoEndingSpace(node, token, tokenBefore) {
			context.report({
				node: node,
				loc: token.loc.start,
				message: "There should be no space before '{{tokenValue}}'.",
				data: {
					tokenValue: token.value
				},
				fix: function fix(fixer) {
					return fixer.removeRange([tokenBefore.range[1], token.range[0]]);
				}
			});
		}
		function reportRequiredBeginningSpace(node, token) {
			context.report({
				node: node,
				loc: token.loc.start,
				message: "A space is required after '{{tokenValue}}'.",
				data: {
					tokenValue: token.value
				},
				fix: function fix(fixer) {
					return fixer.insertTextAfter(token, " ");
				}
			});
		}
		function reportRequiredEndingSpace(node, token) {
			context.report({
				node: node,
				loc: token.loc.start,
				message: "A space is required before '{{tokenValue}}'.",
				data: {
					tokenValue: token.value
				},
				fix: function fix(fixer) {
					return fixer.insertTextBefore(token, " ");
				}
			});
		}
		function checkSpacing(propertyName) {
			return function (node) {
				if (!node.computed) {
					return;
				}

				var property = node[propertyName];

				var before = sourceCode.getTokenBefore(property),
					first = sourceCode.getFirstToken(property),
					last = sourceCode.getLastToken(property),
					after = sourceCode.getTokenAfter(property);

				if (astUtils.isTokenOnSameLine(before, first)) {
					if (propertyNameMustBeSpaced) {
						if (!sourceCode.isSpaceBetweenTokens(before, first) && astUtils.isTokenOnSameLine(before, first)) {
							reportRequiredBeginningSpace(node, before);
						}
					} else {
						if (sourceCode.isSpaceBetweenTokens(before, first)) {
							reportNoBeginningSpace(node, before, first);
						}
					}
				}

				if (astUtils.isTokenOnSameLine(last, after)) {
					if (propertyNameMustBeSpaced) {
						if (!sourceCode.isSpaceBetweenTokens(last, after) && astUtils.isTokenOnSameLine(last, after)) {
							reportRequiredEndingSpace(node, after);
						}
					} else {
						if (sourceCode.isSpaceBetweenTokens(last, after)) {
							reportNoEndingSpace(node, after, last);
						}
					}
				}
			};
		}
		return {
			Property: checkSpacing("key"),
			MemberExpression: checkSpacing("property")
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var lodash = __webpack_require__(10);

var astUtils = __webpack_require__(0);
function isIdentifier(node, name) {
	return node.type === "Identifier" && node.name === name;
}
function isUnreachable(segment) {
	return !segment.reachable;
}
function isClassConstructor(node) {
	return node.type === "FunctionExpression" && node.parent && node.parent.type === "MethodDefinition" && node.parent.kind === "constructor";
}
module.exports = {
	meta: {
		docs: {
			description: "require `return` statements to either always or never specify values",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				treatUndefinedAsUnspecified: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = context.options[0] || {};
		var treatUndefinedAsUnspecified = options.treatUndefinedAsUnspecified === true;
		var funcInfo = null;
		function checkLastSegment(node) {
			var loc = void 0,
				name = void 0;
			if (!funcInfo.hasReturnValue || funcInfo.codePath.currentSegments.every(isUnreachable) || astUtils.isES5Constructor(node) || isClassConstructor(node)) {
				return;
			}
			if (node.type === "Program") {
				loc = { line: 1, column: 0 };
				name = "program";
			} else if (node.type === "ArrowFunctionExpression") {
				loc = context.getSourceCode().getTokenBefore(node.body, astUtils.isArrowToken).loc.start;
			} else if (node.parent.type === "MethodDefinition" || node.parent.type === "Property" && node.parent.method) {
				loc = node.parent.key.loc.start;
			} else {
				loc = (node.id || node).loc.start;
			}

			if (!name) {
				name = astUtils.getFunctionNameWithKind(node);
			}
			context.report({
				node: node,
				loc: loc,
				message: "Expected to return a value at the end of {{name}}.",
				data: { name: name }
			});
		}

		return {
			onCodePathStart: function onCodePathStart(codePath, node) {
				funcInfo = {
					upper: funcInfo,
					codePath: codePath,
					hasReturn: false,
					hasReturnValue: false,
					message: "",
					node: node
				};
			},
			onCodePathEnd: function onCodePathEnd() {
				funcInfo = funcInfo.upper;
			},
			ReturnStatement: function ReturnStatement(node) {
				var argument = node.argument;
				var hasReturnValue = Boolean(argument);

				if (treatUndefinedAsUnspecified && hasReturnValue) {
					hasReturnValue = !isIdentifier(argument, "undefined") && argument.operator !== "void";
				}

				if (!funcInfo.hasReturn) {
					funcInfo.hasReturn = true;
					funcInfo.hasReturnValue = hasReturnValue;
					funcInfo.message = "{{name}} expected {{which}} return value.";
					funcInfo.data = {
						name: funcInfo.node.type === "Program" ? "Program" : lodash.upperFirst(astUtils.getFunctionNameWithKind(funcInfo.node)),
						which: hasReturnValue ? "a" : "no"
					};
				} else if (funcInfo.hasReturnValue !== hasReturnValue) {
					context.report({
						node: node,
						message: funcInfo.message,
						data: funcInfo.data
					});
				}
			},
			"Program:exit": checkLastSegment,
			"FunctionDeclaration:exit": checkLastSegment,
			"FunctionExpression:exit": checkLastSegment,
			"ArrowFunctionExpression:exit": checkLastSegment
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent naming when capturing the current execution context",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: {
			type: "array",
			items: {
				type: "string",
				minLength: 1
			},
			uniqueItems: true
		}
	},

	create: function create(context) {
		var aliases = [];

		if (context.options.length === 0) {
			aliases.push("that");
		} else {
			aliases = context.options;
		}
		function reportBadAssignment(node, alias) {
			context.report({ node: node, message: "Designated alias '{{alias}}' is not assigned to 'this'.", data: { alias: alias } });
		}
		function checkAssignment(node, name, value) {
			var isThis = value.type === "ThisExpression";

			if (aliases.indexOf(name) !== -1) {
				if (!isThis || node.operator && node.operator !== "=") {
					reportBadAssignment(node, name);
				}
			} else if (isThis) {
				context.report({ node: node, message: "Unexpected alias '{{name}}' for 'this'.", data: { name: name } });
			}
		}
		function checkWasAssigned(alias, scope) {
			var variable = scope.set.get(alias);

			if (!variable) {
				return;
			}

			if (variable.defs.some(function (def) {
				return def.node.type === "VariableDeclarator" && def.node.init !== null;
			})) {
				return;
			}
			if (!variable.references.some(function (reference) {
				var write = reference.writeExpr;

				return reference.from === scope && write && write.type === "ThisExpression" && write.parent.operator === "=";
			})) {
				variable.defs.map(function (def) {
					return def.node;
				}).forEach(function (node) {
					reportBadAssignment(node, alias);
				});
			}
		}
		function ensureWasAssigned() {
			var scope = context.getScope();

			aliases.forEach(function (alias) {
				checkWasAssigned(alias, scope);
			});
		}

		return {
			"Program:exit": ensureWasAssigned,
			"FunctionExpression:exit": ensureWasAssigned,
			"FunctionDeclaration:exit": ensureWasAssigned,

			VariableDeclarator: function VariableDeclarator(node) {
				var id = node.id;
				var isDestructuring = id.type === "ArrayPattern" || id.type === "ObjectPattern";

				if (node.init !== null && !isDestructuring) {
					checkAssignment(node, id.name, node.init);
				}
			},
			AssignmentExpression: function AssignmentExpression(node) {
				if (node.left.type === "Identifier") {
					checkAssignment(node, node.left.name, node.right);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function isReachable(segment) {
	return segment.reachable;
}
function isConstructorFunction(node) {
	return node.type === "FunctionExpression" && node.parent.type === "MethodDefinition" && node.parent.kind === "constructor";
}
function isPossibleConstructor(node) {
	if (!node) {
		return false;
	}

	switch (node.type) {
		case "ClassExpression":
		case "FunctionExpression":
		case "ThisExpression":
		case "MemberExpression":
		case "CallExpression":
		case "NewExpression":
		case "YieldExpression":
		case "TaggedTemplateExpression":
		case "MetaProperty":
			return true;

		case "Identifier":
			return node.name !== "undefined";

		case "AssignmentExpression":
			return isPossibleConstructor(node.right);

		case "LogicalExpression":
			return isPossibleConstructor(node.left) || isPossibleConstructor(node.right);

		case "ConditionalExpression":
			return isPossibleConstructor(node.alternate) || isPossibleConstructor(node.consequent);

		case "SequenceExpression":
			{
				var lastExpression = node.expressions[node.expressions.length - 1];

				return isPossibleConstructor(lastExpression);
			}

		default:
			return false;
	}
}
module.exports = {
	meta: {
		docs: {
			description: "require `super()` calls in constructors",
			category: "ECMAScript 6",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		var funcInfo = null;
		var segInfoMap = Object.create(null);
		function isCalledInSomePath(segment) {
			return segment.reachable && segInfoMap[segment.id].calledInSomePaths;
		}
		function isCalledInEveryPath(segment) {
			if (segment.nextSegments.length === 1 && segment.nextSegments[0].isLoopedPrevSegment(segment)) {
				return true;
			}
			return segment.reachable && segInfoMap[segment.id].calledInEveryPaths;
		}

		return {
			onCodePathStart: function onCodePathStart(codePath, node) {
				if (isConstructorFunction(node)) {
					var classNode = node.parent.parent.parent;
					var superClass = classNode.superClass;

					funcInfo = {
						upper: funcInfo,
						isConstructor: true,
						hasExtends: Boolean(superClass),
						superIsConstructor: isPossibleConstructor(superClass),
						codePath: codePath
					};
				} else {
					funcInfo = {
						upper: funcInfo,
						isConstructor: false,
						hasExtends: false,
						superIsConstructor: false,
						codePath: codePath
					};
				}
			},
			onCodePathEnd: function onCodePathEnd(codePath, node) {
				var hasExtends = funcInfo.hasExtends;
				funcInfo = funcInfo.upper;

				if (!hasExtends) {
					return;
				}
				var segments = codePath.returnedSegments;
				var calledInEveryPaths = segments.every(isCalledInEveryPath);
				var calledInSomePaths = segments.some(isCalledInSomePath);

				if (!calledInEveryPaths) {
					context.report({
						message: calledInSomePaths ? "Lacked a call of 'super()' in some code paths." : "Expected to call 'super()'.",
						node: node.parent
					});
				}
			},
			onCodePathSegmentStart: function onCodePathSegmentStart(segment) {
				if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {
					return;
				}
				var info = segInfoMap[segment.id] = {
					calledInSomePaths: false,
					calledInEveryPaths: false,
					validNodes: []
				};
				var prevSegments = segment.prevSegments;

				if (prevSegments.length > 0) {
					info.calledInSomePaths = prevSegments.some(isCalledInSomePath);
					info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);
				}
			},
			onCodePathSegmentLoop: function onCodePathSegmentLoop(fromSegment, toSegment) {
				if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {
					return;
				}
				var isRealLoop = toSegment.prevSegments.length >= 2;

				funcInfo.codePath.traverseSegments({ first: toSegment, last: fromSegment }, function (segment) {
					var info = segInfoMap[segment.id];
					var prevSegments = segment.prevSegments;
					info.calledInSomePaths = prevSegments.some(isCalledInSomePath);
					info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);
					if (info.calledInSomePaths || isRealLoop) {
						var nodes = info.validNodes;

						info.validNodes = [];

						for (var i = 0; i < nodes.length; ++i) {
							var node = nodes[i];

							context.report({
								message: "Unexpected duplicate 'super()'.",
								node: node
							});
						}
					}
				});
			},
			"CallExpression:exit": function CallExpressionExit(node) {
				if (!(funcInfo && funcInfo.isConstructor)) {
					return;
				}
				if (node.callee.type !== "Super") {
					return;
				}
				if (funcInfo.hasExtends) {
					var segments = funcInfo.codePath.currentSegments;
					var duplicate = false;
					var info = null;

					for (var i = 0; i < segments.length; ++i) {
						var segment = segments[i];

						if (segment.reachable) {
							info = segInfoMap[segment.id];

							duplicate = duplicate || info.calledInSomePaths;
							info.calledInSomePaths = info.calledInEveryPaths = true;
						}
					}

					if (info) {
						if (duplicate) {
							context.report({
								message: "Unexpected duplicate 'super()'.",
								node: node
							});
						} else if (!funcInfo.superIsConstructor) {
							context.report({
								message: "Unexpected 'super()' because 'super' is not a constructor.",
								node: node
							});
						} else {
							info.validNodes.push(node);
						}
					}
				} else if (funcInfo.codePath.currentSegments.some(isReachable)) {
					context.report({
						message: "Unexpected 'super()'.",
						node: node
					});
				}
			},
			ReturnStatement: function ReturnStatement(node) {
				if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {
					return;
				}
				if (!node.argument) {
					return;
				}
				var segments = funcInfo.codePath.currentSegments;

				for (var i = 0; i < segments.length; ++i) {
					var segment = segments[i];

					if (segment.reachable) {
						var info = segInfoMap[segment.id];

						info.calledInSomePaths = info.calledInEveryPaths = true;
					}
				}
			},
			"Program:exit": function ProgramExit() {
				segInfoMap = Object.create(null);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent brace style for all control statements",
			category: "Best Practices",
			recommended: false
		},

		schema: {
			anyOf: [{
				type: "array",
				items: [{
					enum: ["all"]
				}],
				minItems: 0,
				maxItems: 1
			}, {
				type: "array",
				items: [{
					enum: ["multi", "multi-line", "multi-or-nest"]
				}, {
					enum: ["consistent"]
				}],
				minItems: 0,
				maxItems: 2
			}]
		},

		fixable: "code"
	},

	create: function create(context) {

		var multiOnly = context.options[0] === "multi";
		var multiLine = context.options[0] === "multi-line";
		var multiOrNest = context.options[0] === "multi-or-nest";
		var consistent = context.options[1] === "consistent";

		var sourceCode = context.getSourceCode();
		function isCollapsedOneLiner(node) {
			var before = sourceCode.getTokenBefore(node);
			var last = sourceCode.getLastToken(node);
			var lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;

			return before.loc.start.line === lastExcludingSemicolon.loc.end.line;
		}
		function isOneLiner(node) {
			var first = sourceCode.getFirstToken(node),
				last = sourceCode.getLastToken(node);

			return first.loc.start.line === last.loc.end.line;
		}
		function isElseKeywordToken(token) {
			return token.value === "else" && token.type === "Keyword";
		}
		function getElseKeyword(node) {
			return node.alternate && sourceCode.getFirstTokenBetween(node.consequent, node.alternate, isElseKeywordToken);
		}
		function requiresBraceOfConsequent(node) {
			if (node.alternate && node.consequent.type === "BlockStatement") {
				if (node.consequent.body.length >= 2) {
					return true;
				}

				node = node.consequent.body[0];
				while (node) {
					if (node.type === "IfStatement" && !node.alternate) {
						return true;
					}
					node = astUtils.getTrailingStatement(node);
				}
			}

			return false;
		}
		function reportExpectedBraceError(node, bodyNode, name, suffix) {
			context.report({
				node: node,
				loc: (name !== "else" ? node : getElseKeyword(node)).loc.start,
				message: "Expected { after '{{name}}'{{suffix}}.",
				data: {
					name: name,
					suffix: suffix ? " " + suffix : ""
				},
				fix: function fix(fixer) {
					return fixer.replaceText(bodyNode, "{" + sourceCode.getText(bodyNode) + "}");
				}
			});
		}
		function needsSemicolon(closingBracket) {
			var tokenBefore = sourceCode.getTokenBefore(closingBracket);
			var tokenAfter = sourceCode.getTokenAfter(closingBracket);
			var lastBlockNode = sourceCode.getNodeByRangeIndex(tokenBefore.range[0]);

			if (astUtils.isSemicolonToken(tokenBefore)) {
				return false;
			}

			if (!tokenAfter) {
				return false;
			}

			if (lastBlockNode.type === "BlockStatement" && lastBlockNode.parent.type !== "FunctionExpression" && lastBlockNode.parent.type !== "ArrowFunctionExpression") {
				return false;
			}

			if (tokenBefore.loc.end.line === tokenAfter.loc.start.line) {
				return true;
			}

			if (/^[([/`+-]/.test(tokenAfter.value)) {
				return true;
			}

			if (tokenBefore.type === "Punctuator" && (tokenBefore.value === "++" || tokenBefore.value === "--")) {
				return true;
			}
			return false;
		}
		function reportUnnecessaryBraceError(node, bodyNode, name, suffix) {
			context.report({
				node: node,
				loc: (name !== "else" ? node : getElseKeyword(node)).loc.start,
				message: "Unnecessary { after '{{name}}'{{suffix}}.",
				data: {
					name: name,
					suffix: suffix ? " " + suffix : ""
				},
				fix: function fix(fixer) {
					var needsPrecedingSpace = node.type === "DoWhileStatement" && sourceCode.getTokenBefore(bodyNode).range[1] === bodyNode.range[0] && !astUtils.canTokensBeAdjacent("do", sourceCode.getFirstToken(bodyNode, { skip: 1 }));

					var openingBracket = sourceCode.getFirstToken(bodyNode);
					var closingBracket = sourceCode.getLastToken(bodyNode);
					var lastTokenInBlock = sourceCode.getTokenBefore(closingBracket);

					if (needsSemicolon(closingBracket)) {
						return null;
					}

					var resultingBodyText = sourceCode.getText().slice(openingBracket.range[1], lastTokenInBlock.range[0]) + sourceCode.getText(lastTokenInBlock) + sourceCode.getText().slice(lastTokenInBlock.range[1], closingBracket.range[0]);

					return fixer.replaceText(bodyNode, (needsPrecedingSpace ? " " : "") + resultingBodyText);
				}
			});
		}
		function prepareCheck(node, body, name, suffix) {
			var hasBlock = body.type === "BlockStatement";
			var expected = null;

			if (node.type === "IfStatement" && node.consequent === body && requiresBraceOfConsequent(node)) {
				expected = true;
			} else if (multiOnly) {
				if (hasBlock && body.body.length === 1) {
					expected = false;
				}
			} else if (multiLine) {
				if (!isCollapsedOneLiner(body)) {
					expected = true;
				}
			} else if (multiOrNest) {
				if (hasBlock && body.body.length === 1 && isOneLiner(body.body[0])) {
					var leadingComments = sourceCode.getCommentsBefore(body.body[0]);

					expected = leadingComments.length > 0;
				} else if (!isOneLiner(body)) {
					expected = true;
				}
			} else {
				expected = true;
			}

			return {
				actual: hasBlock,
				expected: expected,
				check: function check() {
					if (this.expected !== null && this.expected !== this.actual) {
						if (this.expected) {
							reportExpectedBraceError(node, body, name, suffix);
						} else {
							reportUnnecessaryBraceError(node, body, name, suffix);
						}
					}
				}
			};
		}
		function prepareIfChecks(node) {
			var preparedChecks = [];

			do {
				preparedChecks.push(prepareCheck(node, node.consequent, "if", "condition"));
				if (node.alternate && node.alternate.type !== "IfStatement") {
					preparedChecks.push(prepareCheck(node, node.alternate, "else"));
					break;
				}
				node = node.alternate;
			} while (node);

			if (consistent) {
				var expected = preparedChecks.some(function (preparedCheck) {
					if (preparedCheck.expected !== null) {
						return preparedCheck.expected;
					}
					return preparedCheck.actual;
				});

				preparedChecks.forEach(function (preparedCheck) {
					preparedCheck.expected = expected;
				});
			}

			return preparedChecks;
		}
		return {
			IfStatement: function IfStatement(node) {
				if (node.parent.type !== "IfStatement") {
					prepareIfChecks(node).forEach(function (preparedCheck) {
						preparedCheck.check();
					});
				}
			},
			WhileStatement: function WhileStatement(node) {
				prepareCheck(node, node.body, "while", "condition").check();
			},
			DoWhileStatement: function DoWhileStatement(node) {
				prepareCheck(node, node.body, "do").check();
			},
			ForStatement: function ForStatement(node) {
				prepareCheck(node, node.body, "for", "condition").check();
			},
			ForInStatement: function ForInStatement(node) {
				prepareCheck(node, node.body, "for-in").check();
			},
			ForOfStatement: function ForOfStatement(node) {
				prepareCheck(node, node.body, "for-of").check();
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var DEFAULT_COMMENT_PATTERN = /^no default$/i;
module.exports = {
	meta: {
		docs: {
			description: "require `default` cases in `switch` statements",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				commentPattern: {
					type: "string"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = context.options[0] || {};
		var commentPattern = options.commentPattern ? new RegExp(options.commentPattern) : DEFAULT_COMMENT_PATTERN;

		var sourceCode = context.getSourceCode();
		function last(collection) {
			return collection[collection.length - 1];
		}
		return {
			SwitchStatement: function SwitchStatement(node) {

				if (!node.cases.length) {
					return;
				}

				var hasDefault = node.cases.some(function (v) {
					return v.test === null;
				});

				if (!hasDefault) {

					var comment = void 0;

					var lastCase = last(node.cases);
					var comments = sourceCode.getCommentsAfter(lastCase);

					if (comments.length) {
						comment = last(comments);
					}

					if (!comment || !commentPattern.test(comment.value.trim())) {
						context.report({ node: node, message: "Expected a default case." });
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent newlines before and after dots",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			enum: ["object", "property"]
		}],

		fixable: "code"
	},

	create: function create(context) {

		var config = context.options[0];
		var onObject = config === "object" || !config;

		var sourceCode = context.getSourceCode();
		function checkDotLocation(obj, prop, node) {
			var dot = sourceCode.getTokenBefore(prop);
			var textBeforeDot = sourceCode.getText().slice(obj.range[1], dot.range[0]);
			var textAfterDot = sourceCode.getText().slice(dot.range[1], prop.range[0]);

			if (dot.type === "Punctuator" && dot.value === ".") {
				if (onObject) {
					if (!astUtils.isTokenOnSameLine(obj, dot)) {
						var neededTextAfterObj = astUtils.isDecimalInteger(obj) ? " " : "";

						context.report({
							node: node,
							loc: dot.loc.start,
							message: "Expected dot to be on same line as object.",
							fix: function fix(fixer) {
								return fixer.replaceTextRange([obj.range[1], prop.range[0]], neededTextAfterObj + "." + textBeforeDot + textAfterDot);
							}
						});
					}
				} else if (!astUtils.isTokenOnSameLine(dot, prop)) {
					context.report({
						node: node,
						loc: dot.loc.start,
						message: "Expected dot to be on same line as property.",
						fix: function fix(fixer) {
							return fixer.replaceTextRange([obj.range[1], prop.range[0]], "" + textBeforeDot + textAfterDot + ".");
						}
					});
				}
			}
		}
		function checkNode(node) {
			checkDotLocation(node.object, node.property, node);
		}

		return {
			MemberExpression: checkNode
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
var validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/;
var keywords = __webpack_require__(107);

module.exports = {
	meta: {
		docs: {
			description: "enforce dot notation whenever possible",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				allowKeywords: {
					type: "boolean"
				},
				allowPattern: {
					type: "string"
				}
			},
			additionalProperties: false
		}],

		fixable: "code"
	},

	create: function create(context) {
		var options = context.options[0] || {};
		var allowKeywords = options.allowKeywords === void 0 || !!options.allowKeywords;
		var sourceCode = context.getSourceCode();

		var allowPattern = void 0;

		if (options.allowPattern) {
			allowPattern = new RegExp(options.allowPattern);
		}
		function checkComputedProperty(node, value) {
			if (validIdentifier.test(value) && (allowKeywords || keywords.indexOf(String(value)) === -1) && !(allowPattern && allowPattern.test(value))) {
				var formattedValue = node.property.type === "Literal" ? JSON.stringify(value) : "`" + value + "`";

				context.report({
					node: node.property,
					message: "[{{propertyValue}}] is better written in dot notation.",
					data: {
						propertyValue: formattedValue
					},
					fix: function fix(fixer) {
						var leftBracket = sourceCode.getTokenAfter(node.object, astUtils.isOpeningBracketToken);
						var rightBracket = sourceCode.getLastToken(node);

						if (sourceCode.getFirstTokenBetween(leftBracket, rightBracket, { includeComments: true, filter: astUtils.isCommentToken })) {
							return null;
						}

						var tokenAfterProperty = sourceCode.getTokenAfter(rightBracket);
						var needsSpaceAfterProperty = tokenAfterProperty && rightBracket.range[1] === tokenAfterProperty.range[0] && !astUtils.canTokensBeAdjacent(String(value), tokenAfterProperty);

						var textBeforeDot = astUtils.isDecimalInteger(node.object) ? " " : "";
						var textAfterProperty = needsSpaceAfterProperty ? " " : "";

						return fixer.replaceTextRange([leftBracket.range[0], rightBracket.range[1]], textBeforeDot + "." + value + textAfterProperty);
					}
				});
			}
		}

		return {
			MemberExpression: function MemberExpression(node) {
				if (node.computed && node.property.type === "Literal") {
					checkComputedProperty(node, node.property.value);
				}
				if (node.computed && node.property.type === "TemplateLiteral" && node.property.expressions.length === 0) {
					checkComputedProperty(node, node.property.quasis[0].value.cooked);
				}
				if (!allowKeywords && !node.computed && keywords.indexOf(String(node.property.name)) !== -1) {
					context.report({
						node: node.property,
						message: ".{{propertyName}} is a syntax error.",
						data: {
							propertyName: node.property.name
						},
						fix: function fix(fixer) {
							var dot = sourceCode.getTokenBefore(node.property);
							var textAfterDot = sourceCode.text.slice(dot.range[1], node.property.range[0]);

							if (textAfterDot.trim()) {
								return null;
							}

							if (node.object.type === "Identifier" && node.object.name === "let") {
								return null;
							}

							return fixer.replaceTextRange([dot.range[0], node.property.range[1]], "[" + textAfterDot + "\"" + node.property.name + "\"]");
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var lodash = __webpack_require__(10);
module.exports = {
	meta: {
		docs: {
			description: "require or disallow newline at the end of files",
			category: "Stylistic Issues",
			recommended: false
		},
		fixable: "whitespace",
		schema: [{
			enum: ["always", "never", "unix", "windows"]
		}]
	},
	create: function create(context) {
		return {
			Program: function checkBadEOF(node) {
				var sourceCode = context.getSourceCode(),
					src = sourceCode.getText(),
					location = {
					column: lodash.last(sourceCode.lines).length,
					line: sourceCode.lines.length
				},
					LF = "\n",
					CRLF = "\r" + LF,
					endsWithNewline = lodash.endsWith(src, LF);
				if (!src.length) {
					return;
				}

				var mode = context.options[0] || "always",
					appendCRLF = false;

				if (mode === "unix") {
					mode = "always";
				}
				if (mode === "windows") {
					mode = "always";
					appendCRLF = true;
				}
				if (mode === "always" && !endsWithNewline) {
					context.report({
						node: node,
						loc: location,
						message: "Newline required at end of file but not found.",
						fix: function fix(fixer) {
							return fixer.insertTextAfterRange([0, src.length], appendCRLF ? CRLF : LF);
						}
					});
				} else if (mode === "never" && endsWithNewline) {
					context.report({
						node: node,
						loc: location,
						message: "Newline not allowed at end of file.",
						fix: function fix(fixer) {
							var finalEOLs = /(?:\r?\n)+$/,
								match = finalEOLs.exec(sourceCode.text),
								start = match.index,
								end = sourceCode.text.length;

							return fixer.replaceTextRange([start, end], "");
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "require the use of `===` and `!==`",
			category: "Best Practices",
			recommended: false
		},

		schema: {
			anyOf: [{
				type: "array",
				items: [{
					enum: ["always"]
				}, {
					type: "object",
					properties: {
						null: {
							enum: ["always", "never", "ignore"]
						}
					},
					additionalProperties: false
				}],
				additionalItems: false
			}, {
				type: "array",
				items: [{
					enum: ["smart", "allow-null"]
				}],
				additionalItems: false
			}]
		},

		fixable: "code"
	},

	create: function create(context) {
		var config = context.options[0] || "always";
		var options = context.options[1] || {};
		var sourceCode = context.getSourceCode();

		var nullOption = config === "always" ? options.null || "always" : "ignore";
		var enforceRuleForNull = nullOption === "always";
		var enforceInverseRuleForNull = nullOption === "never";
		function isTypeOf(node) {
			return node.type === "UnaryExpression" && node.operator === "typeof";
		}
		function isTypeOfBinary(node) {
			return isTypeOf(node.left) || isTypeOf(node.right);
		}
		function areLiteralsAndSameType(node) {
			return node.left.type === "Literal" && node.right.type === "Literal" && _typeof(node.left.value) === _typeof(node.right.value);
		}
		function isNullCheck(node) {
			return astUtils.isNullLiteral(node.right) || astUtils.isNullLiteral(node.left);
		}
		function getOperatorLocation(node) {
			var opToken = sourceCode.getTokenAfter(node.left);

			return { line: opToken.loc.start.line, column: opToken.loc.start.column };
		}
		function report(node, expectedOperator) {
			context.report({
				node: node,
				loc: getOperatorLocation(node),
				message: "Expected '{{expectedOperator}}' and instead saw '{{actualOperator}}'.",
				data: { expectedOperator: expectedOperator, actualOperator: node.operator },
				fix: function fix(fixer) {
					if (isTypeOfBinary(node) || areLiteralsAndSameType(node)) {
						var operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, function (token) {
							return token.value === node.operator;
						});

						return fixer.replaceText(operatorToken, expectedOperator);
					}
					return null;
				}
			});
		}

		return {
			BinaryExpression: function BinaryExpression(node) {
				var isNull = isNullCheck(node);

				if (node.operator !== "==" && node.operator !== "!=") {
					if (enforceInverseRuleForNull && isNull) {
						report(node, node.operator.slice(0, -1));
					}
					return;
				}

				if (config === "smart" && (isTypeOfBinary(node) || areLiteralsAndSameType(node) || isNull)) {
					return;
				}

				if (!enforceRuleForNull && isNull) {
					return;
				}

				report(node, node.operator + "=");
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "enforce \"for\" loop update clause moving the counter in the right direction.",
			category: "Possible Errors",
			recommended: false
		},
		fixable: null,
		schema: []
	},

	create: function create(context) {
		function report(node) {
			context.report({
				node: node,
				message: "The update clause in this loop moves the variable in the wrong direction."
			});
		}
		function getUpdateDirection(update, counter) {
			if (update.argument.type === "Identifier" && update.argument.name === counter) {
				if (update.operator === "++") {
					return 1;
				}
				if (update.operator === "--") {
					return -1;
				}
			}
			return 0;
		}
		function getAssignmentDirection(update, counter) {
			if (update.left.name === counter) {
				if (update.operator === "+=") {
					return 1;
				}
				if (update.operator === "-=") {
					return -1;
				}
			}
			return 0;
		}
		return {
			ForStatement: function ForStatement(node) {

				if (node.test && node.test.type === "BinaryExpression" && node.test.left.type === "Identifier" && node.update) {
					var counter = node.test.left.name;
					var operator = node.test.operator;
					var update = node.update;

					if (operator === "<" || operator === "<=") {
						if (update.type === "UpdateExpression" && getUpdateDirection(update, counter) < 0) {
							report(node);
						}

						if (update.type === "AssignmentExpression" && getAssignmentDirection(update, counter) < 0) {
							report(node);
						}
					} else if (operator === ">" || operator === ">=") {
						if (update.type === "UpdateExpression" && getUpdateDirection(update, counter) > 0) {
							report(node);
						}

						if (update.type === "AssignmentExpression" && getAssignmentDirection(update, counter) > 0) {
							report(node);
						}
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "require or disallow spacing between function identifiers and their invocations",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",
		schema: {
			anyOf: [{
				type: "array",
				items: [{
					enum: ["never"]
				}],
				minItems: 0,
				maxItems: 1
			}, {
				type: "array",
				items: [{
					enum: ["always"]
				}, {
					type: "object",
					properties: {
						allowNewlines: {
							type: "boolean"
						}
					},
					additionalProperties: false
				}],
				minItems: 0,
				maxItems: 2
			}]
		}
	},

	create: function create(context) {

		var never = context.options[0] !== "always";
		var allowNewlines = !never && context.options[1] && context.options[1].allowNewlines;
		var sourceCode = context.getSourceCode();
		var text = sourceCode.getText();
		function checkSpacing(node) {
			var lastToken = sourceCode.getLastToken(node);
			var lastCalleeToken = sourceCode.getLastToken(node.callee);
			var parenToken = sourceCode.getFirstTokenBetween(lastCalleeToken, lastToken, astUtils.isOpeningParenToken);
			var prevToken = parenToken && sourceCode.getTokenBefore(parenToken);
			if (!(parenToken && parenToken.range[1] < node.range[1])) {
				return;
			}

			var textBetweenTokens = text.slice(prevToken.range[1], parenToken.range[0]).replace(/\/\*.*?\*\//g, "");
			var hasWhitespace = /\s/.test(textBetweenTokens);
			var hasNewline = hasWhitespace && astUtils.LINEBREAK_MATCHER.test(textBetweenTokens);

			if (never && hasWhitespace) {
				context.report({
					node: node,
					loc: lastCalleeToken.loc.start,
					message: "Unexpected space between function name and paren.",
					fix: function fix(fixer) {
						if (!hasNewline) {
							return fixer.removeRange([prevToken.range[1], parenToken.range[0]]);
						}

						return null;
					}
				});
			} else if (!never && !hasWhitespace) {
				context.report({
					node: node,
					loc: lastCalleeToken.loc.start,
					message: "Missing space between function name and paren.",
					fix: function fix(fixer) {
						return fixer.insertTextBefore(parenToken, " ");
					}
				});
			} else if (!never && !allowNewlines && hasNewline) {
				context.report({
					node: node,
					loc: lastCalleeToken.loc.start,
					message: "Unexpected newline between function name and paren.",
					fix: function fix(fixer) {
						return fixer.replaceTextRange([prevToken.range[1], parenToken.range[0]], " ");
					}
				});
			}
		}

		return {
			CallExpression: checkSpacing,
			NewExpression: checkSpacing
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var astUtils = __webpack_require__(0);
var esutils = __webpack_require__(68);
function isModuleExports(pattern) {
	if (pattern.type === "MemberExpression" && pattern.object.type === "Identifier" && pattern.object.name === "module") {
		if (pattern.property.type === "Identifier" && pattern.property.name === "exports") {
			return true;
		}
		if (pattern.property.type === "Literal" && pattern.property.value === "exports") {
			return true;
		}
	}
	return false;
}
function isIdentifier(name, ecmaVersion) {
	if (ecmaVersion >= 6) {
		return esutils.keyword.isIdentifierES6(name);
	}
	return esutils.keyword.isIdentifierES5(name);
}
var alwaysOrNever = { enum: ["always", "never"] };
var optionsObject = {
	type: "object",
	properties: {
		includeCommonJSModuleExports: {
			type: "boolean"
		}
	},
	additionalProperties: false
};

module.exports = {
	meta: {
		docs: {
			description: "require function names to match the name of the variable or property to which they are assigned",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: {
			anyOf: [{
				type: "array",
				additionalItems: false,
				items: [alwaysOrNever, optionsObject]
			}, {
				type: "array",
				additionalItems: false,
				items: [optionsObject]
			}]
		}
	},

	create: function create(context) {
		var options = (_typeof(context.options[0]) === "object" ? context.options[0] : context.options[1]) || {};
		var nameMatches = typeof context.options[0] === "string" ? context.options[0] : "always";
		var includeModuleExports = options.includeCommonJSModuleExports;
		var ecmaVersion = context.parserOptions && context.parserOptions.ecmaVersion ? context.parserOptions.ecmaVersion : 5;
		function shouldWarn(x, y) {
			return nameMatches === "always" && x !== y || nameMatches === "never" && x === y;
		}
		function report(node, name, funcName, isProp) {
			var message = void 0;

			if (nameMatches === "always" && isProp) {
				message = "Function name `{{funcName}}` should match property name `{{name}}`";
			} else if (nameMatches === "always") {
				message = "Function name `{{funcName}}` should match variable name `{{name}}`";
			} else if (isProp) {
				message = "Function name `{{funcName}}` should not match property name `{{name}}`";
			} else {
				message = "Function name `{{funcName}}` should not match variable name `{{name}}`";
			}
			context.report({
				node: node,
				message: message,
				data: {
					name: name,
					funcName: funcName
				}
			});
		}
		function isStringLiteral(node) {
			return node.type === "Literal" && typeof node.value === "string";
		}
		return {
			VariableDeclarator: function VariableDeclarator(node) {
				if (!node.init || node.init.type !== "FunctionExpression" || node.id.type !== "Identifier") {
					return;
				}
				if (node.init.id && shouldWarn(node.id.name, node.init.id.name)) {
					report(node, node.id.name, node.init.id.name, false);
				}
			},
			AssignmentExpression: function AssignmentExpression(node) {
				if (node.right.type !== "FunctionExpression" || node.left.computed && node.left.property.type !== "Literal" || !includeModuleExports && isModuleExports(node.left) || node.left.type !== "Identifier" && node.left.type !== "MemberExpression") {
					return;
				}

				var isProp = node.left.type === "MemberExpression";
				var name = isProp ? astUtils.getStaticPropertyName(node.left) : node.left.name;

				if (node.right.id && isIdentifier(name) && shouldWarn(name, node.right.id.name)) {
					report(node, name, node.right.id.name, isProp);
				}
			},
			Property: function Property(node) {
				if (node.value.type !== "FunctionExpression" || !node.value.id || node.computed && !isStringLiteral(node.key)) {
					return;
				}
				if (node.key.type === "Identifier" && shouldWarn(node.key.name, node.value.id.name)) {
					report(node, node.key.name, node.value.id.name, true);
				} else if (isStringLiteral(node.key) && isIdentifier(node.key.value, ecmaVersion) && shouldWarn(node.key.value, node.value.id.name)) {
					report(node, node.key.value, node.value.id.name, true);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
function isFunctionName(variable) {
	return variable && variable.defs[0].type === "FunctionName";
}
module.exports = {
	meta: {
		docs: {
			description: "require or disallow named `function` expressions",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			enum: ["always", "as-needed", "never"]
		}]
	},

	create: function create(context) {
		var never = context.options[0] === "never";
		var asNeeded = context.options[0] === "as-needed";
		function isObjectOrClassMethod(node) {
			var parent = node.parent;

			return parent.type === "MethodDefinition" || parent.type === "Property" && (parent.method || parent.kind === "get" || parent.kind === "set");
		}
		function hasInferredName(node) {
			var parent = node.parent;

			return isObjectOrClassMethod(node) || parent.type === "VariableDeclarator" && parent.id.type === "Identifier" && parent.init === node || parent.type === "Property" && parent.value === node || parent.type === "AssignmentExpression" && parent.left.type === "Identifier" && parent.right === node || parent.type === "ExportDefaultDeclaration" && parent.declaration === node || parent.type === "AssignmentPattern" && parent.right === node;
		}

		return {
			"FunctionExpression:exit": function FunctionExpressionExit(node) {
				var nameVar = context.getDeclaredVariables(node)[0];

				if (isFunctionName(nameVar) && nameVar.references.length > 0) {
					return;
				}

				var hasName = Boolean(node.id && node.id.name);
				var name = astUtils.getFunctionNameWithKind(node);

				if (never) {
					if (hasName) {
						context.report({
							node: node,
							message: "Unexpected named {{name}}.",
							data: { name: name }
						});
					}
				} else {
					if (!hasName && (asNeeded ? !hasInferredName(node) : !isObjectOrClassMethod(node))) {
						context.report({
							node: node,
							message: "Unexpected unnamed {{name}}.",
							data: { name: name }
						});
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "enforce the consistent use of either `function` declarations or expressions",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			enum: ["declaration", "expression"]
		}, {
			type: "object",
			properties: {
				allowArrowFunctions: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var style = context.options[0],
			allowArrowFunctions = context.options[1] && context.options[1].allowArrowFunctions === true,
			enforceDeclarations = style === "declaration",
			stack = [];

		var nodesToCheck = {
			FunctionDeclaration: function FunctionDeclaration(node) {
				stack.push(false);

				if (!enforceDeclarations && node.parent.type !== "ExportDefaultDeclaration") {
					context.report({ node: node, message: "Expected a function expression." });
				}
			},
			"FunctionDeclaration:exit": function FunctionDeclarationExit() {
				stack.pop();
			},
			FunctionExpression: function FunctionExpression(node) {
				stack.push(false);

				if (enforceDeclarations && node.parent.type === "VariableDeclarator") {
					context.report({ node: node.parent, message: "Expected a function declaration." });
				}
			},
			"FunctionExpression:exit": function FunctionExpressionExit() {
				stack.pop();
			},
			ThisExpression: function ThisExpression() {
				if (stack.length > 0) {
					stack[stack.length - 1] = true;
				}
			}
		};

		if (!allowArrowFunctions) {
			nodesToCheck.ArrowFunctionExpression = function () {
				stack.push(false);
			};

			nodesToCheck["ArrowFunctionExpression:exit"] = function (node) {
				var hasThisExpr = stack.pop();

				if (enforceDeclarations && !hasThisExpr && node.parent.type === "VariableDeclarator") {
					context.report({ node: node.parent, message: "Expected a function declaration." });
				}
			};
		}

		return nodesToCheck;
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent line breaks inside function parentheses",
			category: "Stylistic Issues",
			recommended: false
		},
		fixable: "whitespace",
		schema: [{
			oneOf: [{
				enum: ["always", "never", "consistent", "multiline"]
			}, {
				type: "object",
				properties: {
					minItems: {
						type: "integer",
						minimum: 0
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var rawOption = context.options[0] || "multiline";
		var multilineOption = rawOption === "multiline";
		var consistentOption = rawOption === "consistent";
		var minItems = void 0;

		if ((typeof rawOption === "undefined" ? "undefined" : _typeof(rawOption)) === "object") {
			minItems = rawOption.minItems;
		} else if (rawOption === "always") {
			minItems = 0;
		} else if (rawOption === "never") {
			minItems = Infinity;
		} else {
			minItems = null;
		}
		function shouldHaveNewlines(elements, hasLeftNewline) {
			if (multilineOption) {
				return elements.some(function (element, index) {
					return index !== elements.length - 1 && element.loc.end.line !== elements[index + 1].loc.start.line;
				});
			}
			if (consistentOption) {
				return hasLeftNewline;
			}
			return elements.length >= minItems;
		}
		function validateParens(parens, elements) {
			var leftParen = parens.leftParen;
			var rightParen = parens.rightParen;
			var tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);
			var tokenBeforeRightParen = sourceCode.getTokenBefore(rightParen);
			var hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);
			var hasRightNewline = !astUtils.isTokenOnSameLine(tokenBeforeRightParen, rightParen);
			var needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);

			if (hasLeftNewline && !needsNewlines) {
				context.report({
					node: leftParen,
					message: "Unexpected newline after '('.",
					fix: function fix(fixer) {
						return sourceCode.getText().slice(leftParen.range[1], tokenAfterLeftParen.range[0]).trim()
						? null : fixer.removeRange([leftParen.range[1], tokenAfterLeftParen.range[0]]);
					}
				});
			} else if (!hasLeftNewline && needsNewlines) {
				context.report({
					node: leftParen,
					message: "Expected a newline after '('.",
					fix: function fix(fixer) {
						return fixer.insertTextAfter(leftParen, "\n");
					}
				});
			}

			if (hasRightNewline && !needsNewlines) {
				context.report({
					node: rightParen,
					message: "Unexpected newline before ')'.",
					fix: function fix(fixer) {
						return sourceCode.getText().slice(tokenBeforeRightParen.range[1], rightParen.range[0]).trim()
						? null : fixer.removeRange([tokenBeforeRightParen.range[1], rightParen.range[0]]);
					}
				});
			} else if (!hasRightNewline && needsNewlines) {
				context.report({
					node: rightParen,
					message: "Expected a newline before ')'.",
					fix: function fix(fixer) {
						return fixer.insertTextBefore(rightParen, "\n");
					}
				});
			}
		}
		function getParenTokens(node) {
			switch (node.type) {
				case "NewExpression":
					if (!node.arguments.length && !(astUtils.isOpeningParenToken(sourceCode.getLastToken(node, { skip: 1 })) && astUtils.isClosingParenToken(sourceCode.getLastToken(node)))) {
						return null;
					}
				case "CallExpression":
					return {
						leftParen: sourceCode.getTokenAfter(node.callee, astUtils.isOpeningParenToken),
						rightParen: sourceCode.getLastToken(node)
					};

				case "FunctionDeclaration":
				case "FunctionExpression":
					{
						var leftParen = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);
						var rightParen = node.params.length ? sourceCode.getTokenAfter(node.params[node.params.length - 1], astUtils.isClosingParenToken) : sourceCode.getTokenAfter(leftParen);

						return { leftParen: leftParen, rightParen: rightParen };
					}

				case "ArrowFunctionExpression":
					{
						var firstToken = sourceCode.getFirstToken(node);

						if (!astUtils.isOpeningParenToken(firstToken)) {
							return null;
						}

						return {
							leftParen: firstToken,
							rightParen: sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken)
						};
					}

				default:
					throw new TypeError("unexpected node with type " + node.type);
			}
		}
		function validateNode(node) {
			var parens = getParenTokens(node);

			if (parens) {
				validateParens(parens, astUtils.isFunction(node) ? node.params : node.arguments);
			}
		}
		return {
			ArrowFunctionExpression: validateNode,
			CallExpression: validateNode,
			FunctionDeclaration: validateNode,
			FunctionExpression: validateNode,
			NewExpression: validateNode
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var OVERRIDE_SCHEMA = {
	oneOf: [{
		enum: ["before", "after", "both", "neither"]
	}, {
		type: "object",
		properties: {
			before: { type: "boolean" },
			after: { type: "boolean" }
		},
		additionalProperties: false
	}]
};

module.exports = {
	meta: {
		docs: {
			description: "enforce consistent spacing around `*` operators in generator functions",
			category: "ECMAScript 6",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			oneOf: [{
				enum: ["before", "after", "both", "neither"]
			}, {
				type: "object",
				properties: {
					before: { type: "boolean" },
					after: { type: "boolean" },
					named: OVERRIDE_SCHEMA,
					anonymous: OVERRIDE_SCHEMA,
					method: OVERRIDE_SCHEMA
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {

		var optionDefinitions = {
			before: { before: true, after: false },
			after: { before: false, after: true },
			both: { before: true, after: true },
			neither: { before: false, after: false }
		};
		function optionToDefinition(option, defaults) {
			if (!option) {
				return defaults;
			}

			return typeof option === "string" ? optionDefinitions[option] : Object.assign({}, defaults, option);
		}

		var modes = function (option) {
			option = option || {};
			var defaults = optionToDefinition(option, optionDefinitions.before);

			return {
				named: optionToDefinition(option.named, defaults),
				anonymous: optionToDefinition(option.anonymous, defaults),
				method: optionToDefinition(option.method, defaults)
			};
		}(context.options[0]);

		var sourceCode = context.getSourceCode();
		function isStarToken(token) {
			return token.value === "*" && token.type === "Punctuator";
		}
		function getStarToken(node) {
			return sourceCode.getFirstToken(node.parent.method || node.parent.type === "MethodDefinition" ? node.parent : node, isStarToken);
		}
		function checkSpacing(kind, side, leftToken, rightToken) {
			if (!!(rightToken.range[0] - leftToken.range[1]) !== modes[kind][side]) {
				var after = leftToken.value === "*";
				var spaceRequired = modes[kind][side];
				var node = after ? leftToken : rightToken;
				var type = spaceRequired ? "Missing" : "Unexpected";
				var message = "{{type}} space {{side}} *.";
				var data = {
					type: type,
					side: side
				};

				context.report({
					node: node,
					message: message,
					data: data,
					fix: function fix(fixer) {
						if (spaceRequired) {
							if (after) {
								return fixer.insertTextAfter(node, " ");
							}
							return fixer.insertTextBefore(node, " ");
						}
						return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
					}
				});
			}
		}
		function checkFunction(node) {
			if (!node.generator) {
				return;
			}

			var starToken = getStarToken(node);
			var prevToken = sourceCode.getTokenBefore(starToken);
			var nextToken = sourceCode.getTokenAfter(starToken);

			var kind = "named";

			if (node.parent.type === "MethodDefinition" || node.parent.type === "Property" && node.parent.method) {
				kind = "method";
			} else if (!node.id) {
				kind = "anonymous";
			}
			if (!(kind === "method" && starToken === sourceCode.getFirstToken(node.parent))) {
				checkSpacing(kind, "before", prevToken, starToken);
			}

			checkSpacing(kind, "after", starToken, nextToken);
		}

		return {
			FunctionDeclaration: checkFunction,
			FunctionExpression: checkFunction
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
var TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/;
function isReachable(segment) {
	return segment.reachable;
}
function getId(node) {
	return node.id || node;
}
module.exports = {
	meta: {
		docs: {
			description: "enforce `return` statements in getters",
			category: "Possible Errors",
			recommended: false
		},
		fixable: null,
		schema: [{
			type: "object",
			properties: {
				allowImplicit: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var options = context.options[0] || { allowImplicit: false };

		var funcInfo = {
			upper: null,
			codePath: null,
			hasReturn: false,
			shouldCheck: false,
			node: null
		};
		function checkLastSegment(node) {
			if (funcInfo.shouldCheck && funcInfo.codePath.currentSegments.some(isReachable)) {
				context.report({
					node: node,
					loc: getId(node).loc.start,
					message: funcInfo.hasReturn ? "Expected {{name}} to always return a value." : "Expected to return a value in {{name}}.",
					data: {
						name: astUtils.getFunctionNameWithKind(funcInfo.node)
					}
				});
			}
		}
		function isGetter(node) {
			var parent = node.parent;

			if (TARGET_NODE_TYPE.test(node.type) && node.body.type === "BlockStatement") {
				if (parent.kind === "get") {
					return true;
				}
				if (parent.type === "Property" && astUtils.getStaticPropertyName(parent) === "get" && parent.parent.type === "ObjectExpression") {
					if (parent.parent.parent.type === "CallExpression" && astUtils.getStaticPropertyName(parent.parent.parent.callee) === "defineProperty") {
						return true;
					}
					if (parent.parent.parent.type === "Property" && parent.parent.parent.parent.type === "ObjectExpression" && parent.parent.parent.parent.parent.type === "CallExpression" && astUtils.getStaticPropertyName(parent.parent.parent.parent.parent.callee) === "defineProperties") {
						return true;
					}
				}
			}
			return false;
		}
		return {
			onCodePathStart: function onCodePathStart(codePath, node) {
				funcInfo = {
					upper: funcInfo,
					codePath: codePath,
					hasReturn: false,
					shouldCheck: isGetter(node),
					node: node
				};
			},
			onCodePathEnd: function onCodePathEnd() {
				funcInfo = funcInfo.upper;
			},
			ReturnStatement: function ReturnStatement(node) {
				if (funcInfo.shouldCheck) {
					funcInfo.hasReturn = true;
					if (!options.allowImplicit && !node.argument) {
						context.report({
							node: node,
							message: "Expected to return a value in {{name}}.",
							data: {
								name: astUtils.getFunctionNameWithKind(funcInfo.node)
							}
						});
					}
				}
			},
			"FunctionExpression:exit": checkLastSegment,
			"ArrowFunctionExpression:exit": checkLastSegment
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var ACCEPTABLE_PARENTS = ["AssignmentExpression", "VariableDeclarator", "MemberExpression", "ExpressionStatement", "CallExpression", "ConditionalExpression", "Program", "VariableDeclaration"];
function findReference(scope, node) {
	var references = scope.references.filter(function (reference) {
		return reference.identifier.range[0] === node.range[0] && reference.identifier.range[1] === node.range[1];
	});
	if (references.length === 1) {
		return references[0];
	}
	return null;
}
function isShadowed(scope, node) {
	var reference = findReference(scope, node);

	return reference && reference.resolved && reference.resolved.defs.length > 0;
}

module.exports = {
	meta: {
		docs: {
			description: "require `require()` calls to be placed at top-level module scope",
			category: "Node.js and CommonJS",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		return {
			CallExpression: function CallExpression(node) {
				var currentScope = context.getScope();

				if (node.callee.name === "require" && !isShadowed(currentScope, node.callee)) {
					var isGoodRequire = context.getAncestors().every(function (parent) {
						return ACCEPTABLE_PARENTS.indexOf(parent.type) > -1;
					});

					if (!isGoodRequire) {
						context.report({ node: node, message: "Unexpected require()." });
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require `for-in` loops to include an `if` statement",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			ForInStatement: function ForInStatement(node) {
				var body = node.body.type === "BlockStatement" ? node.body.body[0] : node.body;

				if (body && body.type !== "IfStatement") {
					context.report({ node: node, message: "The body of a for-in should be wrapped in an if statement to filter unwanted properties from the prototype." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require error handling in callbacks",
			category: "Node.js and CommonJS",
			recommended: false
		},

		schema: [{
			type: "string"
		}]
	},

	create: function create(context) {

		var errorArgument = context.options[0] || "err";
		function isPattern(stringToCheck) {
			var firstChar = stringToCheck[0];

			return firstChar === "^";
		}
		function matchesConfiguredErrorName(name) {
			if (isPattern(errorArgument)) {
				var regexp = new RegExp(errorArgument);

				return regexp.test(name);
			}
			return name === errorArgument;
		}
		function getParameters(scope) {
			return scope.variables.filter(function (variable) {
				return variable.defs[0] && variable.defs[0].type === "Parameter";
			});
		}
		function checkForError(node) {
			var scope = context.getScope(),
				parameters = getParameters(scope),
				firstParameter = parameters[0];

			if (firstParameter && matchesConfiguredErrorName(firstParameter.name)) {
				if (firstParameter.references.length === 0) {
					context.report({ node: node, message: "Expected error to be handled." });
				}
			}
		}

		return {
			FunctionDeclaration: checkForError,
			FunctionExpression: checkForError,
			ArrowFunctionExpression: checkForError
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow specified identifiers",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: {
			type: "array",
			items: {
				type: "string"
			},
			uniqueItems: true
		}
	},

	create: function create(context) {
		var blacklist = context.options;
		function isInvalid(name) {
			return blacklist.indexOf(name) !== -1;
		}
		function shouldReport(effectiveParent, name) {
			return effectiveParent.type !== "CallExpression" && effectiveParent.type !== "NewExpression" && isInvalid(name);
		}
		function report(node) {
			context.report({
				node: node,
				message: "Identifier '{{name}}' is blacklisted.",
				data: {
					name: node.name
				}
			});
		}

		return {
			Identifier: function Identifier(node) {
				var name = node.name,
					effectiveParent = node.parent.type === "MemberExpression" ? node.parent.parent : node.parent;
				if (node.parent.type === "MemberExpression") {
					if (node.parent.object.type === "Identifier" && node.parent.object.name === node.name) {
						if (isInvalid(name)) {
							report(node);
						}
					} else if (effectiveParent.type === "AssignmentExpression" && (effectiveParent.right.type !== "MemberExpression" || effectiveParent.left.type === "MemberExpression" && effectiveParent.left.property.name === node.name)) {
						if (isInvalid(name)) {
							report(node);
						}
					}
				} else if (node.parent.type === "Property") {

					if (shouldReport(effectiveParent, name)) {
						report(node);
					}
				} else if (shouldReport(effectiveParent, name)) {
					report(node);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "enforce minimum and maximum identifier lengths",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				min: {
					type: "number"
				},
				max: {
					type: "number"
				},
				exceptions: {
					type: "array",
					uniqueItems: true,
					items: {
						type: "string"
					}
				},
				properties: {
					enum: ["always", "never"]
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = context.options[0] || {};
		var minLength = typeof options.min !== "undefined" ? options.min : 2;
		var maxLength = typeof options.max !== "undefined" ? options.max : Infinity;
		var properties = options.properties !== "never";
		var exceptions = (options.exceptions ? options.exceptions : []).reduce(function (obj, item) {
			obj[item] = true;

			return obj;
		}, {});

		var SUPPORTED_EXPRESSIONS = {
			MemberExpression: properties && function (parent) {
				return !parent.computed && (
				parent.parent.left === parent && parent.parent.type === "AssignmentExpression" ||
				parent.parent.type === "Property" && parent.parent.value === parent && parent.parent.parent.type === "ObjectPattern" && parent.parent.parent.parent.left === parent.parent.parent);
			},
			AssignmentPattern: function AssignmentPattern(parent, node) {
				return parent.left === node;
			},
			VariableDeclarator: function VariableDeclarator(parent, node) {
				return parent.id === node;
			},

			Property: properties && function (parent, node) {
				return parent.key === node;
			},
			ImportDefaultSpecifier: true,
			RestElement: true,
			FunctionExpression: true,
			ArrowFunctionExpression: true,
			ClassDeclaration: true,
			FunctionDeclaration: true,
			MethodDefinition: true,
			CatchClause: true
		};

		return {
			Identifier: function Identifier(node) {
				var name = node.name;
				var parent = node.parent;

				var isShort = name.length < minLength;
				var isLong = name.length > maxLength;

				if (!(isShort || isLong) || exceptions[name]) {
					return; // Nothing to report
				}

				var isValidExpression = SUPPORTED_EXPRESSIONS[parent.type];

				if (isValidExpression && (isValidExpression === true || isValidExpression(parent, node))) {
					context.report({
						node: node,
						message: isShort ? "Identifier name '{{name}}' is too short (< {{min}})." : "Identifier name '{{name}}' is too long (> {{max}}).",
						data: { name: name, min: minLength, max: maxLength }
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require identifiers to match a specified regular expression",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			type: "string"
		}, {
			type: "object",
			properties: {
				properties: {
					type: "boolean"
				}
			}
		}]
	},

	create: function create(context) {
		var pattern = context.options[0] || "^.+$",
			regexp = new RegExp(pattern);

		var options = context.options[1] || {},
			properties = !!options.properties,
			onlyDeclarations = !!options.onlyDeclarations;
		function isInvalid(name) {
			return !regexp.test(name);
		}
		function shouldReport(effectiveParent, name) {
			return effectiveParent.type !== "CallExpression" && effectiveParent.type !== "NewExpression" && isInvalid(name);
		}
		function report(node) {
			context.report({
				node: node,
				message: "Identifier '{{name}}' does not match the pattern '{{pattern}}'.",
				data: {
					name: node.name,
					pattern: pattern
				}
			});
		}

		return {
			Identifier: function Identifier(node) {
				var name = node.name,
					parent = node.parent,
					effectiveParent = parent.type === "MemberExpression" ? parent.parent : parent;

				if (parent.type === "MemberExpression") {

					if (!properties) {
						return;
					}
					if (parent.object.type === "Identifier" && parent.object.name === name) {
						if (isInvalid(name)) {
							report(node);
						}
					} else if (effectiveParent.type === "AssignmentExpression" && (effectiveParent.right.type !== "MemberExpression" || effectiveParent.left.type === "MemberExpression" && effectiveParent.left.property.name === name)) {
						if (isInvalid(name)) {
							report(node);
						}
					}
				} else if (parent.type === "Property") {

					if (!properties || parent.key.name !== name) {
						return;
					}

					if (shouldReport(effectiveParent, name)) {
						report(node);
					}
				} else {
					var isDeclaration = effectiveParent.type === "FunctionDeclaration" || effectiveParent.type === "VariableDeclarator";

					if (onlyDeclarations && !isDeclaration) {
						return;
					}

					if (shouldReport(effectiveParent, name)) {
						report(node);
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "enforce the location of arrow function bodies",
			category: "Stylistic Issues",
			recommended: false
		},
		fixable: "whitespace",
		schema: [{
			enum: ["beside", "below"]
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		function getOption() {
			return context.options[0] || "beside";
		}
		function validateExpression(node) {
			var option = getOption();

			var tokenBefore = sourceCode.getTokenBefore(node.body);
			var hasParens = tokenBefore.value === "(";

			if (node.type === "BlockStatement") {
				return;
			}

			var fixerTarget = node.body;

			if (hasParens) {
				tokenBefore = sourceCode.getTokenBefore(node.body, function (token) {
					return token.value !== "(";
				});
				fixerTarget = sourceCode.getTokenAfter(tokenBefore);
			}

			if (tokenBefore.loc.end.line === fixerTarget.loc.start.line && option === "below") {
				context.report({
					node: fixerTarget,
					message: "Expected a linebreak before this expression.",
					fix: function fix(fixer) {
						return fixer.insertTextBefore(fixerTarget, "\n");
					}
				});
			} else if (tokenBefore.loc.end.line !== fixerTarget.loc.start.line && option === "beside") {
				context.report({
					node: fixerTarget,
					message: "Expected no linebreak before this expression.",
					fix: function fix(fixer) {
						return fixer.replaceTextRange([tokenBefore.range[1], fixerTarget.range[0]], " ");
					}
				});
			}
		}
		return {
			ArrowFunctionExpression: function ArrowFunctionExpression(node) {
				return validateExpression(node);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent indentation",
			category: "Stylistic Issues",
			recommended: false,
			replacedBy: ["indent"]
		},

		deprecated: true,

		fixable: "whitespace",

		schema: [{
			oneOf: [{
				enum: ["tab"]
			}, {
				type: "integer",
				minimum: 0
			}]
		}, {
			type: "object",
			properties: {
				SwitchCase: {
					type: "integer",
					minimum: 0
				},
				VariableDeclarator: {
					oneOf: [{
						type: "integer",
						minimum: 0
					}, {
						type: "object",
						properties: {
							var: {
								type: "integer",
								minimum: 0
							},
							let: {
								type: "integer",
								minimum: 0
							},
							const: {
								type: "integer",
								minimum: 0
							}
						}
					}]
				},
				outerIIFEBody: {
					type: "integer",
					minimum: 0
				},
				MemberExpression: {
					type: "integer",
					minimum: 0
				},
				FunctionDeclaration: {
					type: "object",
					properties: {
						parameters: {
							oneOf: [{
								type: "integer",
								minimum: 0
							}, {
								enum: ["first"]
							}]
						},
						body: {
							type: "integer",
							minimum: 0
						}
					}
				},
				FunctionExpression: {
					type: "object",
					properties: {
						parameters: {
							oneOf: [{
								type: "integer",
								minimum: 0
							}, {
								enum: ["first"]
							}]
						},
						body: {
							type: "integer",
							minimum: 0
						}
					}
				},
				CallExpression: {
					type: "object",
					properties: {
						parameters: {
							oneOf: [{
								type: "integer",
								minimum: 0
							}, {
								enum: ["first"]
							}]
						}
					}
				},
				ArrayExpression: {
					oneOf: [{
						type: "integer",
						minimum: 0
					}, {
						enum: ["first"]
					}]
				},
				ObjectExpression: {
					oneOf: [{
						type: "integer",
						minimum: 0
					}, {
						enum: ["first"]
					}]
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var DEFAULT_VARIABLE_INDENT = 1;
		var DEFAULT_PARAMETER_INDENT = null; // For backwards compatibility, don't check parameter indentation unless specified in the config
		var DEFAULT_FUNCTION_BODY_INDENT = 1;

		var indentType = "space";
		var indentSize = 4;
		var options = {
			SwitchCase: 0,
			VariableDeclarator: {
				var: DEFAULT_VARIABLE_INDENT,
				let: DEFAULT_VARIABLE_INDENT,
				const: DEFAULT_VARIABLE_INDENT
			},
			outerIIFEBody: null,
			FunctionDeclaration: {
				parameters: DEFAULT_PARAMETER_INDENT,
				body: DEFAULT_FUNCTION_BODY_INDENT
			},
			FunctionExpression: {
				parameters: DEFAULT_PARAMETER_INDENT,
				body: DEFAULT_FUNCTION_BODY_INDENT
			},
			CallExpression: {
				arguments: DEFAULT_PARAMETER_INDENT
			},
			ArrayExpression: 1,
			ObjectExpression: 1
		};

		var sourceCode = context.getSourceCode();

		if (context.options.length) {
			if (context.options[0] === "tab") {
				indentSize = 1;
				indentType = "tab";
			} else /* istanbul ignore else : this will be caught by options validation */if (typeof context.options[0] === "number") {
					indentSize = context.options[0];
					indentType = "space";
				}

			if (context.options[1]) {
				var opts = context.options[1];

				options.SwitchCase = opts.SwitchCase || 0;
				var variableDeclaratorRules = opts.VariableDeclarator;

				if (typeof variableDeclaratorRules === "number") {
					options.VariableDeclarator = {
						var: variableDeclaratorRules,
						let: variableDeclaratorRules,
						const: variableDeclaratorRules
					};
				} else if ((typeof variableDeclaratorRules === "undefined" ? "undefined" : _typeof(variableDeclaratorRules)) === "object") {
					Object.assign(options.VariableDeclarator, variableDeclaratorRules);
				}

				if (typeof opts.outerIIFEBody === "number") {
					options.outerIIFEBody = opts.outerIIFEBody;
				}

				if (typeof opts.MemberExpression === "number") {
					options.MemberExpression = opts.MemberExpression;
				}

				if (_typeof(opts.FunctionDeclaration) === "object") {
					Object.assign(options.FunctionDeclaration, opts.FunctionDeclaration);
				}

				if (_typeof(opts.FunctionExpression) === "object") {
					Object.assign(options.FunctionExpression, opts.FunctionExpression);
				}

				if (_typeof(opts.CallExpression) === "object") {
					Object.assign(options.CallExpression, opts.CallExpression);
				}

				if (typeof opts.ArrayExpression === "number" || typeof opts.ArrayExpression === "string") {
					options.ArrayExpression = opts.ArrayExpression;
				}

				if (typeof opts.ObjectExpression === "number" || typeof opts.ObjectExpression === "string") {
					options.ObjectExpression = opts.ObjectExpression;
				}
			}
		}

		var caseIndentStore = {};
		function createErrorMessage(expectedAmount, actualSpaces, actualTabs) {
			var expectedStatement = expectedAmount + " " + indentType + (expectedAmount === 1 ? "" : "s"); // e.g. "2 tabs"
			var foundSpacesWord = "space" + (actualSpaces === 1 ? "" : "s"); // e.g. "space"
			var foundTabsWord = "tab" + (actualTabs === 1 ? "" : "s"); // e.g. "tabs"
			var foundStatement = void 0;

			if (actualSpaces > 0 && actualTabs > 0) {
				foundStatement = actualSpaces + " " + foundSpacesWord + " and " + actualTabs + " " + foundTabsWord; // e.g. "1 space and 2 tabs"
			} else if (actualSpaces > 0) {
				foundStatement = indentType === "space" ? actualSpaces : actualSpaces + " " + foundSpacesWord;
			} else if (actualTabs > 0) {
				foundStatement = indentType === "tab" ? actualTabs : actualTabs + " " + foundTabsWord;
			} else {
				foundStatement = "0";
			}

			return "Expected indentation of " + expectedStatement + " but found " + foundStatement + ".";
		}
		function report(node, needed, gottenSpaces, gottenTabs, loc, isLastNodeCheck) {
			if (gottenSpaces && gottenTabs) {
				return;
			}

			var desiredIndent = (indentType === "space" ? " " : "\t").repeat(needed);

			var textRange = isLastNodeCheck ? [node.range[1] - node.loc.end.column, node.range[1] - node.loc.end.column + gottenSpaces + gottenTabs] : [node.range[0] - node.loc.start.column, node.range[0] - node.loc.start.column + gottenSpaces + gottenTabs];

			context.report({
				node: node,
				loc: loc,
				message: createErrorMessage(needed, gottenSpaces, gottenTabs),
				fix: function fix(fixer) {
					return fixer.replaceTextRange(textRange, desiredIndent);
				}
			});
		}
		function getNodeIndent(node, byLastLine) {
			var token = byLastLine ? sourceCode.getLastToken(node) : sourceCode.getFirstToken(node);
			var srcCharsBeforeNode = sourceCode.getText(token, token.loc.start.column).split("");
			var indentChars = srcCharsBeforeNode.slice(0, srcCharsBeforeNode.findIndex(function (char) {
				return char !== " " && char !== "\t";
			}));
			var spaces = indentChars.filter(function (char) {
				return char === " ";
			}).length;
			var tabs = indentChars.filter(function (char) {
				return char === "\t";
			}).length;

			return {
				space: spaces,
				tab: tabs,
				goodChar: indentType === "space" ? spaces : tabs,
				badChar: indentType === "space" ? tabs : spaces
			};
		}
		function isNodeFirstInLine(node, byEndLocation) {
			var firstToken = byEndLocation === true ? sourceCode.getLastToken(node, 1) : sourceCode.getTokenBefore(node),
				startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line,
				endLine = firstToken ? firstToken.loc.end.line : -1;

			return startLine !== endLine;
		}
		function checkNodeIndent(node, neededIndent) {
			var actualIndent = getNodeIndent(node, false);

			if (node.type !== "ArrayExpression" && node.type !== "ObjectExpression" && (actualIndent.goodChar !== neededIndent || actualIndent.badChar !== 0) && isNodeFirstInLine(node)) {
				report(node, neededIndent, actualIndent.space, actualIndent.tab);
			}

			if (node.type === "IfStatement" && node.alternate) {
				var elseToken = sourceCode.getTokenBefore(node.alternate);

				checkNodeIndent(elseToken, neededIndent);

				if (!isNodeFirstInLine(node.alternate)) {
					checkNodeIndent(node.alternate, neededIndent);
				}
			}

			if (node.type === "TryStatement" && node.handler) {
				var catchToken = sourceCode.getFirstToken(node.handler);

				checkNodeIndent(catchToken, neededIndent);
			}

			if (node.type === "TryStatement" && node.finalizer) {
				var finallyToken = sourceCode.getTokenBefore(node.finalizer);

				checkNodeIndent(finallyToken, neededIndent);
			}

			if (node.type === "DoWhileStatement") {
				var whileToken = sourceCode.getTokenAfter(node.body);

				checkNodeIndent(whileToken, neededIndent);
			}
		}
		function checkNodesIndent(nodes, indent) {
			nodes.forEach(function (node) {
				return checkNodeIndent(node, indent);
			});
		}
		function checkLastNodeLineIndent(node, lastLineIndent) {
			var lastToken = sourceCode.getLastToken(node);
			var endIndent = getNodeIndent(lastToken, true);

			if ((endIndent.goodChar !== lastLineIndent || endIndent.badChar !== 0) && isNodeFirstInLine(node, true)) {
				report(node, lastLineIndent, endIndent.space, endIndent.tab, { line: lastToken.loc.start.line, column: lastToken.loc.start.column }, true);
			}
		}
		function checkLastReturnStatementLineIndent(node, firstLineIndent) {
			var lastToken = sourceCode.getLastToken(node, astUtils.isClosingParenToken);
			var textBeforeClosingParenthesis = sourceCode.getText(lastToken, lastToken.loc.start.column).slice(0, -1);

			if (textBeforeClosingParenthesis.trim()) {
				return;
			}

			var endIndent = getNodeIndent(lastToken, true);

			if (endIndent.goodChar !== firstLineIndent) {
				report(node, firstLineIndent, endIndent.space, endIndent.tab, { line: lastToken.loc.start.line, column: lastToken.loc.start.column }, true);
			}
		}
		function checkFirstNodeLineIndent(node, firstLineIndent) {
			var startIndent = getNodeIndent(node, false);

			if ((startIndent.goodChar !== firstLineIndent || startIndent.badChar !== 0) && isNodeFirstInLine(node)) {
				report(node, firstLineIndent, startIndent.space, startIndent.tab, { line: node.loc.start.line, column: node.loc.start.column });
			}
		}
		function getParentNodeByType(node, type, stopAtList) {
			var parent = node.parent;

			if (!stopAtList) {
				stopAtList = ["Program"];
			}

			while (parent.type !== type && stopAtList.indexOf(parent.type) === -1 && parent.type !== "Program") {
				parent = parent.parent;
			}

			return parent.type === type ? parent : null;
		}
		function getVariableDeclaratorNode(node) {
			return getParentNodeByType(node, "VariableDeclarator");
		}
		function isNodeInVarOnTop(node, varNode) {
			return varNode && varNode.parent.loc.start.line === node.loc.start.line && varNode.parent.declarations.length > 1;
		}
		function isArgBeforeCalleeNodeMultiline(node) {
			var parent = node.parent;

			if (parent.arguments.length >= 2 && parent.arguments[1] === node) {
				return parent.arguments[0].loc.end.line > parent.arguments[0].loc.start.line;
			}

			return false;
		}
		function isOuterIIFE(node) {
			var parent = node.parent;
			var stmt = parent.parent;
			if (parent.type !== "CallExpression" || parent.callee !== node) {

				return false;
			}
			while (stmt.type === "UnaryExpression" && (stmt.operator === "!" || stmt.operator === "~" || stmt.operator === "+" || stmt.operator === "-") || stmt.type === "AssignmentExpression" || stmt.type === "LogicalExpression" || stmt.type === "SequenceExpression" || stmt.type === "VariableDeclarator") {

				stmt = stmt.parent;
			}

			return (stmt.type === "ExpressionStatement" || stmt.type === "VariableDeclaration") && stmt.parent && stmt.parent.type === "Program";
		}
		function checkIndentInFunctionBlock(node) {
			var calleeNode = node.parent; // FunctionExpression
			var indent = void 0;

			if (calleeNode.parent && (calleeNode.parent.type === "Property" || calleeNode.parent.type === "ArrayExpression")) {
				indent = getNodeIndent(calleeNode, false).goodChar;
			} else {
				indent = getNodeIndent(calleeNode).goodChar;
			}

			if (calleeNode.parent.type === "CallExpression") {
				var calleeParent = calleeNode.parent;

				if (calleeNode.type !== "FunctionExpression" && calleeNode.type !== "ArrowFunctionExpression") {
					if (calleeParent && calleeParent.loc.start.line < node.loc.start.line) {
						indent = getNodeIndent(calleeParent).goodChar;
					}
				} else {
					if (isArgBeforeCalleeNodeMultiline(calleeNode) && calleeParent.callee.loc.start.line === calleeParent.callee.loc.end.line && !isNodeFirstInLine(calleeNode)) {
						indent = getNodeIndent(calleeParent).goodChar;
					}
				}
			}
			var functionOffset = indentSize;

			if (options.outerIIFEBody !== null && isOuterIIFE(calleeNode)) {
				functionOffset = options.outerIIFEBody * indentSize;
			} else if (calleeNode.type === "FunctionExpression") {
				functionOffset = options.FunctionExpression.body * indentSize;
			} else if (calleeNode.type === "FunctionDeclaration") {
				functionOffset = options.FunctionDeclaration.body * indentSize;
			}
			indent += functionOffset;
			var parentVarNode = getVariableDeclaratorNode(node);

			if (parentVarNode && isNodeInVarOnTop(node, parentVarNode)) {
				indent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
			}

			if (node.body.length > 0) {
				checkNodesIndent(node.body, indent);
			}

			checkLastNodeLineIndent(node, indent - functionOffset);
		}
		function isSingleLineNode(node) {
			var lastToken = sourceCode.getLastToken(node),
				startLine = node.loc.start.line,
				endLine = lastToken.loc.end.line;

			return startLine === endLine;
		}
		function isFirstArrayElementOnSameLine(node) {
			if (node.type === "ArrayExpression" && node.elements[0]) {
				return node.elements[0].loc.start.line === node.loc.start.line && node.elements[0].type === "ObjectExpression";
			}
			return false;
		}
		function checkIndentInArrayOrObjectBlock(node) {
			if (isSingleLineNode(node)) {
				return;
			}

			var elements = node.type === "ArrayExpression" ? node.elements : node.properties;
			elements = elements.filter(function (elem) {
				return elem !== null;
			});

			var nodeIndent = void 0;
			var elementsIndent = void 0;
			var parentVarNode = getVariableDeclaratorNode(node);
			if (isNodeFirstInLine(node)) {
				var parent = node.parent;

				nodeIndent = getNodeIndent(parent).goodChar;
				if (!parentVarNode || parentVarNode.loc.start.line !== node.loc.start.line) {
					if (parent.type !== "VariableDeclarator" || parentVarNode === parentVarNode.parent.declarations[0]) {
						if (parent.type === "VariableDeclarator" && parentVarNode.loc.start.line === parent.loc.start.line) {
							nodeIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
						} else if (parent.type === "ObjectExpression" || parent.type === "ArrayExpression") {
							var parentElements = node.parent.type === "ObjectExpression" ? node.parent.properties : node.parent.elements;

							if (parentElements[0] && parentElements[0].loc.start.line === parent.loc.start.line && parentElements[0].loc.end.line !== parent.loc.start.line) {
							} else if (typeof options[parent.type] === "number") {
								nodeIndent += options[parent.type] * indentSize;
							} else {
								nodeIndent = parentElements[0].loc.start.column;
							}
						} else if (parent.type === "CallExpression" || parent.type === "NewExpression") {
							if (typeof options.CallExpression.arguments === "number") {
								nodeIndent += options.CallExpression.arguments * indentSize;
							} else if (options.CallExpression.arguments === "first") {
								if (parent.arguments.indexOf(node) !== -1) {
									nodeIndent = parent.arguments[0].loc.start.column;
								}
							} else {
								nodeIndent += indentSize;
							}
						} else if (parent.type === "LogicalExpression" || parent.type === "ArrowFunctionExpression") {
							nodeIndent += indentSize;
						}
					}
				} else if (!parentVarNode && !isFirstArrayElementOnSameLine(parent) && parent.type !== "MemberExpression" && parent.type !== "ExpressionStatement" && parent.type !== "AssignmentExpression" && parent.type !== "Property") {
					nodeIndent += indentSize;
				}

				checkFirstNodeLineIndent(node, nodeIndent);
			} else {
				nodeIndent = getNodeIndent(node).goodChar;
			}

			if (options[node.type] === "first") {
				elementsIndent = elements.length ? elements[0].loc.start.column : 0; // If there are no elements, elementsIndent doesn't matter.
			} else {
				elementsIndent = nodeIndent + indentSize * options[node.type];
			}
			if (isNodeInVarOnTop(node, parentVarNode)) {
				elementsIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
			}

			checkNodesIndent(elements, elementsIndent);

			if (elements.length > 0) {
				if (elements[elements.length - 1].loc.end.line === node.loc.end.line) {
					return;
				}
			}

			checkLastNodeLineIndent(node, nodeIndent + (isNodeInVarOnTop(node, parentVarNode) ? options.VariableDeclarator[parentVarNode.parent.kind] * indentSize : 0));
		}
		function isNodeBodyBlock(node) {
			return node.type === "BlockStatement" || node.type === "ClassBody" || node.body && node.body.type === "BlockStatement" || node.consequent && node.consequent.type === "BlockStatement";
		}
		function blockIndentationCheck(node) {
			if (isSingleLineNode(node)) {
				return;
			}

			if (node.parent && (node.parent.type === "FunctionExpression" || node.parent.type === "FunctionDeclaration" || node.parent.type === "ArrowFunctionExpression")) {
				checkIndentInFunctionBlock(node);
				return;
			}

			var indent = void 0;
			var nodesToCheck = [];
			var statementsWithProperties = ["IfStatement", "WhileStatement", "ForStatement", "ForInStatement", "ForOfStatement", "DoWhileStatement", "ClassDeclaration", "TryStatement"];

			if (node.parent && statementsWithProperties.indexOf(node.parent.type) !== -1 && isNodeBodyBlock(node)) {
				indent = getNodeIndent(node.parent).goodChar;
			} else if (node.parent && node.parent.type === "CatchClause") {
				indent = getNodeIndent(node.parent.parent).goodChar;
			} else {
				indent = getNodeIndent(node).goodChar;
			}

			if (node.type === "IfStatement" && node.consequent.type !== "BlockStatement") {
				nodesToCheck = [node.consequent];
			} else if (Array.isArray(node.body)) {
				nodesToCheck = node.body;
			} else {
				nodesToCheck = [node.body];
			}

			if (nodesToCheck.length > 0) {
				checkNodesIndent(nodesToCheck, indent + indentSize);
			}

			if (node.type === "BlockStatement") {
				checkLastNodeLineIndent(node, indent);
			}
		}
		function filterOutSameLineVars(node) {
			return node.declarations.reduce(function (finalCollection, elem) {
				var lastElem = finalCollection[finalCollection.length - 1];

				if (elem.loc.start.line !== node.loc.start.line && !lastElem || lastElem && lastElem.loc.start.line !== elem.loc.start.line) {
					finalCollection.push(elem);
				}

				return finalCollection;
			}, []);
		}
		function checkIndentInVariableDeclarations(node) {
			var elements = filterOutSameLineVars(node);
			var nodeIndent = getNodeIndent(node).goodChar;
			var lastElement = elements[elements.length - 1];

			var elementsIndent = nodeIndent + indentSize * options.VariableDeclarator[node.kind];

			checkNodesIndent(elements, elementsIndent);
			if (sourceCode.getLastToken(node).loc.end.line <= lastElement.loc.end.line) {
				return;
			}

			var tokenBeforeLastElement = sourceCode.getTokenBefore(lastElement);

			if (tokenBeforeLastElement.value === ",") {
				checkLastNodeLineIndent(node, getNodeIndent(tokenBeforeLastElement).goodChar);
			} else {
				checkLastNodeLineIndent(node, elementsIndent - indentSize);
			}
		}
		function blockLessNodes(node) {
			if (node.body.type !== "BlockStatement") {
				blockIndentationCheck(node);
			}
		}
		function expectedCaseIndent(node, switchIndent) {
			var switchNode = node.type === "SwitchStatement" ? node : node.parent;
			var caseIndent = void 0;

			if (caseIndentStore[switchNode.loc.start.line]) {
				return caseIndentStore[switchNode.loc.start.line];
			}
			if (typeof switchIndent === "undefined") {
				switchIndent = getNodeIndent(switchNode).goodChar;
			}

			if (switchNode.cases.length > 0 && options.SwitchCase === 0) {
				caseIndent = switchIndent;
			} else {
				caseIndent = switchIndent + indentSize * options.SwitchCase;
			}

			caseIndentStore[switchNode.loc.start.line] = caseIndent;
			return caseIndent;
		}
		function isWrappedInParenthesis(node) {
			var regex = /^return\s*?\(\s*?\);*?/;

			var statementWithoutArgument = sourceCode.getText(node).replace(sourceCode.getText(node.argument), "");

			return regex.test(statementWithoutArgument);
		}

		return {
			Program: function Program(node) {
				if (node.body.length > 0) {
					checkNodesIndent(node.body, getNodeIndent(node).goodChar);
				}
			},


			ClassBody: blockIndentationCheck,

			BlockStatement: blockIndentationCheck,

			WhileStatement: blockLessNodes,

			ForStatement: blockLessNodes,

			ForInStatement: blockLessNodes,

			ForOfStatement: blockLessNodes,

			DoWhileStatement: blockLessNodes,

			IfStatement: function IfStatement(node) {
				if (node.consequent.type !== "BlockStatement" && node.consequent.loc.start.line > node.loc.start.line) {
					blockIndentationCheck(node);
				}
			},
			VariableDeclaration: function VariableDeclaration(node) {
				if (node.declarations[node.declarations.length - 1].loc.start.line > node.declarations[0].loc.start.line) {
					checkIndentInVariableDeclarations(node);
				}
			},
			ObjectExpression: function ObjectExpression(node) {
				checkIndentInArrayOrObjectBlock(node);
			},
			ArrayExpression: function ArrayExpression(node) {
				checkIndentInArrayOrObjectBlock(node);
			},
			MemberExpression: function MemberExpression(node) {

				if (typeof options.MemberExpression === "undefined") {
					return;
				}

				if (isSingleLineNode(node)) {
					return;
				}
				if (getParentNodeByType(node, "VariableDeclarator", ["FunctionExpression", "ArrowFunctionExpression"])) {
					return;
				}

				if (getParentNodeByType(node, "AssignmentExpression", ["FunctionExpression"])) {
					return;
				}

				var propertyIndent = getNodeIndent(node).goodChar + indentSize * options.MemberExpression;

				var checkNodes = [node.property];

				var dot = sourceCode.getTokenBefore(node.property);

				if (dot.type === "Punctuator" && dot.value === ".") {
					checkNodes.push(dot);
				}

				checkNodesIndent(checkNodes, propertyIndent);
			},
			SwitchStatement: function SwitchStatement(node) {
				var switchIndent = getNodeIndent(node).goodChar;
				var caseIndent = expectedCaseIndent(node, switchIndent);

				checkNodesIndent(node.cases, caseIndent);

				checkLastNodeLineIndent(node, switchIndent);
			},
			SwitchCase: function SwitchCase(node) {
				if (isSingleLineNode(node)) {
					return;
				}
				var caseIndent = expectedCaseIndent(node);

				checkNodesIndent(node.consequent, caseIndent + indentSize);
			},
			FunctionDeclaration: function FunctionDeclaration(node) {
				if (isSingleLineNode(node)) {
					return;
				}
				if (options.FunctionDeclaration.parameters === "first" && node.params.length) {
					checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);
				} else if (options.FunctionDeclaration.parameters !== null) {
					checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionDeclaration.parameters);
				}
			},
			FunctionExpression: function FunctionExpression(node) {
				if (isSingleLineNode(node)) {
					return;
				}
				if (options.FunctionExpression.parameters === "first" && node.params.length) {
					checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);
				} else if (options.FunctionExpression.parameters !== null) {
					checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionExpression.parameters);
				}
			},
			ReturnStatement: function ReturnStatement(node) {
				if (isSingleLineNode(node)) {
					return;
				}

				var firstLineIndent = getNodeIndent(node).goodChar;
				if (isWrappedInParenthesis(node)) {
					checkLastReturnStatementLineIndent(node, firstLineIndent);
				} else {
					checkNodeIndent(node, firstLineIndent);
				}
			},
			CallExpression: function CallExpression(node) {
				if (isSingleLineNode(node)) {
					return;
				}
				if (options.CallExpression.arguments === "first" && node.arguments.length) {
					checkNodesIndent(node.arguments.slice(1), node.arguments[0].loc.start.column);
				} else if (options.CallExpression.arguments !== null) {
					checkNodesIndent(node.arguments, getNodeIndent(node).goodChar + indentSize * options.CallExpression.arguments);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var lodash = __webpack_require__(10);
var astUtils = __webpack_require__(0);
var createTree = __webpack_require__(439);
var KNOWN_NODES = new Set(["AssignmentExpression", "AssignmentPattern", "ArrayExpression", "ArrayPattern", "ArrowFunctionExpression", "AwaitExpression", "BlockStatement", "BinaryExpression", "BreakStatement", "CallExpression", "CatchClause", "ClassBody", "ClassDeclaration", "ClassExpression", "ConditionalExpression", "ContinueStatement", "DoWhileStatement", "DebuggerStatement", "EmptyStatement", "ExperimentalRestProperty", "ExperimentalSpreadProperty", "ExpressionStatement", "ForStatement", "ForInStatement", "ForOfStatement", "FunctionDeclaration", "FunctionExpression", "Identifier", "IfStatement", "Literal", "LabeledStatement", "LogicalExpression", "MemberExpression", "MetaProperty", "MethodDefinition", "NewExpression", "ObjectExpression", "ObjectPattern", "Program", "Property", "RestElement", "ReturnStatement", "SequenceExpression", "SpreadElement", "Super", "SwitchCase", "SwitchStatement", "TaggedTemplateExpression", "TemplateElement", "TemplateLiteral", "ThisExpression", "ThrowStatement", "TryStatement", "UnaryExpression", "UpdateExpression", "VariableDeclaration", "VariableDeclarator", "WhileStatement", "WithStatement", "YieldExpression", "JSXIdentifier", "JSXNamespacedName", "JSXMemberExpression", "JSXEmptyExpression", "JSXExpressionContainer", "JSXElement", "JSXClosingElement", "JSXOpeningElement", "JSXAttribute", "JSXSpreadAttribute", "JSXText", "ExportDefaultDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration", "ExportSpecifier", "ImportDeclaration", "ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"]);

var BinarySearchTree = function () {
	function BinarySearchTree() {
		_classCallCheck(this, BinarySearchTree);

		this._rbTree = createTree();
	}


	_createClass(BinarySearchTree, [{
		key: "insert",
		value: function insert(key, value) {
			var iterator = this._rbTree.find(key);

			if (iterator.valid) {
				this._rbTree = iterator.update(value);
			} else {
				this._rbTree = this._rbTree.insert(key, value);
			}
		}

	}, {
		key: "findLe",
		value: function findLe(key) {
			var iterator = this._rbTree.le(key);

			return iterator && { key: iterator.key, value: iterator.value };
		}

	}, {
		key: "deleteRange",
		value: function deleteRange(start, end) {
			if (start === end) {
				return;
			}
			var iterator = this._rbTree.ge(start);

			while (iterator.valid && iterator.key < end) {
				this._rbTree = this._rbTree.remove(iterator.key);
				iterator.next();
			}
		}
	}]);

	return BinarySearchTree;
}();


var TokenInfo = function () {
	function TokenInfo(sourceCode) {
		_classCallCheck(this, TokenInfo);

		this.sourceCode = sourceCode;
		this.firstTokensByLineNumber = sourceCode.tokensAndComments.reduce(function (map, token) {
			if (!map.has(token.loc.start.line)) {
				map.set(token.loc.start.line, token);
			}
			if (!map.has(token.loc.end.line) && sourceCode.text.slice(token.range[1] - token.loc.end.column, token.range[1]).trim()) {
				map.set(token.loc.end.line, token);
			}
			return map;
		}, new Map());
	}


	_createClass(TokenInfo, [{
		key: "getFirstTokenOfLine",
		value: function getFirstTokenOfLine(token) {
			return this.firstTokensByLineNumber.get(token.loc.start.line);
		}

	}, {
		key: "isFirstTokenOfLine",
		value: function isFirstTokenOfLine(token) {
			return this.getFirstTokenOfLine(token) === token;
		}

	}, {
		key: "getTokenIndent",
		value: function getTokenIndent(token) {
			return this.sourceCode.text.slice(token.range[0] - token.loc.start.column, token.range[0]);
		}
	}]);

	return TokenInfo;
}();


var OffsetStorage = function () {
	function OffsetStorage(tokenInfo, indentSize, indentType) {
		_classCallCheck(this, OffsetStorage);

		this._tokenInfo = tokenInfo;
		this._indentSize = indentSize;
		this._indentType = indentType;

		this._tree = new BinarySearchTree();
		this._tree.insert(0, { offset: 0, from: null, force: false });

		this._lockedFirstTokens = new WeakMap();
		this._desiredIndentCache = new WeakMap();
		this._ignoredTokens = new WeakSet();
	}

	_createClass(OffsetStorage, [{
		key: "_getOffsetDescriptor",
		value: function _getOffsetDescriptor(token) {
			return this._tree.findLe(token.range[0]).value;
		}

	}, {
		key: "matchOffsetOf",
		value: function matchOffsetOf(baseToken, offsetToken) {
			this._lockedFirstTokens.set(offsetToken, baseToken);
		}

	}, {
		key: "setDesiredOffset",
		value: function setDesiredOffset(token, fromToken, offset) {
			return this.setDesiredOffsets(token.range, fromToken, offset);
		}

	}, {
		key: "setDesiredOffsets",
		value: function setDesiredOffsets(range, fromToken, offset, force) {

			var descriptorToInsert = { offset: offset, from: fromToken, force: force };

			var descriptorAfterRange = this._tree.findLe(range[1]).value;

			var fromTokenIsInRange = fromToken && fromToken.range[0] >= range[0] && fromToken.range[1] <= range[1];
			var fromTokenDescriptor = fromTokenIsInRange && this._getOffsetDescriptor(fromToken);
			this._tree.deleteRange(range[0] + 1, range[1]);
			this._tree.insert(range[0], descriptorToInsert);
			if (fromTokenIsInRange) {
				this._tree.insert(fromToken.range[0], fromTokenDescriptor);
				this._tree.insert(fromToken.range[1], descriptorToInsert);
			}
			this._tree.insert(range[1], descriptorAfterRange);
		}

	}, {
		key: "getDesiredIndent",
		value: function getDesiredIndent(token) {
			if (!this._desiredIndentCache.has(token)) {

				if (this._ignoredTokens.has(token)) {
					this._desiredIndentCache.set(token, this._tokenInfo.getTokenIndent(token));
				} else if (this._lockedFirstTokens.has(token)) {
					var firstToken = this._lockedFirstTokens.get(token);

					this._desiredIndentCache.set(token,
					this.getDesiredIndent(this._tokenInfo.getFirstTokenOfLine(firstToken)) +
					this._indentType.repeat(firstToken.loc.start.column - this._tokenInfo.getFirstTokenOfLine(firstToken).loc.start.column));
				} else {
					var offsetInfo = this._getOffsetDescriptor(token);
					var offset = offsetInfo.from && offsetInfo.from.loc.start.line === token.loc.start.line && !offsetInfo.force ? 0 : offsetInfo.offset * this._indentSize;

					this._desiredIndentCache.set(token, (offsetInfo.from ? this.getDesiredIndent(offsetInfo.from) : "") + this._indentType.repeat(offset));
				}
			}
			return this._desiredIndentCache.get(token);
		}

	}, {
		key: "ignoreToken",
		value: function ignoreToken(token) {
			if (this._tokenInfo.isFirstTokenOfLine(token)) {
				this._ignoredTokens.add(token);
			}
		}

	}, {
		key: "getFirstDependency",
		value: function getFirstDependency(token) {
			return this._getOffsetDescriptor(token).from;
		}
	}]);

	return OffsetStorage;
}();

var ELEMENT_LIST_SCHEMA = {
	oneOf: [{
		type: "integer",
		minimum: 0
	}, {
		enum: ["first", "off"]
	}]
};

module.exports = {
	meta: {
		docs: {
			description: "enforce consistent indentation",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			oneOf: [{
				enum: ["tab"]
			}, {
				type: "integer",
				minimum: 0
			}]
		}, {
			type: "object",
			properties: {
				SwitchCase: {
					type: "integer",
					minimum: 0
				},
				VariableDeclarator: {
					oneOf: [{
						type: "integer",
						minimum: 0
					}, {
						type: "object",
						properties: {
							var: {
								type: "integer",
								minimum: 0
							},
							let: {
								type: "integer",
								minimum: 0
							},
							const: {
								type: "integer",
								minimum: 0
							}
						},
						additionalProperties: false
					}]
				},
				outerIIFEBody: {
					type: "integer",
					minimum: 0
				},
				MemberExpression: {
					oneOf: [{
						type: "integer",
						minimum: 0
					}, {
						enum: ["off"]
					}]
				},
				FunctionDeclaration: {
					type: "object",
					properties: {
						parameters: ELEMENT_LIST_SCHEMA,
						body: {
							type: "integer",
							minimum: 0
						}
					},
					additionalProperties: false
				},
				FunctionExpression: {
					type: "object",
					properties: {
						parameters: ELEMENT_LIST_SCHEMA,
						body: {
							type: "integer",
							minimum: 0
						}
					},
					additionalProperties: false
				},
				CallExpression: {
					type: "object",
					properties: {
						arguments: ELEMENT_LIST_SCHEMA
					},
					additionalProperties: false
				},
				ArrayExpression: ELEMENT_LIST_SCHEMA,
				ObjectExpression: ELEMENT_LIST_SCHEMA,
				ImportDeclaration: ELEMENT_LIST_SCHEMA,
				flatTernaryExpressions: {
					type: "boolean"
				},
				ignoredNodes: {
					type: "array",
					items: {
						type: "string",
						not: {
							pattern: ":exit$"
						}
					}
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var DEFAULT_VARIABLE_INDENT = 1;
		var DEFAULT_PARAMETER_INDENT = 1;
		var DEFAULT_FUNCTION_BODY_INDENT = 1;

		var indentType = "space";
		var indentSize = 4;
		var options = {
			SwitchCase: 0,
			VariableDeclarator: {
				var: DEFAULT_VARIABLE_INDENT,
				let: DEFAULT_VARIABLE_INDENT,
				const: DEFAULT_VARIABLE_INDENT
			},
			outerIIFEBody: 1,
			FunctionDeclaration: {
				parameters: DEFAULT_PARAMETER_INDENT,
				body: DEFAULT_FUNCTION_BODY_INDENT
			},
			FunctionExpression: {
				parameters: DEFAULT_PARAMETER_INDENT,
				body: DEFAULT_FUNCTION_BODY_INDENT
			},
			CallExpression: {
				arguments: DEFAULT_PARAMETER_INDENT
			},
			MemberExpression: 1,
			ArrayExpression: 1,
			ObjectExpression: 1,
			ImportDeclaration: 1,
			flatTernaryExpressions: false,
			ignoredNodes: []
		};

		if (context.options.length) {
			if (context.options[0] === "tab") {
				indentSize = 1;
				indentType = "tab";
			} else {
				indentSize = context.options[0];
				indentType = "space";
			}

			if (context.options[1]) {
				lodash.merge(options, context.options[1]);

				if (typeof options.VariableDeclarator === "number") {
					options.VariableDeclarator = {
						var: options.VariableDeclarator,
						let: options.VariableDeclarator,
						const: options.VariableDeclarator
					};
				}
			}
		}

		var sourceCode = context.getSourceCode();
		var tokenInfo = new TokenInfo(sourceCode);
		var offsets = new OffsetStorage(tokenInfo, indentSize, indentType === "space" ? " " : "\t");
		var parameterParens = new WeakSet();
		function createErrorMessage(expectedAmount, actualSpaces, actualTabs) {
			var expectedStatement = expectedAmount + " " + indentType + (expectedAmount === 1 ? "" : "s"); // e.g. "2 tabs"
			var foundSpacesWord = "space" + (actualSpaces === 1 ? "" : "s"); // e.g. "space"
			var foundTabsWord = "tab" + (actualTabs === 1 ? "" : "s"); // e.g. "tabs"
			var foundStatement = void 0;

			if (actualSpaces > 0) {
				foundStatement = indentType === "space" ? actualSpaces : actualSpaces + " " + foundSpacesWord;
			} else if (actualTabs > 0) {
				foundStatement = indentType === "tab" ? actualTabs : actualTabs + " " + foundTabsWord;
			} else {
				foundStatement = "0";
			}

			return "Expected indentation of " + expectedStatement + " but found " + foundStatement + ".";
		}
		function report(token, neededIndent) {
			var actualIndent = Array.from(tokenInfo.getTokenIndent(token));
			var numSpaces = actualIndent.filter(function (char) {
				return char === " ";
			}).length;
			var numTabs = actualIndent.filter(function (char) {
				return char === "\t";
			}).length;

			context.report({
				node: token,
				message: createErrorMessage(neededIndent.length, numSpaces, numTabs),
				loc: {
					start: { line: token.loc.start.line, column: 0 },
					end: { line: token.loc.start.line, column: token.loc.start.column }
				},
				fix: function fix(fixer) {
					var range = [token.range[0] - token.loc.start.column, token.range[0]];
					var newText = neededIndent;

					return fixer.replaceTextRange(range, newText);
				}
			});
		}
		function validateTokenIndent(token, desiredIndent) {
			var indentation = tokenInfo.getTokenIndent(token);

			return indentation === desiredIndent ||
			indentation.includes(" ") && indentation.includes("\t");
		}
		function isOuterIIFE(node) {
			if (!node.parent || node.parent.type !== "CallExpression" || node.parent.callee !== node) {
				return false;
			}
			var statement = node.parent && node.parent.parent;

			while (statement.type === "UnaryExpression" && ["!", "~", "+", "-"].indexOf(statement.operator) > -1 || statement.type === "AssignmentExpression" || statement.type === "LogicalExpression" || statement.type === "SequenceExpression" || statement.type === "VariableDeclarator") {
				statement = statement.parent;
			}

			return (statement.type === "ExpressionStatement" || statement.type === "VariableDeclaration") && statement.parent.type === "Program";
		}
		function addElementListIndent(elements, startToken, endToken, offset) {
			function getFirstToken(element) {
				var token = sourceCode.getTokenBefore(element);

				while (astUtils.isOpeningParenToken(token) && token !== startToken) {
					token = sourceCode.getTokenBefore(token);
				}
				return sourceCode.getTokenAfter(token);
			}
			offsets.setDesiredOffsets([startToken.range[1], endToken.range[0]], startToken, typeof offset === "number" ? offset : 1);
			offsets.setDesiredOffset(endToken, startToken, 0);
			if (offset === "first" && elements.length && !elements[0]) {
				return;
			}
			elements.forEach(function (element, index) {
				if (!element) {
					return;
				}
				if (offset === "off") {
					offsets.ignoreToken(getFirstToken(element));
				}
				if (index === 0) {
					return;
				}
				if (offset === "first" && tokenInfo.isFirstTokenOfLine(getFirstToken(element))) {
					offsets.matchOffsetOf(getFirstToken(elements[0]), getFirstToken(element));
				} else {
					var previousElement = elements[index - 1];
					var firstTokenOfPreviousElement = previousElement && getFirstToken(previousElement);

					if (previousElement && sourceCode.getLastToken(previousElement).loc.start.line > startToken.loc.end.line) {
						offsets.setDesiredOffsets(element.range, firstTokenOfPreviousElement, 0);
					}
				}
			});
		}
		function addBlocklessNodeIndent(node) {
			if (node.type !== "BlockStatement") {
				var lastParentToken = sourceCode.getTokenBefore(node, astUtils.isNotOpeningParenToken);

				var firstBodyToken = sourceCode.getFirstToken(node);
				var lastBodyToken = sourceCode.getLastToken(node);

				while (astUtils.isOpeningParenToken(sourceCode.getTokenBefore(firstBodyToken)) && astUtils.isClosingParenToken(sourceCode.getTokenAfter(lastBodyToken))) {
					firstBodyToken = sourceCode.getTokenBefore(firstBodyToken);
					lastBodyToken = sourceCode.getTokenAfter(lastBodyToken);
				}

				offsets.setDesiredOffsets([firstBodyToken.range[0], lastBodyToken.range[1]], lastParentToken, 1);
				var lastToken = sourceCode.getLastToken(node);

				if (node.type !== "EmptyStatement" && astUtils.isSemicolonToken(lastToken)) {
					offsets.setDesiredOffset(lastToken, lastParentToken, 0);
				}
			}
		}
		function addFunctionCallIndent(node) {
			var openingParen = void 0;

			if (node.arguments.length) {
				openingParen = sourceCode.getFirstTokenBetween(node.callee, node.arguments[0], astUtils.isOpeningParenToken);
			} else {
				openingParen = sourceCode.getLastToken(node, 1);
			}
			var closingParen = sourceCode.getLastToken(node);

			parameterParens.add(openingParen);
			parameterParens.add(closingParen);
			offsets.setDesiredOffset(openingParen, sourceCode.getTokenBefore(openingParen), 0);

			addElementListIndent(node.arguments, openingParen, closingParen, options.CallExpression.arguments);
		}
		function addParensIndent(tokens) {
			var parenStack = [];
			var parenPairs = [];

			tokens.forEach(function (nextToken) {
				if (astUtils.isOpeningParenToken(nextToken)) {
					parenStack.push(nextToken);
				} else if (astUtils.isClosingParenToken(nextToken)) {
					parenPairs.unshift({ left: parenStack.pop(), right: nextToken });
				}
			});

			parenPairs.forEach(function (pair) {
				var leftParen = pair.left;
				var rightParen = pair.right;
				if (!parameterParens.has(leftParen) && !parameterParens.has(rightParen)) {
					var parenthesizedTokens = new Set(sourceCode.getTokensBetween(leftParen, rightParen));

					parenthesizedTokens.forEach(function (token) {
						if (!parenthesizedTokens.has(offsets.getFirstDependency(token))) {
							offsets.setDesiredOffset(token, leftParen, 1);
						}
					});
				}

				offsets.setDesiredOffset(rightParen, leftParen, 0);
			});
		}
		function ignoreNode(node) {
			var unknownNodeTokens = new Set(sourceCode.getTokens(node, { includeComments: true }));

			unknownNodeTokens.forEach(function (token) {
				if (!unknownNodeTokens.has(offsets.getFirstDependency(token))) {
					var firstTokenOfLine = tokenInfo.getFirstTokenOfLine(token);

					if (token === firstTokenOfLine) {
						offsets.ignoreToken(token);
					} else {
						offsets.setDesiredOffset(token, firstTokenOfLine, 0);
					}
				}
			});
		}
		function isOnFirstLineOfStatement(token, leafNode) {
			var node = leafNode;

			while (node.parent && !node.parent.type.endsWith("Statement") && !node.parent.type.endsWith("Declaration")) {
				node = node.parent;
			}
			node = node.parent;

			return !node || node.loc.start.line === token.loc.start.line;
		}

		var baseOffsetListeners = {
			"ArrayExpression, ArrayPattern": function ArrayExpressionArrayPattern(node) {
				var openingBracket = sourceCode.getFirstToken(node);
				var closingBracket = sourceCode.getTokenAfter(lodash.findLast(node.elements) || openingBracket, astUtils.isClosingBracketToken);

				addElementListIndent(node.elements, openingBracket, closingBracket, options.ArrayExpression);
			},
			"ObjectExpression, ObjectPattern": function ObjectExpressionObjectPattern(node) {
				var openingCurly = sourceCode.getFirstToken(node);
				var closingCurly = sourceCode.getTokenAfter(node.properties.length ? node.properties[node.properties.length - 1] : openingCurly, astUtils.isClosingBraceToken);

				addElementListIndent(node.properties, openingCurly, closingCurly, options.ObjectExpression);
			},
			ArrowFunctionExpression: function ArrowFunctionExpression(node) {
				var firstToken = sourceCode.getFirstToken(node);

				if (astUtils.isOpeningParenToken(firstToken)) {
					var openingParen = firstToken;
					var closingParen = sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken);

					parameterParens.add(openingParen);
					parameterParens.add(closingParen);
					addElementListIndent(node.params, openingParen, closingParen, options.FunctionExpression.parameters);
				}
				addBlocklessNodeIndent(node.body);

				var arrowToken = void 0;

				if (node.params.length) {
					arrowToken = sourceCode.getTokenAfter(node.params[node.params.length - 1], astUtils.isArrowToken);
				} else {
					arrowToken = sourceCode.getFirstToken(node, astUtils.isArrowToken);
				}
				offsets.setDesiredOffset(arrowToken, sourceCode.getFirstToken(node), 0);
			},
			AssignmentExpression: function AssignmentExpression(node) {
				var operator = sourceCode.getFirstTokenBetween(node.left, node.right, function (token) {
					return token.value === node.operator;
				});

				offsets.setDesiredOffsets([operator.range[0], node.range[1]], sourceCode.getLastToken(node.left), 1);
				offsets.ignoreToken(operator);
				offsets.ignoreToken(sourceCode.getTokenAfter(operator));
			},
			"BinaryExpression, LogicalExpression": function BinaryExpressionLogicalExpression(node) {
				var operator = sourceCode.getFirstTokenBetween(node.left, node.right, function (token) {
					return token.value === node.operator;
				});

				var tokenAfterOperator = sourceCode.getTokenAfter(operator);

				offsets.ignoreToken(operator);
				offsets.ignoreToken(tokenAfterOperator);
				offsets.setDesiredOffset(tokenAfterOperator, operator, 0);
				offsets.setDesiredOffsets([tokenAfterOperator.range[1], node.range[1]], tokenAfterOperator, 1);
			},
			"BlockStatement, ClassBody": function BlockStatementClassBody(node) {

				var blockIndentLevel = void 0;

				if (node.parent && isOuterIIFE(node.parent)) {
					blockIndentLevel = options.outerIIFEBody;
				} else if (node.parent && (node.parent.type === "FunctionExpression" || node.parent.type === "ArrowFunctionExpression")) {
					blockIndentLevel = options.FunctionExpression.body;
				} else if (node.parent && node.parent.type === "FunctionDeclaration") {
					blockIndentLevel = options.FunctionDeclaration.body;
				} else {
					blockIndentLevel = 1;
				}
				if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {
					offsets.setDesiredOffset(sourceCode.getFirstToken(node), sourceCode.getFirstToken(node.parent), 0);
				}
				addElementListIndent(node.body, sourceCode.getFirstToken(node), sourceCode.getLastToken(node), blockIndentLevel);
			},


			CallExpression: addFunctionCallIndent,

			"ClassDeclaration[superClass], ClassExpression[superClass]": function ClassDeclarationSuperClassClassExpressionSuperClass(node) {
				var classToken = sourceCode.getFirstToken(node);
				var extendsToken = sourceCode.getTokenBefore(node.superClass, astUtils.isNotOpeningParenToken);

				offsets.setDesiredOffsets([extendsToken.range[0], node.body.range[0]], classToken, 1);
			},
			ConditionalExpression: function ConditionalExpression(node) {
				var firstToken = sourceCode.getFirstToken(node);
				if (!options.flatTernaryExpressions || !astUtils.isTokenOnSameLine(node.test, node.consequent) || isOnFirstLineOfStatement(firstToken, node)) {
					var questionMarkToken = sourceCode.getFirstTokenBetween(node.test, node.consequent, function (token) {
						return token.type === "Punctuator" && token.value === "?";
					});
					var colonToken = sourceCode.getFirstTokenBetween(node.consequent, node.alternate, function (token) {
						return token.type === "Punctuator" && token.value === ":";
					});

					var firstConsequentToken = sourceCode.getTokenAfter(questionMarkToken, { includeComments: true });
					var lastConsequentToken = sourceCode.getTokenBefore(colonToken, { includeComments: true });
					var firstAlternateToken = sourceCode.getTokenAfter(colonToken);

					offsets.setDesiredOffset(questionMarkToken, firstToken, 1);
					offsets.setDesiredOffset(colonToken, firstToken, 1);

					offsets.setDesiredOffset(firstConsequentToken, firstToken, 1);
					if (lastConsequentToken.loc.end.line === firstAlternateToken.loc.start.line) {
						offsets.setDesiredOffset(firstAlternateToken, firstConsequentToken, 0);
					} else {
						offsets.setDesiredOffset(firstAlternateToken, firstToken, 1);
					}

					offsets.setDesiredOffsets([questionMarkToken.range[1], colonToken.range[0]], firstConsequentToken, 0);
					offsets.setDesiredOffsets([colonToken.range[1], node.range[1]], firstAlternateToken, 0);
				}
			},


			"DoWhileStatement, WhileStatement, ForInStatement, ForOfStatement": function DoWhileStatementWhileStatementForInStatementForOfStatement(node) {
				return addBlocklessNodeIndent(node.body);
			},

			ExportNamedDeclaration: function ExportNamedDeclaration(node) {
				if (node.declaration === null) {
					var closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);
					addElementListIndent(node.specifiers, sourceCode.getFirstToken(node, { skip: 1 }), closingCurly, 1);

					if (node.source) {
						offsets.setDesiredOffsets([closingCurly.range[1], node.range[1]], sourceCode.getFirstToken(node), 1);
					}
				}
			},
			ForStatement: function ForStatement(node) {
				var forOpeningParen = sourceCode.getFirstToken(node, 1);

				if (node.init) {
					offsets.setDesiredOffsets(node.init.range, forOpeningParen, 1);
				}
				if (node.test) {
					offsets.setDesiredOffsets(node.test.range, forOpeningParen, 1);
				}
				if (node.update) {
					offsets.setDesiredOffsets(node.update.range, forOpeningParen, 1);
				}
				addBlocklessNodeIndent(node.body);
			},
			"FunctionDeclaration, FunctionExpression": function FunctionDeclarationFunctionExpression(node) {
				var closingParen = sourceCode.getTokenBefore(node.body);
				var openingParen = sourceCode.getTokenBefore(node.params.length ? node.params[0] : closingParen);

				parameterParens.add(openingParen);
				parameterParens.add(closingParen);
				addElementListIndent(node.params, openingParen, closingParen, options[node.type].parameters);
			},
			IfStatement: function IfStatement(node) {
				addBlocklessNodeIndent(node.consequent);
				if (node.alternate && node.alternate.type !== "IfStatement") {
					addBlocklessNodeIndent(node.alternate);
				}
			},
			ImportDeclaration: function ImportDeclaration(node) {
				if (node.specifiers.some(function (specifier) {
					return specifier.type === "ImportSpecifier";
				})) {
					var openingCurly = sourceCode.getFirstToken(node, astUtils.isOpeningBraceToken);
					var closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);

					addElementListIndent(node.specifiers.filter(function (specifier) {
						return specifier.type === "ImportSpecifier";
					}), openingCurly, closingCurly, options.ImportDeclaration);
				}

				var fromToken = sourceCode.getLastToken(node, function (token) {
					return token.type === "Identifier" && token.value === "from";
				});

				if (fromToken) {
					offsets.setDesiredOffsets([fromToken.range[0], node.range[1]], sourceCode.getFirstToken(node), 1);
				}
			},
			"MemberExpression, JSXMemberExpression, MetaProperty": function MemberExpressionJSXMemberExpressionMetaProperty(node) {
				var object = node.type === "MetaProperty" ? node.meta : node.object;
				var firstNonObjectToken = sourceCode.getFirstTokenBetween(object, node.property, astUtils.isNotClosingParenToken);
				var secondNonObjectToken = sourceCode.getTokenAfter(firstNonObjectToken);

				var objectParenCount = sourceCode.getTokensBetween(object, node.property, { filter: astUtils.isClosingParenToken }).length;
				var firstObjectToken = objectParenCount ? sourceCode.getTokenBefore(object, { skip: objectParenCount - 1 }) : sourceCode.getFirstToken(object);
				var lastObjectToken = sourceCode.getTokenBefore(firstNonObjectToken);
				var firstPropertyToken = node.computed ? firstNonObjectToken : secondNonObjectToken;

				if (node.computed) {
					offsets.setDesiredOffset(sourceCode.getLastToken(node), firstNonObjectToken, 0);
					offsets.setDesiredOffsets(node.property.range, firstNonObjectToken, 1);
				}
				var offsetBase = lastObjectToken.loc.end.line === firstPropertyToken.loc.start.line ? lastObjectToken : firstObjectToken;

				if (typeof options.MemberExpression === "number") {
					offsets.setDesiredOffset(firstNonObjectToken, offsetBase, options.MemberExpression);
					offsets.setDesiredOffset(secondNonObjectToken, node.computed ? firstNonObjectToken : offsetBase, options.MemberExpression);
				} else {
					offsets.ignoreToken(firstNonObjectToken);
					offsets.ignoreToken(secondNonObjectToken);
					offsets.setDesiredOffset(firstNonObjectToken, offsetBase, 0);
					offsets.setDesiredOffset(secondNonObjectToken, firstNonObjectToken, 0);
				}
			},
			NewExpression: function NewExpression(node) {
				if (node.arguments.length > 0 || astUtils.isClosingParenToken(sourceCode.getLastToken(node)) && astUtils.isOpeningParenToken(sourceCode.getLastToken(node, 1))) {
					addFunctionCallIndent(node);
				}
			},
			Property: function Property(node) {
				if (!node.shorthand && !node.method && node.kind === "init") {
					var colon = sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isColonToken);

					offsets.ignoreToken(sourceCode.getTokenAfter(colon));
				}
			},
			SwitchStatement: function SwitchStatement(node) {
				var openingCurly = sourceCode.getTokenAfter(node.discriminant, astUtils.isOpeningBraceToken);
				var closingCurly = sourceCode.getLastToken(node);
				var caseKeywords = node.cases.map(function (switchCase) {
					return sourceCode.getFirstToken(switchCase);
				});

				offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, options.SwitchCase);

				node.cases.forEach(function (switchCase, index) {
					var caseKeyword = caseKeywords[index];

					if (!(switchCase.consequent.length === 1 && switchCase.consequent[0].type === "BlockStatement")) {
						var tokenAfterCurrentCase = index === node.cases.length - 1 ? closingCurly : caseKeywords[index + 1];

						offsets.setDesiredOffsets([caseKeyword.range[1], tokenAfterCurrentCase.range[0]], caseKeyword, 1);
					}
				});

				if (node.cases.length) {
					sourceCode.getTokensBetween(node.cases[node.cases.length - 1], closingCurly, { includeComments: true, filter: astUtils.isCommentToken }).forEach(function (token) {
						return offsets.ignoreToken(token);
					});
				}
			},
			TemplateLiteral: function TemplateLiteral(node) {
				node.expressions.forEach(function (expression, index) {
					var previousQuasi = node.quasis[index];
					var nextQuasi = node.quasis[index + 1];
					var tokenToAlignFrom = previousQuasi.loc.start.line === previousQuasi.loc.end.line ? sourceCode.getFirstToken(previousQuasi) : null;

					offsets.setDesiredOffsets([previousQuasi.range[1], nextQuasi.range[0]], tokenToAlignFrom, 1);
					offsets.setDesiredOffset(sourceCode.getFirstToken(nextQuasi), tokenToAlignFrom, 0);
				});
			},
			VariableDeclaration: function VariableDeclaration(node) {
				var variableIndent = options.VariableDeclarator.hasOwnProperty(node.kind) ? options.VariableDeclarator[node.kind] : DEFAULT_VARIABLE_INDENT;

				if (node.declarations[node.declarations.length - 1].loc.start.line > node.loc.start.line) {
					var firstToken = sourceCode.getFirstToken(node);

					offsets.setDesiredOffsets(node.range, firstToken, variableIndent, true);
				} else {
					offsets.setDesiredOffsets(node.range, sourceCode.getFirstToken(node), variableIndent);
				}
				var lastToken = sourceCode.getLastToken(node);

				if (astUtils.isSemicolonToken(lastToken)) {
					offsets.ignoreToken(lastToken);
				}
			},
			VariableDeclarator: function VariableDeclarator(node) {
				if (node.init) {
					var equalOperator = sourceCode.getTokenBefore(node.init, astUtils.isNotOpeningParenToken);
					var tokenAfterOperator = sourceCode.getTokenAfter(equalOperator);

					offsets.ignoreToken(equalOperator);
					offsets.ignoreToken(tokenAfterOperator);
					offsets.setDesiredOffsets([tokenAfterOperator.range[0], node.range[1]], equalOperator, 1);
					offsets.setDesiredOffset(equalOperator, sourceCode.getLastToken(node.id), 0);
				}
			},
			"JSXAttribute[value]": function JSXAttributeValue(node) {
				var equalsToken = sourceCode.getFirstTokenBetween(node.name, node.value, function (token) {
					return token.type === "Punctuator" && token.value === "=";
				});

				offsets.setDesiredOffsets([equalsToken.range[0], node.value.range[1]], sourceCode.getFirstToken(node.name), 1);
			},
			JSXElement: function JSXElement(node) {
				if (node.closingElement) {
					addElementListIndent(node.children, sourceCode.getFirstToken(node.openingElement), sourceCode.getFirstToken(node.closingElement), 1);
				}
			},
			JSXOpeningElement: function JSXOpeningElement(node) {
				var firstToken = sourceCode.getFirstToken(node);
				var closingToken = void 0;

				if (node.selfClosing) {
					closingToken = sourceCode.getLastToken(node, { skip: 1 });
					offsets.setDesiredOffset(sourceCode.getLastToken(node), closingToken, 0);
				} else {
					closingToken = sourceCode.getLastToken(node);
				}
				offsets.setDesiredOffsets(node.name.range, sourceCode.getFirstToken(node));
				addElementListIndent(node.attributes, firstToken, closingToken, 1);
			},
			JSXClosingElement: function JSXClosingElement(node) {
				var firstToken = sourceCode.getFirstToken(node);

				offsets.setDesiredOffsets(node.name.range, firstToken, 1);
				offsets.setDesiredOffset(sourceCode.getLastToken(node), firstToken, 0);
			},
			JSXExpressionContainer: function JSXExpressionContainer(node) {
				var openingCurly = sourceCode.getFirstToken(node);
				var closingCurly = sourceCode.getLastToken(node);

				offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, 1);
				offsets.setDesiredOffset(closingCurly, openingCurly, 0);
			}
		};

		var listenerCallQueue = [];
		var offsetListeners = lodash.mapValues(baseOffsetListeners,
		function (listener) {
			return function (node) {
				return listenerCallQueue.push({ listener: listener, node: node });
			};
		});
		var ignoredNodes = new Set();
		var addToIgnoredNodes = ignoredNodes.add.bind(ignoredNodes);

		var ignoredNodeListeners = options.ignoredNodes.reduce(function (listeners, ignoredSelector) {
			return Object.assign(listeners, _defineProperty({}, ignoredSelector, addToIgnoredNodes));
		}, {});
		return Object.assign(offsetListeners, ignoredNodeListeners, {
			"*:exit": function exit(node) {
				if (!KNOWN_NODES.has(node.type)) {
					ignoredNodes.add(node);
				}
			},
			"Program:exit": function ProgramExit() {
				listenerCallQueue.filter(function (nodeInfo) {
					return !ignoredNodes.has(nodeInfo.node);
				}).forEach(function (nodeInfo) {
					return nodeInfo.listener(nodeInfo.node);
				});
				ignoredNodes.forEach(ignoreNode);

				addParensIndent(sourceCode.ast.tokens);
				var precedingTokens = sourceCode.ast.comments.reduce(function (commentMap, comment) {
					var tokenOrCommentBefore = sourceCode.getTokenBefore(comment, { includeComments: true });

					return commentMap.set(comment, commentMap.has(tokenOrCommentBefore) ? commentMap.get(tokenOrCommentBefore) : tokenOrCommentBefore);
				}, new WeakMap());

				sourceCode.lines.forEach(function (line, lineIndex) {
					var lineNumber = lineIndex + 1;

					if (!tokenInfo.firstTokensByLineNumber.has(lineNumber)) {
						return;
					}

					var firstTokenOfLine = tokenInfo.firstTokensByLineNumber.get(lineNumber);

					if (firstTokenOfLine.loc.start.line !== lineNumber) {
						return;
					}
					if (validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine))) {
						return;
					}

					if (astUtils.isCommentToken(firstTokenOfLine)) {
						var tokenBefore = precedingTokens.get(firstTokenOfLine);
						var tokenAfter = tokenBefore ? sourceCode.getTokenAfter(tokenBefore) : sourceCode.ast.tokens[0];
						if (tokenBefore && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenBefore)) || tokenAfter && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenAfter))) {
							return;
						}
					}
					report(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine));
				});
			}
		});
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = createRBTree;

var RED = 0;
var BLACK = 1;

function RBNode(color, key, value, left, right, count) {
  this._color = color;
  this.key = key;
  this.value = value;
  this.left = left;
  this.right = right;
  this._count = count;
}

function cloneNode(node) {
  return new RBNode(node._color, node.key, node.value, node.left, node.right, node._count);
}

function repaint(color, node) {
  return new RBNode(color, node.key, node.value, node.left, node.right, node._count);
}

function recount(node) {
  node._count = 1 + (node.left ? node.left._count : 0) + (node.right ? node.right._count : 0);
}

function RedBlackTree(compare, root) {
  this._compare = compare;
  this.root = root;
}

var proto = RedBlackTree.prototype;

Object.defineProperty(proto, "keys", {
  get: function get() {
	var result = [];
	this.forEach(function (k, v) {
			result.push(k);
	});
	return result;
  }
});

Object.defineProperty(proto, "values", {
  get: function get() {
	var result = [];
	this.forEach(function (k, v) {
			result.push(v);
	});
	return result;
  }
});
Object.defineProperty(proto, "length", {
  get: function get() {
	if (this.root) {
			return this.root._count;
	}
	return 0;
  }
});
proto.insert = function (key, value) {
  var cmp = this._compare;
  var n = this.root;
  var n_stack = [];
  var d_stack = [];
  while (n) {
	var d = cmp(key, n.key);
	n_stack.push(n);
	d_stack.push(d);
	if (d <= 0) {
			n = n.left;
	} else {
			n = n.right;
	}
  }
  n_stack.push(new RBNode(RED, key, value, null, null, 1));
  for (var s = n_stack.length - 2; s >= 0; --s) {
	var n = n_stack[s];
	if (d_stack[s] <= 0) {
			n_stack[s] = new RBNode(n._color, n.key, n.value, n_stack[s + 1], n.right, n._count + 1);
	} else {
			n_stack[s] = new RBNode(n._color, n.key, n.value, n.left, n_stack[s + 1], n._count + 1);
	}
  }
  for (var s = n_stack.length - 1; s > 1; --s) {
	var p = n_stack[s - 1];
	var n = n_stack[s];
	if (p._color === BLACK || n._color === BLACK) {
			break;
	}
	var pp = n_stack[s - 2];
	if (pp.left === p) {
			if (p.left === n) {
		var y = pp.right;
		if (y && y._color === RED) {
					p._color = BLACK;
					pp.right = repaint(BLACK, y);
					pp._color = RED;
					s -= 1;
		} else {
					pp._color = RED;
					pp.left = p.right;
					p._color = BLACK;
					p.right = pp;
					n_stack[s - 2] = p;
					n_stack[s - 1] = n;
					recount(pp);
					recount(p);
					if (s >= 3) {
			var ppp = n_stack[s - 3];
			if (ppp.left === pp) {
							ppp.left = p;
			} else {
							ppp.right = p;
			}
					}
					break;
		}
			} else {
		var y = pp.right;
		if (y && y._color === RED) {
					p._color = BLACK;
					pp.right = repaint(BLACK, y);
					pp._color = RED;
					s -= 1;
		} else {
					p.right = n.left;
					pp._color = RED;
					pp.left = n.right;
					n._color = BLACK;
					n.left = p;
					n.right = pp;
					n_stack[s - 2] = n;
					n_stack[s - 1] = p;
					recount(pp);
					recount(p);
					recount(n);
					if (s >= 3) {
			var ppp = n_stack[s - 3];
			if (ppp.left === pp) {
							ppp.left = n;
			} else {
							ppp.right = n;
			}
					}
					break;
		}
			}
	} else {
			if (p.right === n) {
		var y = pp.left;
		if (y && y._color === RED) {
					p._color = BLACK;
					pp.left = repaint(BLACK, y);
					pp._color = RED;
					s -= 1;
		} else {
					pp._color = RED;
					pp.right = p.left;
					p._color = BLACK;
					p.left = pp;
					n_stack[s - 2] = p;
					n_stack[s - 1] = n;
					recount(pp);
					recount(p);
					if (s >= 3) {
			var ppp = n_stack[s - 3];
			if (ppp.right === pp) {
							ppp.right = p;
			} else {
							ppp.left = p;
			}
					}
					break;
		}
			} else {
		var y = pp.left;
		if (y && y._color === RED) {
					p._color = BLACK;
					pp.left = repaint(BLACK, y);
					pp._color = RED;
					s -= 1;
		} else {
					p.left = n.right;
					pp._color = RED;
					pp.right = n.left;
					n._color = BLACK;
					n.right = p;
					n.left = pp;
					n_stack[s - 2] = n;
					n_stack[s - 1] = p;
					recount(pp);
					recount(p);
					recount(n);
					if (s >= 3) {
			var ppp = n_stack[s - 3];
			if (ppp.right === pp) {
							ppp.right = n;
			} else {
							ppp.left = n;
			}
					}
					break;
		}
			}
	}
  }
  n_stack[0]._color = BLACK;
  return new RedBlackTree(cmp, n_stack[0]);
};
function doVisitFull(visit, node) {
  if (node.left) {
	var v = doVisitFull(visit, node.left);
	if (v) {
			return v;
	}
  }
  var v = visit(node.key, node.value);
  if (v) {
	return v;
  }
  if (node.right) {
	return doVisitFull(visit, node.right);
  }
}
function doVisitHalf(lo, compare, visit, node) {
  var l = compare(lo, node.key);
  if (l <= 0) {
	if (node.left) {
			var v = doVisitHalf(lo, compare, visit, node.left);
			if (v) {
		return v;
			}
	}
	var v = visit(node.key, node.value);
	if (v) {
			return v;
	}
  }
  if (node.right) {
	return doVisitHalf(lo, compare, visit, node.right);
  }
}
function doVisit(lo, hi, compare, visit, node) {
  var l = compare(lo, node.key);
  var h = compare(hi, node.key);
  var v;
  if (l <= 0) {
	if (node.left) {
			v = doVisit(lo, hi, compare, visit, node.left);
			if (v) {
		return v;
			}
	}
	if (h > 0) {
			v = visit(node.key, node.value);
			if (v) {
		return v;
			}
	}
  }
  if (h > 0 && node.right) {
	return doVisit(lo, hi, compare, visit, node.right);
  }
}

proto.forEach = function rbTreeForEach(visit, lo, hi) {
  if (!this.root) {
	return;
  }
  switch (arguments.length) {
	case 1:
			return doVisitFull(visit, this.root);
			break;

	case 2:
			return doVisitHalf(lo, this._compare, visit, this.root);
			break;

	case 3:
			if (this._compare(lo, hi) >= 0) {
		return;
			}
			return doVisit(lo, hi, this._compare, visit, this.root);
			break;
  }
};
Object.defineProperty(proto, "begin", {
  get: function get() {
	var stack = [];
	var n = this.root;
	while (n) {
			stack.push(n);
			n = n.left;
	}
	return new RedBlackTreeIterator(this, stack);
  }
});
Object.defineProperty(proto, "end", {
  get: function get() {
	var stack = [];
	var n = this.root;
	while (n) {
			stack.push(n);
			n = n.right;
	}
	return new RedBlackTreeIterator(this, stack);
  }
});
proto.at = function (idx) {
  if (idx < 0) {
	return new RedBlackTreeIterator(this, []);
  }
  var n = this.root;
  var stack = [];
  while (true) {
	stack.push(n);
	if (n.left) {
			if (idx < n.left._count) {
		n = n.left;
		continue;
			}
			idx -= n.left._count;
	}
	if (!idx) {
			return new RedBlackTreeIterator(this, stack);
	}
	idx -= 1;
	if (n.right) {
			if (idx >= n.right._count) {
		break;
			}
			n = n.right;
	} else {
			break;
	}
  }
  return new RedBlackTreeIterator(this, []);
};

proto.ge = function (key) {
  var cmp = this._compare;
  var n = this.root;
  var stack = [];
  var last_ptr = 0;
  while (n) {
	var d = cmp(key, n.key);
	stack.push(n);
	if (d <= 0) {
			last_ptr = stack.length;
	}
	if (d <= 0) {
			n = n.left;
	} else {
			n = n.right;
	}
  }
  stack.length = last_ptr;
  return new RedBlackTreeIterator(this, stack);
};

proto.gt = function (key) {
  var cmp = this._compare;
  var n = this.root;
  var stack = [];
  var last_ptr = 0;
  while (n) {
	var d = cmp(key, n.key);
	stack.push(n);
	if (d < 0) {
			last_ptr = stack.length;
	}
	if (d < 0) {
			n = n.left;
	} else {
			n = n.right;
	}
  }
  stack.length = last_ptr;
  return new RedBlackTreeIterator(this, stack);
};

proto.lt = function (key) {
  var cmp = this._compare;
  var n = this.root;
  var stack = [];
  var last_ptr = 0;
  while (n) {
	var d = cmp(key, n.key);
	stack.push(n);
	if (d > 0) {
			last_ptr = stack.length;
	}
	if (d <= 0) {
			n = n.left;
	} else {
			n = n.right;
	}
  }
  stack.length = last_ptr;
  return new RedBlackTreeIterator(this, stack);
};

proto.le = function (key) {
  var cmp = this._compare;
  var n = this.root;
  var stack = [];
  var last_ptr = 0;
  while (n) {
	var d = cmp(key, n.key);
	stack.push(n);
	if (d >= 0) {
			last_ptr = stack.length;
	}
	if (d < 0) {
			n = n.left;
	} else {
			n = n.right;
	}
  }
  stack.length = last_ptr;
  return new RedBlackTreeIterator(this, stack);
};
proto.find = function (key) {
  var cmp = this._compare;
  var n = this.root;
  var stack = [];
  while (n) {
	var d = cmp(key, n.key);
	stack.push(n);
	if (d === 0) {
			return new RedBlackTreeIterator(this, stack);
	}
	if (d <= 0) {
			n = n.left;
	} else {
			n = n.right;
	}
  }
  return new RedBlackTreeIterator(this, []);
};
proto.remove = function (key) {
  var iter = this.find(key);
  if (iter) {
	return iter.remove();
  }
  return this;
};
proto.get = function (key) {
  var cmp = this._compare;
  var n = this.root;
  while (n) {
	var d = cmp(key, n.key);
	if (d === 0) {
			return n.value;
	}
	if (d <= 0) {
			n = n.left;
	} else {
			n = n.right;
	}
  }
  return;
};
function RedBlackTreeIterator(tree, stack) {
  this.tree = tree;
  this._stack = stack;
}

var iproto = RedBlackTreeIterator.prototype;
Object.defineProperty(iproto, "valid", {
  get: function get() {
	return this._stack.length > 0;
  }
});
Object.defineProperty(iproto, "node", {
  get: function get() {
	if (this._stack.length > 0) {
			return this._stack[this._stack.length - 1];
	}
	return null;
  },
  enumerable: true
});
iproto.clone = function () {
  return new RedBlackTreeIterator(this.tree, this._stack.slice());
};
function swapNode(n, v) {
  n.key = v.key;
  n.value = v.value;
  n.left = v.left;
  n.right = v.right;
  n._color = v._color;
  n._count = v._count;
}
function fixDoubleBlack(stack) {
  var n, p, s, z;
  for (var i = stack.length - 1; i >= 0; --i) {
	n = stack[i];
	if (i === 0) {
			n._color = BLACK;
			return;
	}
	p = stack[i - 1];
	if (p.left === n) {
			s = p.right;
			if (s.right && s.right._color === RED) {
		s = p.right = cloneNode(s);
		z = s.right = cloneNode(s.right);
		p.right = s.left;
		s.left = p;
		s.right = z;
		s._color = p._color;
		n._color = BLACK;
		p._color = BLACK;
		z._color = BLACK;
		recount(p);
		recount(s);
		if (i > 1) {
					var pp = stack[i - 2];
					if (pp.left === p) {
			pp.left = s;
					} else {
			pp.right = s;
					}
		}
		stack[i - 1] = s;
		return;
			} else if (s.left && s.left._color === RED) {
		s = p.right = cloneNode(s);
		z = s.left = cloneNode(s.left);
		p.right = z.left;
		s.left = z.right;
		z.left = p;
		z.right = s;
		z._color = p._color;
		p._color = BLACK;
		s._color = BLACK;
		n._color = BLACK;
		recount(p);
		recount(s);
		recount(z);
		if (i > 1) {
					var pp = stack[i - 2];
					if (pp.left === p) {
			pp.left = z;
					} else {
			pp.right = z;
					}
		}
		stack[i - 1] = z;
		return;
			}
			if (s._color === BLACK) {
		if (p._color === RED) {
					p._color = BLACK;
					p.right = repaint(RED, s);
					return;
		} else {
					p.right = repaint(RED, s);
					continue;
		}
			} else {
		s = cloneNode(s);
		p.right = s.left;
		s.left = p;
		s._color = p._color;
		p._color = RED;
		recount(p);
		recount(s);
		if (i > 1) {
					var pp = stack[i - 2];
					if (pp.left === p) {
			pp.left = s;
					} else {
			pp.right = s;
					}
		}
		stack[i - 1] = s;
		stack[i] = p;
		if (i + 1 < stack.length) {
					stack[i + 1] = n;
		} else {
					stack.push(n);
		}
		i = i + 2;
			}
	} else {
			s = p.left;
			if (s.left && s.left._color === RED) {
		s = p.left = cloneNode(s);
		z = s.left = cloneNode(s.left);
		p.left = s.right;
		s.right = p;
		s.left = z;
		s._color = p._color;
		n._color = BLACK;
		p._color = BLACK;
		z._color = BLACK;
		recount(p);
		recount(s);
		if (i > 1) {
					var pp = stack[i - 2];
					if (pp.right === p) {
			pp.right = s;
					} else {
			pp.left = s;
					}
		}
		stack[i - 1] = s;
		return;
			} else if (s.right && s.right._color === RED) {
		s = p.left = cloneNode(s);
		z = s.right = cloneNode(s.right);
		p.left = z.right;
		s.right = z.left;
		z.right = p;
		z.left = s;
		z._color = p._color;
		p._color = BLACK;
		s._color = BLACK;
		n._color = BLACK;
		recount(p);
		recount(s);
		recount(z);
		if (i > 1) {
					var pp = stack[i - 2];
					if (pp.right === p) {
			pp.right = z;
					} else {
			pp.left = z;
					}
		}
		stack[i - 1] = z;
		return;
			}
			if (s._color === BLACK) {
		if (p._color === RED) {
					p._color = BLACK;
					p.left = repaint(RED, s);
					return;
		} else {
					p.left = repaint(RED, s);
					continue;
		}
			} else {
		s = cloneNode(s);
		p.left = s.right;
		s.right = p;
		s._color = p._color;
		p._color = RED;
		recount(p);
		recount(s);
		if (i > 1) {
					var pp = stack[i - 2];
					if (pp.right === p) {
			pp.right = s;
					} else {
			pp.left = s;
					}
		}
		stack[i - 1] = s;
		stack[i] = p;
		if (i + 1 < stack.length) {
					stack[i + 1] = n;
		} else {
					stack.push(n);
		}
		i = i + 2;
			}
	}
  }
}
iproto.remove = function () {
  var stack = this._stack;
  if (stack.length === 0) {
	return this.tree;
  }
  var cstack = new Array(stack.length);
  var n = stack[stack.length - 1];
  cstack[cstack.length - 1] = new RBNode(n._color, n.key, n.value, n.left, n.right, n._count);
  for (var i = stack.length - 2; i >= 0; --i) {
	var n = stack[i];
	if (n.left === stack[i + 1]) {
			cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i + 1], n.right, n._count);
	} else {
			cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
	}
  }
  n = cstack[cstack.length - 1];
  if (n.left && n.right) {
	var split = cstack.length;
	n = n.left;
	while (n.right) {
			cstack.push(n);
			n = n.right;
	}
	var v = cstack[split - 1];
	cstack.push(new RBNode(n._color, v.key, v.value, n.left, n.right, n._count));
	cstack[split - 1].key = n.key;
	cstack[split - 1].value = n.value;
	for (var i = cstack.length - 2; i >= split; --i) {
			n = cstack[i];
			cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
	}
	cstack[split - 1].left = cstack[split];
  }
  n = cstack[cstack.length - 1];
  if (n._color === RED) {
	var p = cstack[cstack.length - 2];
	if (p.left === n) {
			p.left = null;
	} else if (p.right === n) {
			p.right = null;
	}
	cstack.pop();
	for (var i = 0; i < cstack.length; ++i) {
			cstack[i]._count--;
	}
	return new RedBlackTree(this.tree._compare, cstack[0]);
  } else {
	if (n.left || n.right) {
			if (n.left) {
		swapNode(n, n.left);
			} else if (n.right) {
		swapNode(n, n.right);
			}
			n._color = BLACK;
			for (var i = 0; i < cstack.length - 1; ++i) {
		cstack[i]._count--;
			}
			return new RedBlackTree(this.tree._compare, cstack[0]);
	} else if (cstack.length === 1) {
			return new RedBlackTree(this.tree._compare, null);
	} else {
			for (var i = 0; i < cstack.length; ++i) {
		cstack[i]._count--;
			}
			var parent = cstack[cstack.length - 2];
			fixDoubleBlack(cstack);
			if (parent.left === n) {
		parent.left = null;
			} else {
		parent.right = null;
			}
	}
  }
  return new RedBlackTree(this.tree._compare, cstack[0]);
};
Object.defineProperty(iproto, "key", {
  get: function get() {
	if (this._stack.length > 0) {
			return this._stack[this._stack.length - 1].key;
	}
	return;
  },
  enumerable: true
});
Object.defineProperty(iproto, "value", {
  get: function get() {
	if (this._stack.length > 0) {
			return this._stack[this._stack.length - 1].value;
	}
	return;
  },
  enumerable: true
});
Object.defineProperty(iproto, "index", {
  get: function get() {
	var idx = 0;
	var stack = this._stack;
	if (stack.length === 0) {
			var r = this.tree.root;
			if (r) {
		return r._count;
			}
			return 0;
	} else if (stack[stack.length - 1].left) {
			idx = stack[stack.length - 1].left._count;
	}
	for (var s = stack.length - 2; s >= 0; --s) {
			if (stack[s + 1] === stack[s].right) {
		++idx;
		if (stack[s].left) {
					idx += stack[s].left._count;
		}
			}
	}
	return idx;
  },
  enumerable: true
});
iproto.next = function () {
  var stack = this._stack;
  if (stack.length === 0) {
	return;
  }
  var n = stack[stack.length - 1];
  if (n.right) {
	n = n.right;
	while (n) {
			stack.push(n);
			n = n.left;
	}
  } else {
	stack.pop();
	while (stack.length > 0 && stack[stack.length - 1].right === n) {
			n = stack[stack.length - 1];
			stack.pop();
	}
  }
};
Object.defineProperty(iproto, "hasNext", {
  get: function get() {
	var stack = this._stack;
	if (stack.length === 0) {
			return false;
	}
	if (stack[stack.length - 1].right) {
			return true;
	}
	for (var s = stack.length - 1; s > 0; --s) {
			if (stack[s - 1].left === stack[s]) {
		return true;
			}
	}
	return false;
  }
});
iproto.update = function (value) {
  var stack = this._stack;
  if (stack.length === 0) {
	throw new Error("Can't update empty node!");
  }
  var cstack = new Array(stack.length);
  var n = stack[stack.length - 1];
  cstack[cstack.length - 1] = new RBNode(n._color, n.key, value, n.left, n.right, n._count);
  for (var i = stack.length - 2; i >= 0; --i) {
	n = stack[i];
	if (n.left === stack[i + 1]) {
			cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i + 1], n.right, n._count);
	} else {
			cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
	}
  }
  return new RedBlackTree(this.tree._compare, cstack[0]);
};
iproto.prev = function () {
  var stack = this._stack;
  if (stack.length === 0) {
	return;
  }
  var n = stack[stack.length - 1];
  if (n.left) {
	n = n.left;
	while (n) {
			stack.push(n);
			n = n.right;
	}
  } else {
	stack.pop();
	while (stack.length > 0 && stack[stack.length - 1].left === n) {
			n = stack[stack.length - 1];
			stack.pop();
	}
  }
};
Object.defineProperty(iproto, "hasPrev", {
  get: function get() {
	var stack = this._stack;
	if (stack.length === 0) {
			return false;
	}
	if (stack[stack.length - 1].left) {
			return true;
	}
	for (var s = stack.length - 1; s > 0; --s) {
			if (stack[s - 1].right === stack[s]) {
		return true;
			}
	}
	return false;
  }
});
function defaultCompare(a, b) {
  if (a < b) {
	return -1;
  }
  if (a > b) {
	return 1;
  }
  return 0;
}
function createRBTree(compare) {
  return new RedBlackTree(compare || defaultCompare, null);
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function isForLoop(block) {
	return block.type === "ForInStatement" || block.type === "ForOfStatement" || block.type === "ForStatement";
}
function isInitialized(node) {
	var declaration = node.parent;
	var block = declaration.parent;

	if (isForLoop(block)) {
		if (block.type === "ForStatement") {
			return block.init === declaration;
		}
		return block.left === declaration;
	}
	return Boolean(node.init);
}
module.exports = {
	meta: {
		docs: {
			description: "require or disallow initialization in variable declarations",
			category: "Variables",
			recommended: false
		},

		schema: {
			anyOf: [{
				type: "array",
				items: [{
					enum: ["always"]
				}],
				minItems: 0,
				maxItems: 1
			}, {
				type: "array",
				items: [{
					enum: ["never"]
				}, {
					type: "object",
					properties: {
						ignoreForLoopInit: {
							type: "boolean"
						}
					},
					additionalProperties: false
				}],
				minItems: 0,
				maxItems: 2
			}]
		}
	},

	create: function create(context) {

		var MODE_ALWAYS = "always",
			MODE_NEVER = "never";

		var mode = context.options[0] || MODE_ALWAYS;
		var params = context.options[1] || {};
		return {
			"VariableDeclaration:exit": function VariableDeclarationExit(node) {

				var kind = node.kind,
					declarations = node.declarations;

				for (var i = 0; i < declarations.length; ++i) {
					var declaration = declarations[i],
						id = declaration.id,
						initialized = isInitialized(declaration),
						isIgnoredForLoop = params.ignoreForLoopInit && isForLoop(node.parent);

					if (id.type !== "Identifier") {
						continue;
					}

					if (mode === MODE_ALWAYS && !initialized) {
						context.report({
							node: declaration,
							message: "Variable '{{idName}}' should be initialized on declaration.",
							data: {
								idName: id.name
							}
						});
					} else if (mode === MODE_NEVER && kind !== "const" && initialized && !isIgnoredForLoop) {
						context.report({
							node: declaration,
							message: "Variable '{{idName}}' should not be initialized on declaration.",
							data: {
								idName: id.name
							}
						});
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
var QUOTE_SETTINGS = {
	"prefer-double": {
		quote: "\"",
		description: "singlequote",
		convert: function convert(str) {
			return str.replace(/'/g, "\"");
		}
	},
	"prefer-single": {
		quote: "'",
		description: "doublequote",
		convert: function convert(str) {
			return str.replace(/"/g, "'");
		}
	}
};
module.exports = {
	meta: {
		docs: {
			description: "enforce the consistent use of either double or single quotes in JSX attributes",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			enum: ["prefer-single", "prefer-double"]
		}]
	},

	create: function create(context) {
		var quoteOption = context.options[0] || "prefer-double",
			setting = QUOTE_SETTINGS[quoteOption];
		function usesExpectedQuotes(node) {
			return node.value.indexOf(setting.quote) !== -1 || astUtils.isSurroundedBy(node.raw, setting.quote);
		}

		return {
			JSXAttribute: function JSXAttribute(node) {
				var attributeValue = node.value;

				if (attributeValue && astUtils.isStringLiteral(attributeValue) && !usesExpectedQuotes(attributeValue)) {
					context.report({
						node: attributeValue,
						message: "Unexpected usage of {{description}}.",
						data: {
							description: setting.description
						},
						fix: function fix(fixer) {
							return fixer.replaceText(attributeValue, setting.convert(attributeValue.raw));
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var astUtils = __webpack_require__(0);
function containsLineTerminator(str) {
	return astUtils.LINEBREAK_MATCHER.test(str);
}
function last(arr) {
	return arr[arr.length - 1];
}
function isSingleLine(node) {
	return node.loc.end.line === node.loc.start.line;
}
function initOptionProperty(toOptions, fromOptions) {
	toOptions.mode = fromOptions.mode || "strict";
	if (typeof fromOptions.beforeColon !== "undefined") {
		toOptions.beforeColon = +fromOptions.beforeColon;
	} else {
		toOptions.beforeColon = 0;
	}
	if (typeof fromOptions.afterColon !== "undefined") {
		toOptions.afterColon = +fromOptions.afterColon;
	} else {
		toOptions.afterColon = 1;
	}
	if (typeof fromOptions.align !== "undefined") {
		if (_typeof(fromOptions.align) === "object") {
			toOptions.align = fromOptions.align;
		} else {
			toOptions.align = {
				on: fromOptions.align,
				mode: toOptions.mode,
				beforeColon: toOptions.beforeColon,
				afterColon: toOptions.afterColon
			};
		}
	}

	return toOptions;
}
function initOptions(toOptions, fromOptions) {
	if (_typeof(fromOptions.align) === "object") {
		toOptions.align = initOptionProperty({}, fromOptions.align);
		toOptions.align.on = fromOptions.align.on || "colon";
		toOptions.align.mode = fromOptions.align.mode || "strict";

		toOptions.multiLine = initOptionProperty({}, fromOptions.multiLine || fromOptions);
		toOptions.singleLine = initOptionProperty({}, fromOptions.singleLine || fromOptions);
	} else {
		toOptions.multiLine = initOptionProperty({}, fromOptions.multiLine || fromOptions);
		toOptions.singleLine = initOptionProperty({}, fromOptions.singleLine || fromOptions);
		if (toOptions.multiLine.align) {
			toOptions.align = {
				on: toOptions.multiLine.align.on,
				mode: toOptions.multiLine.align.mode || toOptions.multiLine.mode,
				beforeColon: toOptions.multiLine.align.beforeColon,
				afterColon: toOptions.multiLine.align.afterColon
			};
		}
	}

	return toOptions;
}
var messages = {
	key: "{{error}} space after {{computed}}key '{{key}}'.",
	value: "{{error}} space before value for {{computed}}key '{{key}}'."
};

module.exports = {
	meta: {
		docs: {
			description: "enforce consistent spacing between keys and values in object literal properties",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			anyOf: [{
				type: "object",
				properties: {
					align: {
						anyOf: [{
							enum: ["colon", "value"]
						}, {
							type: "object",
							properties: {
								mode: {
									enum: ["strict", "minimum"]
								},
								on: {
									enum: ["colon", "value"]
								},
								beforeColon: {
									type: "boolean"
								},
								afterColon: {
									type: "boolean"
								}
							},
							additionalProperties: false
						}]
					},
					mode: {
						enum: ["strict", "minimum"]
					},
					beforeColon: {
						type: "boolean"
					},
					afterColon: {
						type: "boolean"
					}
				},
				additionalProperties: false
			}, {
				type: "object",
				properties: {
					singleLine: {
						type: "object",
						properties: {
							mode: {
								enum: ["strict", "minimum"]
							},
							beforeColon: {
								type: "boolean"
							},
							afterColon: {
								type: "boolean"
							}
						},
						additionalProperties: false
					},
					multiLine: {
						type: "object",
						properties: {
							align: {
								anyOf: [{
									enum: ["colon", "value"]
								}, {
									type: "object",
									properties: {
										mode: {
											enum: ["strict", "minimum"]
										},
										on: {
											enum: ["colon", "value"]
										},
										beforeColon: {
											type: "boolean"
										},
										afterColon: {
											type: "boolean"
										}
									},
									additionalProperties: false
								}]
							},
							mode: {
								enum: ["strict", "minimum"]
							},
							beforeColon: {
								type: "boolean"
							},
							afterColon: {
								type: "boolean"
							}
						},
						additionalProperties: false
					}
				},
				additionalProperties: false
			}, {
				type: "object",
				properties: {
					singleLine: {
						type: "object",
						properties: {
							mode: {
								enum: ["strict", "minimum"]
							},
							beforeColon: {
								type: "boolean"
							},
							afterColon: {
								type: "boolean"
							}
						},
						additionalProperties: false
					},
					multiLine: {
						type: "object",
						properties: {
							mode: {
								enum: ["strict", "minimum"]
							},
							beforeColon: {
								type: "boolean"
							},
							afterColon: {
								type: "boolean"
							}
						},
						additionalProperties: false
					},
					align: {
						type: "object",
						properties: {
							mode: {
								enum: ["strict", "minimum"]
							},
							on: {
								enum: ["colon", "value"]
							},
							beforeColon: {
								type: "boolean"
							},
							afterColon: {
								type: "boolean"
							}
						},
						additionalProperties: false
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {
		var options = context.options[0] || {},
			ruleOptions = initOptions({}, options),
			multiLineOptions = ruleOptions.multiLine,
			singleLineOptions = ruleOptions.singleLine,
			alignmentOptions = ruleOptions.align || null;

		var sourceCode = context.getSourceCode();
		function continuesPropertyGroup(lastMember, candidate) {
			var groupEndLine = lastMember.loc.start.line,
				candidateStartLine = candidate.loc.start.line;

			if (candidateStartLine - groupEndLine <= 1) {
				return true;
			}
			var leadingComments = sourceCode.getCommentsBefore(candidate);

			if (leadingComments.length && leadingComments[0].loc.start.line - groupEndLine <= 1 && candidateStartLine - last(leadingComments).loc.end.line <= 1) {
				for (var i = 1; i < leadingComments.length; i++) {
					if (leadingComments[i].loc.start.line - leadingComments[i - 1].loc.end.line > 1) {
						return false;
					}
				}
				return true;
			}

			return false;
		}
		function isKeyValueProperty(property) {
			return !(property.method || property.shorthand || property.kind !== "init" || property.type !== "Property");
		}
		function getLastTokenBeforeColon(node) {
			var colonToken = sourceCode.getTokenAfter(node, astUtils.isColonToken);

			return sourceCode.getTokenBefore(colonToken);
		}
		function getNextColon(node) {
			return sourceCode.getTokenAfter(node, astUtils.isColonToken);
		}
		function getKey(property) {
			var key = property.key;

			if (property.computed) {
				return sourceCode.getText().slice(key.range[0], key.range[1]);
			}

			return property.key.name || property.key.value;
		}
		function report(property, side, whitespace, expected, mode) {
			var diff = whitespace.length - expected,
				nextColon = getNextColon(property.key),
				tokenBeforeColon = sourceCode.getTokenBefore(nextColon, { includeComments: true }),
				tokenAfterColon = sourceCode.getTokenAfter(nextColon, { includeComments: true }),
				isKeySide = side === "key",
				locStart = isKeySide ? tokenBeforeColon.loc.start : tokenAfterColon.loc.start,
				isExtra = diff > 0,
				diffAbs = Math.abs(diff),
				spaces = Array(diffAbs + 1).join(" ");

			if ((diff && mode === "strict" || diff < 0 && mode === "minimum" || diff > 0 && !expected && mode === "minimum") && !(expected && containsLineTerminator(whitespace))) {
				var fix = void 0;

				if (isExtra) {
					var range = void 0;
					if (isKeySide) {
						range = [tokenBeforeColon.range[1], tokenBeforeColon.range[1] + diffAbs];
					} else {
						range = [tokenAfterColon.range[0] - diffAbs, tokenAfterColon.range[0]];
					}
					fix = function fix(fixer) {
						return fixer.removeRange(range);
					};
				} else {
					if (isKeySide) {
						fix = function fix(fixer) {
							return fixer.insertTextAfter(tokenBeforeColon, spaces);
						};
					} else {
						fix = function fix(fixer) {
							return fixer.insertTextBefore(tokenAfterColon, spaces);
						};
					}
				}

				context.report({
					node: property[side],
					loc: locStart,
					message: messages[side],
					data: {
						error: isExtra ? "Extra" : "Missing",
						computed: property.computed ? "computed " : "",
						key: getKey(property)
					},
					fix: fix
				});
			}
		}
		function getKeyWidth(property) {
			var startToken = sourceCode.getFirstToken(property);
			var endToken = getLastTokenBeforeColon(property.key);

			return endToken.range[1] - startToken.range[0];
		}
		function getPropertyWhitespace(property) {
			var whitespace = /(\s*):(\s*)/.exec(sourceCode.getText().slice(property.key.range[1], property.value.range[0]));

			if (whitespace) {
				return {
					beforeColon: whitespace[1],
					afterColon: whitespace[2]
				};
			}
			return null;
		}
		function createGroups(node) {
			if (node.properties.length === 1) {
				return [node.properties];
			}

			return node.properties.reduce(function (groups, property) {
				var currentGroup = last(groups),
					prev = last(currentGroup);

				if (!prev || continuesPropertyGroup(prev, property)) {
					currentGroup.push(property);
				} else {
					groups.push([property]);
				}

				return groups;
			}, [[]]);
		}
		function verifyGroupAlignment(properties) {
			var length = properties.length,
				widths = properties.map(getKeyWidth),
			align = alignmentOptions.on; // "value" or "colon"
			var targetWidth = Math.max.apply(null, widths),
				beforeColon = void 0,
				afterColon = void 0,
				mode = void 0;

			if (alignmentOptions && length > 1) {
				beforeColon = alignmentOptions.beforeColon;
				afterColon = alignmentOptions.afterColon;
				mode = alignmentOptions.mode;
			} else {
				beforeColon = multiLineOptions.beforeColon;
				afterColon = multiLineOptions.afterColon;
				mode = alignmentOptions.mode;
			}
			targetWidth += align === "colon" ? beforeColon : afterColon;

			for (var i = 0; i < length; i++) {
				var property = properties[i];
				var whitespace = getPropertyWhitespace(property);

				if (whitespace) {
					var width = widths[i];

					if (align === "value") {
						report(property, "key", whitespace.beforeColon, beforeColon, mode);
						report(property, "value", whitespace.afterColon, targetWidth - width, mode);
					} else {
						report(property, "key", whitespace.beforeColon, targetWidth - width, mode);
						report(property, "value", whitespace.afterColon, afterColon, mode);
					}
				}
			}
		}
		function verifyAlignment(node) {
			createGroups(node).forEach(function (group) {
				verifyGroupAlignment(group.filter(isKeyValueProperty));
			});
		}
		function verifySpacing(node, lineOptions) {
			var actual = getPropertyWhitespace(node);

			if (actual) {
				report(node, "key", actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);
				report(node, "value", actual.afterColon, lineOptions.afterColon, lineOptions.mode);
			}
		}
		function verifyListSpacing(properties) {
			var length = properties.length;

			for (var i = 0; i < length; i++) {
				verifySpacing(properties[i], singleLineOptions);
			}
		}
		if (alignmentOptions) {
			return {
				ObjectExpression: function ObjectExpression(node) {
					if (isSingleLine(node)) {
						verifyListSpacing(node.properties.filter(isKeyValueProperty));
					} else {
						verifyAlignment(node);
					}
				}
			};
		}
		return {
			Property: function Property(node) {
				verifySpacing(node, isSingleLine(node.parent) ? singleLineOptions : multiLineOptions);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0),
	keywords = __webpack_require__(107);
var PREV_TOKEN = /^[)\]}>]$/;
var NEXT_TOKEN = /^(?:[([{<~!]|\+\+?|--?)$/;
var PREV_TOKEN_M = /^[)\]}>*]$/;
var NEXT_TOKEN_M = /^[{*]$/;
var TEMPLATE_OPEN_PAREN = /\$\{$/;
var TEMPLATE_CLOSE_PAREN = /^\}/;
var CHECK_TYPE = /^(?:JSXElement|RegularExpression|String|Template)$/;
var KEYS = keywords.concat(["as", "async", "await", "from", "get", "let", "of", "set", "yield"]);
(function () {
	KEYS.sort();
	for (var i = 1; i < KEYS.length; ++i) {
		if (KEYS[i] === KEYS[i - 1]) {
			throw new Error("Duplication was found in the keyword list: " + KEYS[i]);
		}
	}
})();
function isOpenParenOfTemplate(token) {
	return token.type === "Template" && TEMPLATE_OPEN_PAREN.test(token.value);
}
function isCloseParenOfTemplate(token) {
	return token.type === "Template" && TEMPLATE_CLOSE_PAREN.test(token.value);
}
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent spacing before and after keywords",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			type: "object",
			properties: {
				before: { type: "boolean" },
				after: { type: "boolean" },
				overrides: {
					type: "object",
					properties: KEYS.reduce(function (retv, key) {
						retv[key] = {
							type: "object",
							properties: {
								before: { type: "boolean" },
								after: { type: "boolean" }
							},
							additionalProperties: false
						};
						return retv;
					}, {}),
					additionalProperties: false
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		function expectSpaceBefore(token, pattern) {
			pattern = pattern || PREV_TOKEN;

			var prevToken = sourceCode.getTokenBefore(token);

			if (prevToken && (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) && !isOpenParenOfTemplate(prevToken) && astUtils.isTokenOnSameLine(prevToken, token) && !sourceCode.isSpaceBetweenTokens(prevToken, token)) {
				context.report({
					loc: token.loc.start,
					message: "Expected space(s) before \"{{value}}\".",
					data: token,
					fix: function fix(fixer) {
						return fixer.insertTextBefore(token, " ");
					}
				});
			}
		}
		function unexpectSpaceBefore(token, pattern) {
			pattern = pattern || PREV_TOKEN;

			var prevToken = sourceCode.getTokenBefore(token);

			if (prevToken && (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) && !isOpenParenOfTemplate(prevToken) && astUtils.isTokenOnSameLine(prevToken, token) && sourceCode.isSpaceBetweenTokens(prevToken, token)) {
				context.report({
					loc: token.loc.start,
					message: "Unexpected space(s) before \"{{value}}\".",
					data: token,
					fix: function fix(fixer) {
						return fixer.removeRange([prevToken.range[1], token.range[0]]);
					}
				});
			}
		}
		function expectSpaceAfter(token, pattern) {
			pattern = pattern || NEXT_TOKEN;

			var nextToken = sourceCode.getTokenAfter(token);

			if (nextToken && (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) && !isCloseParenOfTemplate(nextToken) && astUtils.isTokenOnSameLine(token, nextToken) && !sourceCode.isSpaceBetweenTokens(token, nextToken)) {
				context.report({
					loc: token.loc.start,
					message: "Expected space(s) after \"{{value}}\".",
					data: token,
					fix: function fix(fixer) {
						return fixer.insertTextAfter(token, " ");
					}
				});
			}
		}
		function unexpectSpaceAfter(token, pattern) {
			pattern = pattern || NEXT_TOKEN;

			var nextToken = sourceCode.getTokenAfter(token);

			if (nextToken && (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) && !isCloseParenOfTemplate(nextToken) && astUtils.isTokenOnSameLine(token, nextToken) && sourceCode.isSpaceBetweenTokens(token, nextToken)) {
				context.report({
					loc: token.loc.start,
					message: "Unexpected space(s) after \"{{value}}\".",
					data: token,
					fix: function fix(fixer) {
						return fixer.removeRange([token.range[1], nextToken.range[0]]);
					}
				});
			}
		}
		function parseOptions(options) {
			var before = !options || options.before !== false;
			var after = !options || options.after !== false;
			var defaultValue = {
				before: before ? expectSpaceBefore : unexpectSpaceBefore,
				after: after ? expectSpaceAfter : unexpectSpaceAfter
			};
			var overrides = options && options.overrides || {};
			var retv = Object.create(null);

			for (var i = 0; i < KEYS.length; ++i) {
				var key = KEYS[i];
				var override = overrides[key];

				if (override) {
					var thisBefore = "before" in override ? override.before : before;
					var thisAfter = "after" in override ? override.after : after;

					retv[key] = {
						before: thisBefore ? expectSpaceBefore : unexpectSpaceBefore,
						after: thisAfter ? expectSpaceAfter : unexpectSpaceAfter
					};
				} else {
					retv[key] = defaultValue;
				}
			}

			return retv;
		}

		var checkMethodMap = parseOptions(context.options[0]);
		function checkSpacingBefore(token, pattern) {
			checkMethodMap[token.value].before(token, pattern);
		}
		function checkSpacingAfter(token, pattern) {
			checkMethodMap[token.value].after(token, pattern);
		}
		function checkSpacingAround(token) {
			checkSpacingBefore(token);
			checkSpacingAfter(token);
		}
		function checkSpacingAroundFirstToken(node) {
			var firstToken = node && sourceCode.getFirstToken(node);

			if (firstToken && firstToken.type === "Keyword") {
				checkSpacingAround(firstToken);
			}
		}
		function checkSpacingBeforeFirstToken(node) {
			var firstToken = node && sourceCode.getFirstToken(node);

			if (firstToken && firstToken.type === "Keyword") {
				checkSpacingBefore(firstToken);
			}
		}
		function checkSpacingAroundTokenBefore(node) {
			if (node) {
				var token = sourceCode.getTokenBefore(node, astUtils.isKeywordToken);

				checkSpacingAround(token);
			}
		}
		function checkSpacingForFunction(node) {
			var firstToken = node && sourceCode.getFirstToken(node);

			if (firstToken && (firstToken.type === "Keyword" && firstToken.value === "function" || firstToken.value === "async")) {
				checkSpacingBefore(firstToken);
			}
		}
		function checkSpacingForClass(node) {
			checkSpacingAroundFirstToken(node);
			checkSpacingAroundTokenBefore(node.superClass);
		}
		function checkSpacingForIfStatement(node) {
			checkSpacingAroundFirstToken(node);
			checkSpacingAroundTokenBefore(node.alternate);
		}
		function checkSpacingForTryStatement(node) {
			checkSpacingAroundFirstToken(node);
			checkSpacingAroundFirstToken(node.handler);
			checkSpacingAroundTokenBefore(node.finalizer);
		}
		function checkSpacingForDoWhileStatement(node) {
			checkSpacingAroundFirstToken(node);
			checkSpacingAroundTokenBefore(node.test);
		}
		function checkSpacingForForInStatement(node) {
			checkSpacingAroundFirstToken(node);
			checkSpacingAroundTokenBefore(node.right);
		}
		function checkSpacingForForOfStatement(node) {
			checkSpacingAroundFirstToken(node);
			checkSpacingAround(sourceCode.getTokenBefore(node.right, astUtils.isNotOpeningParenToken));
		}
		function checkSpacingForModuleDeclaration(node) {
			var firstToken = sourceCode.getFirstToken(node);

			checkSpacingBefore(firstToken, PREV_TOKEN_M);
			checkSpacingAfter(firstToken, NEXT_TOKEN_M);

			if (node.source) {
				var fromToken = sourceCode.getTokenBefore(node.source);

				checkSpacingBefore(fromToken, PREV_TOKEN_M);
				checkSpacingAfter(fromToken, NEXT_TOKEN_M);
			}
		}
		function checkSpacingForImportNamespaceSpecifier(node) {
			var asToken = sourceCode.getFirstToken(node, 1);

			checkSpacingBefore(asToken, PREV_TOKEN_M);
		}
		function checkSpacingForProperty(node) {
			if (node.static) {
				checkSpacingAroundFirstToken(node);
			}
			if (node.kind === "get" || node.kind === "set" || (node.method || node.type === "MethodDefinition") && node.value.async) {
				var token = sourceCode.getTokenBefore(node.key, function (tok) {
					switch (tok.value) {
						case "get":
						case "set":
						case "async":
							return true;
						default:
							return false;
					}
				});

				if (!token) {
					throw new Error("Failed to find token get, set, or async beside method name");
				}

				checkSpacingAround(token);
			}
		}
		function checkSpacingForAwaitExpression(node) {
			checkSpacingBefore(sourceCode.getFirstToken(node));
		}

		return {
			DebuggerStatement: checkSpacingAroundFirstToken,
			WithStatement: checkSpacingAroundFirstToken,
			BreakStatement: checkSpacingAroundFirstToken,
			ContinueStatement: checkSpacingAroundFirstToken,
			ReturnStatement: checkSpacingAroundFirstToken,
			ThrowStatement: checkSpacingAroundFirstToken,
			TryStatement: checkSpacingForTryStatement,
			IfStatement: checkSpacingForIfStatement,
			SwitchStatement: checkSpacingAroundFirstToken,
			SwitchCase: checkSpacingAroundFirstToken,
			DoWhileStatement: checkSpacingForDoWhileStatement,
			ForInStatement: checkSpacingForForInStatement,
			ForOfStatement: checkSpacingForForOfStatement,
			ForStatement: checkSpacingAroundFirstToken,
			WhileStatement: checkSpacingAroundFirstToken,
			ClassDeclaration: checkSpacingForClass,
			ExportNamedDeclaration: checkSpacingForModuleDeclaration,
			ExportDefaultDeclaration: checkSpacingAroundFirstToken,
			ExportAllDeclaration: checkSpacingForModuleDeclaration,
			FunctionDeclaration: checkSpacingForFunction,
			ImportDeclaration: checkSpacingForModuleDeclaration,
			VariableDeclaration: checkSpacingAroundFirstToken,
			ArrowFunctionExpression: checkSpacingForFunction,
			AwaitExpression: checkSpacingForAwaitExpression,
			ClassExpression: checkSpacingForClass,
			FunctionExpression: checkSpacingForFunction,
			NewExpression: checkSpacingBeforeFirstToken,
			Super: checkSpacingBeforeFirstToken,
			ThisExpression: checkSpacingBeforeFirstToken,
			UnaryExpression: checkSpacingBeforeFirstToken,
			YieldExpression: checkSpacingBeforeFirstToken,
			ImportNamespaceSpecifier: checkSpacingForImportNamespaceSpecifier,
			MethodDefinition: checkSpacingForProperty,
			Property: checkSpacingForProperty
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce position of line comments",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			oneOf: [{
				enum: ["above", "beside"]
			}, {
				type: "object",
				properties: {
					position: {
						enum: ["above", "beside"]
					},
					ignorePattern: {
						type: "string"
					},
					applyDefaultPatterns: {
						type: "boolean"
					},
					applyDefaultIgnorePatterns: {
						type: "boolean"
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {
		var options = context.options[0];

		var above = void 0,
			ignorePattern = void 0,
			applyDefaultIgnorePatterns = true;

		if (!options || typeof options === "string") {
			above = !options || options === "above";
		} else {
			above = options.position === "above";
			ignorePattern = options.ignorePattern;

			if (options.hasOwnProperty("applyDefaultIgnorePatterns")) {
				applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns !== false;
			} else {
				applyDefaultIgnorePatterns = options.applyDefaultPatterns !== false;
			}
		}

		var defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;
		var fallThroughRegExp = /^\s*falls?\s?through/;
		var customIgnoreRegExp = new RegExp(ignorePattern);
		var sourceCode = context.getSourceCode();
		return {
			Program: function Program() {
				var comments = sourceCode.getAllComments();

				comments.filter(function (token) {
					return token.type === "Line";
				}).forEach(function (node) {
					if (applyDefaultIgnorePatterns && (defaultIgnoreRegExp.test(node.value) || fallThroughRegExp.test(node.value))) {
						return;
					}

					if (ignorePattern && customIgnoreRegExp.test(node.value)) {
						return;
					}

					var previous = sourceCode.getTokenBefore(node, { includeComments: true });
					var isOnSameLine = previous && previous.loc.end.line === node.loc.start.line;

					if (above) {
						if (isOnSameLine) {
							context.report({
								node: node,
								message: "Expected comment to be above code."
							});
						}
					} else {
						if (!isOnSameLine) {
							context.report({
								node: node,
								message: "Expected comment to be beside code."
							});
						}
					}
				});
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent linebreak style",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			enum: ["unix", "windows"]
		}]
	},

	create: function create(context) {

		var EXPECTED_LF_MSG = "Expected linebreaks to be 'LF' but found 'CRLF'.",
			EXPECTED_CRLF_MSG = "Expected linebreaks to be 'CRLF' but found 'LF'.";

		var sourceCode = context.getSourceCode();
		function createFix(range, text) {
			return function (fixer) {
				return fixer.replaceTextRange(range, text);
			};
		}
		return {
			Program: function checkForlinebreakStyle(node) {
				var linebreakStyle = context.options[0] || "unix",
					expectedLF = linebreakStyle === "unix",
					expectedLFChars = expectedLF ? "\n" : "\r\n",
					source = sourceCode.getText(),
					pattern = astUtils.createGlobalLinebreakMatcher();
				var match = void 0;

				var i = 0;

				while ((match = pattern.exec(source)) !== null) {
					i++;
					if (match[0] === expectedLFChars) {
						continue;
					}

					var index = match.index;
					var range = [index, index + match[0].length];

					context.report({
						node: node,
						loc: {
							line: i,
							column: sourceCode.lines[i - 1].length
						},
						message: expectedLF ? EXPECTED_LF_MSG : EXPECTED_CRLF_MSG,
						fix: createFix(range, expectedLFChars)
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var lodash = __webpack_require__(10),
	astUtils = __webpack_require__(0);
function getEmptyLineNums(lines) {
	var emptyLines = lines.map(function (line, i) {
		return {
			code: line.trim(),
			num: i + 1
		};
	}).filter(function (line) {
		return !line.code;
	}).map(function (line) {
		return line.num;
	});

	return emptyLines;
}
function getCommentLineNums(comments) {
	var lines = [];

	comments.forEach(function (token) {
		var start = token.loc.start.line;
		var end = token.loc.end.line;

		lines.push(start, end);
	});
	return lines;
}
module.exports = {
	meta: {
		docs: {
			description: "require empty lines around comments",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			type: "object",
			properties: {
				beforeBlockComment: {
					type: "boolean"
				},
				afterBlockComment: {
					type: "boolean"
				},
				beforeLineComment: {
					type: "boolean"
				},
				afterLineComment: {
					type: "boolean"
				},
				allowBlockStart: {
					type: "boolean"
				},
				allowBlockEnd: {
					type: "boolean"
				},
				allowClassStart: {
					type: "boolean"
				},
				allowClassEnd: {
					type: "boolean"
				},
				allowObjectStart: {
					type: "boolean"
				},
				allowObjectEnd: {
					type: "boolean"
				},
				allowArrayStart: {
					type: "boolean"
				},
				allowArrayEnd: {
					type: "boolean"
				},
				ignorePattern: {
					type: "string"
				},
				applyDefaultIgnorePatterns: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var options = context.options[0] ? Object.assign({}, context.options[0]) : {};
		var ignorePattern = options.ignorePattern;
		var defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;
		var customIgnoreRegExp = new RegExp(ignorePattern);
		var applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns !== false;

		options.beforeLineComment = options.beforeLineComment || false;
		options.afterLineComment = options.afterLineComment || false;
		options.beforeBlockComment = typeof options.beforeBlockComment !== "undefined" ? options.beforeBlockComment : true;
		options.afterBlockComment = options.afterBlockComment || false;
		options.allowBlockStart = options.allowBlockStart || false;
		options.allowBlockEnd = options.allowBlockEnd || false;

		var sourceCode = context.getSourceCode();

		var lines = sourceCode.lines,
			numLines = lines.length + 1,
			comments = sourceCode.getAllComments(),
			commentLines = getCommentLineNums(comments),
			emptyLines = getEmptyLineNums(lines),
			commentAndEmptyLines = commentLines.concat(emptyLines);
		function codeAroundComment(token) {
			var currentToken = token;

			do {
				currentToken = sourceCode.getTokenBefore(currentToken, { includeComments: true });
			} while (currentToken && astUtils.isCommentToken(currentToken));

			if (currentToken && astUtils.isTokenOnSameLine(currentToken, token)) {
				return true;
			}

			currentToken = token;
			do {
				currentToken = sourceCode.getTokenAfter(currentToken, { includeComments: true });
			} while (currentToken && astUtils.isCommentToken(currentToken));

			if (currentToken && astUtils.isTokenOnSameLine(token, currentToken)) {
				return true;
			}

			return false;
		}
		function isParentNodeType(parent, nodeType) {
			return parent.type === nodeType || parent.body && parent.body.type === nodeType || parent.consequent && parent.consequent.type === nodeType;
		}
		function getParentNodeOfToken(token) {
			return sourceCode.getNodeByRangeIndex(token.range[0]);
		}
		function isCommentAtParentStart(token, nodeType) {
			var parent = getParentNodeOfToken(token);

			return parent && isParentNodeType(parent, nodeType) && token.loc.start.line - parent.loc.start.line === 1;
		}
		function isCommentAtParentEnd(token, nodeType) {
			var parent = getParentNodeOfToken(token);

			return parent && isParentNodeType(parent, nodeType) && parent.loc.end.line - token.loc.end.line === 1;
		}
		function isCommentAtBlockStart(token) {
			return isCommentAtParentStart(token, "ClassBody") || isCommentAtParentStart(token, "BlockStatement") || isCommentAtParentStart(token, "SwitchCase");
		}
		function isCommentAtBlockEnd(token) {
			return isCommentAtParentEnd(token, "ClassBody") || isCommentAtParentEnd(token, "BlockStatement") || isCommentAtParentEnd(token, "SwitchCase") || isCommentAtParentEnd(token, "SwitchStatement");
		}
		function isCommentAtClassStart(token) {
			return isCommentAtParentStart(token, "ClassBody");
		}
		function isCommentAtClassEnd(token) {
			return isCommentAtParentEnd(token, "ClassBody");
		}
		function isCommentAtObjectStart(token) {
			return isCommentAtParentStart(token, "ObjectExpression") || isCommentAtParentStart(token, "ObjectPattern");
		}
		function isCommentAtObjectEnd(token) {
			return isCommentAtParentEnd(token, "ObjectExpression") || isCommentAtParentEnd(token, "ObjectPattern");
		}
		function isCommentAtArrayStart(token) {
			return isCommentAtParentStart(token, "ArrayExpression") || isCommentAtParentStart(token, "ArrayPattern");
		}
		function isCommentAtArrayEnd(token) {
			return isCommentAtParentEnd(token, "ArrayExpression") || isCommentAtParentEnd(token, "ArrayPattern");
		}
		function checkForEmptyLine(token, opts) {
			if (applyDefaultIgnorePatterns && defaultIgnoreRegExp.test(token.value)) {
				return;
			}

			if (ignorePattern && customIgnoreRegExp.test(token.value)) {
				return;
			}

			var after = opts.after,
				before = opts.before;

			var prevLineNum = token.loc.start.line - 1,
				nextLineNum = token.loc.end.line + 1,
				commentIsNotAlone = codeAroundComment(token);

			var blockStartAllowed = options.allowBlockStart && isCommentAtBlockStart(token) && !(options.allowClassStart === false && isCommentAtClassStart(token)),
				blockEndAllowed = options.allowBlockEnd && isCommentAtBlockEnd(token) && !(options.allowClassEnd === false && isCommentAtClassEnd(token)),
				classStartAllowed = options.allowClassStart && isCommentAtClassStart(token),
				classEndAllowed = options.allowClassEnd && isCommentAtClassEnd(token),
				objectStartAllowed = options.allowObjectStart && isCommentAtObjectStart(token),
				objectEndAllowed = options.allowObjectEnd && isCommentAtObjectEnd(token),
				arrayStartAllowed = options.allowArrayStart && isCommentAtArrayStart(token),
				arrayEndAllowed = options.allowArrayEnd && isCommentAtArrayEnd(token);

			var exceptionStartAllowed = blockStartAllowed || classStartAllowed || objectStartAllowed || arrayStartAllowed;
			var exceptionEndAllowed = blockEndAllowed || classEndAllowed || objectEndAllowed || arrayEndAllowed;
			if (prevLineNum < 1) {
				before = false;
			}
			if (nextLineNum >= numLines) {
				after = false;
			}
			if (commentIsNotAlone) {
				return;
			}

			var previousTokenOrComment = sourceCode.getTokenBefore(token, { includeComments: true });
			var nextTokenOrComment = sourceCode.getTokenAfter(token, { includeComments: true });
			if (!exceptionStartAllowed && before && !lodash.includes(commentAndEmptyLines, prevLineNum) && !(astUtils.isCommentToken(previousTokenOrComment) && astUtils.isTokenOnSameLine(previousTokenOrComment, token))) {
				var lineStart = token.range[0] - token.loc.start.column;
				var range = [lineStart, lineStart];

				context.report({
					node: token,
					message: "Expected line before comment.",
					fix: function fix(fixer) {
						return fixer.insertTextBeforeRange(range, "\n");
					}
				});
			}
			if (!exceptionEndAllowed && after && !lodash.includes(commentAndEmptyLines, nextLineNum) && !(astUtils.isCommentToken(nextTokenOrComment) && astUtils.isTokenOnSameLine(token, nextTokenOrComment))) {
				context.report({
					node: token,
					message: "Expected line after comment.",
					fix: function fix(fixer) {
						return fixer.insertTextAfter(token, "\n");
					}
				});
			}
		}
		return {
			Program: function Program() {
				comments.forEach(function (token) {
					if (token.type === "Line") {
						if (options.beforeLineComment || options.afterLineComment) {
							checkForEmptyLine(token, {
								after: options.afterLineComment,
								before: options.beforeLineComment
							});
						}
					} else if (token.type === "Block") {
						if (options.beforeBlockComment || options.afterBlockComment) {
							checkForEmptyLine(token, {
								after: options.afterBlockComment,
								before: options.beforeBlockComment
							});
						}
					}
				});
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "require or disallow newlines around directives",
			category: "Stylistic Issues",
			recommended: false,
			replacedBy: ["padding-line-between-statements"]
		},
		schema: [{
			oneOf: [{
				enum: ["always", "never"]
			}, {
				type: "object",
				properties: {
					before: {
						enum: ["always", "never"]
					},
					after: {
						enum: ["always", "never"]
					}
				},
				additionalProperties: false,
				minProperties: 2
			}]
		}],
		fixable: "whitespace",
		deprecated: true
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var config = context.options[0] || "always";
		var expectLineBefore = typeof config === "string" ? config : config.before;
		var expectLineAfter = typeof config === "string" ? config : config.after;
		function hasNewlineBefore(node) {
			var tokenBefore = sourceCode.getTokenBefore(node, { includeComments: true });
			var tokenLineBefore = tokenBefore ? tokenBefore.loc.end.line : 0;

			return node.loc.start.line - tokenLineBefore >= 2;
		}
		function getLastTokenOnLine(node) {
			var lastToken = sourceCode.getLastToken(node);
			var secondToLastToken = sourceCode.getTokenBefore(lastToken);

			return astUtils.isSemicolonToken(lastToken) && lastToken.loc.start.line > secondToLastToken.loc.end.line ? secondToLastToken : lastToken;
		}
		function hasNewlineAfter(node) {
			var lastToken = getLastTokenOnLine(node);
			var tokenAfter = sourceCode.getTokenAfter(lastToken, { includeComments: true });

			return tokenAfter.loc.start.line - lastToken.loc.end.line >= 2;
		}
		function reportError(node, location, expected) {
			context.report({
				node: node,
				message: "{{expected}} newline {{location}} \"{{value}}\" directive.",
				data: {
					expected: expected ? "Expected" : "Unexpected",
					value: node.expression.value,
					location: location
				},
				fix: function fix(fixer) {
					var lastToken = getLastTokenOnLine(node);

					if (expected) {
						return location === "before" ? fixer.insertTextBefore(node, "\n") : fixer.insertTextAfter(lastToken, "\n");
					}
					return fixer.removeRange(location === "before" ? [node.range[0] - 1, node.range[0]] : [lastToken.range[1], lastToken.range[1] + 1]);
				}
			});
		}
		function checkDirectives(node) {
			var directives = astUtils.getDirectivePrologue(node);

			if (!directives.length) {
				return;
			}

			var firstDirective = directives[0];
			var leadingComments = sourceCode.getCommentsBefore(firstDirective);
			if (leadingComments.length) {
				if (expectLineBefore === "always" && !hasNewlineBefore(firstDirective)) {
					reportError(firstDirective, "before", true);
				}

				if (expectLineBefore === "never" && hasNewlineBefore(firstDirective)) {
					reportError(firstDirective, "before", false);
				}
			} else if (node.type === "Program" && expectLineBefore === "never" && !leadingComments.length && hasNewlineBefore(firstDirective)) {
				reportError(firstDirective, "before", false);
			}

			var lastDirective = directives[directives.length - 1];
			var statements = node.type === "Program" ? node.body : node.body.body;
			if (lastDirective === statements[statements.length - 1] && !lastDirective.trailingComments) {
				return;
			}

			if (expectLineAfter === "always" && !hasNewlineAfter(lastDirective)) {
				reportError(lastDirective, "after", true);
			}

			if (expectLineAfter === "never" && hasNewlineAfter(lastDirective)) {
				reportError(lastDirective, "after", false);
			}
		}
		return {
			Program: checkDirectives,
			FunctionDeclaration: checkDirectives,
			FunctionExpression: checkDirectives,
			ArrowFunctionExpression: checkDirectives
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "require or disallow an empty line between class members",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			enum: ["always", "never"]
		}, {
			type: "object",
			properties: {
				exceptAfterSingleLine: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var options = [];

		options[0] = context.options[0] || "always";
		options[1] = context.options[1] || { exceptAfterSingleLine: false };

		var ALWAYS_MESSAGE = "Expected blank line between class members.";
		var NEVER_MESSAGE = "Unexpected blank line between class members.";

		var sourceCode = context.getSourceCode();
		function isPaddingBetweenTokens(first, second) {
			return second.loc.start.line - first.loc.end.line >= 2;
		}

		return {
			ClassBody: function ClassBody(node) {
				var body = node.body;

				var _loop = function _loop(i) {
					var curFirst = sourceCode.getFirstToken(body[i]);
					var curLast = sourceCode.getLastToken(body[i]);
					var comments = sourceCode.getCommentsBefore(body[i + 1]);
					var nextFirst = comments.length ? comments[0] : sourceCode.getFirstToken(body[i + 1]);
					var isPadded = isPaddingBetweenTokens(curLast, nextFirst);
					var isMulti = !astUtils.isTokenOnSameLine(curFirst, curLast);
					var skip = !isMulti && options[1].exceptAfterSingleLine;

					if (options[0] === "always" && !skip && !isPadded || options[0] === "never" && isPadded) {
						context.report({
							node: body[i + 1],
							message: isPadded ? NEVER_MESSAGE : ALWAYS_MESSAGE,
							fix: function fix(fixer) {
								return isPadded ? fixer.replaceTextRange([curLast.range[1], nextFirst.range[0]], "\n") : fixer.insertTextAfter(curLast, "\n");
							}
						});
					}
				};

				for (var i = 0; i < body.length - 1; i++) {
					_loop(i);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = {
	meta: {
		docs: {
			description: "enforce a maximum depth that blocks can be nested",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			oneOf: [{
				type: "integer",
				minimum: 0
			}, {
				type: "object",
				properties: {
					maximum: {
						type: "integer",
						minimum: 0
					},
					max: {
						type: "integer",
						minimum: 0
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {
		var functionStack = [],
			option = context.options[0];
		var maxDepth = 4;

		if ((typeof option === "undefined" ? "undefined" : _typeof(option)) === "object" && option.hasOwnProperty("maximum") && typeof option.maximum === "number") {
			maxDepth = option.maximum;
		}
		if ((typeof option === "undefined" ? "undefined" : _typeof(option)) === "object" && option.hasOwnProperty("max") && typeof option.max === "number") {
			maxDepth = option.max;
		}
		if (typeof option === "number") {
			maxDepth = option;
		}
		function startFunction() {
			functionStack.push(0);
		}
		function endFunction() {
			functionStack.pop();
		}
		function pushBlock(node) {
			var len = ++functionStack[functionStack.length - 1];

			if (len > maxDepth) {
				context.report({ node: node, message: "Blocks are nested too deeply ({{depth}}).", data: { depth: len } });
			}
		}
		function popBlock() {
			functionStack[functionStack.length - 1]--;
		}
		return {
			Program: startFunction,
			FunctionDeclaration: startFunction,
			FunctionExpression: startFunction,
			ArrowFunctionExpression: startFunction,

			IfStatement: function IfStatement(node) {
				if (node.parent.type !== "IfStatement") {
					pushBlock(node);
				}
			},

			SwitchStatement: pushBlock,
			TryStatement: pushBlock,
			DoWhileStatement: pushBlock,
			WhileStatement: pushBlock,
			WithStatement: pushBlock,
			ForStatement: pushBlock,
			ForInStatement: pushBlock,
			ForOfStatement: pushBlock,

			"IfStatement:exit": popBlock,
			"SwitchStatement:exit": popBlock,
			"TryStatement:exit": popBlock,
			"DoWhileStatement:exit": popBlock,
			"WhileStatement:exit": popBlock,
			"WithStatement:exit": popBlock,
			"ForStatement:exit": popBlock,
			"ForInStatement:exit": popBlock,
			"ForOfStatement:exit": popBlock,

			"FunctionDeclaration:exit": endFunction,
			"FunctionExpression:exit": endFunction,
			"ArrowFunctionExpression:exit": endFunction,
			"Program:exit": endFunction
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var OPTIONS_SCHEMA = {
	type: "object",
	properties: {
		code: {
			type: "integer",
			minimum: 0
		},
		comments: {
			type: "integer",
			minimum: 0
		},
		tabWidth: {
			type: "integer",
			minimum: 0
		},
		ignorePattern: {
			type: "string"
		},
		ignoreComments: {
			type: "boolean"
		},
		ignoreStrings: {
			type: "boolean"
		},
		ignoreUrls: {
			type: "boolean"
		},
		ignoreTemplateLiterals: {
			type: "boolean"
		},
		ignoreRegExpLiterals: {
			type: "boolean"
		},
		ignoreTrailingComments: {
			type: "boolean"
		}
	},
	additionalProperties: false
};

var OPTIONS_OR_INTEGER_SCHEMA = {
	anyOf: [OPTIONS_SCHEMA, {
		type: "integer",
		minimum: 0
	}]
};
module.exports = {
	meta: {
		docs: {
			description: "enforce a maximum line length",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [OPTIONS_OR_INTEGER_SCHEMA, OPTIONS_OR_INTEGER_SCHEMA, OPTIONS_SCHEMA]
	},

	create: function create(context) {
		var URL_REGEXP = /[^:/?#]:\/\/[^?#]/;

		var sourceCode = context.getSourceCode();
		function computeLineLength(line, tabWidth) {
			var extraCharacterCount = 0;

			line.replace(/\t/g, function (match, offset) {
				var totalOffset = offset + extraCharacterCount,
					previousTabStopOffset = tabWidth ? totalOffset % tabWidth : 0,
					spaceCount = tabWidth - previousTabStopOffset;

				extraCharacterCount += spaceCount - 1; // -1 for the replaced tab
			});
			return Array.from(line).length + extraCharacterCount;
		}
		var lastOption = context.options[context.options.length - 1];
		var options = (typeof lastOption === "undefined" ? "undefined" : _typeof(lastOption)) === "object" ? Object.create(lastOption) : {};
		if (typeof context.options[0] === "number") {
			options.code = context.options[0];
		}
		if (typeof context.options[1] === "number") {
			options.tabWidth = context.options[1];
		}

		var maxLength = options.code || 80,
			tabWidth = options.tabWidth || 4,
			ignoreComments = options.ignoreComments || false,
			ignoreStrings = options.ignoreStrings || false,
			ignoreTemplateLiterals = options.ignoreTemplateLiterals || false,
			ignoreRegExpLiterals = options.ignoreRegExpLiterals || false,
			ignoreTrailingComments = options.ignoreTrailingComments || options.ignoreComments || false,
			ignoreUrls = options.ignoreUrls || false,
			maxCommentLength = options.comments;
		var ignorePattern = options.ignorePattern || null;

		if (ignorePattern) {
			ignorePattern = new RegExp(ignorePattern);
		}
		function isTrailingComment(line, lineNumber, comment) {
			return comment && comment.loc.start.line === lineNumber && lineNumber <= comment.loc.end.line && (comment.loc.end.line > lineNumber || comment.loc.end.column === line.length);
		}
		function isFullLineComment(line, lineNumber, comment) {
			var start = comment.loc.start,
				end = comment.loc.end,
				isFirstTokenOnLine = !line.slice(0, comment.loc.start.column).trim();

			return comment && (start.line < lineNumber || start.line === lineNumber && isFirstTokenOnLine) && (end.line > lineNumber || end.line === lineNumber && end.column === line.length);
		}
		function stripTrailingComment(line, comment) {
			return line.slice(0, comment.loc.start.column).replace(/\s+$/, "");
		}
		function ensureArrayAndPush(object, key, value) {
			if (!Array.isArray(object[key])) {
				object[key] = [];
			}
			object[key].push(value);
		}
		function getAllStrings() {
			return sourceCode.ast.tokens.filter(function (token) {
				return token.type === "String";
			});
		}
		function getAllTemplateLiterals() {
			return sourceCode.ast.tokens.filter(function (token) {
				return token.type === "Template";
			});
		}
		function getAllRegExpLiterals() {
			return sourceCode.ast.tokens.filter(function (token) {
				return token.type === "RegularExpression";
			});
		}
		function groupByLineNumber(acc, node) {
			for (var i = node.loc.start.line; i <= node.loc.end.line; ++i) {
				ensureArrayAndPush(acc, i, node);
			}
			return acc;
		}
		function checkProgramForMaxLength(node) {
			var lines = sourceCode.lines,
			comments = ignoreComments || maxCommentLength || ignoreTrailingComments ? sourceCode.getAllComments() : [];
			var commentsIndex = 0;

			var strings = getAllStrings();
			var stringsByLine = strings.reduce(groupByLineNumber, {});

			var templateLiterals = getAllTemplateLiterals();
			var templateLiteralsByLine = templateLiterals.reduce(groupByLineNumber, {});

			var regExpLiterals = getAllRegExpLiterals();
			var regExpLiteralsByLine = regExpLiterals.reduce(groupByLineNumber, {});

			lines.forEach(function (line, i) {
				var lineNumber = i + 1;
				var lineIsComment = false;
				if (commentsIndex < comments.length) {
					var comment = null;
					do {
						comment = comments[++commentsIndex];
					} while (comment && comment.loc.start.line <= lineNumber);
					comment = comments[--commentsIndex];

					if (isFullLineComment(line, lineNumber, comment)) {
						lineIsComment = true;
					} else if (ignoreTrailingComments && isTrailingComment(line, lineNumber, comment)) {
						line = stripTrailingComment(line, comment);
					}
				}
				if (ignorePattern && ignorePattern.test(line) || ignoreUrls && URL_REGEXP.test(line) || ignoreStrings && stringsByLine[lineNumber] || ignoreTemplateLiterals && templateLiteralsByLine[lineNumber] || ignoreRegExpLiterals && regExpLiteralsByLine[lineNumber]) {
					return;
				}

				var lineLength = computeLineLength(line, tabWidth);
				var commentLengthApplies = lineIsComment && maxCommentLength;

				if (lineIsComment && ignoreComments) {
					return;
				}

				if (commentLengthApplies) {
					if (lineLength > maxCommentLength) {
						context.report({
							node: node,
							loc: { line: lineNumber, column: 0 },
							message: "Line {{lineNumber}} exceeds the maximum comment line length of {{maxCommentLength}}.",
							data: {
								lineNumber: i + 1,
								maxCommentLength: maxCommentLength
							}
						});
					}
				} else if (lineLength > maxLength) {
					context.report({
						node: node,
						loc: { line: lineNumber, column: 0 },
						message: "Line {{lineNumber}} exceeds the maximum line length of {{maxLength}}.",
						data: {
							lineNumber: i + 1,
							maxLength: maxLength
						}
					});
				}
			});
		}
		return {
			Program: checkProgramForMaxLength
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var lodash = __webpack_require__(10);
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce a maximum number of lines per file",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			oneOf: [{
				type: "integer",
				minimum: 0
			}, {
				type: "object",
				properties: {
					max: {
						type: "integer",
						minimum: 0
					},
					skipComments: {
						type: "boolean"
					},
					skipBlankLines: {
						type: "boolean"
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {
		var option = context.options[0];
		var max = 300;

		if ((typeof option === "undefined" ? "undefined" : _typeof(option)) === "object" && option.hasOwnProperty("max") && typeof option.max === "number") {
			max = option.max;
		}

		if (typeof option === "number") {
			max = option;
		}

		var skipComments = option && option.skipComments;
		var skipBlankLines = option && option.skipBlankLines;

		var sourceCode = context.getSourceCode();
		function isCommentNodeType(token) {
			return token && (token.type === "Block" || token.type === "Line");
		}
		function getLinesWithoutCode(comment) {
			var start = comment.loc.start.line;
			var end = comment.loc.end.line;

			var token = void 0;

			token = comment;
			do {
				token = sourceCode.getTokenBefore(token, { includeComments: true });
			} while (isCommentNodeType(token));

			if (token && astUtils.isTokenOnSameLine(token, comment)) {
				start += 1;
			}

			token = comment;
			do {
				token = sourceCode.getTokenAfter(token, { includeComments: true });
			} while (isCommentNodeType(token));

			if (token && astUtils.isTokenOnSameLine(comment, token)) {
				end -= 1;
			}

			if (start <= end) {
				return lodash.range(start, end + 1);
			}
			return [];
		}

		return {
			"Program:exit": function ProgramExit() {
				var lines = sourceCode.lines.map(function (text, i) {
					return { lineNumber: i + 1, text: text };
				});

				if (skipBlankLines) {
					lines = lines.filter(function (l) {
						return l.text.trim() !== "";
					});
				}

				if (skipComments) {
					var comments = sourceCode.getAllComments();

					var commentLines = lodash.flatten(comments.map(function (comment) {
						return getLinesWithoutCode(comment);
					}));

					lines = lines.filter(function (l) {
						return !lodash.includes(commentLines, l.lineNumber);
					});
				}

				if (lines.length > max) {
					context.report({
						loc: { line: 1, column: 0 },
						message: "File must be at most {{max}} lines long. It's {{actual}} lines long.",
						data: {
							max: max,
							actual: lines.length
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = {
	meta: {
		docs: {
			description: "enforce a maximum depth that callbacks can be nested",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			oneOf: [{
				type: "integer",
				minimum: 0
			}, {
				type: "object",
				properties: {
					maximum: {
						type: "integer",
						minimum: 0
					},
					max: {
						type: "integer",
						minimum: 0
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {
		var option = context.options[0];
		var THRESHOLD = 10;

		if ((typeof option === "undefined" ? "undefined" : _typeof(option)) === "object" && option.hasOwnProperty("maximum") && typeof option.maximum === "number") {
			THRESHOLD = option.maximum;
		}
		if ((typeof option === "undefined" ? "undefined" : _typeof(option)) === "object" && option.hasOwnProperty("max") && typeof option.max === "number") {
			THRESHOLD = option.max;
		}
		if (typeof option === "number") {
			THRESHOLD = option;
		}
		var callbackStack = [];
		function checkFunction(node) {
			var parent = node.parent;

			if (parent.type === "CallExpression") {
				callbackStack.push(node);
			}

			if (callbackStack.length > THRESHOLD) {
				var opts = { num: callbackStack.length, max: THRESHOLD };

				context.report({ node: node, message: "Too many nested callbacks ({{num}}). Maximum allowed is {{max}}.", data: opts });
			}
		}
		function popStack() {
			callbackStack.pop();
		}
		return {
			ArrowFunctionExpression: checkFunction,
			"ArrowFunctionExpression:exit": popStack,

			FunctionExpression: checkFunction,
			"FunctionExpression:exit": popStack
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var lodash = __webpack_require__(10);

var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce a maximum number of parameters in function definitions",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			oneOf: [{
				type: "integer",
				minimum: 0
			}, {
				type: "object",
				properties: {
					maximum: {
						type: "integer",
						minimum: 0
					},
					max: {
						type: "integer",
						minimum: 0
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {

		var option = context.options[0];
		var numParams = 3;

		if ((typeof option === "undefined" ? "undefined" : _typeof(option)) === "object" && option.hasOwnProperty("maximum") && typeof option.maximum === "number") {
			numParams = option.maximum;
		}
		if ((typeof option === "undefined" ? "undefined" : _typeof(option)) === "object" && option.hasOwnProperty("max") && typeof option.max === "number") {
			numParams = option.max;
		}
		if (typeof option === "number") {
			numParams = option;
		}
		function checkFunction(node) {
			if (node.params.length > numParams) {
				context.report({
					node: node,
					message: "{{name}} has too many parameters ({{count}}). Maximum allowed is {{max}}.",
					data: {
						name: lodash.upperFirst(astUtils.getFunctionNameWithKind(node)),
						count: node.params.length,
						max: numParams
					}
				});
			}
		}

		return {
			FunctionDeclaration: checkFunction,
			ArrowFunctionExpression: checkFunction,
			FunctionExpression: checkFunction
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce a maximum number of statements allowed per line",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				max: {
					type: "integer",
					minimum: 1
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var sourceCode = context.getSourceCode(),
			options = context.options[0] || {},
			maxStatementsPerLine = typeof options.max !== "undefined" ? options.max : 1,
			message = "This line has {{numberOfStatementsOnThisLine}} {{statements}}. Maximum allowed is {{maxStatementsPerLine}}.";

		var lastStatementLine = 0,
			numberOfStatementsOnThisLine = 0,
			firstExtraStatement = void 0;
		var SINGLE_CHILD_ALLOWED = /^(?:(?:DoWhile|For|ForIn|ForOf|If|Labeled|While)Statement|Export(?:Default|Named)Declaration)$/;
		function reportFirstExtraStatementAndClear() {
			if (firstExtraStatement) {
				context.report({
					node: firstExtraStatement,
					message: message,
					data: {
						numberOfStatementsOnThisLine: numberOfStatementsOnThisLine,
						maxStatementsPerLine: maxStatementsPerLine,
						statements: numberOfStatementsOnThisLine === 1 ? "statement" : "statements"
					}
				});
			}
			firstExtraStatement = null;
		}
		function getActualLastToken(node) {
			return sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);
		}
		function enterStatement(node) {
			var line = node.loc.start.line;
			if (SINGLE_CHILD_ALLOWED.test(node.parent.type) && node.parent.alternate !== node) {
				return;
			}
			if (line === lastStatementLine) {
				numberOfStatementsOnThisLine += 1;
			} else {
				reportFirstExtraStatementAndClear();
				numberOfStatementsOnThisLine = 1;
				lastStatementLine = line;
			}
			if (numberOfStatementsOnThisLine === maxStatementsPerLine + 1) {
				firstExtraStatement = firstExtraStatement || node;
			}
		}
		function leaveStatement(node) {
			var line = getActualLastToken(node).loc.end.line;
			if (line !== lastStatementLine) {
				reportFirstExtraStatementAndClear();
				numberOfStatementsOnThisLine = 1;
				lastStatementLine = line;
			}
		}
		return {
			BreakStatement: enterStatement,
			ClassDeclaration: enterStatement,
			ContinueStatement: enterStatement,
			DebuggerStatement: enterStatement,
			DoWhileStatement: enterStatement,
			ExpressionStatement: enterStatement,
			ForInStatement: enterStatement,
			ForOfStatement: enterStatement,
			ForStatement: enterStatement,
			FunctionDeclaration: enterStatement,
			IfStatement: enterStatement,
			ImportDeclaration: enterStatement,
			LabeledStatement: enterStatement,
			ReturnStatement: enterStatement,
			SwitchStatement: enterStatement,
			ThrowStatement: enterStatement,
			TryStatement: enterStatement,
			VariableDeclaration: enterStatement,
			WhileStatement: enterStatement,
			WithStatement: enterStatement,
			ExportNamedDeclaration: enterStatement,
			ExportDefaultDeclaration: enterStatement,
			ExportAllDeclaration: enterStatement,

			"BreakStatement:exit": leaveStatement,
			"ClassDeclaration:exit": leaveStatement,
			"ContinueStatement:exit": leaveStatement,
			"DebuggerStatement:exit": leaveStatement,
			"DoWhileStatement:exit": leaveStatement,
			"ExpressionStatement:exit": leaveStatement,
			"ForInStatement:exit": leaveStatement,
			"ForOfStatement:exit": leaveStatement,
			"ForStatement:exit": leaveStatement,
			"FunctionDeclaration:exit": leaveStatement,
			"IfStatement:exit": leaveStatement,
			"ImportDeclaration:exit": leaveStatement,
			"LabeledStatement:exit": leaveStatement,
			"ReturnStatement:exit": leaveStatement,
			"SwitchStatement:exit": leaveStatement,
			"ThrowStatement:exit": leaveStatement,
			"TryStatement:exit": leaveStatement,
			"VariableDeclaration:exit": leaveStatement,
			"WhileStatement:exit": leaveStatement,
			"WithStatement:exit": leaveStatement,
			"ExportNamedDeclaration:exit": leaveStatement,
			"ExportDefaultDeclaration:exit": leaveStatement,
			"ExportAllDeclaration:exit": leaveStatement,
			"Program:exit": reportFirstExtraStatementAndClear
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var lodash = __webpack_require__(10);

var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce a maximum number of statements allowed in function blocks",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			oneOf: [{
				type: "integer",
				minimum: 0
			}, {
				type: "object",
				properties: {
					maximum: {
						type: "integer",
						minimum: 0
					},
					max: {
						type: "integer",
						minimum: 0
					}
				},
				additionalProperties: false
			}]
		}, {
			type: "object",
			properties: {
				ignoreTopLevelFunctions: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var functionStack = [],
			option = context.options[0],
			ignoreTopLevelFunctions = context.options[1] && context.options[1].ignoreTopLevelFunctions || false,
			topLevelFunctions = [];
		var maxStatements = 10;

		if ((typeof option === "undefined" ? "undefined" : _typeof(option)) === "object" && option.hasOwnProperty("maximum") && typeof option.maximum === "number") {
			maxStatements = option.maximum;
		}
		if ((typeof option === "undefined" ? "undefined" : _typeof(option)) === "object" && option.hasOwnProperty("max") && typeof option.max === "number") {
			maxStatements = option.max;
		}
		if (typeof option === "number") {
			maxStatements = option;
		}
		function reportIfTooManyStatements(node, count, max) {
			if (count > max) {
				var name = lodash.upperFirst(astUtils.getFunctionNameWithKind(node));

				context.report({
					node: node,
					message: "{{name}} has too many statements ({{count}}). Maximum allowed is {{max}}.",
					data: { name: name, count: count, max: max }
				});
			}
		}
		function startFunction() {
			functionStack.push(0);
		}
		function endFunction(node) {
			var count = functionStack.pop();

			if (ignoreTopLevelFunctions && functionStack.length === 0) {
				topLevelFunctions.push({ node: node, count: count });
			} else {
				reportIfTooManyStatements(node, count, maxStatements);
			}
		}
		function countStatements(node) {
			functionStack[functionStack.length - 1] += node.body.length;
		}
		return {
			FunctionDeclaration: startFunction,
			FunctionExpression: startFunction,
			ArrowFunctionExpression: startFunction,

			BlockStatement: countStatements,

			"FunctionDeclaration:exit": endFunction,
			"FunctionExpression:exit": endFunction,
			"ArrowFunctionExpression:exit": endFunction,

			"Program:exit": function ProgramExit() {
				if (topLevelFunctions.length === 1) {
					return;
				}

				topLevelFunctions.forEach(function (element) {
					var count = element.count;
					var node = element.node;

					reportIfTooManyStatements(node, count, maxStatements);
				});
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce a particular style for multiline comments",
			category: "Stylistic Issues",
			recommended: false
		},
		fixable: "whitespace",
		schema: [{ enum: ["starred-block", "separate-lines", "bare-block"] }]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var option = context.options[0] || "starred-block";

		var EXPECTED_BLOCK_ERROR = "Expected a block comment instead of consecutive line comments.";
		var START_NEWLINE_ERROR = "Expected a linebreak after '/*'.";
		var END_NEWLINE_ERROR = "Expected a linebreak before '*/'.";
		var MISSING_STAR_ERROR = "Expected a '*' at the start of this line.";
		var ALIGNMENT_ERROR = "Expected this line to be aligned with the start of the comment.";
		var EXPECTED_LINES_ERROR = "Expected multiple line comments instead of a block comment.";
		function getCommentLines(commentGroup) {
			if (commentGroup[0].type === "Line") {
				return commentGroup.map(function (comment) {
					return comment.value;
				});
			}
			return commentGroup[0].value.split(astUtils.LINEBREAK_MATCHER).map(function (line) {
				return line.replace(/^\s*\*?/, "");
			});
		}
		function convertToStarredBlock(firstComment, commentLinesList) {
			var initialOffset = sourceCode.text.slice(firstComment.range[0] - firstComment.loc.start.column, firstComment.range[0]);
			var starredLines = commentLinesList.map(function (line) {
				return initialOffset + " *" + line;
			});

			return "\n" + starredLines.join("\n") + "\n" + initialOffset + " ";
		}
		function convertToSeparateLines(firstComment, commentLinesList) {
			var initialOffset = sourceCode.text.slice(firstComment.range[0] - firstComment.loc.start.column, firstComment.range[0]);
			var separateLines = commentLinesList.map(function (line) {
				return "// " + line.trim();
			});

			return separateLines.join("\n" + initialOffset);
		}
		function convertToBlock(firstComment, commentLinesList) {
			var initialOffset = sourceCode.text.slice(firstComment.range[0] - firstComment.loc.start.column, firstComment.range[0]);
			var blockLines = commentLinesList.map(function (line) {
				return line.trim();
			});

			return "/* " + blockLines.join("\n" + initialOffset + "   ") + " */";
		}
		function isJSDoc(commentGroup) {
			var lines = commentGroup[0].value.split(astUtils.LINEBREAK_MATCHER);

			return commentGroup[0].type === "Block" && /^\*\s*$/.test(lines[0]) && lines.slice(1, -1).every(function (line) {
				return (/^\s* /.test(line)
				);
			}) && /^\s*$/.test(lines[lines.length - 1]);
		}
		var commentGroupCheckers = {
			"starred-block": function starredBlock(commentGroup) {
				var commentLines = getCommentLines(commentGroup);

				if (commentLines.some(function (value) {
					return value.includes("*/");
				})) {
					return;
				}

				if (commentGroup.length > 1) {
					context.report({
						loc: {
							start: commentGroup[0].loc.start,
							end: commentGroup[commentGroup.length - 1].loc.end
						},
						message: EXPECTED_BLOCK_ERROR,
						fix: function fix(fixer) {
							var range = [commentGroup[0].range[0], commentGroup[commentGroup.length - 1].range[1]];
							var starredBlock = "/*" + convertToStarredBlock(commentGroup[0], commentLines) + "*/";

							return commentLines.some(function (value) {
								return value.startsWith("/");
							}) ? null : fixer.replaceTextRange(range, starredBlock);
						}
					});
				} else {
					(function () {
						var block = commentGroup[0];
						var lines = block.value.split(astUtils.LINEBREAK_MATCHER);
						var expectedLinePrefix = sourceCode.text.slice(block.range[0] - block.loc.start.column, block.range[0]) + " *";

						if (!/^\*?\s*$/.test(lines[0])) {
							var start = block.value.startsWith("*") ? block.range[0] + 1 : block.range[0];

							context.report({
								loc: {
									start: block.loc.start,
									end: { line: block.loc.start.line, column: block.loc.start.column + 2 }
								},
								message: START_NEWLINE_ERROR,
								fix: function fix(fixer) {
									return fixer.insertTextAfterRange([start, start + 2], "\n" + expectedLinePrefix);
								}
							});
						}

						if (!/^\s*$/.test(lines[lines.length - 1])) {
							context.report({
								loc: {
									start: { line: block.loc.end.line, column: block.loc.end.column - 2 },
									end: block.loc.end
								},
								message: END_NEWLINE_ERROR,
								fix: function fix(fixer) {
									return fixer.replaceTextRange([block.range[1] - 2, block.range[1]], "\n" + expectedLinePrefix + "/");
								}
							});
						}

						var _loop = function _loop(lineNumber) {
							var lineText = sourceCode.lines[lineNumber - 1];

							if (!lineText.startsWith(expectedLinePrefix)) {
								context.report({
									loc: {
										start: { line: lineNumber, column: 0 },
										end: { line: lineNumber, column: sourceCode.lines[lineNumber - 1].length }
									},
									message: /^\s*\*/.test(lineText) ? ALIGNMENT_ERROR : MISSING_STAR_ERROR,
									fix: function fix(fixer) {
										var lineStartIndex = sourceCode.getIndexFromLoc({ line: lineNumber, column: 0 });
										var linePrefixLength = lineText.match(/^\s*\*? ?/)[0].length;
										var commentStartIndex = lineStartIndex + linePrefixLength;

										var replacementText = lineNumber === block.loc.end.line || lineText.length === linePrefixLength ? expectedLinePrefix : expectedLinePrefix + " ";

										return fixer.replaceTextRange([lineStartIndex, commentStartIndex], replacementText);
									}
								});
							}
						};

						for (var lineNumber = block.loc.start.line + 1; lineNumber <= block.loc.end.line; lineNumber++) {
							_loop(lineNumber);
						}
					})();
				}
			},
			"separate-lines": function separateLines(commentGroup) {
				if (!isJSDoc(commentGroup) && commentGroup[0].type === "Block") {
					var commentLines = getCommentLines(commentGroup);
					var block = commentGroup[0];
					var tokenAfter = sourceCode.getTokenAfter(block, { includeComments: true });

					if (tokenAfter && block.loc.end.line === tokenAfter.loc.start.line) {
						return;
					}

					context.report({
						loc: {
							start: block.loc.start,
							end: { line: block.loc.start.line, column: block.loc.start.column + 2 }
						},
						message: EXPECTED_LINES_ERROR,
						fix: function fix(fixer) {
							return fixer.replaceText(block, convertToSeparateLines(block, commentLines.filter(function (line) {
								return line;
							})));
						}
					});
				}
			},
			"bare-block": function bareBlock(commentGroup) {
				if (!isJSDoc(commentGroup)) {
					var commentLines = getCommentLines(commentGroup);
					if (commentGroup[0].type === "Line" && commentLines.length > 1 && !commentLines.some(function (value) {
						return value.includes("*/");
					})) {
						context.report({
							loc: {
								start: commentGroup[0].loc.start,
								end: commentGroup[commentGroup.length - 1].loc.end
							},
							message: EXPECTED_BLOCK_ERROR,
							fix: function fix(fixer) {
								var range = [commentGroup[0].range[0], commentGroup[commentGroup.length - 1].range[1]];
								var block = convertToBlock(commentGroup[0], commentLines.filter(function (line) {
									return line;
								}));

								return fixer.replaceTextRange(range, block);
							}
						});
					}
					if (commentGroup[0].type === "Block") {
						var block = commentGroup[0];
						var lines = block.value.split(astUtils.LINEBREAK_MATCHER).filter(function (line) {
							return line.trim();
						});

						if (lines.length > 0 && lines.every(function (line) {
							return (/^\s*\*/.test(line)
							);
						})) {
							context.report({
								loc: {
									start: block.loc.start,
									end: { line: block.loc.start.line, column: block.loc.start.column + 2 }
								},
								message: EXPECTED_BLOCK_ERROR,
								fix: function fix(fixer) {
									return fixer.replaceText(block, convertToBlock(block, commentLines.filter(function (line) {
										return line;
									})));
								}
							});
						}
					}
				}
			}
		};
		return {
			Program: function Program() {
				return sourceCode.getAllComments().filter(function (comment) {
					return comment.type !== "Shebang";
				}).filter(function (comment) {
					return !astUtils.COMMENTS_IGNORE_PATTERN.test(comment.value);
				}).filter(function (comment) {
					var tokenBefore = sourceCode.getTokenBefore(comment, { includeComments: true });

					return !tokenBefore || tokenBefore.loc.end.line < comment.loc.start.line;
				}).reduce(function (commentGroups, comment, index, commentList) {
					var tokenBefore = sourceCode.getTokenBefore(comment, { includeComments: true });

					if (comment.type === "Line" && index && commentList[index - 1].type === "Line" && tokenBefore && tokenBefore.loc.end.line === comment.loc.start.line - 1 && tokenBefore === commentList[index - 1]) {
						commentGroups[commentGroups.length - 1].push(comment);
					} else {
						commentGroups.push([comment]);
					}

					return commentGroups;
				}, []).filter(function (commentGroup) {
					return !(commentGroup.length === 1 && commentGroup[0].loc.start.line === commentGroup[0].loc.end.line);
				}).forEach(commentGroupCheckers[option]);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce newlines between operands of ternary expressions",
			category: "Stylistic Issues",
			recommended: false
		},
		schema: [{
			enum: ["always", "always-multiline", "never"]
		}]
	},

	create: function create(context) {
		var option = context.options[0];
		var multiline = option !== "never";
		var allowSingleLine = option === "always-multiline";
		function reportError(node, parentNode, expected) {
			context.report({
				node: node,
				message: "{{expected}} newline between {{typeOfError}} of ternary expression.",
				data: {
					expected: expected ? "Expected" : "Unexpected",
					typeOfError: node === parentNode.test ? "test and consequent" : "consequent and alternate"
				}
			});
		}
		return {
			ConditionalExpression: function ConditionalExpression(node) {
				var areTestAndConsequentOnSameLine = astUtils.isTokenOnSameLine(node.test, node.consequent);
				var areConsequentAndAlternateOnSameLine = astUtils.isTokenOnSameLine(node.consequent, node.alternate);

				if (!multiline) {
					if (!areTestAndConsequentOnSameLine) {
						reportError(node.test, node, false);
					}

					if (!areConsequentAndAlternateOnSameLine) {
						reportError(node.consequent, node, false);
					}
				} else {
					if (allowSingleLine && node.loc.start.line === node.loc.end.line) {
						return;
					}

					if (areTestAndConsequentOnSameLine) {
						reportError(node.test, node, true);
					}

					if (areConsequentAndAlternateOnSameLine) {
						reportError(node.consequent, node, true);
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var CAPS_ALLOWED = ["Array", "Boolean", "Date", "Error", "Function", "Number", "Object", "RegExp", "String", "Symbol"];
function checkArray(obj, key, fallback) {
	if (Object.prototype.hasOwnProperty.call(obj, key) && !Array.isArray(obj[key])) {
		throw new TypeError(key + ", if provided, must be an Array");
	}
	return obj[key] || fallback;
}
function invert(map, key) {
	map[key] = true;
	return map;
}
function calculateCapIsNewExceptions(config) {
	var capIsNewExceptions = checkArray(config, "capIsNewExceptions", CAPS_ALLOWED);

	if (capIsNewExceptions !== CAPS_ALLOWED) {
		capIsNewExceptions = capIsNewExceptions.concat(CAPS_ALLOWED);
	}

	return capIsNewExceptions.reduce(invert, {});
}
module.exports = {
	meta: {
		docs: {
			description: "require constructor names to begin with a capital letter",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				newIsCap: {
					type: "boolean"
				},
				capIsNew: {
					type: "boolean"
				},
				newIsCapExceptions: {
					type: "array",
					items: {
						type: "string"
					}
				},
				newIsCapExceptionPattern: {
					type: "string"
				},
				capIsNewExceptions: {
					type: "array",
					items: {
						type: "string"
					}
				},
				capIsNewExceptionPattern: {
					type: "string"
				},
				properties: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var config = context.options[0] ? Object.assign({}, context.options[0]) : {};

		config.newIsCap = config.newIsCap !== false;
		config.capIsNew = config.capIsNew !== false;
		var skipProperties = config.properties === false;

		var newIsCapExceptions = checkArray(config, "newIsCapExceptions", []).reduce(invert, {});
		var newIsCapExceptionPattern = config.newIsCapExceptionPattern ? new RegExp(config.newIsCapExceptionPattern) : null;

		var capIsNewExceptions = calculateCapIsNewExceptions(config);
		var capIsNewExceptionPattern = config.capIsNewExceptionPattern ? new RegExp(config.capIsNewExceptionPattern) : null;

		var listeners = {};

		var sourceCode = context.getSourceCode();
		function extractNameFromExpression(node) {

			var name = "";

			if (node.callee.type === "MemberExpression") {
				var property = node.callee.property;

				if (property.type === "Literal" && typeof property.value === "string") {
					name = property.value;
				} else if (property.type === "Identifier" && !node.callee.computed) {
					name = property.name;
				}
			} else {
				name = node.callee.name;
			}
			return name;
		}
		function getCap(str) {
			var firstChar = str.charAt(0);

			var firstCharLower = firstChar.toLowerCase();
			var firstCharUpper = firstChar.toUpperCase();

			if (firstCharLower === firstCharUpper) {
				return "non-alpha";
			}
			if (firstChar === firstCharLower) {
				return "lower";
			}
			return "upper";
		}
		function isCapAllowed(allowedMap, node, calleeName, pattern) {
			var sourceText = sourceCode.getText(node.callee);

			if (allowedMap[calleeName] || allowedMap[sourceText]) {
				return true;
			}

			if (pattern && pattern.test(sourceText)) {
				return true;
			}

			if (calleeName === "UTC" && node.callee.type === "MemberExpression") {
				return node.callee.object.type === "Identifier" && node.callee.object.name === "Date";
			}

			return skipProperties && node.callee.type === "MemberExpression";
		}
		function report(node, message) {
			var callee = node.callee;

			if (callee.type === "MemberExpression") {
				callee = callee.property;
			}

			context.report({ node: node, loc: callee.loc.start, message: message });
		}
		if (config.newIsCap) {
			listeners.NewExpression = function (node) {

				var constructorName = extractNameFromExpression(node);

				if (constructorName) {
					var capitalization = getCap(constructorName);
					var isAllowed = capitalization !== "lower" || isCapAllowed(newIsCapExceptions, node, constructorName, newIsCapExceptionPattern);

					if (!isAllowed) {
						report(node, "A constructor name should not start with a lowercase letter.");
					}
				}
			};
		}

		if (config.capIsNew) {
			listeners.CallExpression = function (node) {

				var calleeName = extractNameFromExpression(node);

				if (calleeName) {
					var capitalization = getCap(calleeName);
					var isAllowed = capitalization !== "upper" || isCapAllowed(capIsNewExceptions, node, calleeName, capIsNewExceptionPattern);

					if (!isAllowed) {
						report(node, "A function with a name starting with an uppercase letter should only be used as a constructor.");
					}
				}
			};
		}

		return listeners;
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "require parentheses when invoking a constructor with no arguments",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [],

		fixable: "code"
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		return {
			NewExpression: function NewExpression(node) {
				if (node.arguments.length !== 0) {
					return; // shortcut: if there are arguments, there have to be parens
				}

				var lastToken = sourceCode.getLastToken(node);
				var hasLastParen = lastToken && astUtils.isClosingParenToken(lastToken);
				var hasParens = hasLastParen && astUtils.isOpeningParenToken(sourceCode.getTokenBefore(lastToken));

				if (!hasParens) {
					context.report({
						node: node,
						message: "Missing '()' invoking a constructor.",
						fix: function fix(fixer) {
							return fixer.insertTextAfter(node, "()");
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "require or disallow an empty line after variable declarations",
			category: "Stylistic Issues",
			recommended: false,
			replacedBy: ["padding-line-between-statements"]
		},

		schema: [{
			enum: ["never", "always"]
		}],

		fixable: "whitespace",

		deprecated: true
	},

	create: function create(context) {

		var ALWAYS_MESSAGE = "Expected blank line after variable declarations.",
			NEVER_MESSAGE = "Unexpected blank line after variable declarations.";

		var sourceCode = context.getSourceCode();
		var mode = context.options[0] === "never" ? "never" : "always";
		var commentEndLine = sourceCode.getAllComments().reduce(function (result, token) {
			result[token.loc.start.line] = token.loc.end.line;
			return result;
		}, {});
		function getLastToken(node) {
			var lastToken = sourceCode.getLastToken(node);

			if (lastToken.type === "Punctuator" && lastToken.value === ";") {
				var prevToken = sourceCode.getTokenBefore(lastToken);

				if (prevToken.loc.end.line !== lastToken.loc.start.line) {
					return prevToken;
				}
			}

			return lastToken;
		}
		function isVar(keyword) {
			return keyword === "var" || keyword === "let" || keyword === "const";
		}
		function isForTypeSpecifier(keyword) {
			return keyword === "ForStatement" || keyword === "ForInStatement" || keyword === "ForOfStatement";
		}
		function isExportSpecifier(nodeType) {
			return nodeType === "ExportNamedDeclaration" || nodeType === "ExportSpecifier" || nodeType === "ExportDefaultDeclaration" || nodeType === "ExportAllDeclaration";
		}
		function isLastNode(node) {
			var token = sourceCode.getTokenAfter(node);

			return !token || token.type === "Punctuator" && token.value === "}";
		}
		function getLastCommentLineOfBlock(commentStartLine) {
			var currentCommentEnd = commentEndLine[commentStartLine];

			return commentEndLine[currentCommentEnd + 1] ? getLastCommentLineOfBlock(currentCommentEnd + 1) : currentCommentEnd;
		}
		function hasBlankLineAfterComment(token, commentStartLine) {
			return token.loc.start.line > getLastCommentLineOfBlock(commentStartLine) + 1;
		}
		function checkForBlankLine(node) {
			var lastToken = getLastToken(node),
			nextToken = lastToken === sourceCode.getLastToken(node) ? sourceCode.getTokenAfter(node) : sourceCode.getLastToken(node),
				nextLineNum = lastToken.loc.end.line + 1;
			if (!nextToken) {
				return;
			}
			if (isForTypeSpecifier(node.parent.type)) {
				return;
			}
			if (isExportSpecifier(node.parent.type)) {
				return;
			}
			if (nextToken.type === "Keyword" && isVar(nextToken.value)) {
				return;
			}
			if (isLastNode(node)) {
				return;
			}
			var noNextLineToken = nextToken.loc.start.line > nextLineNum;
			var hasNextLineComment = typeof commentEndLine[nextLineNum] !== "undefined";

			if (mode === "never" && noNextLineToken && !hasNextLineComment) {
				context.report({
					node: node,
					message: NEVER_MESSAGE,
					data: { identifier: node.name },
					fix: function fix(fixer) {
						var linesBetween = sourceCode.getText().slice(lastToken.range[1], nextToken.range[0]).split(astUtils.LINEBREAK_MATCHER);

						return fixer.replaceTextRange([lastToken.range[1], nextToken.range[0]], linesBetween.slice(0, -1).join("") + "\n" + linesBetween[linesBetween.length - 1]);
					}
				});
			}
			if (mode === "always" && (!noNextLineToken || hasNextLineComment && !hasBlankLineAfterComment(nextToken, nextLineNum))) {
				context.report({
					node: node,
					message: ALWAYS_MESSAGE,
					data: { identifier: node.name },
					fix: function fix(fixer) {
						if ((noNextLineToken ? getLastCommentLineOfBlock(nextLineNum) : lastToken.loc.end.line) === nextToken.loc.start.line) {
							return fixer.insertTextBefore(nextToken, "\n\n");
						}

						return fixer.insertTextBeforeRange([nextToken.range[0] - nextToken.loc.start.column, nextToken.range[1]], "\n");
					}
				});
			}
		}
		return {
			VariableDeclaration: checkForBlankLine
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require an empty line before `return` statements",
			category: "Stylistic Issues",
			recommended: false,
			replacedBy: ["padding-line-between-statements"]
		},
		fixable: "whitespace",
		schema: [],
		deprecated: true
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		function isPrecededByTokens(node, testTokens) {
			var tokenBefore = sourceCode.getTokenBefore(node);

			return testTokens.some(function (token) {
				return tokenBefore.value === token;
			});
		}
		function isFirstNode(node) {
			var parentType = node.parent.type;

			if (node.parent.body) {
				return Array.isArray(node.parent.body) ? node.parent.body[0] === node : node.parent.body === node;
			}

			if (parentType === "IfStatement") {
				return isPrecededByTokens(node, ["else", ")"]);
			}
			if (parentType === "DoWhileStatement") {
				return isPrecededByTokens(node, ["do"]);
			}
			if (parentType === "SwitchCase") {
				return isPrecededByTokens(node, [":"]);
			}
			return isPrecededByTokens(node, [")"]);
		}
		function calcCommentLines(node, lineNumTokenBefore) {
			var comments = sourceCode.getCommentsBefore(node);
			var numLinesComments = 0;

			if (!comments.length) {
				return numLinesComments;
			}

			comments.forEach(function (comment) {
				numLinesComments++;

				if (comment.type === "Block") {
					numLinesComments += comment.loc.end.line - comment.loc.start.line;
				}
				if (comment.loc.start.line === lineNumTokenBefore) {
					numLinesComments--;
				}

				if (comment.loc.end.line === node.loc.start.line) {
					numLinesComments--;
				}
			});

			return numLinesComments;
		}
		function getLineNumberOfTokenBefore(node) {
			var tokenBefore = sourceCode.getTokenBefore(node);
			var lineNumTokenBefore = void 0;
			if (tokenBefore) {
				lineNumTokenBefore = tokenBefore.loc.end.line;
			} else {
				lineNumTokenBefore = 0; // global return at beginning of script
			}

			return lineNumTokenBefore;
		}
		function hasNewlineBefore(node) {
			var lineNumNode = node.loc.start.line;
			var lineNumTokenBefore = getLineNumberOfTokenBefore(node);
			var commentLines = calcCommentLines(node, lineNumTokenBefore);

			return lineNumNode - lineNumTokenBefore - commentLines > 1;
		}
		function canFix(node) {
			var leadingComments = sourceCode.getCommentsBefore(node);
			var lastLeadingComment = leadingComments[leadingComments.length - 1];
			var tokenBefore = sourceCode.getTokenBefore(node);

			if (leadingComments.length === 0) {
				return true;
			}
			if (lastLeadingComment.loc.end.line === tokenBefore.loc.end.line && lastLeadingComment.loc.end.line !== node.loc.start.line) {
				return true;
			}

			return false;
		}
		return {
			ReturnStatement: function ReturnStatement(node) {
				if (!isFirstNode(node) && !hasNewlineBefore(node)) {
					context.report({
						node: node,
						message: "Expected newline before return statement.",
						fix: function fix(fixer) {
							if (canFix(node)) {
								var tokenBefore = sourceCode.getTokenBefore(node);
								var newlines = node.loc.start.line === tokenBefore.loc.end.line ? "\n\n" : "\n";

								return fixer.insertTextBefore(node, newlines);
							}
							return null;
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "require a newline after each call in a method chain",
			category: "Stylistic Issues",
			recommended: false
		},
		fixable: "whitespace",
		schema: [{
			type: "object",
			properties: {
				ignoreChainWithDepth: {
					type: "integer",
					minimum: 1,
					maximum: 10
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var options = context.options[0] || {},
			ignoreChainWithDepth = options.ignoreChainWithDepth || 2;

		var sourceCode = context.getSourceCode();
		function getPrefix(node) {
			return node.computed ? "[" : ".";
		}
		function getPropertyText(node) {
			var prefix = getPrefix(node);
			var lines = sourceCode.getText(node.property).split(astUtils.LINEBREAK_MATCHER);
			var suffix = node.computed && lines.length === 1 ? "]" : "";

			return prefix + lines[0] + suffix;
		}

		return {
			"CallExpression:exit": function CallExpressionExit(node) {
				if (!node.callee || node.callee.type !== "MemberExpression") {
					return;
				}

				var callee = node.callee;
				var parent = callee.object;
				var depth = 1;

				while (parent && parent.callee) {
					depth += 1;
					parent = parent.callee.object;
				}

				if (depth > ignoreChainWithDepth && astUtils.isTokenOnSameLine(callee.object, callee.property)) {
					context.report({
						node: callee.property,
						loc: callee.property.loc.start,
						message: "Expected line break before `{{callee}}`.",
						data: {
							callee: getPropertyText(callee)
						},
						fix: function fix(fixer) {
							var firstTokenAfterObject = sourceCode.getTokenAfter(callee.object, astUtils.isNotClosingParenToken);

							return fixer.insertTextBefore(firstTokenAfterObject, "\n");
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var getPropertyName = __webpack_require__(0).getStaticPropertyName;
function isProhibitedIdentifier(name) {
	return (/^(alert|confirm|prompt)$/.test(name)
	);
}
function report(context, node, identifierName) {
	context.report(node, "Unexpected {{name}}.", { name: identifierName });
}
function findReference(scope, node) {
	var references = scope.references.filter(function (reference) {
		return reference.identifier.range[0] === node.range[0] && reference.identifier.range[1] === node.range[1];
	});

	if (references.length === 1) {
		return references[0];
	}
	return null;
}
function isShadowed(scope, node) {
	var reference = findReference(scope, node);

	return reference && reference.resolved && reference.resolved.defs.length > 0;
}
function isGlobalThisReferenceOrGlobalWindow(scope, node) {
	if (scope.type === "global" && node.type === "ThisExpression") {
		return true;
	}
	if (node.name === "window") {
		return !isShadowed(scope, node);
	}

	return false;
}
module.exports = {
	meta: {
		docs: {
			description: "disallow the use of `alert`, `confirm`, and `prompt`",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		return {
			CallExpression: function CallExpression(node) {
				var callee = node.callee,
					currentScope = context.getScope();
				if (callee.type === "Identifier") {
					var identifierName = callee.name;

					if (!isShadowed(currentScope, callee) && isProhibitedIdentifier(callee.name)) {
						report(context, node, identifierName);
					}
				} else if (callee.type === "MemberExpression" && isGlobalThisReferenceOrGlobalWindow(currentScope, callee.object)) {
					var _identifierName = getPropertyName(callee);

					if (isProhibitedIdentifier(_identifierName)) {
						report(context, node, _identifierName);
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow `Array` constructors",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		function check(node) {
			if (node.arguments.length !== 1 && node.callee.type === "Identifier" && node.callee.name === "Array") {
				context.report({ node: node, message: "The array literal notation [] is preferrable." });
			}
		}

		return {
			CallExpression: check,
			NewExpression: check
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var loopTypes = new Set(["ForStatement", "ForOfStatement", "ForInStatement", "WhileStatement", "DoWhileStatement"]);
var boundaryTypes = new Set(["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"]);

module.exports = {
	meta: {
		docs: {
			description: "disallow `await` inside of loops",
			category: "Possible Errors",
			recommended: false
		},
		schema: []
	},
	create: function create(context) {
		return {
			AwaitExpression: function AwaitExpression(node) {
				var ancestors = context.getAncestors();
				ancestors.reverse();
				var ancestorSet = new Set(ancestors).add(node);

				for (var i = 0; i < ancestors.length; i++) {
					var ancestor = ancestors[i];

					if (boundaryTypes.has(ancestor.type)) {
						return;
					}
					if (loopTypes.has(ancestor.type)) {
						if (ancestorSet.has(ancestor.body) || ancestorSet.has(ancestor.test) || ancestorSet.has(ancestor.update)) {
							context.report({
								node: node,
								message: "Unexpected `await` inside a loop."
							});
							return;
						}
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var BITWISE_OPERATORS = ["^", "|", "&", "<<", ">>", ">>>", "^=", "|=", "&=", "<<=", ">>=", ">>>=", "~"];
module.exports = {
	meta: {
		docs: {
			description: "disallow bitwise operators",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				allow: {
					type: "array",
					items: {
						enum: BITWISE_OPERATORS
					},
					uniqueItems: true
				},
				int32Hint: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = context.options[0] || {};
		var allowed = options.allow || [];
		var int32Hint = options.int32Hint === true;
		function report(node) {
			context.report({ node: node, message: "Unexpected use of '{{operator}}'.", data: { operator: node.operator } });
		}
		function hasBitwiseOperator(node) {
			return BITWISE_OPERATORS.indexOf(node.operator) !== -1;
		}
		function allowedOperator(node) {
			return allowed.indexOf(node.operator) !== -1;
		}
		function isInt32Hint(node) {
			return int32Hint && node.operator === "|" && node.right && node.right.type === "Literal" && node.right.value === 0;
		}
		function checkNodeForBitwiseOperator(node) {
			if (hasBitwiseOperator(node) && !allowedOperator(node) && !isInt32Hint(node)) {
				report(node);
			}
		}

		return {
			AssignmentExpression: checkNodeForBitwiseOperator,
			BinaryExpression: checkNodeForBitwiseOperator,
			UnaryExpression: checkNodeForBitwiseOperator
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow use of the Buffer() constructor",
			category: "Node.js and CommonJS",
			recommended: false
		},
		schema: []
	},

	create: function create(context) {
		return {
			"CallExpression[callee.name='Buffer'], NewExpression[callee.name='Buffer']": function CallExpressionCalleeNameBufferNewExpressionCalleeNameBuffer(node) {
				context.report({
					node: node,
					message: "{{example}} is deprecated. Use Buffer.from(), Buffer.alloc(), or Buffer.allocUnsafe() instead.",
					data: { example: node.type === "CallExpression" ? "Buffer()" : "new Buffer()" }
				});
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow the use of `arguments.caller` or `arguments.callee`",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			MemberExpression: function MemberExpression(node) {
				var objectName = node.object.name,
					propertyName = node.property.name;

				if (objectName === "arguments" && !node.computed && propertyName && propertyName.match(/^calle[er]$/)) {
					context.report({ node: node, message: "Avoid arguments.{{property}}.", data: { property: propertyName } });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow lexical declarations in case clauses",
			category: "Best Practices",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		function isLexicalDeclaration(node) {
			switch (node.type) {
				case "FunctionDeclaration":
				case "ClassDeclaration":
					return true;
				case "VariableDeclaration":
					return node.kind !== "var";
				default:
					return false;
			}
		}

		return {
			SwitchCase: function SwitchCase(node) {
				for (var i = 0; i < node.consequent.length; i++) {
					var statement = node.consequent[i];

					if (isLexicalDeclaration(statement)) {
						context.report({
							node: node,
							message: "Unexpected lexical declaration in case block."
						});
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow `catch` clause parameters from shadowing variables in the outer scope",
			category: "Variables",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		function paramIsShadowing(scope, name) {
			return astUtils.getVariableByName(scope, name) !== null;
		}
		return {
			CatchClause: function CatchClause(node) {
				var scope = context.getScope();
				if (scope.block === node) {
					scope = scope.upper;
				}

				if (paramIsShadowing(scope, node.param.name)) {
					context.report({ node: node, message: "Value of '{{name}}' may be overwritten in IE 8 and earlier.", data: { name: node.param.name } });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow reassigning class members",
			category: "ECMAScript 6",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		function checkVariable(variable) {
			astUtils.getModifyingReferences(variable.references).forEach(function (reference) {
				context.report({ node: reference.identifier, message: "'{{name}}' is a class.", data: { name: reference.identifier.name } });
			});
		}
		function checkForClass(node) {
			context.getDeclaredVariables(node).forEach(checkVariable);
		}

		return {
			ClassDeclaration: checkForClass,
			ClassExpression: checkForClass
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow comparing against -0",
			category: "Possible Errors",
			recommended: true
		},
		fixable: null,
		schema: []
	},

	create: function create(context) {
		function isNegZero(node) {
			return node.type === "UnaryExpression" && node.operator === "-" && node.argument.type === "Literal" && node.argument.value === 0;
		}
		var OPERATORS_TO_CHECK = new Set([">", ">=", "<", "<=", "==", "===", "!=", "!=="]);

		return {
			BinaryExpression: function BinaryExpression(node) {
				if (OPERATORS_TO_CHECK.has(node.operator)) {
					if (isNegZero(node.left) || isNegZero(node.right)) {
						context.report({
							node: node,
							message: "Do not use the '{{operator}}' operator to compare against -0.",
							data: { operator: node.operator }
						});
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var astUtils = __webpack_require__(0);

var NODE_DESCRIPTIONS = {
	DoWhileStatement: "a 'do...while' statement",
	ForStatement: "a 'for' statement",
	IfStatement: "an 'if' statement",
	WhileStatement: "a 'while' statement"
};
module.exports = {
	meta: {
		docs: {
			description: "disallow assignment operators in conditional expressions",
			category: "Possible Errors",
			recommended: true
		},

		schema: [{
			enum: ["except-parens", "always"]
		}]
	},

	create: function create(context) {

		var prohibitAssign = context.options[0] || "except-parens";

		var sourceCode = context.getSourceCode();
		function isConditionalTestExpression(node) {
			return node.parent && node.parent.test && node === node.parent.test;
		}
		function findConditionalAncestor(node) {
			var currentAncestor = node;

			do {
				if (isConditionalTestExpression(currentAncestor)) {
					return currentAncestor.parent;
				}
			} while ((currentAncestor = currentAncestor.parent) && !astUtils.isFunction(currentAncestor));

			return null;
		}
		function isParenthesisedTwice(node) {
			var previousToken = sourceCode.getTokenBefore(node, 1),
				nextToken = sourceCode.getTokenAfter(node, 1);

			return astUtils.isParenthesised(sourceCode, node) && astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] && astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];
		}
		function testForAssign(node) {
			if (node.test && node.test.type === "AssignmentExpression" && (node.type === "ForStatement" ? !astUtils.isParenthesised(sourceCode, node.test) : !isParenthesisedTwice(node.test))) {
				context.report({
					node: node,
					loc: node.test.loc.start,
					message: "Expected a conditional expression and instead saw an assignment."
				});
			}
		}
		function testForConditionalAncestor(node) {
			var ancestor = findConditionalAncestor(node);

			if (ancestor) {
				context.report({
					node: ancestor,
					message: "Unexpected assignment within {{type}}.",
					data: {
						type: NODE_DESCRIPTIONS[ancestor.type] || ancestor.type
					}
				});
			}
		}

		if (prohibitAssign === "always") {
			return {
				AssignmentExpression: testForConditionalAncestor
			};
		}

		return {
			DoWhileStatement: testForAssign,
			ForStatement: testForAssign,
			IfStatement: testForAssign,
			WhileStatement: testForAssign
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
function isConditional(node) {
	return node && node.type === "ConditionalExpression";
}
module.exports = {
	meta: {
		docs: {
			description: "disallow arrow functions where they could be confused with comparisons",
			category: "ECMAScript 6",
			recommended: false
		},

		fixable: "code",

		schema: [{
			type: "object",
			properties: {
				allowParens: { type: "boolean" }
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var config = context.options[0] || {};
		var sourceCode = context.getSourceCode();
		function checkArrowFunc(node) {
			var body = node.body;

			if (isConditional(body) && !(config.allowParens && astUtils.isParenthesised(sourceCode, body))) {
				context.report({
					node: node,
					message: "Arrow function used ambiguously with a conditional expression.",
					fix: function fix(fixer) {
						return config.allowParens && fixer.replaceText(node.body, "(" + sourceCode.getText(node.body) + ")");
					}
				});
			}
		}

		return {
			ArrowFunctionExpression: checkArrowFunc
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow the use of `console`",
			category: "Possible Errors",
			recommended: true
		},

		schema: [{
			type: "object",
			properties: {
				allow: {
					type: "array",
					items: {
						type: "string"
					},
					minItems: 1,
					uniqueItems: true
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = context.options[0] || {};
		var allowed = options.allow || [];
		function isConsole(reference) {
			var id = reference.identifier;

			return id && id.name === "console";
		}
		function isAllowed(node) {
			var propertyName = astUtils.getStaticPropertyName(node);

			return propertyName && allowed.indexOf(propertyName) !== -1;
		}
		function isMemberAccessExceptAllowed(reference) {
			var node = reference.identifier;
			var parent = node.parent;

			return parent.type === "MemberExpression" && parent.object === node && !isAllowed(parent);
		}
		function report(reference) {
			var node = reference.identifier.parent;

			context.report({
				node: node,
				loc: node.loc,
				message: "Unexpected console statement."
			});
		}

		return {
			"Program:exit": function ProgramExit() {
				var scope = context.getScope();
				var consoleVar = astUtils.getVariableByName(scope, "console");
				var shadowed = consoleVar && consoleVar.defs.length > 0;
				var references = consoleVar ? consoleVar.references : scope.through.filter(isConsole);

				if (!shadowed) {
					references.filter(isMemberAccessExceptAllowed).forEach(report);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow reassigning `const` variables",
			category: "ECMAScript 6",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		function checkVariable(variable) {
			astUtils.getModifyingReferences(variable.references).forEach(function (reference) {
				context.report({ node: reference.identifier, message: "'{{name}}' is constant.", data: { name: reference.identifier.name } });
			});
		}

		return {
			VariableDeclaration: function VariableDeclaration(node) {
				if (node.kind === "const") {
					context.getDeclaredVariables(node).forEach(checkVariable);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow constant expressions in conditions",
			category: "Possible Errors",
			recommended: true
		},

		schema: [{
			type: "object",
			properties: {
				checkLoops: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = context.options[0] || {},
			checkLoops = options.checkLoops !== false,
			loopSetStack = [];

		var loopsInCurrentScope = new Set();
		function isLogicalIdentity(node, operator) {
			switch (node.type) {
				case "Literal":
					return operator === "||" && node.value === true || operator === "&&" && node.value === false;

				case "UnaryExpression":
					return operator === "&&" && node.operator === "void";

				case "LogicalExpression":
					return isLogicalIdentity(node.left, node.operator) || isLogicalIdentity(node.right, node.operator);
			}
			return false;
		}
		function isConstant(node, inBooleanPosition) {
			switch (node.type) {
				case "Literal":
				case "ArrowFunctionExpression":
				case "FunctionExpression":
				case "ObjectExpression":
				case "ArrayExpression":
					return true;

				case "UnaryExpression":
					if (node.operator === "void") {
						return true;
					}

					return node.operator === "typeof" && inBooleanPosition || isConstant(node.argument, true);

				case "BinaryExpression":
					return isConstant(node.left, false) && isConstant(node.right, false) && node.operator !== "in";

				case "LogicalExpression":
					{
						var isLeftConstant = isConstant(node.left, inBooleanPosition);
						var isRightConstant = isConstant(node.right, inBooleanPosition);
						var isLeftShortCircuit = isLeftConstant && isLogicalIdentity(node.left, node.operator);
						var isRightShortCircuit = isRightConstant && isLogicalIdentity(node.right, node.operator);

						return isLeftConstant && isRightConstant || isLeftShortCircuit || isRightShortCircuit;
					}

				case "AssignmentExpression":
					return node.operator === "=" && isConstant(node.right, inBooleanPosition);

				case "SequenceExpression":
					return isConstant(node.expressions[node.expressions.length - 1], inBooleanPosition);
			}
			return false;
		}
		function trackConstantConditionLoop(node) {
			if (node.test && isConstant(node.test, true)) {
				loopsInCurrentScope.add(node);
			}
		}
		function checkConstantConditionLoopInSet(node) {
			if (loopsInCurrentScope.has(node)) {
				loopsInCurrentScope.delete(node);
				context.report({ node: node.test, message: "Unexpected constant condition." });
			}
		}
		function reportIfConstant(node) {
			if (node.test && isConstant(node.test, true)) {
				context.report({ node: node.test, message: "Unexpected constant condition." });
			}
		}
		function enterFunction() {
			loopSetStack.push(loopsInCurrentScope);
			loopsInCurrentScope = new Set();
		}
		function exitFunction() {
			loopsInCurrentScope = loopSetStack.pop();
		}
		function checkLoop(node) {
			if (checkLoops) {
				trackConstantConditionLoop(node);
			}
		}
		return {
			ConditionalExpression: reportIfConstant,
			IfStatement: reportIfConstant,
			WhileStatement: checkLoop,
			"WhileStatement:exit": checkConstantConditionLoopInSet,
			DoWhileStatement: checkLoop,
			"DoWhileStatement:exit": checkConstantConditionLoopInSet,
			ForStatement: checkLoop,
			"ForStatement > .test": function ForStatementTest(node) {
				return checkLoop(node.parent);
			},
			"ForStatement:exit": checkConstantConditionLoopInSet,
			FunctionDeclaration: enterFunction,
			"FunctionDeclaration:exit": exitFunction,
			YieldExpression: function YieldExpression() {
				return loopsInCurrentScope.clear();
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow `continue` statements",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			ContinueStatement: function ContinueStatement(node) {
				context.report({ node: node, message: "Unexpected use of continue statement." });
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow control characters in regular expressions",
			category: "Possible Errors",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		function getRegExp(node) {
			if (node.value instanceof RegExp) {
				return node.value;
			}
			if (typeof node.value === "string") {

				var parent = context.getAncestors().pop();

				if ((parent.type === "NewExpression" || parent.type === "CallExpression") && parent.callee.type === "Identifier" && parent.callee.name === "RegExp") {
					try {
						return new RegExp(node.value);
					} catch (ex) {
						return null;
					}
				}
			}

			return null;
		}

		var controlChar = /[\x00-\x1f]/g; // eslint-disable-line no-control-regex
		var consecutiveSlashes = /\\+/g;
		var consecutiveSlashesAtEnd = /\\+$/g;
		var stringControlChar = /\\x[01][0-9a-f]/ig;
		var stringControlCharWithoutSlash = /x[01][0-9a-f]/ig;
		function getControlCharacters(regexStr) {
			var controlChars = regexStr.match(controlChar) || [];

			var stringControlChars = [];
			var subStrIndex = regexStr.search(stringControlChar);

			if (subStrIndex > -1) {
				var possibleEscapeCharacters = regexStr.slice(0, subStrIndex).match(consecutiveSlashesAtEnd);

				var hasControlChars = possibleEscapeCharacters === null || !(possibleEscapeCharacters[0].length % 2);

				if (hasControlChars) {
					stringControlChars = regexStr.slice(subStrIndex, -1).split(consecutiveSlashes).filter(Boolean).map(function (x) {
						var match = x.match(stringControlCharWithoutSlash) || [x];

						return "\\" + match[0];
					});
				}
			}

			return controlChars.map(function (x) {
				var hexCode = ("0" + x.charCodeAt(0).toString(16)).slice(-2);

				return "\\x" + hexCode;
			}).concat(stringControlChars);
		}

		return {
			Literal: function Literal(node) {
				var regex = getRegExp(node);

				if (regex) {
					var computedValue = regex.toString();

					var controlCharacters = getControlCharacters(computedValue);

					if (controlCharacters.length > 0) {
						context.report({
							node: node,
							message: "Unexpected control character(s) in regular expression: {{controlChars}}.",
							data: {
								controlChars: controlCharacters.join(", ")
							}
						});
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow the use of `debugger`",
			category: "Possible Errors",
			recommended: true
		},
		fixable: "code",
		schema: []
	},

	create: function create(context) {

		return {
			DebuggerStatement: function DebuggerStatement(node) {
				context.report({
					node: node,
					message: "Unexpected 'debugger' statement.",
					fix: function fix(fixer) {
						if (astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {
							return fixer.remove(node);
						}
						return null;
					}
				});
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow deleting variables",
			category: "Variables",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {

		return {
			UnaryExpression: function UnaryExpression(node) {
				if (node.operator === "delete" && node.argument.type === "Identifier") {
					context.report({ node: node, message: "Variables should not be deleted." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow division operators explicitly at the beginning of regular expressions",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		return {
			Literal: function Literal(node) {
				var token = sourceCode.getFirstToken(node);

				if (token.type === "RegularExpression" && token.value[1] === "=") {
					context.report({ node: node, message: "A regular expression literal can be confused with '/='." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow duplicate arguments in `function` definitions",
			category: "Possible Errors",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		function isParameter(def) {
			return def.type === "Parameter";
		}
		function checkParams(node) {
			var variables = context.getDeclaredVariables(node);

			for (var i = 0; i < variables.length; ++i) {
				var variable = variables[i];
				var defs = variable.defs.filter(isParameter);

				if (defs.length >= 2) {
					context.report({
						node: node,
						message: "Duplicate param '{{name}}'.",
						data: { name: variable.name }
					});
				}
			}
		}
		return {
			FunctionDeclaration: checkParams,
			FunctionExpression: checkParams
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow duplicate class members",
			category: "ECMAScript 6",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		var stack = [];
		function getState(name, isStatic) {
			var stateMap = stack[stack.length - 1];
			var key = "$" + name; // to avoid "__proto__".

			if (!stateMap[key]) {
				stateMap[key] = {
					nonStatic: { init: false, get: false, set: false },
					static: { init: false, get: false, set: false }
				};
			}

			return stateMap[key][isStatic ? "static" : "nonStatic"];
		}
		function getName(node) {
			switch (node.type) {
				case "Identifier":
					return node.name;
				case "Literal":
					return String(node.value);
				default:
					return "";
			}
		}

		return {
			Program: function Program() {
				stack = [];
			},
			ClassBody: function ClassBody() {
				stack.push(Object.create(null));
			},
			"ClassBody:exit": function ClassBodyExit() {
				stack.pop();
			},
			MethodDefinition: function MethodDefinition(node) {
				if (node.computed) {
					return;
				}

				var name = getName(node.key);
				var state = getState(name, node.static);
				var isDuplicate = false;

				if (node.kind === "get") {
					isDuplicate = state.init || state.get;
					state.get = true;
				} else if (node.kind === "set") {
					isDuplicate = state.init || state.set;
					state.set = true;
				} else {
					isDuplicate = state.init || state.get || state.set;
					state.init = true;
				}

				if (isDuplicate) {
					context.report({ node: node, message: "Duplicate name '{{name}}'.", data: { name: name } });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var astUtils = __webpack_require__(0);
var GET_KIND = /^(?:init|get)$/;
var SET_KIND = /^(?:init|set)$/;

var ObjectInfo = function () {
	function ObjectInfo(upper, node) {
		_classCallCheck(this, ObjectInfo);

		this.upper = upper;
		this.node = node;
		this.properties = new Map();
	}


	_createClass(ObjectInfo, [{
		key: "getPropertyInfo",
		value: function getPropertyInfo(node) {
			var name = astUtils.getStaticPropertyName(node);

			if (!this.properties.has(name)) {
				this.properties.set(name, { get: false, set: false });
			}
			return this.properties.get(name);
		}

	}, {
		key: "isPropertyDefined",
		value: function isPropertyDefined(node) {
			var entry = this.getPropertyInfo(node);

			return GET_KIND.test(node.kind) && entry.get || SET_KIND.test(node.kind) && entry.set;
		}

	}, {
		key: "defineProperty",
		value: function defineProperty(node) {
			var entry = this.getPropertyInfo(node);

			if (GET_KIND.test(node.kind)) {
				entry.get = true;
			}
			if (SET_KIND.test(node.kind)) {
				entry.set = true;
			}
		}
	}]);

	return ObjectInfo;
}();
module.exports = {
	meta: {
		docs: {
			description: "disallow duplicate keys in object literals",
			category: "Possible Errors",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		var info = null;

		return {
			ObjectExpression: function ObjectExpression(node) {
				info = new ObjectInfo(info, node);
			},
			"ObjectExpression:exit": function ObjectExpressionExit() {
				info = info.upper;
			},
			Property: function Property(node) {
				var name = astUtils.getStaticPropertyName(node);
				if (node.parent.type !== "ObjectExpression") {
					return;
				}
				if (!name) {
					return;
				}
				if (info.isPropertyDefined(node)) {
					context.report({
						node: info.node,
						loc: node.key.loc,
						message: "Duplicate key '{{name}}'.",
						data: { name: name }
					});
				}
				info.defineProperty(node);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow duplicate case labels",
			category: "Possible Errors",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		return {
			SwitchStatement: function SwitchStatement(node) {
				var mapping = {};

				node.cases.forEach(function (switchCase) {
					var key = sourceCode.getText(switchCase.test);

					if (mapping[key]) {
						context.report({ node: switchCase, message: "Duplicate case label." });
					} else {
						mapping[key] = switchCase;
					}
				});
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function getValue(node) {
	if (node && node.source && node.source.value) {
		return node.source.value.trim();
	}

	return "";
}
function checkAndReport(context, node, value, array, message) {
	if (array.indexOf(value) !== -1) {
		context.report({
			node: node,
			message: "'{{module}}' {{message}}",
			data: {
				module: value,
				message: message
			}
		});
	}
}
function handleImports(context, includeExports, importsInFile, exportsInFile) {
	return function (node) {
		var value = getValue(node);

		if (value) {
			checkAndReport(context, node, value, importsInFile, "import is duplicated.");

			if (includeExports) {
				checkAndReport(context, node, value, exportsInFile, "import is duplicated as export.");
			}

			importsInFile.push(value);
		}
	};
}
function handleExports(context, importsInFile, exportsInFile) {
	return function (node) {
		var value = getValue(node);

		if (value) {
			checkAndReport(context, node, value, exportsInFile, "export is duplicated.");
			checkAndReport(context, node, value, importsInFile, "export is duplicated as import.");

			exportsInFile.push(value);
		}
	};
}

module.exports = {
	meta: {
		docs: {
			description: "disallow duplicate module imports",
			category: "ECMAScript 6",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				includeExports: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var includeExports = (context.options[0] || {}).includeExports,
			importsInFile = [],
			exportsInFile = [];

		var handlers = {
			ImportDeclaration: handleImports(context, includeExports, importsInFile, exportsInFile)
		};

		if (includeExports) {
			handlers.ExportNamedDeclaration = handleExports(context, importsInFile, exportsInFile);
			handlers.ExportAllDeclaration = handleExports(context, importsInFile, exportsInFile);
		}

		return handlers;
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
var FixTracker = __webpack_require__(70);
module.exports = {
	meta: {
		docs: {
			description: "disallow `else` blocks after `return` statements in `if` statements",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				allowElseIf: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}],
		fixable: "code"
	},

	create: function create(context) {
		function displayReport(node) {
			context.report({
				node: node,
				message: "Unnecessary 'else' after 'return'.",
				fix: function fix(fixer) {
					var sourceCode = context.getSourceCode();
					var startToken = sourceCode.getFirstToken(node);
					var elseToken = sourceCode.getTokenBefore(startToken);
					var source = sourceCode.getText(node);
					var lastIfToken = sourceCode.getTokenBefore(elseToken);
					var fixedSource = void 0,
						firstTokenOfElseBlock = void 0;

					if (startToken.type === "Punctuator" && startToken.value === "{") {
						firstTokenOfElseBlock = sourceCode.getTokenAfter(startToken);
					} else {
						firstTokenOfElseBlock = startToken;
					}
					var ifBlockMaybeUnsafe = node.parent.consequent.type !== "BlockStatement" && lastIfToken.value !== ";";
					var elseBlockUnsafe = /^[([/+`-]/.test(firstTokenOfElseBlock.value);

					if (ifBlockMaybeUnsafe && elseBlockUnsafe) {
						return null;
					}

					var endToken = sourceCode.getLastToken(node);
					var lastTokenOfElseBlock = sourceCode.getTokenBefore(endToken);

					if (lastTokenOfElseBlock.value !== ";") {
						var nextToken = sourceCode.getTokenAfter(endToken);

						var nextTokenUnsafe = nextToken && /^[([/+`-]/.test(nextToken.value);
						var nextTokenOnSameLine = nextToken && nextToken.loc.start.line === lastTokenOfElseBlock.loc.start.line;
						if (nextTokenUnsafe || nextTokenOnSameLine && nextToken.value !== "}") {
							return null;
						}
					}

					if (startToken.type === "Punctuator" && startToken.value === "{") {
						fixedSource = source.slice(1, -1);
					} else {
						fixedSource = source;
					}
					return new FixTracker(fixer, sourceCode).retainEnclosingFunction(node).replaceTextRange([elseToken.range[0], node.range[1]], fixedSource);
				}
			});
		}
		function checkForReturn(node) {
			return node.type === "ReturnStatement";
		}
		function naiveHasReturn(node) {
			if (node.type === "BlockStatement") {
				var body = node.body,
					lastChildNode = body[body.length - 1];

				return lastChildNode && checkForReturn(lastChildNode);
			}
			return checkForReturn(node);
		}
		function hasElse(node) {
			return node.alternate && node.consequent;
		}
		function checkForIf(node) {
			return node.type === "IfStatement" && hasElse(node) && naiveHasReturn(node.alternate) && naiveHasReturn(node.consequent);
		}
		function checkForReturnOrIf(node) {
			return checkForReturn(node) || checkForIf(node);
		}
		function alwaysReturns(node) {
			if (node.type === "BlockStatement") {
				return node.body.some(checkForReturnOrIf);
			}
			return checkForReturnOrIf(node);
		}
		function checkIfWithoutElse(node) {
			var parent = node.parent;
			var consequents = void 0,
				alternate = void 0;
			if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {
				return;
			}

			for (consequents = []; node.type === "IfStatement"; node = node.alternate) {
				if (!node.alternate) {
					return;
				}
				consequents.push(node.consequent);
				alternate = node.alternate;
			}

			if (consequents.every(alwaysReturns)) {
				displayReport(alternate);
			}
		}
		function checkIfWithElse(node) {
			var parent = node.parent;
			if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {
				return;
			}

			var alternate = node.alternate;

			if (alternate && alwaysReturns(node.consequent)) {
				displayReport(alternate);
			}
		}

		var allowElseIf = !(context.options[0] && context.options[0].allowElseIf === false);
		return {

			"IfStatement:exit": allowElseIf ? checkIfWithoutElse : checkIfWithElse

		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var regex = /^\/([^\\[]|\\.|\[([^\\\]]|\\.)+])*\/[gimuy]*$/;
module.exports = {
	meta: {
		docs: {
			description: "disallow empty character classes in regular expressions",
			category: "Possible Errors",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		return {
			Literal: function Literal(node) {
				var token = sourceCode.getFirstToken(node);

				if (token.type === "RegularExpression" && !regex.test(token.value)) {
					context.report({ node: node, message: "Empty class." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
var ALLOW_OPTIONS = Object.freeze(["functions", "arrowFunctions", "generatorFunctions", "methods", "generatorMethods", "getters", "setters", "constructors"]);
function getKind(node) {
	var parent = node.parent;
	var kind = "";

	if (node.type === "ArrowFunctionExpression") {
		return "arrowFunctions";
	}
	if (parent.type === "Property") {
		if (parent.kind === "get") {
			return "getters";
		}
		if (parent.kind === "set") {
			return "setters";
		}
		kind = parent.method ? "methods" : "functions";
	} else if (parent.type === "MethodDefinition") {
		if (parent.kind === "get") {
			return "getters";
		}
		if (parent.kind === "set") {
			return "setters";
		}
		if (parent.kind === "constructor") {
			return "constructors";
		}
		kind = "methods";
	} else {
		kind = "functions";
	}
	var prefix = "";

	if (node.generator) {
		prefix = "generator";
	} else if (node.async) {
		prefix = "async";
	} else {
		return kind;
	}
	return prefix + kind[0].toUpperCase() + kind.slice(1);
}
module.exports = {
	meta: {
		docs: {
			description: "disallow empty functions",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				allow: {
					type: "array",
					items: { enum: ALLOW_OPTIONS },
					uniqueItems: true
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = context.options[0] || {};
		var allowed = options.allow || [];

		var sourceCode = context.getSourceCode();
		function reportIfEmpty(node) {
			var kind = getKind(node);
			var name = astUtils.getFunctionNameWithKind(node);
			var innerComments = sourceCode.getTokens(node.body, {
				includeComments: true,
				filter: astUtils.isCommentToken
			});

			if (allowed.indexOf(kind) === -1 && node.body.type === "BlockStatement" && node.body.body.length === 0 && innerComments.length === 0) {
				context.report({
					node: node,
					loc: node.body.loc.start,
					message: "Unexpected empty {{name}}.",
					data: { name: name }
				});
			}
		}

		return {
			ArrowFunctionExpression: reportIfEmpty,
			FunctionDeclaration: reportIfEmpty,
			FunctionExpression: reportIfEmpty
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow empty destructuring patterns",
			category: "Best Practices",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		return {
			ObjectPattern: function ObjectPattern(node) {
				if (node.properties.length === 0) {
					context.report({ node: node, message: "Unexpected empty object pattern." });
				}
			},
			ArrayPattern: function ArrayPattern(node) {
				if (node.elements.length === 0) {
					context.report({ node: node, message: "Unexpected empty array pattern." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow empty block statements",
			category: "Possible Errors",
			recommended: true
		},

		schema: [{
			type: "object",
			properties: {
				allowEmptyCatch: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = context.options[0] || {},
			allowEmptyCatch = options.allowEmptyCatch || false;

		var sourceCode = context.getSourceCode();

		return {
			BlockStatement: function BlockStatement(node) {
				if (node.body.length !== 0) {
					return;
				}
				if (astUtils.isFunction(node.parent)) {
					return;
				}

				if (allowEmptyCatch && node.parent.type === "CatchClause") {
					return;
				}
				if (sourceCode.getCommentsInside(node).length > 0) {
					return;
				}

				context.report({ node: node, message: "Empty block statement." });
			},
			SwitchStatement: function SwitchStatement(node) {

				if (typeof node.cases === "undefined" || node.cases.length === 0) {
					context.report({ node: node, message: "Empty switch statement." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow `null` comparisons without type-checking operators",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			BinaryExpression: function BinaryExpression(node) {
				var badOperator = node.operator === "==" || node.operator === "!=";

				if (node.right.type === "Literal" && node.right.raw === "null" && badOperator || node.left.type === "Literal" && node.left.raw === "null" && badOperator) {
					context.report({ node: node, message: "Use === to compare with null." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
var candidatesOfGlobalObject = Object.freeze(["global", "window"]);
function isIdentifier(node, name) {
	return node.type === "Identifier" && node.name === name;
}
function isConstant(node, name) {
	switch (node.type) {
		case "Literal":
			return node.value === name;

		case "TemplateLiteral":
			return node.expressions.length === 0 && node.quasis[0].value.cooked === name;

		default:
			return false;
	}
}
function isMember(node, name) {
	return node.type === "MemberExpression" && (node.computed ? isConstant : isIdentifier)(node.property, name);
}
module.exports = {
	meta: {
		docs: {
			description: "disallow the use of `eval()`",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				allowIndirect: { type: "boolean" }
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var allowIndirect = Boolean(context.options[0] && context.options[0].allowIndirect);
		var sourceCode = context.getSourceCode();
		var funcInfo = null;
		function enterVarScope(node) {
			var strict = context.getScope().isStrict;

			funcInfo = {
				upper: funcInfo,
				node: node,
				strict: strict,
				defaultThis: false,
				initialized: strict
			};
		}
		function exitVarScope() {
			funcInfo = funcInfo.upper;
		}
		function report(node) {
			var locationNode = node;
			var parent = node.parent;

			if (node.type === "MemberExpression") {
				locationNode = node.property;
			}
			if (parent.type === "CallExpression" && parent.callee === node) {
				node = parent;
			}

			context.report({
				node: node,
				loc: locationNode.loc.start,
				message: "eval can be harmful."
			});
		}
		function reportAccessingEvalViaGlobalObject(globalScope) {
			for (var i = 0; i < candidatesOfGlobalObject.length; ++i) {
				var name = candidatesOfGlobalObject[i];
				var variable = astUtils.getVariableByName(globalScope, name);

				if (!variable) {
					continue;
				}

				var references = variable.references;

				for (var j = 0; j < references.length; ++j) {
					var identifier = references[j].identifier;
					var node = identifier.parent;
					while (isMember(node, name)) {
						node = node.parent;
					}
					if (isMember(node, "eval")) {
						report(node);
					}
				}
			}
		}
		function reportAccessingEval(globalScope) {
			var variable = astUtils.getVariableByName(globalScope, "eval");

			if (!variable) {
				return;
			}

			var references = variable.references;

			for (var i = 0; i < references.length; ++i) {
				var reference = references[i];
				var id = reference.identifier;

				if (id.name === "eval" && !astUtils.isCallee(id)) {
					report(id);
				}
			}
		}

		if (allowIndirect) {
			return {
				"CallExpression:exit": function CallExpressionExit(node) {
					var callee = node.callee;

					if (isIdentifier(callee, "eval")) {
						report(callee);
					}
				}
			};
		}

		return {
			"CallExpression:exit": function CallExpressionExit(node) {
				var callee = node.callee;

				if (isIdentifier(callee, "eval")) {
					report(callee);
				}
			},
			Program: function Program(node) {
				var scope = context.getScope(),
					features = context.parserOptions.ecmaFeatures || {},
					strict = scope.isStrict || node.sourceType === "module" || features.globalReturn && scope.childScopes[0].isStrict;

				funcInfo = {
					upper: null,
					node: node,
					strict: strict,
					defaultThis: true,
					initialized: true
				};
			},
			"Program:exit": function ProgramExit() {
				var globalScope = context.getScope();

				exitVarScope();
				reportAccessingEval(globalScope);
				reportAccessingEvalViaGlobalObject(globalScope);
			},


			FunctionDeclaration: enterVarScope,
			"FunctionDeclaration:exit": exitVarScope,
			FunctionExpression: enterVarScope,
			"FunctionExpression:exit": exitVarScope,
			ArrowFunctionExpression: enterVarScope,
			"ArrowFunctionExpression:exit": exitVarScope,

			ThisExpression: function ThisExpression(node) {
				if (!isMember(node.parent, "eval")) {
					return;
				}
				if (!funcInfo.initialized) {
					funcInfo.initialized = true;
					funcInfo.defaultThis = astUtils.isDefaultThisBinding(funcInfo.node, sourceCode);
				}

				if (!funcInfo.strict && funcInfo.defaultThis) {
					report(node.parent);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow reassigning exceptions in `catch` clauses",
			category: "Possible Errors",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		function checkVariable(variable) {
			astUtils.getModifyingReferences(variable.references).forEach(function (reference) {
				context.report({ node: reference.identifier, message: "Do not assign to the exception parameter." });
			});
		}

		return {
			CatchClause: function CatchClause(node) {
				context.getDeclaredVariables(node).forEach(checkVariable);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
var globals = __webpack_require__(162);
var propertyDefinitionMethods = new Set(["defineProperty", "defineProperties"]);
module.exports = {
	meta: {
		docs: {
			description: "disallow extending native types",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				exceptions: {
					type: "array",
					items: {
						type: "string"
					},
					uniqueItems: true
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var config = context.options[0] || {};
		var exceptions = new Set(config.exceptions || []);
		var modifiedBuiltins = new Set(Object.keys(globals.builtin).filter(function (builtin) {
			return builtin[0].toUpperCase() === builtin[0];
		}).filter(function (builtin) {
			return !exceptions.has(builtin);
		}));
		function reportNode(node, builtin) {
			context.report({
				node: node,
				message: "{{builtin}} prototype is read only, properties should not be added.",
				data: {
					builtin: builtin
				}
			});
		}
		function isPrototypePropertyAccessed(identifierNode) {
			return Boolean(identifierNode && identifierNode.parent && identifierNode.parent.type === "MemberExpression" && identifierNode.parent.object === identifierNode && astUtils.getStaticPropertyName(identifierNode.parent) === "prototype");
		}
		function isInPrototypePropertyAssignment(identifierNode) {
			return Boolean(isPrototypePropertyAccessed(identifierNode) && identifierNode.parent.parent.type === "MemberExpression" && identifierNode.parent.parent.parent.type === "AssignmentExpression" && identifierNode.parent.parent.parent.left === identifierNode.parent.parent);
		}
		function isInDefinePropertyCall(identifierNode) {
			return Boolean(isPrototypePropertyAccessed(identifierNode) && identifierNode.parent.parent.type === "CallExpression" && identifierNode.parent.parent.arguments[0] === identifierNode.parent && identifierNode.parent.parent.callee.type === "MemberExpression" && identifierNode.parent.parent.callee.object.type === "Identifier" && identifierNode.parent.parent.callee.object.name === "Object" && identifierNode.parent.parent.callee.property.type === "Identifier" && propertyDefinitionMethods.has(identifierNode.parent.parent.callee.property.name));
		}
		function checkAndReportPrototypeExtension(identifierNode) {
			if (isInPrototypePropertyAssignment(identifierNode)) {
				reportNode(identifierNode.parent.parent.parent, identifierNode.name);
			} else if (isInDefinePropertyCall(identifierNode)) {
				reportNode(identifierNode.parent.parent, identifierNode.name);
			}
		}

		return {
			"Program:exit": function ProgramExit() {
				var globalScope = context.getScope();

				modifiedBuiltins.forEach(function (builtin) {
					var builtinVar = globalScope.set.get(builtin);

					if (builtinVar && builtinVar.references) {
						builtinVar.references.map(function (ref) {
							return ref.identifier;
						}).forEach(checkAndReportPrototypeExtension);
					}
				});
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow unnecessary calls to `.bind()`",
			category: "Best Practices",
			recommended: false
		},

		schema: [],

		fixable: "code"
	},

	create: function create(context) {
		var scopeInfo = null;
		function report(node) {
			context.report({
				node: node.parent.parent,
				message: "The function binding is unnecessary.",
				loc: node.parent.property.loc.start,
				fix: function fix(fixer) {
					var firstTokenToRemove = context.getSourceCode().getFirstTokenBetween(node.parent.object, node.parent.property, astUtils.isNotClosingParenToken);

					return fixer.removeRange([firstTokenToRemove.range[0], node.parent.parent.range[1]]);
				}
			});
		}
		function isCalleeOfBindMethod(node) {
			var parent = node.parent;
			var grandparent = parent.parent;

			return grandparent && grandparent.type === "CallExpression" && grandparent.callee === parent && grandparent.arguments.length === 1 && parent.type === "MemberExpression" && parent.object === node && astUtils.getStaticPropertyName(parent) === "bind";
		}
		function enterFunction(node) {
			scopeInfo = {
				isBound: isCalleeOfBindMethod(node),
				thisFound: false,
				upper: scopeInfo
			};
		}
		function exitFunction(node) {
			if (scopeInfo.isBound && !scopeInfo.thisFound) {
				report(node);
			}

			scopeInfo = scopeInfo.upper;
		}
		function exitArrowFunction(node) {
			if (isCalleeOfBindMethod(node)) {
				report(node);
			}
		}
		function markAsThisFound() {
			if (scopeInfo) {
				scopeInfo.thisFound = true;
			}
		}

		return {
			"ArrowFunctionExpression:exit": exitArrowFunction,
			FunctionDeclaration: enterFunction,
			"FunctionDeclaration:exit": exitFunction,
			FunctionExpression: enterFunction,
			"FunctionExpression:exit": exitFunction,
			ThisExpression: markAsThisFound
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow unnecessary boolean casts",
			category: "Possible Errors",
			recommended: true
		},

		schema: [],

		fixable: "code"
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var BOOLEAN_NODE_TYPES = ["IfStatement", "DoWhileStatement", "WhileStatement", "ConditionalExpression", "ForStatement"];
		function isInBooleanContext(node, parent) {
			return BOOLEAN_NODE_TYPES.indexOf(parent.type) !== -1 && node === parent.test ||
			parent.type === "UnaryExpression" && parent.operator === "!";
		}

		return {
			UnaryExpression: function UnaryExpression(node) {
				var ancestors = context.getAncestors(),
					parent = ancestors.pop(),
					grandparent = ancestors.pop();
				if (node.operator !== "!" || parent.type !== "UnaryExpression" || parent.operator !== "!") {
					return;
				}

				if (isInBooleanContext(parent, grandparent) ||
				(grandparent.type === "CallExpression" || grandparent.type === "NewExpression") && grandparent.callee.type === "Identifier" && grandparent.callee.name === "Boolean") {
					context.report({
						node: node,
						message: "Redundant double negation.",
						fix: function fix(fixer) {
							return fixer.replaceText(parent, sourceCode.getText(node.argument));
						}
					});
				}
			},
			CallExpression: function CallExpression(node) {
				var parent = node.parent;

				if (node.callee.type !== "Identifier" || node.callee.name !== "Boolean") {
					return;
				}

				if (isInBooleanContext(node, parent)) {
					context.report({
						node: node,
						message: "Redundant Boolean call.",
						fix: function fix(fixer) {
							if (!node.arguments.length) {
								return fixer.replaceText(parent, "true");
							}

							if (node.arguments.length > 1 || node.arguments[0].type === "SpreadElement") {
								return null;
							}

							var argument = node.arguments[0];

							if (astUtils.getPrecedence(argument) < astUtils.getPrecedence(node.parent)) {
								return fixer.replaceText(node, "(" + sourceCode.getText(argument) + ")");
							}
							return fixer.replaceText(node, sourceCode.getText(argument));
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow unnecessary labels",
			category: "Best Practices",
			recommended: false
		},

		schema: [],

		fixable: "code"
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var scopeInfo = null;
		function enterBreakableStatement(node) {
			scopeInfo = {
				label: node.parent.type === "LabeledStatement" ? node.parent.label : null,
				breakable: true,
				upper: scopeInfo
			};
		}
		function exitBreakableStatement() {
			scopeInfo = scopeInfo.upper;
		}
		function enterLabeledStatement(node) {
			if (!astUtils.isBreakableStatement(node.body)) {
				scopeInfo = {
					label: node.label,
					breakable: false,
					upper: scopeInfo
				};
			}
		}
		function exitLabeledStatement(node) {
			if (!astUtils.isBreakableStatement(node.body)) {
				scopeInfo = scopeInfo.upper;
			}
		}
		function reportIfUnnecessary(node) {
			if (!node.label) {
				return;
			}

			var labelNode = node.label;

			for (var info = scopeInfo; info !== null; info = info.upper) {
				if (info.breakable || info.label && info.label.name === labelNode.name) {
					if (info.breakable && info.label && info.label.name === labelNode.name) {
						context.report({
							node: labelNode,
							message: "This label '{{name}}' is unnecessary.",
							data: labelNode,
							fix: function fix(fixer) {
								return fixer.removeRange([sourceCode.getFirstToken(node).range[1], labelNode.range[1]]);
							}
						});
					}
					return;
				}
			}
		}

		return {
			WhileStatement: enterBreakableStatement,
			"WhileStatement:exit": exitBreakableStatement,
			DoWhileStatement: enterBreakableStatement,
			"DoWhileStatement:exit": exitBreakableStatement,
			ForStatement: enterBreakableStatement,
			"ForStatement:exit": exitBreakableStatement,
			ForInStatement: enterBreakableStatement,
			"ForInStatement:exit": exitBreakableStatement,
			ForOfStatement: enterBreakableStatement,
			"ForOfStatement:exit": exitBreakableStatement,
			SwitchStatement: enterBreakableStatement,
			"SwitchStatement:exit": exitBreakableStatement,
			LabeledStatement: enterLabeledStatement,
			"LabeledStatement:exit": exitLabeledStatement,
			BreakStatement: reportIfUnnecessary,
			ContinueStatement: reportIfUnnecessary
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);

module.exports = {
	meta: {
		docs: {
			description: "disallow unnecessary parentheses",
			category: "Possible Errors",
			recommended: false
		},

		fixable: "code",

		schema: {
			anyOf: [{
				type: "array",
				items: [{
					enum: ["functions"]
				}],
				minItems: 0,
				maxItems: 1
			}, {
				type: "array",
				items: [{
					enum: ["all"]
				}, {
					type: "object",
					properties: {
						conditionalAssign: { type: "boolean" },
						nestedBinaryExpressions: { type: "boolean" },
						returnAssign: { type: "boolean" },
						ignoreJSX: { enum: ["none", "all", "single-line", "multi-line"] },
						enforceForArrowConditionals: { type: "boolean" }
					},
					additionalProperties: false
				}],
				minItems: 0,
				maxItems: 2
			}]
		}
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		var tokensToIgnore = new WeakSet();
		var isParenthesised = astUtils.isParenthesised.bind(astUtils, sourceCode);
		var precedence = astUtils.getPrecedence;
		var ALL_NODES = context.options[0] !== "functions";
		var EXCEPT_COND_ASSIGN = ALL_NODES && context.options[1] && context.options[1].conditionalAssign === false;
		var NESTED_BINARY = ALL_NODES && context.options[1] && context.options[1].nestedBinaryExpressions === false;
		var EXCEPT_RETURN_ASSIGN = ALL_NODES && context.options[1] && context.options[1].returnAssign === false;
		var IGNORE_JSX = ALL_NODES && context.options[1] && context.options[1].ignoreJSX;
		var IGNORE_ARROW_CONDITIONALS = ALL_NODES && context.options[1] && context.options[1].enforceForArrowConditionals === false;

		var PRECEDENCE_OF_ASSIGNMENT_EXPR = precedence({ type: "AssignmentExpression" });
		var PRECEDENCE_OF_UPDATE_EXPR = precedence({ type: "UpdateExpression" });
		function ruleApplies(node) {
			if (node.type === "JSXElement") {
				var isSingleLine = node.loc.start.line === node.loc.end.line;

				switch (IGNORE_JSX) {
					case "all":
						return false;
					case "multi-line":
						return isSingleLine;
					case "single-line":
						return !isSingleLine;
					case "none":
						break;
				}
			}

			return ALL_NODES || node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression";
		}
		function isParenthesisedTwice(node) {
			var previousToken = sourceCode.getTokenBefore(node, 1),
				nextToken = sourceCode.getTokenAfter(node, 1);

			return isParenthesised(node) && previousToken && nextToken && astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] && astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];
		}
		function hasExcessParens(node) {
			return ruleApplies(node) && isParenthesised(node);
		}
		function hasDoubleExcessParens(node) {
			return ruleApplies(node) && isParenthesisedTwice(node);
		}
		function isCondAssignException(node) {
			return EXCEPT_COND_ASSIGN && node.test.type === "AssignmentExpression";
		}
		function isInReturnStatement(node) {
			while (node) {
				if (node.type === "ReturnStatement" || node.type === "ArrowFunctionExpression" && node.body.type !== "BlockStatement") {
					return true;
				}
				node = node.parent;
			}

			return false;
		}
		function isNewExpressionWithParens(newExpression) {
			var lastToken = sourceCode.getLastToken(newExpression);
			var penultimateToken = sourceCode.getTokenBefore(lastToken);

			return newExpression.arguments.length > 0 || astUtils.isOpeningParenToken(penultimateToken) && astUtils.isClosingParenToken(lastToken);
		}
		function containsAssignment(node) {
			if (node.type === "AssignmentExpression") {
				return true;
			}
			if (node.type === "ConditionalExpression" && (node.consequent.type === "AssignmentExpression" || node.alternate.type === "AssignmentExpression")) {
				return true;
			}
			if (node.left && node.left.type === "AssignmentExpression" || node.right && node.right.type === "AssignmentExpression") {
				return true;
			}

			return false;
		}
		function isReturnAssignException(node) {
			if (!EXCEPT_RETURN_ASSIGN || !isInReturnStatement(node)) {
				return false;
			}

			if (node.type === "ReturnStatement") {
				return node.argument && containsAssignment(node.argument);
			}
			if (node.type === "ArrowFunctionExpression" && node.body.type !== "BlockStatement") {
				return containsAssignment(node.body);
			}
			return containsAssignment(node);
		}
		function hasExcessParensNoLineTerminator(token, node) {
			if (token.loc.end.line === node.loc.start.line) {
				return hasExcessParens(node);
			}

			return hasDoubleExcessParens(node);
		}
		function requiresLeadingSpace(node) {
			var leftParenToken = sourceCode.getTokenBefore(node);
			var tokenBeforeLeftParen = sourceCode.getTokenBefore(node, 1);
			var firstToken = sourceCode.getFirstToken(node);

			return tokenBeforeLeftParen && tokenBeforeLeftParen.range[1] === leftParenToken.range[0] && leftParenToken.range[1] === firstToken.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeLeftParen, firstToken);
		}
		function requiresTrailingSpace(node) {
			var nextTwoTokens = sourceCode.getTokensAfter(node, { count: 2 });
			var rightParenToken = nextTwoTokens[0];
			var tokenAfterRightParen = nextTwoTokens[1];
			var tokenBeforeRightParen = sourceCode.getLastToken(node);

			return rightParenToken && tokenAfterRightParen && !sourceCode.isSpaceBetweenTokens(rightParenToken, tokenAfterRightParen) && !astUtils.canTokensBeAdjacent(tokenBeforeRightParen, tokenAfterRightParen);
		}
		function isIIFE(node) {
			return node.type === "CallExpression" && node.callee.type === "FunctionExpression";
		}
		function report(node) {
			var leftParenToken = sourceCode.getTokenBefore(node);
			var rightParenToken = sourceCode.getTokenAfter(node);

			if (!isParenthesisedTwice(node)) {
				if (tokensToIgnore.has(sourceCode.getFirstToken(node))) {
					return;
				}

				if (isIIFE(node) && !isParenthesised(node.callee)) {
					return;
				}
			}

			context.report({
				node: node,
				loc: leftParenToken.loc.start,
				message: "Gratuitous parentheses around expression.",
				fix: function fix(fixer) {
					var parenthesizedSource = sourceCode.text.slice(leftParenToken.range[1], rightParenToken.range[0]);

					return fixer.replaceTextRange([leftParenToken.range[0], rightParenToken.range[1]], (requiresLeadingSpace(node) ? " " : "") + parenthesizedSource + (requiresTrailingSpace(node) ? " " : ""));
				}
			});
		}
		function checkUnaryUpdate(node) {
			if (node.type === "UnaryExpression" && node.argument.type === "BinaryExpression" && node.argument.operator === "**") {
				return;
			}

			if (hasExcessParens(node.argument) && precedence(node.argument) >= precedence(node)) {
				report(node.argument);
			}
		}
		function doesMemberExpressionContainCallExpression(node) {
			var currentNode = node.object;
			var currentNodeType = node.object.type;

			while (currentNodeType === "MemberExpression") {
				currentNode = currentNode.object;
				currentNodeType = currentNode.type;
			}

			return currentNodeType === "CallExpression";
		}
		function checkCallNew(node) {
			var callee = node.callee;

			if (hasExcessParens(callee) && precedence(callee) >= precedence(node)) {
				var hasNewParensException = callee.type === "NewExpression" && !isNewExpressionWithParens(callee);

				if (hasDoubleExcessParens(callee) || !isIIFE(node) && !hasNewParensException && !(
				callee.type === "MemberExpression" && doesMemberExpressionContainCallExpression(callee))) {
					report(node.callee);
				}
			}
			if (node.arguments.length === 1) {
				if (hasDoubleExcessParens(node.arguments[0]) && precedence(node.arguments[0]) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {
					report(node.arguments[0]);
				}
			} else {
				node.arguments.filter(function (arg) {
					return hasExcessParens(arg) && precedence(arg) >= PRECEDENCE_OF_ASSIGNMENT_EXPR;
				}).forEach(report);
			}
		}
		function checkBinaryLogical(node) {
			var prec = precedence(node);
			var leftPrecedence = precedence(node.left);
			var rightPrecedence = precedence(node.right);
			var isExponentiation = node.operator === "**";
			var shouldSkipLeft = NESTED_BINARY && (node.left.type === "BinaryExpression" || node.left.type === "LogicalExpression") || node.left.type === "UnaryExpression" && isExponentiation;
			var shouldSkipRight = NESTED_BINARY && (node.right.type === "BinaryExpression" || node.right.type === "LogicalExpression");

			if (!shouldSkipLeft && hasExcessParens(node.left) && (leftPrecedence > prec || leftPrecedence === prec && !isExponentiation)) {
				report(node.left);
			}
			if (!shouldSkipRight && hasExcessParens(node.right) && (rightPrecedence > prec || rightPrecedence === prec && isExponentiation)) {
				report(node.right);
			}
		}
		function checkClass(node) {
			if (!node.superClass) {
				return;
			}
			var hasExtraParens = precedence(node.superClass) > PRECEDENCE_OF_UPDATE_EXPR ? hasExcessParens(node.superClass) : hasDoubleExcessParens(node.superClass);

			if (hasExtraParens) {
				report(node.superClass);
			}
		}
		function checkSpreadOperator(node) {
			var hasExtraParens = precedence(node.argument) >= PRECEDENCE_OF_ASSIGNMENT_EXPR ? hasExcessParens(node.argument) : hasDoubleExcessParens(node.argument);

			if (hasExtraParens) {
				report(node.argument);
			}
		}
		function checkExpressionOrExportStatement(node) {
			var firstToken = isParenthesised(node) ? sourceCode.getTokenBefore(node) : sourceCode.getFirstToken(node);
			var secondToken = sourceCode.getTokenAfter(firstToken, astUtils.isNotOpeningParenToken);
			var thirdToken = secondToken ? sourceCode.getTokenAfter(secondToken) : null;

			if (astUtils.isOpeningParenToken(firstToken) && (astUtils.isOpeningBraceToken(secondToken) || secondToken.type === "Keyword" && (secondToken.value === "function" || secondToken.value === "class" || secondToken.value === "let" && astUtils.isOpeningBracketToken(sourceCode.getTokenAfter(secondToken, astUtils.isNotClosingParenToken))) || secondToken && secondToken.type === "Identifier" && secondToken.value === "async" && thirdToken && thirdToken.type === "Keyword" && thirdToken.value === "function")) {
				tokensToIgnore.add(secondToken);
			}

			if (hasExcessParens(node)) {
				report(node);
			}
		}

		return {
			ArrayExpression: function ArrayExpression(node) {
				node.elements.filter(function (e) {
					return e && hasExcessParens(e) && precedence(e) >= PRECEDENCE_OF_ASSIGNMENT_EXPR;
				}).forEach(report);
			},
			ArrowFunctionExpression: function ArrowFunctionExpression(node) {
				if (isReturnAssignException(node)) {
					return;
				}

				if (node.body.type === "ConditionalExpression" && IGNORE_ARROW_CONDITIONALS && !isParenthesisedTwice(node.body)) {
					return;
				}

				if (node.body.type !== "BlockStatement") {
					var firstBodyToken = sourceCode.getFirstToken(node.body, astUtils.isNotOpeningParenToken);
					var tokenBeforeFirst = sourceCode.getTokenBefore(firstBodyToken);

					if (astUtils.isOpeningParenToken(tokenBeforeFirst) && astUtils.isOpeningBraceToken(firstBodyToken)) {
						tokensToIgnore.add(firstBodyToken);
					}
					if (hasExcessParens(node.body) && precedence(node.body) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {
						report(node.body);
					}
				}
			},
			AssignmentExpression: function AssignmentExpression(node) {
				if (isReturnAssignException(node)) {
					return;
				}

				if (hasExcessParens(node.right) && precedence(node.right) >= precedence(node)) {
					report(node.right);
				}
			},


			BinaryExpression: checkBinaryLogical,
			CallExpression: checkCallNew,

			ConditionalExpression: function ConditionalExpression(node) {
				if (isReturnAssignException(node)) {
					return;
				}

				if (hasExcessParens(node.test) && precedence(node.test) >= precedence({ type: "LogicalExpression", operator: "||" })) {
					report(node.test);
				}

				if (hasExcessParens(node.consequent) && precedence(node.consequent) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {
					report(node.consequent);
				}

				if (hasExcessParens(node.alternate) && precedence(node.alternate) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) {
					report(node.alternate);
				}
			},
			DoWhileStatement: function DoWhileStatement(node) {
				if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {
					report(node.test);
				}
			},


			ExportDefaultDeclaration: function ExportDefaultDeclaration(node) {
				return checkExpressionOrExportStatement(node.declaration);
			},
			ExpressionStatement: function ExpressionStatement(node) {
				return checkExpressionOrExportStatement(node.expression);
			},

			"ForInStatement, ForOfStatement": function ForInStatementForOfStatement(node) {
				if (node.left.type !== "VariableDeclarator") {
					var firstLeftToken = sourceCode.getFirstToken(node.left, astUtils.isNotOpeningParenToken);

					if (firstLeftToken.value === "let" && (
					firstLeftToken.range[1] === node.left.range[1] ||
					astUtils.isOpeningBracketToken(sourceCode.getTokenAfter(firstLeftToken, astUtils.isNotClosingParenToken)))) {
						tokensToIgnore.add(firstLeftToken);
					}
				}
				if (hasExcessParens(node.right)) {
					report(node.right);
				}
				if (hasExcessParens(node.left)) {
					report(node.left);
				}
			},
			ForStatement: function ForStatement(node) {
				if (node.init && hasExcessParens(node.init)) {
					report(node.init);
				}

				if (node.test && hasExcessParens(node.test) && !isCondAssignException(node)) {
					report(node.test);
				}

				if (node.update && hasExcessParens(node.update)) {
					report(node.update);
				}
			},
			IfStatement: function IfStatement(node) {
				if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {
					report(node.test);
				}
			},


			LogicalExpression: checkBinaryLogical,

			MemberExpression: function MemberExpression(node) {
				var nodeObjHasExcessParens = hasExcessParens(node.object);

				if (nodeObjHasExcessParens && precedence(node.object) >= precedence(node) && (node.computed || !(astUtils.isDecimalInteger(node.object) ||
				node.object.type === "Literal" && node.object.regex))) {
					report(node.object);
				}

				if (nodeObjHasExcessParens && node.object.type === "CallExpression" && node.parent.type !== "NewExpression") {
					report(node.object);
				}

				if (node.computed && hasExcessParens(node.property)) {
					report(node.property);
				}
			},


			NewExpression: checkCallNew,

			ObjectExpression: function ObjectExpression(node) {
				node.properties.filter(function (property) {
					var value = property.value;

					return value && hasExcessParens(value) && precedence(value) >= PRECEDENCE_OF_ASSIGNMENT_EXPR;
				}).forEach(function (property) {
					return report(property.value);
				});
			},
			ReturnStatement: function ReturnStatement(node) {
				var returnToken = sourceCode.getFirstToken(node);

				if (isReturnAssignException(node)) {
					return;
				}

				if (node.argument && hasExcessParensNoLineTerminator(returnToken, node.argument) &&
				!(node.argument.type === "Literal" && node.argument.regex)) {
					report(node.argument);
				}
			},
			SequenceExpression: function SequenceExpression(node) {
				node.expressions.filter(function (e) {
					return hasExcessParens(e) && precedence(e) >= precedence(node);
				}).forEach(report);
			},
			SwitchCase: function SwitchCase(node) {
				if (node.test && hasExcessParens(node.test)) {
					report(node.test);
				}
			},
			SwitchStatement: function SwitchStatement(node) {
				if (hasDoubleExcessParens(node.discriminant)) {
					report(node.discriminant);
				}
			},
			ThrowStatement: function ThrowStatement(node) {
				var throwToken = sourceCode.getFirstToken(node);

				if (hasExcessParensNoLineTerminator(throwToken, node.argument)) {
					report(node.argument);
				}
			},


			UnaryExpression: checkUnaryUpdate,
			UpdateExpression: checkUnaryUpdate,
			AwaitExpression: checkUnaryUpdate,

			VariableDeclarator: function VariableDeclarator(node) {
				if (node.init && hasExcessParens(node.init) && precedence(node.init) >= PRECEDENCE_OF_ASSIGNMENT_EXPR &&
				!(node.init.type === "Literal" && node.init.regex)) {
					report(node.init);
				}
			},
			WhileStatement: function WhileStatement(node) {
				if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {
					report(node.test);
				}
			},
			WithStatement: function WithStatement(node) {
				if (hasDoubleExcessParens(node.object)) {
					report(node.object);
				}
			},
			YieldExpression: function YieldExpression(node) {
				if (node.argument) {
					var yieldToken = sourceCode.getFirstToken(node);

					if (precedence(node.argument) >= precedence(node) && hasExcessParensNoLineTerminator(yieldToken, node.argument) || hasDoubleExcessParens(node.argument)) {
						report(node.argument);
					}
				}
			},


			ClassDeclaration: checkClass,
			ClassExpression: checkClass,

			SpreadElement: checkSpreadOperator,
			SpreadProperty: checkSpreadOperator,
			ExperimentalSpreadProperty: checkSpreadOperator
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var FixTracker = __webpack_require__(70);
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow unnecessary semicolons",
			category: "Possible Errors",
			recommended: true
		},

		fixable: "code",
		schema: []
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		function report(nodeOrToken) {
			context.report({
				node: nodeOrToken,
				message: "Unnecessary semicolon.",
				fix: function fix(fixer) {
					return new FixTracker(fixer, context.getSourceCode()).retainSurroundingTokens(nodeOrToken).remove(nodeOrToken);
				}
			});
		}
		function checkForPartOfClassBody(firstToken) {
			for (var token = firstToken; token.type === "Punctuator" && !astUtils.isClosingBraceToken(token); token = sourceCode.getTokenAfter(token)) {
				if (astUtils.isSemicolonToken(token)) {
					report(token);
				}
			}
		}

		return {
			EmptyStatement: function EmptyStatement(node) {
				var parent = node.parent,
					allowedParentTypes = ["ForStatement", "ForInStatement", "ForOfStatement", "WhileStatement", "DoWhileStatement", "IfStatement", "LabeledStatement", "WithStatement"];

				if (allowedParentTypes.indexOf(parent.type) === -1) {
					report(node);
				}
			},
			ClassBody: function ClassBody(node) {
				checkForPartOfClassBody(sourceCode.getFirstToken(node, 1)); // 0 is `{`.
			},
			MethodDefinition: function MethodDefinition(node) {
				checkForPartOfClassBody(sourceCode.getTokenAfter(node));
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var lodash = __webpack_require__(10);
var DEFAULT_FALLTHROUGH_COMMENT = /falls?\s?through/i;
function hasFallthroughComment(node, context, fallthroughCommentPattern) {
	var sourceCode = context.getSourceCode();
	var comment = lodash.last(sourceCode.getCommentsBefore(node));

	return Boolean(comment && fallthroughCommentPattern.test(comment.value));
}
function isReachable(segment) {
	return segment.reachable;
}
function hasBlankLinesBetween(node, token) {
	return token.loc.start.line > node.loc.end.line + 1;
}
module.exports = {
	meta: {
		docs: {
			description: "disallow fallthrough of `case` statements",
			category: "Best Practices",
			recommended: true
		},

		schema: [{
			type: "object",
			properties: {
				commentPattern: {
					type: "string"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = context.options[0] || {};
		var currentCodePath = null;
		var sourceCode = context.getSourceCode();
		var fallthroughCase = null;
		var fallthroughCommentPattern = null;

		if (options.commentPattern) {
			fallthroughCommentPattern = new RegExp(options.commentPattern);
		} else {
			fallthroughCommentPattern = DEFAULT_FALLTHROUGH_COMMENT;
		}

		return {
			onCodePathStart: function onCodePathStart(codePath) {
				currentCodePath = codePath;
			},
			onCodePathEnd: function onCodePathEnd() {
				currentCodePath = currentCodePath.upper;
			},
			SwitchCase: function SwitchCase(node) {
				if (fallthroughCase && !hasFallthroughComment(node, context, fallthroughCommentPattern)) {
					context.report({
						message: "Expected a 'break' statement before '{{type}}'.",
						data: { type: node.test ? "case" : "default" },
						node: node
					});
				}
				fallthroughCase = null;
			},
			"SwitchCase:exit": function SwitchCaseExit(node) {
				var nextToken = sourceCode.getTokenAfter(node);
				if (currentCodePath.currentSegments.some(isReachable) && (node.consequent.length > 0 || hasBlankLinesBetween(node, nextToken)) && lodash.last(node.parent.cases) !== node) {
					fallthroughCase = node;
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow leading or trailing decimal points in numeric literals",
			category: "Best Practices",
			recommended: false
		},

		schema: [],

		fixable: "code"
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		return {
			Literal: function Literal(node) {

				if (typeof node.value === "number") {
					if (node.raw.startsWith(".")) {
						context.report({
							node: node,
							message: "A leading decimal point can be confused with a dot.",
							fix: function fix(fixer) {
								var tokenBefore = sourceCode.getTokenBefore(node);
								var needsSpaceBefore = tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, "0" + node.raw);

								return fixer.insertTextBefore(node, needsSpaceBefore ? " 0" : "0");
							}
						});
					}
					if (node.raw.indexOf(".") === node.raw.length - 1) {
						context.report({
							node: node,
							message: "A trailing decimal point can be confused with a dot.",
							fix: function fix(fixer) {
								return fixer.insertTextAfter(node, "0");
							}
						});
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow reassigning `function` declarations",
			category: "Possible Errors",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		function checkReference(references) {
			astUtils.getModifyingReferences(references).forEach(function (reference) {
				context.report({ node: reference.identifier, message: "'{{name}}' is a function.", data: { name: reference.identifier.name } });
			});
		}
		function checkVariable(variable) {
			if (variable.defs[0].type === "FunctionName") {
				checkReference(variable.references);
			}
		}
		function checkForFunction(node) {
			context.getDeclaredVariables(node).forEach(checkVariable);
		}

		return {
			FunctionDeclaration: checkForFunction,
			FunctionExpression: checkForFunction
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow assignments to native objects or read-only global variables",
			category: "Best Practices",
			recommended: true
		},

		schema: [{
			type: "object",
			properties: {
				exceptions: {
					type: "array",
					items: { type: "string" },
					uniqueItems: true
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var config = context.options[0];
		var exceptions = config && config.exceptions || [];
		function checkReference(reference, index, references) {
			var identifier = reference.identifier;

			if (reference.init === false && reference.isWrite() && (
			index === 0 || references[index - 1].identifier !== identifier)) {
				context.report({
					node: identifier,
					message: "Read-only global '{{name}}' should not be modified.",
					data: identifier
				});
			}
		}
		function checkVariable(variable) {
			if (variable.writeable === false && exceptions.indexOf(variable.name) === -1) {
				variable.references.forEach(checkReference);
			}
		}

		return {
			Program: function Program() {
				var globalScope = context.getScope();

				globalScope.variables.forEach(checkVariable);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
var INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/;
var ALLOWABLE_OPERATORS = ["~", "!!", "+", "*"];
function parseOptions(options) {
	options = options || {};
	return {
		boolean: "boolean" in options ? Boolean(options.boolean) : true,
		number: "number" in options ? Boolean(options.number) : true,
		string: "string" in options ? Boolean(options.string) : true,
		allow: options.allow || []
	};
}
function isDoubleLogicalNegating(node) {
	return node.operator === "!" && node.argument.type === "UnaryExpression" && node.argument.operator === "!";
}
function isBinaryNegatingOfIndexOf(node) {
	return node.operator === "~" && node.argument.type === "CallExpression" && node.argument.callee.type === "MemberExpression" && node.argument.callee.property.type === "Identifier" && INDEX_OF_PATTERN.test(node.argument.callee.property.name);
}
function isMultiplyByOne(node) {
	return node.operator === "*" && (node.left.type === "Literal" && node.left.value === 1 || node.right.type === "Literal" && node.right.value === 1);
}
function isNumeric(node) {
	return node.type === "Literal" && typeof node.value === "number" || node.type === "CallExpression" && (node.callee.name === "Number" || node.callee.name === "parseInt" || node.callee.name === "parseFloat");
}
function getNonNumericOperand(node) {
	var left = node.left,
		right = node.right;

	if (right.type !== "BinaryExpression" && !isNumeric(right)) {
		return right;
	}

	if (left.type !== "BinaryExpression" && !isNumeric(left)) {
		return left;
	}

	return null;
}
function isEmptyString(node) {
	return astUtils.isStringLiteral(node) && (node.value === "" || node.type === "TemplateLiteral" && node.quasis.length === 1 && node.quasis[0].value.cooked === "");
}
function isConcatWithEmptyString(node) {
	return node.operator === "+" && (isEmptyString(node.left) && !astUtils.isStringLiteral(node.right) || isEmptyString(node.right) && !astUtils.isStringLiteral(node.left));
}
function isAppendEmptyString(node) {
	return node.operator === "+=" && isEmptyString(node.right);
}
function getNonEmptyOperand(node) {
	return isEmptyString(node.left) ? node.right : node.left;
}
module.exports = {
	meta: {
		docs: {
			description: "disallow shorthand type conversions",
			category: "Best Practices",
			recommended: false
		},

		fixable: "code",
		schema: [{
			type: "object",
			properties: {
				boolean: {
					type: "boolean"
				},
				number: {
					type: "boolean"
				},
				string: {
					type: "boolean"
				},
				allow: {
					type: "array",
					items: {
						enum: ALLOWABLE_OPERATORS
					},
					uniqueItems: true
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = parseOptions(context.options[0]);
		var sourceCode = context.getSourceCode();
		function report(node, recommendation, shouldFix) {
			shouldFix = typeof shouldFix === "undefined" ? true : shouldFix;

			context.report({
				node: node,
				message: "use `{{recommendation}}` instead.",
				data: {
					recommendation: recommendation
				},
				fix: function fix(fixer) {
					if (!shouldFix) {
						return null;
					}

					var tokenBefore = sourceCode.getTokenBefore(node);

					if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, recommendation)) {
						return fixer.replaceText(node, " " + recommendation);
					}
					return fixer.replaceText(node, recommendation);
				}
			});
		}

		return {
			UnaryExpression: function UnaryExpression(node) {
				var operatorAllowed = void 0;
				operatorAllowed = options.allow.indexOf("!!") >= 0;
				if (!operatorAllowed && options.boolean && isDoubleLogicalNegating(node)) {
					var recommendation = "Boolean(" + sourceCode.getText(node.argument.argument) + ")";

					report(node, recommendation);
				}
				operatorAllowed = options.allow.indexOf("~") >= 0;
				if (!operatorAllowed && options.boolean && isBinaryNegatingOfIndexOf(node)) {
					var _recommendation = sourceCode.getText(node.argument) + " !== -1";

					report(node, _recommendation, false);
				}
				operatorAllowed = options.allow.indexOf("+") >= 0;
				if (!operatorAllowed && options.number && node.operator === "+" && !isNumeric(node.argument)) {
					var _recommendation2 = "Number(" + sourceCode.getText(node.argument) + ")";

					report(node, _recommendation2);
				}
			},
			"BinaryExpression:exit": function BinaryExpressionExit(node) {
				var operatorAllowed = void 0;
				operatorAllowed = options.allow.indexOf("*") >= 0;
				var nonNumericOperand = !operatorAllowed && options.number && isMultiplyByOne(node) && getNonNumericOperand(node);

				if (nonNumericOperand) {
					var recommendation = "Number(" + sourceCode.getText(nonNumericOperand) + ")";

					report(node, recommendation);
				}
				operatorAllowed = options.allow.indexOf("+") >= 0;
				if (!operatorAllowed && options.string && isConcatWithEmptyString(node)) {
					var _recommendation3 = "String(" + sourceCode.getText(getNonEmptyOperand(node)) + ")";

					report(node, _recommendation3);
				}
			},
			AssignmentExpression: function AssignmentExpression(node) {
				var operatorAllowed = options.allow.indexOf("+") >= 0;

				if (!operatorAllowed && options.string && isAppendEmptyString(node)) {
					var code = sourceCode.getText(getNonEmptyOperand(node));
					var recommendation = code + " = String(" + code + ")";

					report(node, recommendation);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow variable and `function` declarations in the global scope",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		return {
			Program: function Program() {
				var scope = context.getScope();

				scope.variables.forEach(function (variable) {
					if (variable.writeable) {
						return;
					}

					variable.defs.forEach(function (def) {
						if (def.type === "FunctionName" || def.type === "Variable" && def.parent.kind === "var") {
							context.report({ node: def.node, message: "Implicit global variable, assign as global property instead." });
						}
					});
				});

				scope.implicit.variables.forEach(function (variable) {
					var scopeVariable = scope.set.get(variable.name);

					if (scopeVariable && scopeVariable.writeable) {
						return;
					}

					variable.defs.forEach(function (def) {
						context.report({ node: def.node, message: "Implicit global variable, assign as global property instead." });
					});
				});
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow the use of `eval()`-like methods",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		var CALLEE_RE = /^(setTimeout|setInterval|execScript)$/;
		var impliedEvalAncestorsStack = [];
		function last(arr) {
			return arr ? arr[arr.length - 1] : null;
		}
		function isImpliedEvalMemberExpression(node) {
			var object = node.object,
				property = node.property,
				hasImpliedEvalName = CALLEE_RE.test(property.name) || CALLEE_RE.test(property.value);

			return object.name === "window" && hasImpliedEvalName;
		}
		function isImpliedEvalCallExpression(node) {
			var isMemberExpression = node.callee.type === "MemberExpression",
				isIdentifier = node.callee.type === "Identifier",
				isImpliedEvalCallee = isIdentifier && CALLEE_RE.test(node.callee.name) || isMemberExpression && isImpliedEvalMemberExpression(node.callee);

			return isImpliedEvalCallee && node.arguments.length;
		}
		function hasImpliedEvalParent(node) {
			return node.parent === last(last(impliedEvalAncestorsStack)) && (
			node.parent.type !== "CallExpression" || node === node.parent.arguments[0]);
		}
		function checkString(node) {
			if (hasImpliedEvalParent(node)) {
				var substack = impliedEvalAncestorsStack.pop();

				context.report({ node: substack[0], message: "Implied eval. Consider passing a function instead of a string." });
			}
		}
		return {
			CallExpression: function CallExpression(node) {
				if (isImpliedEvalCallExpression(node)) {
					impliedEvalAncestorsStack.push([node]);
				}
			},
			"CallExpression:exit": function CallExpressionExit(node) {
				if (node === last(last(impliedEvalAncestorsStack))) {
					impliedEvalAncestorsStack.pop();
				}
			},
			BinaryExpression: function BinaryExpression(node) {
				if (node.operator === "+" && hasImpliedEvalParent(node)) {
					last(impliedEvalAncestorsStack).push(node);
				}
			},
			"BinaryExpression:exit": function BinaryExpressionExit(node) {
				if (node === last(last(impliedEvalAncestorsStack))) {
					last(impliedEvalAncestorsStack).pop();
				}
			},
			Literal: function Literal(node) {
				if (typeof node.value === "string") {
					checkString(node);
				}
			},
			TemplateLiteral: function TemplateLiteral(node) {
				checkString(node);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow inline comments after code",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		function testCodeAroundComment(node) {
			var startLine = String(sourceCode.lines[node.loc.start.line - 1]);
			var endLine = String(sourceCode.lines[node.loc.end.line - 1]);

			var preamble = startLine.slice(0, node.loc.start.column).trim();
			var postamble = endLine.slice(node.loc.end.column).trim();
			var isDirective = astUtils.isDirectiveComment(node);
			if (!isDirective && (preamble || postamble)) {
				context.report({ node: node, message: "Unexpected comment inline with code." });
			}
		}
		return {
			Program: function Program() {
				var comments = sourceCode.getAllComments();

				comments.filter(function (token) {
					return token.type !== "Shebang";
				}).forEach(testCodeAroundComment);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow variable or `function` declarations in nested blocks",
			category: "Possible Errors",
			recommended: true
		},

		schema: [{
			enum: ["functions", "both"]
		}]
	},

	create: function create(context) {
		function nearestBody() {
			var ancestors = context.getAncestors();
			var ancestor = ancestors.pop(),
				generation = 1;

			while (ancestor && ["Program", "FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"].indexOf(ancestor.type) < 0) {
				generation += 1;
				ancestor = ancestors.pop();
			}

			return {
				type: ancestor.type,
				distance: generation
			};
		}
		function check(node) {
			var body = nearestBody(),
				valid = body.type === "Program" && body.distance === 1 || body.distance === 2;

			if (!valid) {
				context.report({
					node: node,
					message: "Move {{type}} declaration to {{body}} root.",
					data: {
						type: node.type === "FunctionDeclaration" ? "function" : "variable",
						body: body.type === "Program" ? "program" : "function body"
					}
				});
			}
		}

		return {

			FunctionDeclaration: check,
			VariableDeclaration: function VariableDeclaration(node) {
				if (context.options[0] === "both" && node.kind === "var") {
					check(node);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var espree = __webpack_require__(69);
module.exports = {
	meta: {
		docs: {
			description: "disallow invalid regular expression strings in `RegExp` constructors",
			category: "Possible Errors",
			recommended: true
		},

		schema: [{
			type: "object",
			properties: {
				allowConstructorFlags: {
					type: "array",
					items: {
						type: "string"
					}
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var options = context.options[0];
		var allowedFlags = "";

		if (options && options.allowConstructorFlags) {
			allowedFlags = options.allowConstructorFlags.join("");
		}
		function isString(node) {
			return node && node.type === "Literal" && typeof node.value === "string";
		}
		function check(node) {
			if (node.callee.type === "Identifier" && node.callee.name === "RegExp" && isString(node.arguments[0])) {
				var flags = isString(node.arguments[1]) ? node.arguments[1].value : "";

				if (allowedFlags) {
					flags = flags.replace(new RegExp("[" + allowedFlags + "]", "gi"), "");
				}

				try {
					void new RegExp(node.arguments[0].value);
				} catch (e) {
					context.report({
						node: node,
						message: "{{message}}.",
						data: e
					});
				}

				if (flags) {

					try {
						espree.parse("/./" + flags, context.parserOptions);
					} catch (ex) {
						context.report({
							node: node,
							message: "Invalid flags supplied to RegExp constructor '{{flags}}'.",
							data: {
								flags: flags
							}
						});
					}
				}
			}
		}

		return {
			CallExpression: check,
			NewExpression: check
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow `this` keywords outside of classes or class-like objects",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		var stack = [],
			sourceCode = context.getSourceCode();
		stack.getCurrent = function () {
			var current = this[this.length - 1];

			if (!current.init) {
				current.init = true;
				current.valid = !astUtils.isDefaultThisBinding(current.node, sourceCode);
			}
			return current;
		};
		function enterFunction(node) {
			stack.push({
				init: !context.getScope().isStrict,
				node: node,
				valid: true
			});
		}
		function exitFunction() {
			stack.pop();
		}

		return {
			Program: function Program(node) {
				var scope = context.getScope(),
					features = context.parserOptions.ecmaFeatures || {};

				stack.push({
					init: true,
					node: node,
					valid: !(scope.isStrict || node.sourceType === "module" || features.globalReturn && scope.childScopes[0].isStrict)
				});
			},
			"Program:exit": function ProgramExit() {
				stack.pop();
			},


			FunctionDeclaration: enterFunction,
			"FunctionDeclaration:exit": exitFunction,
			FunctionExpression: enterFunction,
			"FunctionExpression:exit": exitFunction,
			ThisExpression: function ThisExpression(node) {
				var current = stack.getCurrent();

				if (current && !current.valid) {
					context.report({ node: node, message: "Unexpected 'this'." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
var ALL_IRREGULARS = /[\f\v\u0085\ufeff\u00a0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u202f\u205f\u3000\u2028\u2029]/;
var IRREGULAR_WHITESPACE = /[\f\v\u0085\ufeff\u00a0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u202f\u205f\u3000]+/mg;
var IRREGULAR_LINE_TERMINATORS = /[\u2028\u2029]/mg;
var LINE_BREAK = astUtils.createGlobalLinebreakMatcher();
module.exports = {
	meta: {
		docs: {
			description: "disallow irregular whitespace outside of strings and comments",
			category: "Possible Errors",
			recommended: true
		},

		schema: [{
			type: "object",
			properties: {
				skipComments: {
					type: "boolean"
				},
				skipStrings: {
					type: "boolean"
				},
				skipTemplates: {
					type: "boolean"
				},
				skipRegExps: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var errors = [];
		var options = context.options[0] || {};
		var skipComments = !!options.skipComments;
		var skipStrings = options.skipStrings !== false;
		var skipRegExps = !!options.skipRegExps;
		var skipTemplates = !!options.skipTemplates;

		var sourceCode = context.getSourceCode();
		var commentNodes = sourceCode.getAllComments();
		function removeWhitespaceError(node) {
			var locStart = node.loc.start;
			var locEnd = node.loc.end;

			errors = errors.filter(function (error) {
				var errorLoc = error[1];

				if (errorLoc.line >= locStart.line && errorLoc.line <= locEnd.line) {
					if (errorLoc.column >= locStart.column && (errorLoc.column <= locEnd.column || errorLoc.line < locEnd.line)) {
						return false;
					}
				}
				return true;
			});
		}
		function removeInvalidNodeErrorsInIdentifierOrLiteral(node) {
			var shouldCheckStrings = skipStrings && typeof node.value === "string";
			var shouldCheckRegExps = skipRegExps && node.value instanceof RegExp;

			if (shouldCheckStrings || shouldCheckRegExps) {
				if (ALL_IRREGULARS.test(node.raw)) {
					removeWhitespaceError(node);
				}
			}
		}
		function removeInvalidNodeErrorsInTemplateLiteral(node) {
			if (typeof node.value.raw === "string") {
				if (ALL_IRREGULARS.test(node.value.raw)) {
					removeWhitespaceError(node);
				}
			}
		}
		function removeInvalidNodeErrorsInComment(node) {
			if (ALL_IRREGULARS.test(node.value)) {
				removeWhitespaceError(node);
			}
		}
		function checkForIrregularWhitespace(node) {
			var sourceLines = sourceCode.lines;

			sourceLines.forEach(function (sourceLine, lineIndex) {
				var lineNumber = lineIndex + 1;
				var match = void 0;

				while ((match = IRREGULAR_WHITESPACE.exec(sourceLine)) !== null) {
					var location = {
						line: lineNumber,
						column: match.index
					};

					errors.push([node, location, "Irregular whitespace not allowed."]);
				}
			});
		}
		function checkForIrregularLineTerminators(node) {
			var source = sourceCode.getText(),
				sourceLines = sourceCode.lines,
				linebreaks = source.match(LINE_BREAK);
			var lastLineIndex = -1,
				match = void 0;

			while ((match = IRREGULAR_LINE_TERMINATORS.exec(source)) !== null) {
				var lineIndex = linebreaks.indexOf(match[0], lastLineIndex + 1) || 0;
				var location = {
					line: lineIndex + 1,
					column: sourceLines[lineIndex].length
				};

				errors.push([node, location, "Irregular whitespace not allowed."]);
				lastLineIndex = lineIndex;
			}
		}
		function noop() {}

		var nodes = {};

		if (ALL_IRREGULARS.test(sourceCode.getText())) {
			nodes.Program = function (node) {
				checkForIrregularWhitespace(node);
				checkForIrregularLineTerminators(node);
			};

			nodes.Identifier = removeInvalidNodeErrorsInIdentifierOrLiteral;
			nodes.Literal = removeInvalidNodeErrorsInIdentifierOrLiteral;
			nodes.TemplateElement = skipTemplates ? removeInvalidNodeErrorsInTemplateLiteral : noop;
			nodes["Program:exit"] = function () {
				if (skipComments) {
					commentNodes.forEach(removeInvalidNodeErrorsInComment);
				}
				errors.forEach(function (error) {
					context.report.apply(context, error);
				});
			};
		} else {
			nodes.Program = noop;
		}

		return nodes;
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow the use of the `__iterator__` property",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			MemberExpression: function MemberExpression(node) {

				if (node.property && node.property.type === "Identifier" && node.property.name === "__iterator__" && !node.computed || node.property.type === "Literal" && node.property.value === "__iterator__") {
					context.report({ node: node, message: "Reserved name '__iterator__'." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow labels that share a name with a variable",
			category: "Variables",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		function findIdentifier(scope, name) {
			return astUtils.getVariableByName(scope, name) !== null;
		}
		return {
			LabeledStatement: function LabeledStatement(node) {
				var scope = context.getScope();
				if (findIdentifier(scope, node.label.name)) {
					context.report({ node: node, message: "Found identifier with same name as label." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow labeled statements",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				allowLoop: {
					type: "boolean"
				},
				allowSwitch: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = context.options[0];
		var allowLoop = Boolean(options && options.allowLoop);
		var allowSwitch = Boolean(options && options.allowSwitch);
		var scopeInfo = null;
		function getBodyKind(node) {
			if (astUtils.isLoop(node)) {
				return "loop";
			}
			if (node.type === "SwitchStatement") {
				return "switch";
			}
			return "other";
		}
		function isAllowed(kind) {
			switch (kind) {
				case "loop":
					return allowLoop;
				case "switch":
					return allowSwitch;
				default:
					return false;
			}
		}
		function getKind(label) {
			var info = scopeInfo;

			while (info) {
				if (info.label === label) {
					return info.kind;
				}
				info = info.upper;
			}
			return "other";
		}
		return {
			LabeledStatement: function LabeledStatement(node) {
				scopeInfo = {
					label: node.label.name,
					kind: getBodyKind(node.body),
					upper: scopeInfo
				};
			},
			"LabeledStatement:exit": function LabeledStatementExit(node) {
				if (!isAllowed(scopeInfo.kind)) {
					context.report({
						node: node,
						message: "Unexpected labeled statement."
					});
				}

				scopeInfo = scopeInfo.upper;
			},
			BreakStatement: function BreakStatement(node) {
				if (node.label && !isAllowed(getKind(node.label.name))) {
					context.report({
						node: node,
						message: "Unexpected label in break statement."
					});
				}
			},
			ContinueStatement: function ContinueStatement(node) {
				if (node.label && !isAllowed(getKind(node.label.name))) {
					context.report({
						node: node,
						message: "Unexpected label in continue statement."
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow unnecessary nested blocks",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		var loneBlocks = [];
		var ruleDef = void 0;
		function report(node) {
			var message = node.parent.type === "BlockStatement" ? "Nested block is redundant." : "Block is redundant.";

			context.report({ node: node, message: message });
		}
		function isLoneBlock(node) {
			return node.parent.type === "BlockStatement" || node.parent.type === "Program" ||
			node.parent.type === "SwitchCase" && !(node.parent.consequent[0] === node && node.parent.consequent.length === 1);
		}
		function markLoneBlock() {
			if (loneBlocks.length === 0) {
				return;
			}

			var block = context.getAncestors().pop();

			if (loneBlocks[loneBlocks.length - 1] === block) {
				loneBlocks.pop();
			}
		}
		ruleDef = {
			BlockStatement: function BlockStatement(node) {
				if (isLoneBlock(node)) {
					report(node);
				}
			}
		};
		if (context.parserOptions.ecmaVersion >= 6) {
			ruleDef = {
				BlockStatement: function BlockStatement(node) {
					if (isLoneBlock(node)) {
						loneBlocks.push(node);
					}
				},
				"BlockStatement:exit": function BlockStatementExit(node) {
					if (loneBlocks.length > 0 && loneBlocks[loneBlocks.length - 1] === node) {
						loneBlocks.pop();
						report(node);
					}
				}
			};

			ruleDef.VariableDeclaration = function (node) {
				if (node.kind === "let" || node.kind === "const") {
					markLoneBlock();
				}
			};

			ruleDef.FunctionDeclaration = function () {
				if (context.getScope().isStrict) {
					markLoneBlock();
				}
			};

			ruleDef.ClassDeclaration = markLoneBlock;
		}

		return ruleDef;
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow `if` statements as the only statement in `else` blocks",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [],

		fixable: "code"
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		return {
			IfStatement: function IfStatement(node) {
				var ancestors = context.getAncestors(),
					parent = ancestors.pop(),
					grandparent = ancestors.pop();

				if (parent && parent.type === "BlockStatement" && parent.body.length === 1 && grandparent && grandparent.type === "IfStatement" && parent === grandparent.alternate) {
					context.report({
						node: node,
						message: "Unexpected if as the only statement in an else block.",
						fix: function fix(fixer) {
							var openingElseCurly = sourceCode.getFirstToken(parent);
							var closingElseCurly = sourceCode.getLastToken(parent);
							var elseKeyword = sourceCode.getTokenBefore(openingElseCurly);
							var tokenAfterElseBlock = sourceCode.getTokenAfter(closingElseCurly);
							var lastIfToken = sourceCode.getLastToken(node.consequent);
							var sourceText = sourceCode.getText();

							if (sourceText.slice(openingElseCurly.range[1], node.range[0]).trim() || sourceText.slice(node.range[1], closingElseCurly.range[0]).trim()) {
								return null;
							}

							if (node.consequent.type !== "BlockStatement" && lastIfToken.value !== ";" && tokenAfterElseBlock && (node.consequent.loc.end.line === tokenAfterElseBlock.loc.start.line || /^[([/+`-]/.test(tokenAfterElseBlock.value) || lastIfToken.value === "++" || lastIfToken.value === "--")) {
								return null;
							}

							return fixer.replaceTextRange([openingElseCurly.range[0], closingElseCurly.range[1]], (elseKeyword.range[1] === openingElseCurly.range[0] ? " " : "") + sourceCode.getText(node));
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function getContainingLoopNode(node) {
	var parent = node.parent;

	while (parent) {
		switch (parent.type) {
			case "WhileStatement":
			case "DoWhileStatement":
				return parent;

			case "ForStatement":
				if (parent.init !== node) {
					return parent;
				}
				break;

			case "ForInStatement":
			case "ForOfStatement":
				if (parent.right !== node) {
					return parent;
				}
				break;

			case "ArrowFunctionExpression":
			case "FunctionExpression":
			case "FunctionDeclaration":
				return null;

			default:
				break;
		}

		node = parent;
		parent = node.parent;
	}

	return null;
}
function getTopLoopNode(node, excludedNode) {
	var retv = node;
	var border = excludedNode ? excludedNode.range[1] : 0;

	while (node && node.range[0] >= border) {
		retv = node;
		node = getContainingLoopNode(node);
	}

	return retv;
}
function isSafe(loopNode, reference) {
	var variable = reference.resolved;
	var definition = variable && variable.defs[0];
	var declaration = definition && definition.parent;
	var kind = declaration && declaration.type === "VariableDeclaration" ? declaration.kind : "";
	if (kind === "const") {
		return true;
	}
	if (kind === "let" && declaration.range[0] > loopNode.range[0] && declaration.range[1] < loopNode.range[1]) {
		return true;
	}
	var border = getTopLoopNode(loopNode, kind === "let" ? declaration : null).range[0];
	function isSafeReference(upperRef) {
		var id = upperRef.identifier;

		return !upperRef.isWrite() || variable.scope.variableScope === upperRef.from.variableScope && id.range[0] < border;
	}

	return Boolean(variable) && variable.references.every(isSafeReference);
}
module.exports = {
	meta: {
		docs: {
			description: "disallow `function` declarations and expressions inside loop statements",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		function checkForLoops(node) {
			var loopNode = getContainingLoopNode(node);

			if (!loopNode) {
				return;
			}

			var references = context.getScope().through;

			if (references.length > 0 && !references.every(isSafe.bind(null, loopNode))) {
				context.report({ node: node, message: "Don't make functions within a loop." });
			}
		}

		return {
			ArrowFunctionExpression: checkForLoops,
			FunctionExpression: checkForLoops,
			FunctionDeclaration: checkForLoops
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow magic numbers",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				detectObjects: {
					type: "boolean"
				},
				enforceConst: {
					type: "boolean"
				},
				ignore: {
					type: "array",
					items: {
						type: "number"
					},
					uniqueItems: true
				},
				ignoreArrayIndexes: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var config = context.options[0] || {},
			detectObjects = !!config.detectObjects,
			enforceConst = !!config.enforceConst,
			ignore = config.ignore || [],
			ignoreArrayIndexes = !!config.ignoreArrayIndexes;
		function isNumber(node) {
			return typeof node.value === "number";
		}
		function shouldIgnoreNumber(num) {
			return ignore.indexOf(num) !== -1;
		}
		function shouldIgnoreParseInt(parent, node) {
			return parent.type === "CallExpression" && node === parent.arguments[1] && (parent.callee.name === "parseInt" || parent.callee.type === "MemberExpression" && parent.callee.object.name === "Number" && parent.callee.property.name === "parseInt");
		}
		function shouldIgnoreJSXNumbers(parent) {
			return parent.type.indexOf("JSX") === 0;
		}
		function shouldIgnoreArrayIndexes(parent) {
			return parent.type === "MemberExpression" && ignoreArrayIndexes;
		}

		return {
			Literal: function Literal(node) {
				var parent = node.parent,
					value = node.value,
					raw = node.raw;
				var okTypes = detectObjects ? [] : ["ObjectExpression", "Property", "AssignmentExpression"];

				if (!isNumber(node)) {
					return;
				}
				if (parent.type === "UnaryExpression" && parent.operator === "-") {
					node = parent;
					parent = node.parent;
					value = -value;
					raw = "-" + raw;
				}

				if (shouldIgnoreNumber(value) || shouldIgnoreParseInt(parent, node) || shouldIgnoreArrayIndexes(parent) || shouldIgnoreJSXNumbers(parent)) {
					return;
				}

				if (parent.type === "VariableDeclarator") {
					if (enforceConst && parent.parent.kind !== "const") {
						context.report({
							node: node,
							message: "Number constants declarations must use 'const'."
						});
					}
				} else if (okTypes.indexOf(parent.type) === -1 || parent.type === "AssignmentExpression" && parent.left.type === "Identifier") {
					context.report({
						node: node,
						message: "No magic number: {{raw}}.",
						data: {
							raw: raw
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
var ARITHMETIC_OPERATORS = ["+", "-", "*", "/", "%", "**"];
var BITWISE_OPERATORS = ["&", "|", "^", "~", "<<", ">>", ">>>"];
var COMPARISON_OPERATORS = ["==", "!=", "===", "!==", ">", ">=", "<", "<="];
var LOGICAL_OPERATORS = ["&&", "||"];
var RELATIONAL_OPERATORS = ["in", "instanceof"];
var ALL_OPERATORS = [].concat(ARITHMETIC_OPERATORS, BITWISE_OPERATORS, COMPARISON_OPERATORS, LOGICAL_OPERATORS, RELATIONAL_OPERATORS);
var DEFAULT_GROUPS = [ARITHMETIC_OPERATORS, BITWISE_OPERATORS, COMPARISON_OPERATORS, LOGICAL_OPERATORS, RELATIONAL_OPERATORS];
var TARGET_NODE_TYPE = /^(?:Binary|Logical)Expression$/;
function normalizeOptions(options) {
	var hasGroups = options && options.groups && options.groups.length > 0;
	var groups = hasGroups ? options.groups : DEFAULT_GROUPS;
	var allowSamePrecedence = (options && options.allowSamePrecedence) !== false;

	return {
		groups: groups,
		allowSamePrecedence: allowSamePrecedence
	};
}
function includesBothInAGroup(groups, left, right) {
	return groups.some(function (group) {
		return group.indexOf(left) !== -1 && group.indexOf(right) !== -1;
	});
}
module.exports = {
	meta: {
		docs: {
			description: "disallow mixed binary operators",
			category: "Stylistic Issues",
			recommended: false
		},
		schema: [{
			type: "object",
			properties: {
				groups: {
					type: "array",
					items: {
						type: "array",
						items: { enum: ALL_OPERATORS },
						minItems: 2,
						uniqueItems: true
					},
					uniqueItems: true
				},
				allowSamePrecedence: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var options = normalizeOptions(context.options[0]);
		function shouldIgnore(node) {
			var a = node;
			var b = node.parent;

			return !includesBothInAGroup(options.groups, a.operator, b.operator) || options.allowSamePrecedence && astUtils.getPrecedence(a) === astUtils.getPrecedence(b);
		}
		function isMixedWithParent(node) {
			return node.operator !== node.parent.operator && !astUtils.isParenthesised(sourceCode, node);
		}
		function getOperatorToken(node) {
			return sourceCode.getTokenAfter(node.left, astUtils.isNotClosingParenToken);
		}
		function reportBothOperators(node) {
			var parent = node.parent;
			var left = parent.left === node ? node : parent;
			var right = parent.left !== node ? node : parent;
			var message = "Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'.";
			var data = {
				leftOperator: left.operator,
				rightOperator: right.operator
			};

			context.report({
				node: left,
				loc: getOperatorToken(left).loc.start,
				message: message,
				data: data
			});
			context.report({
				node: right,
				loc: getOperatorToken(right).loc.start,
				message: message,
				data: data
			});
		}
		function check(node) {
			if (TARGET_NODE_TYPE.test(node.parent.type) && isMixedWithParent(node) && !shouldIgnore(node)) {
				reportBothOperators(node);
			}
		}

		return {
			BinaryExpression: check,
			LogicalExpression: check
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = {
	meta: {
		docs: {
			description: "disallow `require` calls to be mixed with regular variable declarations",
			category: "Node.js and CommonJS",
			recommended: false
		},

		schema: [{
			oneOf: [{
				type: "boolean"
			}, {
				type: "object",
				properties: {
					grouping: {
						type: "boolean"
					},
					allowCall: {
						type: "boolean"
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {

		var options = context.options[0];
		var grouping = false,
			allowCall = false;

		if ((typeof options === "undefined" ? "undefined" : _typeof(options)) === "object") {
			grouping = options.grouping;
			allowCall = options.allowCall;
		} else {
			grouping = !!options;
		}
		function getBuiltinModules() {
			return ["assert", "buffer", "child_process", "cluster", "crypto", "dgram", "dns", "domain", "events", "fs", "http", "https", "net", "os", "path", "punycode", "querystring", "readline", "repl", "smalloc", "stream", "string_decoder", "tls", "tty", "url", "util", "v8", "vm", "zlib"];
		}

		var BUILTIN_MODULES = getBuiltinModules();

		var DECL_REQUIRE = "require",
			DECL_UNINITIALIZED = "uninitialized",
			DECL_OTHER = "other";

		var REQ_CORE = "core",
			REQ_FILE = "file",
			REQ_MODULE = "module",
			REQ_COMPUTED = "computed";
		function getDeclarationType(initExpression) {
			if (!initExpression) {
				return DECL_UNINITIALIZED;
			}

			if (initExpression.type === "CallExpression" && initExpression.callee.type === "Identifier" && initExpression.callee.name === "require") {
				return DECL_REQUIRE;
			}
			if (allowCall && initExpression.type === "CallExpression" && initExpression.callee.type === "CallExpression") {
				return getDeclarationType(initExpression.callee);
			}
			if (initExpression.type === "MemberExpression") {
				return getDeclarationType(initExpression.object);
			}
			return DECL_OTHER;
		}
		function inferModuleType(initExpression) {
			if (initExpression.type === "MemberExpression") {
				return inferModuleType(initExpression.object);
			}
			if (initExpression.arguments.length === 0) {
				return REQ_COMPUTED;
			}

			var arg = initExpression.arguments[0];

			if (arg.type !== "Literal" || typeof arg.value !== "string") {
				return REQ_COMPUTED;
			}

			if (BUILTIN_MODULES.indexOf(arg.value) !== -1) {
				return REQ_CORE;
			}
			if (/^\.{0,2}\//.test(arg.value)) {
				return REQ_FILE;
			}
			return REQ_MODULE;
		}
		function isMixed(declarations) {
			var contains = {};

			declarations.forEach(function (declaration) {
				var type = getDeclarationType(declaration.init);

				contains[type] = true;
			});

			return !!(contains[DECL_REQUIRE] && (contains[DECL_UNINITIALIZED] || contains[DECL_OTHER]));
		}
		function isGrouped(declarations) {
			var found = {};

			declarations.forEach(function (declaration) {
				if (getDeclarationType(declaration.init) === DECL_REQUIRE) {
					found[inferModuleType(declaration.init)] = true;
				}
			});

			return Object.keys(found).length <= 1;
		}

		return {
			VariableDeclaration: function VariableDeclaration(node) {

				if (isMixed(node.declarations)) {
					context.report({ node: node, message: "Do not mix 'require' and other declarations." });
				} else if (grouping && !isGrouped(node.declarations)) {
					context.report({ node: node, message: "Do not mix core, module, file and computed requires." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow mixed spaces and tabs for indentation",
			category: "Stylistic Issues",
			recommended: true
		},

		schema: [{
			enum: ["smart-tabs", true, false]
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		var smartTabs = void 0;
		var ignoredLocs = [];

		switch (context.options[0]) {
			case true: // Support old syntax, maybe add deprecation warning here
			case "smart-tabs":
				smartTabs = true;
				break;
			default:
				smartTabs = false;
		}
		function beforeLoc(loc, line, column) {
			if (line < loc.start.line) {
				return true;
			}
			return line === loc.start.line && column < loc.start.column;
		}
		function afterLoc(loc, line, column) {
			if (line > loc.end.line) {
				return true;
			}
			return line === loc.end.line && column > loc.end.column;
		}
		return {
			TemplateElement: function TemplateElement(node) {
				ignoredLocs.push(node.loc);
			},
			"Program:exit": function ProgramExit(node) {
				var regex = /^(?=[\t ]*(\t | \t))/;
				var lines = sourceCode.lines,
					comments = sourceCode.getAllComments();

				comments.forEach(function (comment) {
					ignoredLocs.push(comment.loc);
				});

				ignoredLocs.sort(function (first, second) {
					if (beforeLoc(first, second.start.line, second.start.column)) {
						return 1;
					}

					if (beforeLoc(second, first.start.line, second.start.column)) {
						return -1;
					}

					return 0;
				});

				if (smartTabs) {
					regex = /^(?=[\t ]* \t)/;
				}

				lines.forEach(function (line, i) {
					var match = regex.exec(line);

					if (match) {
						var lineNumber = i + 1,
							column = match.index + 1;

						for (var j = 0; j < ignoredLocs.length; j++) {
							if (beforeLoc(ignoredLocs[j], lineNumber, column)) {
								continue;
							}
							if (afterLoc(ignoredLocs[j], lineNumber, column)) {
								continue;
							}

							return;
						}

						context.report({ node: node, loc: { line: lineNumber, column: column }, message: "Mixed spaces and tabs." });
					}
				});
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow use of chained assignment expressions",
			category: "Stylistic Issues",
			recommended: false
		},
		schema: []
	},

	create: function create(context) {
		return {
			AssignmentExpression: function AssignmentExpression(node) {
				if (["AssignmentExpression", "VariableDeclarator"].indexOf(node.parent.type) !== -1) {
					context.report({
						node: node,
						message: "Unexpected chained assignment."
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow multiple spaces",
			category: "Best Practices",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			type: "object",
			properties: {
				exceptions: {
					type: "object",
					patternProperties: {
						"^([A-Z][a-z]*)+$": {
							type: "boolean"
						}
					},
					additionalProperties: false
				},
				ignoreEOLComments: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var options = context.options[0] || {};
		var ignoreEOLComments = options.ignoreEOLComments;
		var exceptions = Object.assign({ Property: true }, options.exceptions);
		var hasExceptions = Object.keys(exceptions).filter(function (key) {
			return exceptions[key];
		}).length > 0;
		function formatReportedCommentValue(token) {
			var valueLines = token.value.split("\n");
			var value = valueLines[0];
			var formattedValue = value.slice(0, 12) + "...";

			return valueLines.length === 1 && value.length <= 12 ? value : formattedValue;
		}
		return {
			Program: function Program() {
				sourceCode.tokensAndComments.forEach(function (leftToken, leftIndex, tokensAndComments) {
					if (leftIndex === tokensAndComments.length - 1) {
						return;
					}
					var rightToken = tokensAndComments[leftIndex + 1];
					if (!sourceCode.text.slice(leftToken.range[1], rightToken.range[0]).includes("  ") || leftToken.loc.end.line < rightToken.loc.start.line) {
						return;
					}
					if (ignoreEOLComments && astUtils.isCommentToken(rightToken) && (leftIndex === tokensAndComments.length - 2 || rightToken.loc.end.line < tokensAndComments[leftIndex + 2].loc.start.line)) {
						return;
					}
					if (hasExceptions) {
						var parentNode = sourceCode.getNodeByRangeIndex(rightToken.range[0] - 1);

						if (parentNode && exceptions[parentNode.type]) {
							return;
						}
					}

					var displayValue = void 0;

					if (rightToken.type === "Block") {
						displayValue = "/*" + formatReportedCommentValue(rightToken) + "*/";
					} else if (rightToken.type === "Line") {
						displayValue = "//" + formatReportedCommentValue(rightToken);
					} else {
						displayValue = rightToken.value;
					}

					context.report({
						node: rightToken,
						loc: rightToken.loc.start,
						message: "Multiple spaces found before '{{displayValue}}'.",
						data: { displayValue: displayValue },
						fix: function fix(fixer) {
							return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], " ");
						}
					});
				});
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow multiline strings",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		function isJSXElement(node) {
			return node.type.indexOf("JSX") === 0;
		}
		return {
			Literal: function Literal(node) {
				if (astUtils.LINEBREAK_MATCHER.test(node.raw) && !isJSXElement(node.parent)) {
					context.report({ node: node, message: "Multiline support is limited to browsers supporting ES5 only." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow multiple empty lines",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			type: "object",
			properties: {
				max: {
					type: "integer",
					minimum: 0
				},
				maxEOF: {
					type: "integer",
					minimum: 0
				},
				maxBOF: {
					type: "integer",
					minimum: 0
				}
			},
			required: ["max"],
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var max = 2,
			maxEOF = max,
			maxBOF = max;

		if (context.options.length) {
			max = context.options[0].max;
			maxEOF = typeof context.options[0].maxEOF !== "undefined" ? context.options[0].maxEOF : max;
			maxBOF = typeof context.options[0].maxBOF !== "undefined" ? context.options[0].maxBOF : max;
		}

		var sourceCode = context.getSourceCode();
		var allLines = sourceCode.lines[sourceCode.lines.length - 1] === "" ? sourceCode.lines.slice(0, -1) : sourceCode.lines;
		var templateLiteralLines = new Set();
		return {
			TemplateLiteral: function TemplateLiteral(node) {
				node.quasis.forEach(function (literalPart) {
					for (var ignoredLine = literalPart.loc.start.line; ignoredLine < literalPart.loc.end.line; ignoredLine++) {
						templateLiteralLines.add(ignoredLine);
					}
				});
			},
			"Program:exit": function ProgramExit(node) {
				return allLines
				.reduce(function (nonEmptyLineNumbers, line, index) {
					if (line.trim() || templateLiteralLines.has(index + 1)) {
						nonEmptyLineNumbers.push(index + 1);
					}
					return nonEmptyLineNumbers;
				}, [])
				.concat(allLines.length + 1)
				.reduce(function (lastLineNumber, lineNumber) {
					var message = void 0,
						maxAllowed = void 0;

					if (lastLineNumber === 0) {
						message = "Too many blank lines at the beginning of file. Max of {{max}} allowed.";
						maxAllowed = maxBOF;
					} else if (lineNumber === allLines.length + 1) {
						message = "Too many blank lines at the end of file. Max of {{max}} allowed.";
						maxAllowed = maxEOF;
					} else {
						message = "More than {{max}} blank {{pluralizedLines}} not allowed.";
						maxAllowed = max;
					}

					if (lineNumber - lastLineNumber - 1 > maxAllowed) {
						context.report({
							node: node,
							loc: { start: { line: lastLineNumber + 1, column: 0 }, end: { line: lineNumber, column: 0 } },
							message: message,
							data: { max: maxAllowed, pluralizedLines: maxAllowed === 1 ? "line" : "lines" },
							fix: function fix(fixer) {
								var rangeStart = sourceCode.getIndexFromLoc({ line: lastLineNumber + 1, column: 0 });
								var lineNumberAfterRemovedLines = lineNumber - maxAllowed;
								var rangeEnd = lineNumberAfterRemovedLines <= allLines.length ? sourceCode.getIndexFromLoc({ line: lineNumberAfterRemovedLines, column: 0 }) : sourceCode.text.length;

								return fixer.removeRange([rangeStart, rangeEnd]);
							}
						});
					}

					return lineNumber;
				}, 0);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow assignments to native objects or read-only global variables",
			category: "Best Practices",
			recommended: false,
			replacedBy: ["no-global-assign"]
		},

		deprecated: true,

		schema: [{
			type: "object",
			properties: {
				exceptions: {
					type: "array",
					items: { type: "string" },
					uniqueItems: true
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var config = context.options[0];
		var exceptions = config && config.exceptions || [];
		function checkReference(reference, index, references) {
			var identifier = reference.identifier;

			if (reference.init === false && reference.isWrite() && (
			index === 0 || references[index - 1].identifier !== identifier)) {
				context.report({
					node: identifier,
					message: "Read-only global '{{name}}' should not be modified.",
					data: identifier
				});
			}
		}
		function checkVariable(variable) {
			if (variable.writeable === false && exceptions.indexOf(variable.name) === -1) {
				variable.references.forEach(checkReference);
			}
		}

		return {
			Program: function Program() {
				var globalScope = context.getScope();

				globalScope.variables.forEach(checkVariable);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow negated conditions",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		function hasElseWithoutCondition(node) {
			return node.alternate && node.alternate.type !== "IfStatement";
		}
		function isNegatedUnaryExpression(test) {
			return test.type === "UnaryExpression" && test.operator === "!";
		}
		function isNegatedBinaryExpression(test) {
			return test.type === "BinaryExpression" && (test.operator === "!=" || test.operator === "!==");
		}
		function isNegatedIf(node) {
			return isNegatedUnaryExpression(node.test) || isNegatedBinaryExpression(node.test);
		}

		return {
			IfStatement: function IfStatement(node) {
				if (!hasElseWithoutCondition(node)) {
					return;
				}

				if (isNegatedIf(node)) {
					context.report({ node: node, message: "Unexpected negated condition." });
				}
			},
			ConditionalExpression: function ConditionalExpression(node) {
				if (isNegatedIf(node)) {
					context.report({ node: node, message: "Unexpected negated condition." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow negating the left operand in `in` expressions",
			category: "Possible Errors",
			recommended: false,
			replacedBy: ["no-unsafe-negation"]
		},
		deprecated: true,

		schema: []
	},

	create: function create(context) {

		return {
			BinaryExpression: function BinaryExpression(node) {
				if (node.operator === "in" && node.left.type === "UnaryExpression" && node.left.operator === "!") {
					context.report({ node: node, message: "The 'in' expression's left operand is negated." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow nested ternary expressions",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			ConditionalExpression: function ConditionalExpression(node) {
				if (node.alternate.type === "ConditionalExpression" || node.consequent.type === "ConditionalExpression") {
					context.report({ node: node, message: "Do not nest ternary expressions." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow `new` operators with the `Function` object",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		function report(node) {
			context.report({ node: node, message: "The Function constructor is eval." });
		}

		return {
			"NewExpression[callee.name = 'Function']": report,
			"CallExpression[callee.name = 'Function']": report
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow `Object` constructors",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			NewExpression: function NewExpression(node) {
				if (node.callee.name === "Object") {
					context.report({ node: node, message: "The object literal notation {} is preferrable." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow `new` operators with calls to `require`",
			category: "Node.js and CommonJS",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			NewExpression: function NewExpression(node) {
				if (node.callee.type === "Identifier" && node.callee.name === "require") {
					context.report({ node: node, message: "Unexpected use of new with require." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow `new` operators with the `Symbol` object",
			category: "ECMAScript 6",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {

		return {
			"Program:exit": function ProgramExit() {
				var globalScope = context.getScope();
				var variable = globalScope.set.get("Symbol");

				if (variable && variable.defs.length === 0) {
					variable.references.forEach(function (ref) {
						var node = ref.identifier;

						if (node.parent && node.parent.type === "NewExpression") {
							context.report({ node: node, message: "`Symbol` cannot be called as a constructor." });
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow `new` operators with the `String`, `Number`, and `Boolean` objects",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			NewExpression: function NewExpression(node) {
				var wrapperObjects = ["String", "Number", "Boolean", "Math", "JSON"];

				if (wrapperObjects.indexOf(node.callee.name) > -1) {
					context.report({ node: node, message: "Do not use {{fn}} as a constructor.", data: { fn: node.callee.name } });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow `new` operators outside of assignments or comparisons",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			"ExpressionStatement > NewExpression": function ExpressionStatementNewExpression(node) {
				context.report({ node: node.parent, message: "Do not use 'new' for side effects." });
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow calling global object properties as functions",
			category: "Possible Errors",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {

		return {
			CallExpression: function CallExpression(node) {

				if (node.callee.type === "Identifier") {
					var name = node.callee.name;

					if (name === "Math" || name === "JSON" || name === "Reflect") {
						context.report({ node: node, message: "'{{name}}' is not a function.", data: { name: name } });
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow octal escape sequences in string literals",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			Literal: function Literal(node) {
				if (typeof node.value !== "string") {
					return;
				}

				var match = node.raw.match(/^([^\\]|\\[^0-7])*\\([0-3][0-7]{1,2}|[4-7][0-7]|[0-7])/);

				if (match) {
					var octalDigit = match[2];
					if (match[2] !== "0" || typeof match[3] !== "undefined") {
						context.report({ node: node, message: "Don't use octal: '\\{{octalDigit}}'. Use '\\u....' instead.", data: { octalDigit: octalDigit } });
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow octal literals",
			category: "Best Practices",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {

		return {
			Literal: function Literal(node) {
				if (typeof node.value === "number" && /^0[0-7]/.test(node.raw)) {
					context.report({ node: node, message: "Octal literals should not be used." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var stopNodePattern = /(?:Statement|Declaration|Function(?:Expression)?|Program)$/;

module.exports = {
	meta: {
		docs: {
			description: "disallow reassigning `function` parameters",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			oneOf: [{
				type: "object",
				properties: {
					props: {
						enum: [false]
					}
				},
				additionalProperties: false
			}, {
				type: "object",
				properties: {
					props: {
						enum: [true]
					},
					ignorePropertyModificationsFor: {
						type: "array",
						items: {
							type: "string"
						},
						uniqueItems: true
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {
		var props = context.options[0] && Boolean(context.options[0].props);
		var ignoredPropertyAssignmentsFor = context.options[0] && context.options[0].ignorePropertyModificationsFor || [];
		function isModifyingProp(reference) {
			var node = reference.identifier;
			var parent = node.parent;

			while (parent && !stopNodePattern.test(parent.type)) {
				switch (parent.type) {
					case "AssignmentExpression":
						return parent.left === node;
					case "UpdateExpression":
						return true;
					case "UnaryExpression":
						if (parent.operator === "delete") {
							return true;
						}
						break;
					case "CallExpression":
						if (parent.callee !== node) {
							return false;
						}
						break;
					case "MemberExpression":
						if (parent.property === node) {
							return false;
						}
						break;
					case "Property":
						if (parent.key === node) {
							return false;
						}

						break;
				}

				node = parent;
				parent = node.parent;
			}

			return false;
		}
		function checkReference(reference, index, references) {
			var identifier = reference.identifier;

			if (identifier && !reference.init && (
			index === 0 || references[index - 1].identifier !== identifier)) {
				if (reference.isWrite()) {
					context.report({ node: identifier, message: "Assignment to function parameter '{{name}}'.", data: { name: identifier.name } });
				} else if (props && isModifyingProp(reference) && ignoredPropertyAssignmentsFor.indexOf(identifier.name) === -1) {
					context.report({ node: identifier, message: "Assignment to property of function parameter '{{name}}'.", data: { name: identifier.name } });
				}
			}
		}
		function checkVariable(variable) {
			if (variable.defs[0].type === "Parameter") {
				variable.references.forEach(checkReference);
			}
		}
		function checkForFunction(node) {
			context.getDeclaredVariables(node).forEach(checkVariable);
		}

		return {
			"FunctionDeclaration:exit": checkForFunction,
			"FunctionExpression:exit": checkForFunction,
			"ArrowFunctionExpression:exit": checkForFunction
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow string concatenation with `__dirname` and `__filename`",
			category: "Node.js and CommonJS",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		var MATCHER = /^__(?:dir|file)name$/;
		return {
			BinaryExpression: function BinaryExpression(node) {

				var left = node.left,
					right = node.right;

				if (node.operator === "+" && (left.type === "Identifier" && MATCHER.test(left.name) || right.type === "Identifier" && MATCHER.test(right.name))) {

					context.report({ node: node, message: "Use path.join() or path.resolve() instead of + to create paths." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = {
	meta: {
		docs: {
			description: "disallow the unary operators `++` and `--`",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				allowForLoopAfterthoughts: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var config = context.options[0];
		var allowInForAfterthought = false;

		if ((typeof config === "undefined" ? "undefined" : _typeof(config)) === "object") {
			allowInForAfterthought = config.allowForLoopAfterthoughts === true;
		}

		return {
			UpdateExpression: function UpdateExpression(node) {
				if (allowInForAfterthought && node.parent.type === "ForStatement") {
					return;
				}
				context.report({
					node: node,
					message: "Unary operator '{{operator}}' used.",
					data: {
						operator: node.operator
					}
				});
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow the use of `process.env`",
			category: "Node.js and CommonJS",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			MemberExpression: function MemberExpression(node) {
				var objectName = node.object.name,
					propertyName = node.property.name;

				if (objectName === "process" && !node.computed && propertyName && propertyName === "env") {
					context.report({ node: node, message: "Unexpected use of process.env." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow the use of `process.exit()`",
			category: "Node.js and CommonJS",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		return {
			"CallExpression > MemberExpression.callee[object.name = 'process'][property.name = 'exit']": function CallExpressionMemberExpressionCalleeObjectNameProcessPropertyNameExit(node) {
				context.report({ node: node.parent, message: "Don't use process.exit(); throw an error instead." });
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow the use of the `__proto__` property",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			MemberExpression: function MemberExpression(node) {

				if (node.property && node.property.type === "Identifier" && node.property.name === "__proto__" && !node.computed || node.property.type === "Literal" && node.property.value === "__proto__") {
					context.report({ node: node, message: "The '__proto__' property is deprecated." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow calling some `Object.prototype` methods directly on objects",
			category: "Possible Errors",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		var DISALLOWED_PROPS = ["hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable"];
		function disallowBuiltIns(node) {
			if (node.callee.type !== "MemberExpression" || node.callee.computed) {
				return;
			}
			var propName = node.callee.property.name;

			if (DISALLOWED_PROPS.indexOf(propName) > -1) {
				context.report({
					message: "Do not access Object.prototype method '{{prop}}' from target object.",
					loc: node.callee.property.loc.start,
					data: { prop: propName },
					node: node
				});
			}
		}

		return {
			CallExpression: disallowBuiltIns
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow variable redeclaration",
			category: "Best Practices",
			recommended: true
		},

		schema: [{
			type: "object",
			properties: {
				builtinGlobals: { type: "boolean" }
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = {
			builtinGlobals: Boolean(context.options[0] && context.options[0].builtinGlobals)
		};
		function findVariablesInScope(scope) {
			scope.variables.forEach(function (variable) {
				var hasBuiltin = options.builtinGlobals && "writeable" in variable;
				var count = (hasBuiltin ? 1 : 0) + variable.identifiers.length;

				if (count >= 2) {
					variable.identifiers.sort(function (a, b) {
						return a.range[1] - b.range[1];
					});

					for (var i = hasBuiltin ? 0 : 1, l = variable.identifiers.length; i < l; i++) {
						context.report({ node: variable.identifiers[i], message: "'{{a}}' is already defined.", data: { a: variable.name } });
					}
				}
			});
		}
		function checkForGlobal(node) {
			var scope = context.getScope(),
				parserOptions = context.parserOptions,
				ecmaFeatures = parserOptions.ecmaFeatures || {};
			if (ecmaFeatures.globalReturn || node.sourceType === "module") {
				findVariablesInScope(scope.childScopes[0]);
			} else {
				findVariablesInScope(scope);
			}
		}
		function checkForBlock() {
			findVariablesInScope(context.getScope());
		}

		if (context.parserOptions.ecmaVersion >= 6) {
			return {
				Program: checkForGlobal,
				BlockStatement: checkForBlock,
				SwitchStatement: checkForBlock
			};
		}
		return {
			Program: checkForGlobal,
			FunctionDeclaration: checkForBlock,
			FunctionExpression: checkForBlock,
			ArrowFunctionExpression: checkForBlock
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow multiple spaces in regular expressions",
			category: "Possible Errors",
			recommended: true
		},

		schema: [],

		fixable: "code"
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		function checkRegex(node, value, valueStart) {
			var multipleSpacesRegex = /( {2,})( [+*{?]|[^+*{?]|$)/,
				regexResults = multipleSpacesRegex.exec(value);

			if (regexResults !== null) {
				var count = regexResults[1].length;

				context.report({
					node: node,
					message: "Spaces are hard to count. Use {{{count}}}.",
					data: { count: count },
					fix: function fix(fixer) {
						return fixer.replaceTextRange([valueStart + regexResults.index, valueStart + regexResults.index + count], " {" + count + "}");
					}
				});
			}
		}
		function checkLiteral(node) {
			var token = sourceCode.getFirstToken(node),
				nodeType = token.type,
				nodeValue = token.value;

			if (nodeType === "RegularExpression") {
				checkRegex(node, nodeValue, token.range[0]);
			}
		}
		function isString(node) {
			return node && node.type === "Literal" && typeof node.value === "string";
		}
		function checkFunction(node) {
			var scope = context.getScope();
			var regExpVar = astUtils.getVariableByName(scope, "RegExp");
			var shadowed = regExpVar && regExpVar.defs.length > 0;

			if (node.callee.type === "Identifier" && node.callee.name === "RegExp" && isString(node.arguments[0]) && !shadowed) {
				checkRegex(node, node.arguments[0].value, node.arguments[0].range[0] + 1);
			}
		}

		return {
			Literal: checkLiteral,
			CallExpression: checkFunction,
			NewExpression: checkFunction
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var DEFAULT_MESSAGE_TEMPLATE = "Unexpected use of '{{name}}'.",
	CUSTOM_MESSAGE_TEMPLATE = "Unexpected use of '{{name}}'. {{customMessage}}";
module.exports = {
	meta: {
		docs: {
			description: "disallow specified global variables",
			category: "Variables",
			recommended: false
		},

		schema: {
			type: "array",
			items: {
				oneOf: [{
					type: "string"
				}, {
					type: "object",
					properties: {
						name: { type: "string" },
						message: { type: "string" }
					},
					required: ["name"],
					additionalProperties: false
				}]
			},
			uniqueItems: true,
			minItems: 0
		}
	},

	create: function create(context) {
		if (context.options.length === 0) {
			return {};
		}

		var restrictedGlobalMessages = context.options.reduce(function (memo, option) {
			if (typeof option === "string") {
				memo[option] = null;
			} else {
				memo[option.name] = option.message;
			}

			return memo;
		}, {});
		function reportReference(reference) {
			var name = reference.identifier.name,
				customMessage = restrictedGlobalMessages[name],
				message = customMessage ? CUSTOM_MESSAGE_TEMPLATE : DEFAULT_MESSAGE_TEMPLATE;

			context.report({
				node: reference.identifier,
				message: message,
				data: {
					name: name,
					customMessage: customMessage
				}
			});
		}
		function isRestricted(name) {
			return restrictedGlobalMessages.hasOwnProperty(name);
		}

		return {
			Program: function Program() {
				var scope = context.getScope();
				scope.variables.forEach(function (variable) {
					if (!variable.defs.length && isRestricted(variable.name)) {
						variable.references.forEach(reportReference);
					}
				});
				scope.through.forEach(function (reference) {
					if (isRestricted(reference.identifier.name)) {
						reportReference(reference);
					}
				});
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var DEFAULT_MESSAGE_TEMPLATE = "'{{importSource}}' import is restricted from being used.";
var CUSTOM_MESSAGE_TEMPLATE = "'{{importSource}}' import is restricted from being used. {{customMessage}}";
var ignore = __webpack_require__(163);

var arrayOfStrings = {
	type: "array",
	items: { type: "string" },
	uniqueItems: true
};

var arrayOfStringsOrObjects = {
	type: "array",
	items: {
		anyOf: [{ type: "string" }, {
			type: "object",
			properties: {
				name: { type: "string" },
				message: {
					type: "string",
					minLength: 1
				},
				importNames: {
					type: "array",
					items: {
						type: "string"
					}
				}
			},
			additionalProperties: false,
			required: ["name"]
		}]
	},
	uniqueItems: true
};

module.exports = {
	meta: {
		docs: {
			description: "disallow specified modules when loaded by `import`",
			category: "ECMAScript 6",
			recommended: false
		},

		schema: {
			anyOf: [arrayOfStringsOrObjects, {
				type: "array",
				items: {
					type: "object",
					properties: {
						paths: arrayOfStringsOrObjects,
						patterns: arrayOfStrings
					},
					additionalProperties: false
				},
				additionalItems: false
			}]
		}
	},

	create: function create(context) {
		var options = Array.isArray(context.options) ? context.options : [];
		var isPathAndPatternsObject = _typeof(options[0]) === "object" && (options[0].hasOwnProperty("paths") || options[0].hasOwnProperty("patterns"));

		var restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];
		var restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];

		var restrictedPathMessages = restrictedPaths.reduce(function (memo, importSource) {
			if (typeof importSource === "string") {
				memo[importSource] = { message: null };
			} else {
				memo[importSource.name] = {
					message: importSource.message,
					importNames: importSource.importNames
				};
			}
			return memo;
		}, {});
		if (Object.keys(restrictedPaths).length === 0 && restrictedPatterns.length === 0) {
			return {};
		}

		var restrictedPatternsMatcher = ignore().add(restrictedPatterns);
		function isEverythingImported(importNames) {
			return importNames.has("*");
		}
		function reportPath(node) {
			var importSource = node.source.value.trim();
			var customMessage = restrictedPathMessages[importSource] && restrictedPathMessages[importSource].message;
			var message = customMessage ? CUSTOM_MESSAGE_TEMPLATE : DEFAULT_MESSAGE_TEMPLATE;

			context.report({
				node: node,
				message: message,
				data: {
					importSource: importSource,
					customMessage: customMessage
				}
			});
		}
		function reportPathForPatterns(node) {
			var importSource = node.source.value.trim();

			context.report({
				node: node,
				message: "'{{importSource}}' import is restricted from being used by a pattern.",
				data: {
					importSource: importSource
				}
			});
		}
		function reportPathForEverythingImported(importSource, node) {
			var importNames = restrictedPathMessages[importSource].importNames;

			context.report({
				node: node,
				message: "* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted.",
				data: {
					importSource: importSource,
					importNames: importNames
				}
			});
		}
		function isRestrictedForEverythingImported(importSource, importNames) {
			return Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource) && restrictedPathMessages[importSource].importNames && isEverythingImported(importNames);
		}
		function isRestrictedObject(importNames, restrictedImportNames) {
			return restrictedImportNames.some(function (restrictedObjectName) {
				return importNames.has(restrictedObjectName);
			});
		}
		function isRestrictedPath(importSource, importNames) {
			var isRestricted = false;

			if (Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource)) {
				if (restrictedPathMessages[importSource].importNames) {
					isRestricted = isRestrictedObject(importNames, restrictedPathMessages[importSource].importNames);
				} else {
					isRestricted = true;
				}
			}

			return isRestricted;
		}
		function isRestrictedPattern(importSource) {
			return restrictedPatterns.length > 0 && restrictedPatternsMatcher.ignores(importSource);
		}

		return {
			ImportDeclaration: function ImportDeclaration(node) {
				var importSource = node.source.value.trim();
				var importNames = node.specifiers.reduce(function (set, specifier) {
					if (specifier.type === "ImportDefaultSpecifier") {
						set.add("default");
					} else if (specifier.type === "ImportNamespaceSpecifier") {
						set.add("*");
					} else {
						set.add(specifier.imported.name);
					}
					return set;
				}, new Set());

				if (isRestrictedForEverythingImported(importSource, importNames)) {
					reportPathForEverythingImported(importSource, node);
				}

				if (isRestrictedPath(importSource, importNames)) {
					reportPath(node);
				}
				if (isRestrictedPattern(importSource)) {
					reportPathForPatterns(node);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var DEFAULT_MESSAGE_TEMPLATE = "'{{moduleName}}' module is restricted from being used.";
var CUSTOM_MESSAGE_TEMPLATE = "'{{moduleName}}' module is restricted from being used. {{customMessage}}";
var ignore = __webpack_require__(163);

var arrayOfStrings = {
	type: "array",
	items: { type: "string" },
	uniqueItems: true
};

var arrayOfStringsOrObjects = {
	type: "array",
	items: {
		anyOf: [{ type: "string" }, {
			type: "object",
			properties: {
				name: { type: "string" },
				message: {
					type: "string",
					minLength: 1
				}
			},
			additionalProperties: false,
			required: ["name"]
		}]
	},
	uniqueItems: true
};

module.exports = {
	meta: {
		docs: {
			description: "disallow specified modules when loaded by `require`",
			category: "Node.js and CommonJS",
			recommended: false
		},

		schema: {
			anyOf: [arrayOfStringsOrObjects, {
				type: "array",
				items: {
					type: "object",
					properties: {
						paths: arrayOfStringsOrObjects,
						patterns: arrayOfStrings
					},
					additionalProperties: false
				},
				additionalItems: false
			}]
		}
	},

	create: function create(context) {
		var options = Array.isArray(context.options) ? context.options : [];
		var isPathAndPatternsObject = _typeof(options[0]) === "object" && (options[0].hasOwnProperty("paths") || options[0].hasOwnProperty("patterns"));

		var restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];
		var restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];

		var restrictedPathMessages = restrictedPaths.reduce(function (memo, importName) {
			if (typeof importName === "string") {
				memo[importName] = null;
			} else {
				memo[importName.name] = importName.message;
			}
			return memo;
		}, {});
		if (Object.keys(restrictedPaths).length === 0 && restrictedPatterns.length === 0) {
			return {};
		}

		var ig = ignore().add(restrictedPatterns);
		function isString(node) {
			return node && node.type === "Literal" && typeof node.value === "string";
		}
		function isRequireCall(node) {
			return node.callee.type === "Identifier" && node.callee.name === "require";
		}
		function reportPath(node) {
			var moduleName = node.arguments[0].value.trim();
			var customMessage = restrictedPathMessages[moduleName];
			var message = customMessage ? CUSTOM_MESSAGE_TEMPLATE : DEFAULT_MESSAGE_TEMPLATE;

			context.report({
				node: node,
				message: message,
				data: {
					moduleName: moduleName,
					customMessage: customMessage
				}
			});
		}
		function isRestrictedPath(name) {
			return Object.prototype.hasOwnProperty.call(restrictedPathMessages, name);
		}

		return {
			CallExpression: function CallExpression(node) {
				if (isRequireCall(node)) {
					if (node.arguments.length && isString(node.arguments[0])) {
						var moduleName = node.arguments[0].value.trim();
						if (isRestrictedPath(moduleName)) {
							reportPath(node);
						}

						if (restrictedPatterns.length > 0 && ig.ignores(moduleName)) {
							context.report({
								node: node,
								message: "'{{moduleName}}' module is restricted from being used by a pattern.",
								data: { moduleName: moduleName }
							});
						}
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow certain properties on certain objects",
			category: "Best Practices",
			recommended: false
		},

		schema: {
			type: "array",
			items: {
				anyOf: [// `object` and `property` are both optional, but at least one of them must be provided.
				{
					type: "object",
					properties: {
						object: {
							type: "string"
						},
						property: {
							type: "string"
						},
						message: {
							type: "string"
						}
					},
					additionalProperties: false,
					required: ["object"]
				}, {
					type: "object",
					properties: {
						object: {
							type: "string"
						},
						property: {
							type: "string"
						},
						message: {
							type: "string"
						}
					},
					additionalProperties: false,
					required: ["property"]
				}]
			},
			uniqueItems: true
		}
	},

	create: function create(context) {
		var restrictedCalls = context.options;

		if (restrictedCalls.length === 0) {
			return {};
		}

		var restrictedProperties = new Map();
		var globallyRestrictedObjects = new Map();
		var globallyRestrictedProperties = new Map();

		restrictedCalls.forEach(function (option) {
			var objectName = option.object;
			var propertyName = option.property;

			if (typeof objectName === "undefined") {
				globallyRestrictedProperties.set(propertyName, { message: option.message });
			} else if (typeof propertyName === "undefined") {
				globallyRestrictedObjects.set(objectName, { message: option.message });
			} else {
				if (!restrictedProperties.has(objectName)) {
					restrictedProperties.set(objectName, new Map());
				}

				restrictedProperties.get(objectName).set(propertyName, {
					message: option.message
				});
			}
		});
		function checkPropertyAccess(node, objectName, propertyName) {
			if (propertyName === null) {
				return;
			}
			var matchedObject = restrictedProperties.get(objectName);
			var matchedObjectProperty = matchedObject ? matchedObject.get(propertyName) : globallyRestrictedObjects.get(objectName);
			var globalMatchedProperty = globallyRestrictedProperties.get(propertyName);

			if (matchedObjectProperty) {
				var message = matchedObjectProperty.message ? " " + matchedObjectProperty.message : "";

				context.report({
					node: node,
					message: "'{{objectName}}.{{propertyName}}' is restricted from being used.{{message}}",
					data: {
						objectName: objectName,
						propertyName: propertyName,
						message: message
					}
				});
			} else if (globalMatchedProperty) {
				var _message = globalMatchedProperty.message ? " " + globalMatchedProperty.message : "";

				context.report({
					node: node,
					message: "'{{propertyName}}' is restricted from being used.{{message}}",
					data: {
						propertyName: propertyName,
						message: _message
					}
				});
			}
		}
		function checkDestructuringAssignment(node) {
			if (node.right.type === "Identifier") {
				var objectName = node.right.name;

				if (node.left.type === "ObjectPattern") {
					node.left.properties.forEach(function (property) {
						checkPropertyAccess(node.left, objectName, astUtils.getStaticPropertyName(property));
					});
				}
			}
		}

		return {
			MemberExpression: function MemberExpression(node) {
				checkPropertyAccess(node, node.object && node.object.name, astUtils.getStaticPropertyName(node));
			},
			VariableDeclarator: function VariableDeclarator(node) {
				if (node.init && node.init.type === "Identifier") {
					var objectName = node.init.name;

					if (node.id.type === "ObjectPattern") {
						node.id.properties.forEach(function (property) {
							checkPropertyAccess(node.id, objectName, astUtils.getStaticPropertyName(property));
						});
					}
				}
			},

			AssignmentExpression: checkDestructuringAssignment,
			AssignmentPattern: checkDestructuringAssignment
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

module.exports = {
	meta: {
		docs: {
			description: "disallow specified syntax",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: {
			type: "array",
			items: [{
				oneOf: [{
					type: "string"
				}, {
					type: "object",
					properties: {
						selector: { type: "string" },
						message: { type: "string" }
					},
					required: ["selector"],
					additionalProperties: false
				}]
			}],
			uniqueItems: true,
			minItems: 0
		}
	},

	create: function create(context) {
		return context.options.reduce(function (result, selectorOrObject) {
			var isStringFormat = typeof selectorOrObject === "string";
			var hasCustomMessage = !isStringFormat && Boolean(selectorOrObject.message);

			var selector = isStringFormat ? selectorOrObject : selectorOrObject.selector;
			var message = hasCustomMessage ? selectorOrObject.message : "Using '{{selector}}' is not allowed.";

			return Object.assign(result, _defineProperty({}, selector, function (node) {
				context.report({
					node: node,
					message: message,
					data: hasCustomMessage ? {} : { selector: selector }
				});
			}));
		}, {});
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
var SENTINEL_TYPE = /^(?:[a-zA-Z]+?Statement|ArrowFunctionExpression|FunctionExpression|ClassExpression)$/;
module.exports = {
	meta: {
		docs: {
			description: "disallow assignment operators in `return` statements",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			enum: ["except-parens", "always"]
		}]
	},

	create: function create(context) {
		var always = (context.options[0] || "except-parens") !== "except-parens";
		var sourceCode = context.getSourceCode();

		return {
			AssignmentExpression: function AssignmentExpression(node) {
				if (!always && astUtils.isParenthesised(sourceCode, node)) {
					return;
				}

				var parent = node.parent;
				while (parent && !SENTINEL_TYPE.test(parent.type)) {
					node = parent;
					parent = parent.parent;
				}
				if (parent && parent.type === "ReturnStatement") {
					context.report({
						node: parent,
						message: "Return statement should not contain assignment."
					});
				} else if (parent && parent.type === "ArrowFunctionExpression" && parent.body === node) {
					context.report({
						node: parent,
						message: "Arrow function should not return assignment."
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var astUtils = __webpack_require__(0);
var message = "Redundant use of `await` on a return value.";

module.exports = {
	meta: {
		docs: {
			description: "disallow unnecessary `return await`",
			category: "Best Practices",
			recommended: false // TODO: set to true
		},
		fixable: null,
		schema: []
	},

	create: function create(context) {
		function reportUnnecessaryAwait(node) {
			context.report({
				node: context.getSourceCode().getFirstToken(node),
				loc: node.loc,
				message: message
			});
		}
		function hasErrorHandler(node) {
			var ancestor = node;

			while (!astUtils.isFunction(ancestor) && ancestor.type !== "Program") {
				if (ancestor.parent.type === "TryStatement" && (ancestor === ancestor.parent.block || ancestor === ancestor.parent.handler && ancestor.parent.finalizer)) {
					return true;
				}
				ancestor = ancestor.parent;
			}
			return false;
		}
		function isInTailCallPosition(node) {
			if (node.parent.type === "ArrowFunctionExpression") {
				return true;
			}
			if (node.parent.type === "ReturnStatement") {
				return !hasErrorHandler(node.parent);
			}
			if (node.parent.type === "ConditionalExpression" && (node === node.parent.consequent || node === node.parent.alternate)) {
				return isInTailCallPosition(node.parent);
			}
			if (node.parent.type === "LogicalExpression" && node === node.parent.right) {
				return isInTailCallPosition(node.parent);
			}
			if (node.parent.type === "SequenceExpression" && node === node.parent.expressions[node.parent.expressions.length - 1]) {
				return isInTailCallPosition(node.parent);
			}
			return false;
		}

		return {
			AwaitExpression: function AwaitExpression(node) {
				if (isInTailCallPosition(node) && !hasErrorHandler(node)) {
					reportUnnecessaryAwait(node);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow `javascript:` urls",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			Literal: function Literal(node) {
				if (node.value && typeof node.value === "string") {
					var value = node.value.toLowerCase();

					if (value.indexOf("javascript:") === 0) {
						context.report({ node: node, message: "Script URL is a form of eval." });
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
var SPACES = /\s+/g;
function isSameProperty(left, right) {
	if (left.property.type === "Identifier" && left.property.type === right.property.type && left.property.name === right.property.name && left.computed === right.computed) {
		return true;
	}

	var lname = astUtils.getStaticPropertyName(left);
	var rname = astUtils.getStaticPropertyName(right);

	return lname !== null && lname === rname;
}
function isSameMember(left, right) {
	if (!isSameProperty(left, right)) {
		return false;
	}

	var lobj = left.object;
	var robj = right.object;

	if (lobj.type !== robj.type) {
		return false;
	}
	if (lobj.type === "MemberExpression") {
		return isSameMember(lobj, robj);
	}
	return lobj.type === "Identifier" && lobj.name === robj.name;
}
function eachSelfAssignment(left, right, props, report) {
	if (!left || !right) {
	} else if (left.type === "Identifier" && right.type === "Identifier" && left.name === right.name) {
		report(right);
	} else if (left.type === "ArrayPattern" && right.type === "ArrayExpression") {
		var end = Math.min(left.elements.length, right.elements.length);

		for (var i = 0; i < end; ++i) {
			var rightElement = right.elements[i];

			eachSelfAssignment(left.elements[i], rightElement, props, report);
			if (rightElement && rightElement.type === "SpreadElement") {
				break;
			}
		}
	} else if (left.type === "RestElement" && right.type === "SpreadElement") {
		eachSelfAssignment(left.argument, right.argument, props, report);
	} else if (left.type === "ObjectPattern" && right.type === "ObjectExpression" && right.properties.length >= 1) {
		var startJ = 0;

		for (var _i = right.properties.length - 1; _i >= 0; --_i) {
			if (right.properties[_i].type === "ExperimentalSpreadProperty") {
				startJ = _i + 1;
				break;
			}
		}

		for (var _i2 = 0; _i2 < left.properties.length; ++_i2) {
			for (var j = startJ; j < right.properties.length; ++j) {
				eachSelfAssignment(left.properties[_i2], right.properties[j], props, report);
			}
		}
	} else if (left.type === "Property" && right.type === "Property" && !left.computed && !right.computed && right.kind === "init" && !right.method && left.key.name === right.key.name) {
		eachSelfAssignment(left.value, right.value, props, report);
	} else if (props && left.type === "MemberExpression" && right.type === "MemberExpression" && isSameMember(left, right)) {
		report(right);
	}
}
module.exports = {
	meta: {
		docs: {
			description: "disallow assignments where both sides are exactly the same",
			category: "Best Practices",
			recommended: true
		},

		schema: [{
			type: "object",
			properties: {
				props: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var options = context.options[0];
		var props = Boolean(options && options.props);
		function report(node) {
			context.report({
				node: node,
				message: "'{{name}}' is assigned to itself.",
				data: {
					name: sourceCode.getText(node).replace(SPACES, "")
				}
			});
		}

		return {
			AssignmentExpression: function AssignmentExpression(node) {
				if (node.operator === "=") {
					eachSelfAssignment(node.left, node.right, props, report);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow comparisons where both sides are exactly the same",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		function hasSameTokens(nodeA, nodeB) {
			var tokensA = sourceCode.getTokens(nodeA);
			var tokensB = sourceCode.getTokens(nodeB);

			return tokensA.length === tokensB.length && tokensA.every(function (token, index) {
				return token.type === tokensB[index].type && token.value === tokensB[index].value;
			});
		}

		return {
			BinaryExpression: function BinaryExpression(node) {
				var operators = new Set(["===", "==", "!==", "!=", ">", "<", ">=", "<="]);

				if (operators.has(node.operator) && hasSameTokens(node.left, node.right)) {
					context.report({ node: node, message: "Comparing to itself is potentially pointless." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow comma operators",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var parenthesized = {
			DoWhileStatement: "test",
			IfStatement: "test",
			SwitchStatement: "discriminant",
			WhileStatement: "test",
			WithStatement: "object",
			ArrowFunctionExpression: "body"
		};
		function requiresExtraParens(node) {
			return node.parent && parenthesized[node.parent.type] && node === node.parent[parenthesized[node.parent.type]];
		}
		function isParenthesised(node) {
			return astUtils.isParenthesised(sourceCode, node);
		}
		function isParenthesisedTwice(node) {
			var previousToken = sourceCode.getTokenBefore(node, 1),
				nextToken = sourceCode.getTokenAfter(node, 1);

			return isParenthesised(node) && previousToken && nextToken && astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] && astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];
		}

		return {
			SequenceExpression: function SequenceExpression(node) {
				if (node.parent.type === "ForStatement" && (node === node.parent.init || node === node.parent.update)) {
					return;
				}
				if (requiresExtraParens(node)) {
					if (isParenthesisedTwice(node)) {
						return;
					}
				} else {
					if (isParenthesised(node)) {
						return;
					}
				}

				var child = sourceCode.getTokenAfter(node.expressions[0]);

				context.report({ node: node, loc: child.loc.start, message: "Unexpected use of comma operator." });
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow identifiers from shadowing restricted names",
			category: "Variables",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		var RESTRICTED = ["undefined", "NaN", "Infinity", "arguments", "eval"];
		function checkForViolation(id) {
			if (RESTRICTED.indexOf(id.name) > -1) {
				context.report({
					node: id,
					message: "Shadowing of global property '{{idName}}'.",
					data: {
						idName: id.name
					}
				});
			}
		}

		return {
			VariableDeclarator: function VariableDeclarator(node) {
				checkForViolation(node.id);
			},
			ArrowFunctionExpression: function ArrowFunctionExpression(node) {
				[].map.call(node.params, checkForViolation);
			},
			FunctionExpression: function FunctionExpression(node) {
				if (node.id) {
					checkForViolation(node.id);
				}
				[].map.call(node.params, checkForViolation);
			},
			FunctionDeclaration: function FunctionDeclaration(node) {
				if (node.id) {
					checkForViolation(node.id);
					[].map.call(node.params, checkForViolation);
				}
			},
			CatchClause: function CatchClause(node) {
				checkForViolation(node.param);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow variable declarations from shadowing variables declared in the outer scope",
			category: "Variables",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				builtinGlobals: { type: "boolean" },
				hoist: { enum: ["all", "functions", "never"] },
				allow: {
					type: "array",
					items: {
						type: "string"
					}
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var options = {
			builtinGlobals: Boolean(context.options[0] && context.options[0].builtinGlobals),
			hoist: context.options[0] && context.options[0].hoist || "functions",
			allow: context.options[0] && context.options[0].allow || []
		};
		function isAllowed(variable) {
			return options.allow.indexOf(variable.name) !== -1;
		}
		function isDuplicatedClassNameVariable(variable) {
			var block = variable.scope.block;

			return block.type === "ClassDeclaration" && block.id === variable.identifiers[0];
		}
		function isOnInitializer(variable, scopeVar) {
			var outerScope = scopeVar.scope;
			var outerDef = scopeVar.defs[0];
			var outer = outerDef && outerDef.parent && outerDef.parent.range;
			var innerScope = variable.scope;
			var innerDef = variable.defs[0];
			var inner = innerDef && innerDef.name.range;

			return outer && inner && outer[0] < inner[0] && inner[1] < outer[1] && (innerDef.type === "FunctionName" && innerDef.node.type === "FunctionExpression" || innerDef.node.type === "ClassExpression") && outerScope === innerScope.upper;
		}
		function getNameRange(variable) {
			var def = variable.defs[0];

			return def && def.name.range;
		}
		function isInTdz(variable, scopeVar) {
			var outerDef = scopeVar.defs[0];
			var inner = getNameRange(variable);
			var outer = getNameRange(scopeVar);

			return inner && outer && inner[1] < outer[0] && (
			options.hoist !== "functions" || !outerDef || outerDef.node.type !== "FunctionDeclaration");
		}
		function checkForShadows(scope) {
			var variables = scope.variables;

			for (var i = 0; i < variables.length; ++i) {
				var variable = variables[i];
				if (variable.identifiers.length === 0 || isDuplicatedClassNameVariable(variable) || isAllowed(variable)) {
					continue;
				}
				var shadowed = astUtils.getVariableByName(scope.upper, variable.name);

				if (shadowed && (shadowed.identifiers.length > 0 || options.builtinGlobals && "writeable" in shadowed) && !isOnInitializer(variable, shadowed) && !(options.hoist !== "all" && isInTdz(variable, shadowed))) {
					context.report({
						node: variable.identifiers[0],
						message: "'{{name}}' is already declared in the upper scope.",
						data: variable
					});
				}
			}
		}

		return {
			"Program:exit": function ProgramExit() {
				var globalScope = context.getScope();
				var stack = globalScope.childScopes.slice();

				while (stack.length) {
					var scope = stack.pop();

					stack.push.apply(stack, scope.childScopes);
					checkForShadows(scope);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow spacing between function identifiers and their applications (deprecated)",
			category: "Stylistic Issues",
			recommended: false,
			replacedBy: ["func-call-spacing"]
		},

		deprecated: true,

		fixable: "whitespace",
		schema: []
	},

	create: function create(context) {

		var sourceCode = context.getSourceCode();
		function detectOpenSpaces(node) {
			var lastCalleeToken = sourceCode.getLastToken(node.callee);
			var prevToken = lastCalleeToken,
				parenToken = sourceCode.getTokenAfter(lastCalleeToken);
			while (parenToken && parenToken.range[1] < node.range[1] && parenToken.value !== "(") {
				prevToken = parenToken;
				parenToken = sourceCode.getTokenAfter(parenToken);
			}
			if (parenToken && parenToken.range[1] < node.range[1] && sourceCode.isSpaceBetweenTokens(prevToken, parenToken)) {
				context.report({
					node: node,
					loc: lastCalleeToken.loc.start,
					message: "Unexpected space between function name and paren.",
					fix: function fix(fixer) {
						return fixer.removeRange([prevToken.range[1], parenToken.range[0]]);
					}
				});
			}
		}

		return {
			CallExpression: detectOpenSpaces,
			NewExpression: detectOpenSpaces
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow sparse arrays",
			category: "Possible Errors",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		return {
			ArrayExpression: function ArrayExpression(node) {

				var emptySpot = node.elements.indexOf(null) > -1;

				if (emptySpot) {
					context.report({ node: node, message: "Unexpected comma in middle of array." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

module.exports = {
	meta: {
		docs: {
			description: "disallow synchronous methods",
			category: "Node.js and CommonJS",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				allowAtRootLevel: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var selector = context.options[0] && context.options[0].allowAtRootLevel ? ":function MemberExpression[property.name=/.*Sync$/]" : "MemberExpression[property.name=/.*Sync$/]";

		return _defineProperty({}, selector, function (node) {
			context.report({
				node: node,
				message: "Unexpected sync method: '{{propertyName}}'.",
				data: {
					propertyName: node.property.name
				}
			});
		});
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var regex = /\t/;
module.exports = {
	meta: {
		docs: {
			description: "disallow all tabs",
			category: "Stylistic Issues",
			recommended: false
		},
		schema: []
	},

	create: function create(context) {
		return {
			Program: function Program(node) {
				context.getSourceCode().getLines().forEach(function (line, index) {
					var match = regex.exec(line);

					if (match) {
						context.report({
							node: node,
							loc: {
								line: index + 1,
								column: match.index + 1
							},
							message: "Unexpected tab character."
						});
					}
				});
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow template literal placeholder syntax in regular strings",
			category: "Possible Errors",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		var regex = /\$\{[^}]+\}/;

		return {
			Literal: function Literal(node) {
				if (typeof node.value === "string" && regex.test(node.value)) {
					context.report({
						node: node,
						message: "Unexpected template string expression."
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow ternary operators",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			ConditionalExpression: function ConditionalExpression(node) {
				context.report({ node: node, message: "Ternary operator used." });
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
function isConstructorFunction(node) {
	return node.type === "FunctionExpression" && node.parent.type === "MethodDefinition" && node.parent.kind === "constructor";
}
module.exports = {
	meta: {
		docs: {
			description: "disallow `this`/`super` before calling `super()` in constructors",
			category: "ECMAScript 6",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		var funcInfo = null;
		var segInfoMap = Object.create(null);
		function isCalled(segment) {
			return !segment.reachable || segInfoMap[segment.id].superCalled;
		}
		function isInConstructorOfDerivedClass() {
			return Boolean(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends);
		}
		function isBeforeCallOfSuper() {
			return isInConstructorOfDerivedClass() && !funcInfo.codePath.currentSegments.every(isCalled);
		}
		function setInvalid(node) {
			var segments = funcInfo.codePath.currentSegments;

			for (var i = 0; i < segments.length; ++i) {
				var segment = segments[i];

				if (segment.reachable) {
					segInfoMap[segment.id].invalidNodes.push(node);
				}
			}
		}
		function setSuperCalled() {
			var segments = funcInfo.codePath.currentSegments;

			for (var i = 0; i < segments.length; ++i) {
				var segment = segments[i];

				if (segment.reachable) {
					segInfoMap[segment.id].superCalled = true;
				}
			}
		}

		return {
			onCodePathStart: function onCodePathStart(codePath, node) {
				if (isConstructorFunction(node)) {
					var classNode = node.parent.parent.parent;

					funcInfo = {
						upper: funcInfo,
						isConstructor: true,
						hasExtends: Boolean(classNode.superClass && !astUtils.isNullOrUndefined(classNode.superClass)),
						codePath: codePath
					};
				} else {
					funcInfo = {
						upper: funcInfo,
						isConstructor: false,
						hasExtends: false,
						codePath: codePath
					};
				}
			},
			onCodePathEnd: function onCodePathEnd(codePath) {
				var isDerivedClass = funcInfo.hasExtends;

				funcInfo = funcInfo.upper;
				if (!isDerivedClass) {
					return;
				}

				codePath.traverseSegments(function (segment, controller) {
					var info = segInfoMap[segment.id];

					for (var i = 0; i < info.invalidNodes.length; ++i) {
						var invalidNode = info.invalidNodes[i];

						context.report({
							message: "'{{kind}}' is not allowed before 'super()'.",
							node: invalidNode,
							data: {
								kind: invalidNode.type === "Super" ? "super" : "this"
							}
						});
					}

					if (info.superCalled) {
						controller.skip();
					}
				});
			},
			onCodePathSegmentStart: function onCodePathSegmentStart(segment) {
				if (!isInConstructorOfDerivedClass()) {
					return;
				}
				segInfoMap[segment.id] = {
					superCalled: segment.prevSegments.length > 0 && segment.prevSegments.every(isCalled),
					invalidNodes: []
				};
			},
			onCodePathSegmentLoop: function onCodePathSegmentLoop(fromSegment, toSegment) {
				if (!isInConstructorOfDerivedClass()) {
					return;
				}
				funcInfo.codePath.traverseSegments({ first: toSegment, last: fromSegment }, function (segment, controller) {
					var info = segInfoMap[segment.id];

					if (info.superCalled) {
						info.invalidNodes = [];
						controller.skip();
					} else if (segment.prevSegments.length > 0 && segment.prevSegments.every(isCalled)) {
						info.superCalled = true;
						info.invalidNodes = [];
					}
				});
			},
			ThisExpression: function ThisExpression(node) {
				if (isBeforeCallOfSuper()) {
					setInvalid(node);
				}
			},
			Super: function Super(node) {
				if (!astUtils.isCallee(node) && isBeforeCallOfSuper()) {
					setInvalid(node);
				}
			},
			"CallExpression:exit": function CallExpressionExit(node) {
				if (node.callee.type === "Super" && isBeforeCallOfSuper()) {
					setSuperCalled();
				}
			},
			"Program:exit": function ProgramExit() {
				segInfoMap = Object.create(null);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow throwing literals as exceptions",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			ThrowStatement: function ThrowStatement(node) {
				if (!astUtils.couldBeError(node.argument)) {
					context.report({ node: node, message: "Expected an object to be thrown." });
				} else if (node.argument.type === "Identifier") {
					if (node.argument.name === "undefined") {
						context.report({ node: node, message: "Do not throw undefined." });
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow trailing whitespace at the end of lines",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			type: "object",
			properties: {
				skipBlankLines: {
					type: "boolean"
				},
				ignoreComments: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		var BLANK_CLASS = "[ \t\xA0\u2000-\u200B\u3000]",
			SKIP_BLANK = "^" + BLANK_CLASS + "*$",
			NONBLANK = BLANK_CLASS + "+$";

		var options = context.options[0] || {},
			skipBlankLines = options.skipBlankLines || false,
			ignoreComments = typeof options.ignoreComments === "boolean" && options.ignoreComments;
		function report(node, location, fixRange) {
			context.report({
				node: node,
				loc: location,
				message: "Trailing spaces not allowed.",
				fix: function fix(fixer) {
					return fixer.removeRange(fixRange);
				}
			});
		}
		function getCommentLineNumbers(comments) {
			var lines = new Set();

			comments.forEach(function (comment) {
				for (var i = comment.loc.start.line; i <= comment.loc.end.line; i++) {
					lines.add(i);
				}
			});

			return lines;
		}
		return {

			Program: function checkTrailingSpaces(node) {

				var re = new RegExp(NONBLANK),
					skipMatch = new RegExp(SKIP_BLANK),
					lines = sourceCode.lines,
					linebreaks = sourceCode.getText().match(astUtils.createGlobalLinebreakMatcher()),
					comments = sourceCode.getAllComments(),
					commentLineNumbers = getCommentLineNumbers(comments);

				var totalLength = 0,
					fixRange = [];

				for (var i = 0, ii = lines.length; i < ii; i++) {
					var matches = re.exec(lines[i]);
					var linebreakLength = linebreaks && linebreaks[i] ? linebreaks[i].length : 1;
					var lineLength = lines[i].length + linebreakLength;

					if (matches) {
						var location = {
							line: i + 1,
							column: matches.index
						};

						var rangeStart = totalLength + location.column;
						var rangeEnd = totalLength + lineLength - linebreakLength;
						var containingNode = sourceCode.getNodeByRangeIndex(rangeStart);

						if (containingNode && containingNode.type === "TemplateElement" && rangeStart > containingNode.parent.range[0] && rangeEnd < containingNode.parent.range[1]) {
							totalLength += lineLength;
							continue;
						}
						if (skipBlankLines && skipMatch.test(lines[i])) {
							totalLength += lineLength;
							continue;
						}

						fixRange = [rangeStart, rangeEnd];

						if (!ignoreComments || !commentLineNumbers.has(location.line)) {
							report(node, location, fixRange);
						}
					}

					totalLength += lineLength;
				}
			}

		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow initializing variables to `undefined`",
			category: "Variables",
			recommended: false
		},

		schema: [],

		fixable: "code"
	},

	create: function create(context) {

		var sourceCode = context.getSourceCode();

		return {
			VariableDeclarator: function VariableDeclarator(node) {
				var name = sourceCode.getText(node.id),
					init = node.init && node.init.name,
					scope = context.getScope(),
					undefinedVar = astUtils.getVariableByName(scope, "undefined"),
					shadowed = undefinedVar && undefinedVar.defs.length > 0;

				if (init === "undefined" && node.parent.kind !== "const" && !shadowed) {
					context.report({
						node: node,
						message: "It's not necessary to initialize '{{name}}' to undefined.",
						data: { name: name },
						fix: function fix(fixer) {
							if (node.parent.kind === "var") {
								return null;
							}

							if (node.id.type === "ArrayPattern" || node.id.type === "ObjectPattern") {
								return null;
							}
							return fixer.removeRange([node.id.range[1], node.range[1]]);
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function hasTypeOfOperator(node) {
	var parent = node.parent;

	return parent.type === "UnaryExpression" && parent.operator === "typeof";
}
module.exports = {
	meta: {
		docs: {
			description: "disallow the use of undeclared variables unless mentioned in `/*global */` comments",
			category: "Variables",
			recommended: true
		},

		schema: [{
			type: "object",
			properties: {
				typeof: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = context.options[0];
		var considerTypeOf = options && options.typeof === true || false;

		return {
			"Program:exit": function ProgramExit() /* node */{
				var globalScope = context.getScope();

				globalScope.through.forEach(function (ref) {
					var identifier = ref.identifier;

					if (!considerTypeOf && hasTypeOfOperator(identifier)) {
						return;
					}

					context.report({
						node: identifier,
						message: "'{{name}}' is not defined.",
						data: identifier
					});
				});
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow the use of `undefined` as an identifier",
			category: "Variables",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		function report(node) {
			context.report({
				node: node,
				message: "Unexpected use of undefined."
			});
		}
		function checkScope(scope) {
			var undefinedVar = scope.set.get("undefined");

			if (!undefinedVar) {
				return;
			}

			var references = undefinedVar.references;

			var defs = undefinedVar.defs;
			references.filter(function (ref) {
				return !ref.init;
			}).forEach(function (ref) {
				return report(ref.identifier);
			});

			defs.forEach(function (def) {
				return report(def.name);
			});
		}

		return {
			"Program:exit": function ProgramExit() {
				var globalScope = context.getScope();

				var stack = [globalScope];

				while (stack.length) {
					var scope = stack.pop();

					stack.push.apply(stack, scope.childScopes);
					checkScope(scope);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow dangling underscores in identifiers",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				allow: {
					type: "array",
					items: {
						type: "string"
					}
				},
				allowAfterThis: {
					type: "boolean"
				},
				allowAfterSuper: {
					type: "boolean"
				},
				enforceInMethodNames: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var options = context.options[0] || {};
		var ALLOWED_VARIABLES = options.allow ? options.allow : [];
		var allowAfterThis = typeof options.allowAfterThis !== "undefined" ? options.allowAfterThis : false;
		var allowAfterSuper = typeof options.allowAfterSuper !== "undefined" ? options.allowAfterSuper : false;
		var enforceInMethodNames = typeof options.enforceInMethodNames !== "undefined" ? options.enforceInMethodNames : false;
		function isAllowed(identifier) {
			return ALLOWED_VARIABLES.some(function (ident) {
				return ident === identifier;
			});
		}
		function hasTrailingUnderscore(identifier) {
			var len = identifier.length;

			return identifier !== "_" && (identifier[0] === "_" || identifier[len - 1] === "_");
		}
		function isSpecialCaseIdentifierForMemberExpression(identifier) {
			return identifier === "__proto__";
		}
		function isSpecialCaseIdentifierInVariableExpression(identifier) {
			return identifier === "_";
		}
		function checkForTrailingUnderscoreInFunctionDeclaration(node) {
			if (node.id) {
				var identifier = node.id.name;

				if (typeof identifier !== "undefined" && hasTrailingUnderscore(identifier) && !isAllowed(identifier)) {
					context.report({
						node: node,
						message: "Unexpected dangling '_' in '{{identifier}}'.",
						data: {
							identifier: identifier
						}
					});
				}
			}
		}
		function checkForTrailingUnderscoreInVariableExpression(node) {
			var identifier = node.id.name;

			if (typeof identifier !== "undefined" && hasTrailingUnderscore(identifier) && !isSpecialCaseIdentifierInVariableExpression(identifier) && !isAllowed(identifier)) {
				context.report({
					node: node,
					message: "Unexpected dangling '_' in '{{identifier}}'.",
					data: {
						identifier: identifier
					}
				});
			}
		}
		function checkForTrailingUnderscoreInMemberExpression(node) {
			var identifier = node.property.name,
				isMemberOfThis = node.object.type === "ThisExpression",
				isMemberOfSuper = node.object.type === "Super";

			if (typeof identifier !== "undefined" && hasTrailingUnderscore(identifier) && !(isMemberOfThis && allowAfterThis) && !(isMemberOfSuper && allowAfterSuper) && !isSpecialCaseIdentifierForMemberExpression(identifier) && !isAllowed(identifier)) {
				context.report({
					node: node,
					message: "Unexpected dangling '_' in '{{identifier}}'.",
					data: {
						identifier: identifier
					}
				});
			}
		}
		function checkForTrailingUnderscoreInMethod(node) {
			var identifier = node.key.name;
			var isMethod = node.type === "MethodDefinition" || node.type === "Property" && node.method;

			if (typeof identifier !== "undefined" && enforceInMethodNames && isMethod && hasTrailingUnderscore(identifier)) {
				context.report({
					node: node,
					message: "Unexpected dangling '_' in '{{identifier}}'.",
					data: {
						identifier: identifier
					}
				});
			}
		}
		return {
			FunctionDeclaration: checkForTrailingUnderscoreInFunctionDeclaration,
			VariableDeclarator: checkForTrailingUnderscoreInVariableExpression,
			MemberExpression: checkForTrailingUnderscoreInMemberExpression,
			MethodDefinition: checkForTrailingUnderscoreInMethod,
			Property: checkForTrailingUnderscoreInMethod
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow confusing multiline expressions",
			category: "Possible Errors",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {

		var FUNCTION_MESSAGE = "Unexpected newline between function and ( of function call.";
		var PROPERTY_MESSAGE = "Unexpected newline between object and [ of property access.";
		var TAGGED_TEMPLATE_MESSAGE = "Unexpected newline between template tag and template literal.";
		var DIVISION_MESSAGE = "Unexpected newline between numerator and division operator.";

		var REGEX_FLAG_MATCHER = /^[gimuy]+$/;

		var sourceCode = context.getSourceCode();
		function checkForBreakAfter(node, msg) {
			var openParen = sourceCode.getTokenAfter(node, astUtils.isNotClosingParenToken);
			var nodeExpressionEnd = sourceCode.getTokenBefore(openParen);

			if (openParen.loc.start.line !== nodeExpressionEnd.loc.end.line) {
				context.report({ node: node, loc: openParen.loc.start, message: msg, data: { char: openParen.value } });
			}
		}
		return {
			MemberExpression: function MemberExpression(node) {
				if (!node.computed) {
					return;
				}
				checkForBreakAfter(node.object, PROPERTY_MESSAGE);
			},
			TaggedTemplateExpression: function TaggedTemplateExpression(node) {
				if (node.tag.loc.end.line === node.quasi.loc.start.line) {
					return;
				}
				context.report({ node: node, loc: node.loc.start, message: TAGGED_TEMPLATE_MESSAGE });
			},
			CallExpression: function CallExpression(node) {
				if (node.arguments.length === 0) {
					return;
				}
				checkForBreakAfter(node.callee, FUNCTION_MESSAGE);
			},
			"BinaryExpression[operator='/'] > BinaryExpression[operator='/'].left": function BinaryExpressionOperatorBinaryExpressionOperatorLeft(node) {
				var secondSlash = sourceCode.getTokenAfter(node, function (token) {
					return token.value === "/";
				});
				var tokenAfterOperator = sourceCode.getTokenAfter(secondSlash);

				if (tokenAfterOperator.type === "Identifier" && REGEX_FLAG_MATCHER.test(tokenAfterOperator.value) && secondSlash.range[1] === tokenAfterOperator.range[0]) {
					checkForBreakAfter(node.left, DIVISION_MESSAGE);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var Traverser = __webpack_require__(106),
	astUtils = __webpack_require__(0);
var pushAll = Function.apply.bind(Array.prototype.push);
var SENTINEL_PATTERN = /(?:(?:Call|Class|Function|Member|New|Yield)Expression|Statement|Declaration)$/;
var LOOP_PATTERN = /^(?:DoWhile|For|While)Statement$/; // for-in/of statements don't have `test` property.
var GROUP_PATTERN = /^(?:BinaryExpression|ConditionalExpression)$/;
var SKIP_PATTERN = /^(?:ArrowFunction|Class|Function)Expression$/;
var DYNAMIC_PATTERN = /^(?:Call|Member|New|TaggedTemplate|Yield)Expression$/;
function isWriteReference(reference) {
	if (reference.init) {
		var def = reference.resolved && reference.resolved.defs[0];

		if (!def || def.type !== "Variable" || def.parent.kind !== "var") {
			return false;
		}
	}
	return reference.isWrite();
}
function isUnmodified(condition) {
	return !condition.modified;
}
function isUnmodifiedAndNotBelongToGroup(condition) {
	return !(condition.modified || condition.group);
}
function isInRange(node, reference) {
	var or = node.range;
	var ir = reference.identifier.range;

	return or[0] <= ir[0] && ir[1] <= or[1];
}
var isInLoop = {
	WhileStatement: isInRange,
	DoWhileStatement: isInRange,
	ForStatement: function ForStatement(node, reference) {
		return isInRange(node, reference) && !(node.init && isInRange(node.init, reference));
	}
};
function hasDynamicExpressions(root) {
	var retv = false;
	var traverser = new Traverser();

	traverser.traverse(root, {
		enter: function enter(node) {
			if (DYNAMIC_PATTERN.test(node.type)) {
				retv = true;
				this.break();
			} else if (SKIP_PATTERN.test(node.type)) {
				this.skip();
			}
		}
	});

	return retv;
}
function toLoopCondition(reference) {
	if (reference.init) {
		return null;
	}

	var group = null;
	var child = reference.identifier;
	var node = child.parent;

	while (node) {
		if (SENTINEL_PATTERN.test(node.type)) {
			if (LOOP_PATTERN.test(node.type) && node.test === child) {
				return {
					reference: reference,
					group: group,
					isInLoop: isInLoop[node.type].bind(null, node),
					modified: false
				};
			}
			break;
		}
		if (GROUP_PATTERN.test(node.type)) {
			if (hasDynamicExpressions(node)) {
				break;
			} else {
				group = node;
			}
		}

		child = node;
		node = node.parent;
	}

	return null;
}
function getEncloseFunctionDeclaration(reference) {
	var node = reference.identifier;

	while (node) {
		if (node.type === "FunctionDeclaration") {
			return node.id ? node : null;
		}

		node = node.parent;
	}

	return null;
}
function updateModifiedFlag(conditions, modifiers) {

	for (var i = 0; i < conditions.length; ++i) {
		var condition = conditions[i];

		for (var j = 0; !condition.modified && j < modifiers.length; ++j) {
			var modifier = modifiers[j];
			var funcNode = void 0,
				funcVar = void 0;
			var inLoop = condition.isInLoop(modifier) || Boolean((funcNode = getEncloseFunctionDeclaration(modifier)) && (funcVar = astUtils.getVariableByName(modifier.from.upper, funcNode.id.name)) && funcVar.references.some(condition.isInLoop));

			condition.modified = inLoop;
		}
	}
}
module.exports = {
	meta: {
		docs: {
			description: "disallow unmodified loop conditions",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		var groupMap = null;
		function report(condition) {
			var node = condition.reference.identifier;

			context.report({
				node: node,
				message: "'{{name}}' is not modified in this loop.",
				data: node
			});
		}
		function registerConditionsToGroup(conditions) {
			for (var i = 0; i < conditions.length; ++i) {
				var condition = conditions[i];

				if (condition.group) {
					var group = groupMap.get(condition.group);

					if (!group) {
						group = [];
						groupMap.set(condition.group, group);
					}
					group.push(condition);
				}
			}
		}
		function checkConditionsInGroup(conditions) {
			if (conditions.every(isUnmodified)) {
				conditions.forEach(report);
			}
		}
		function checkReferences(variable) {
			var conditions = variable.references.map(toLoopCondition).filter(Boolean);

			if (conditions.length === 0) {
				return;
			}
			registerConditionsToGroup(conditions);
			var modifiers = variable.references.filter(isWriteReference);

			if (modifiers.length > 0) {
				updateModifiedFlag(conditions, modifiers);
			}
			conditions.filter(isUnmodifiedAndNotBelongToGroup).forEach(report);
		}

		return {
			"Program:exit": function ProgramExit() {
				var queue = [context.getScope()];

				groupMap = new Map();

				var scope = void 0;

				while (scope = queue.pop()) {
					pushAll(queue, scope.childScopes);
					scope.variables.forEach(checkReferences);
				}

				groupMap.forEach(checkConditionsInGroup);
				groupMap = null;
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
var BOOLEAN_OPERATORS = new Set(["==", "===", "!=", "!==", ">", ">=", "<", "<=", "in", "instanceof"]);
var OPERATOR_INVERSES = {
	"==": "!=",
	"!=": "==",
	"===": "!==",
	"!==": "==="
};
module.exports = {
	meta: {
		docs: {
			description: "disallow ternary operators when simpler alternatives exist",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				defaultAssignment: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}],

		fixable: "code"
	},

	create: function create(context) {
		var options = context.options[0] || {};
		var defaultAssignment = options.defaultAssignment !== false;
		var sourceCode = context.getSourceCode();
		function isBooleanLiteral(node) {
			return node.type === "Literal" && typeof node.value === "boolean";
		}
		function invertExpression(node) {
			if (node.type === "BinaryExpression" && Object.prototype.hasOwnProperty.call(OPERATOR_INVERSES, node.operator)) {
				var operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, function (token) {
					return token.value === node.operator;
				});
				var text = sourceCode.getText();

				return text.slice(node.range[0], operatorToken.range[0]) + OPERATOR_INVERSES[node.operator] + text.slice(operatorToken.range[1], node.range[1]);
			}

			if (astUtils.getPrecedence(node) < astUtils.getPrecedence({ type: "UnaryExpression" })) {
				return "!(" + astUtils.getParenthesisedText(sourceCode, node) + ")";
			}
			return "!" + astUtils.getParenthesisedText(sourceCode, node);
		}
		function isBooleanExpression(node) {
			return node.type === "BinaryExpression" && BOOLEAN_OPERATORS.has(node.operator) || node.type === "UnaryExpression" && node.operator === "!";
		}
		function matchesDefaultAssignment(node) {
			return node.test.type === "Identifier" && node.consequent.type === "Identifier" && node.test.name === node.consequent.name;
		}

		return {
			ConditionalExpression: function ConditionalExpression(node) {
				if (isBooleanLiteral(node.alternate) && isBooleanLiteral(node.consequent)) {
					context.report({
						node: node,
						loc: node.consequent.loc.start,
						message: "Unnecessary use of boolean literals in conditional expression.",
						fix: function fix(fixer) {
							if (node.consequent.value === node.alternate.value) {
								return node.test.type === "Identifier" ? fixer.replaceText(node, node.consequent.value.toString()) : null;
							}
							if (node.alternate.value) {
								return fixer.replaceText(node, invertExpression(node.test));
							}
							return fixer.replaceText(node, isBooleanExpression(node.test) ? astUtils.getParenthesisedText(sourceCode, node.test) : "!" + invertExpression(node.test));
						}
					});
				} else if (!defaultAssignment && matchesDefaultAssignment(node)) {
					context.report({
						node: node,
						loc: node.consequent.loc.start,
						message: "Unnecessary use of conditional expression for default assignment.",
						fix: function fix(fixer) {
							var nodeAlternate = astUtils.getParenthesisedText(sourceCode, node.alternate);

							if (node.alternate.type === "ConditionalExpression") {
								var isAlternateParenthesised = astUtils.isParenthesised(sourceCode, node.alternate);

								nodeAlternate = isAlternateParenthesised ? nodeAlternate : "(" + nodeAlternate + ")";
							}

							return fixer.replaceText(node, astUtils.getParenthesisedText(sourceCode, node.test) + " || " + nodeAlternate);
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function isInitialized(node) {
	return Boolean(node.init);
}
function isUnreachable(segment) {
	return !segment.reachable;
}

var ConsecutiveRange = function () {
	function ConsecutiveRange(sourceCode) {
		_classCallCheck(this, ConsecutiveRange);

		this.sourceCode = sourceCode;
		this.startNode = null;
		this.endNode = null;
	}


	_createClass(ConsecutiveRange, [{
		key: "contains",
		value: function contains(node) {
			return node.range[0] >= this.startNode.range[0] && node.range[1] <= this.endNode.range[1];
		}

	}, {
		key: "isConsecutive",
		value: function isConsecutive(node) {
			return this.contains(this.sourceCode.getTokenBefore(node));
		}

	}, {
		key: "merge",
		value: function merge(node) {
			this.endNode = node;
		}

	}, {
		key: "reset",
		value: function reset(node) {
			this.startNode = this.endNode = node;
		}
	}, {
		key: "location",
		get: function get() {
			return {
				start: this.startNode.loc.start,
				end: this.endNode.loc.end
			};
		}

	}, {
		key: "isEmpty",
		get: function get() {
			return !(this.startNode && this.endNode);
		}
	}]);

	return ConsecutiveRange;
}();
module.exports = {
	meta: {
		docs: {
			description: "disallow unreachable code after `return`, `throw`, `continue`, and `break` statements",
			category: "Possible Errors",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		var currentCodePath = null;

		var range = new ConsecutiveRange(context.getSourceCode());
		function reportIfUnreachable(node) {
			var nextNode = null;

			if (node && currentCodePath.currentSegments.every(isUnreachable)) {
				if (range.isEmpty) {
					range.reset(node);
					return;
				}
				if (range.contains(node)) {
					return;
				}
				if (range.isConsecutive(node)) {
					range.merge(node);
					return;
				}

				nextNode = node;
			}
			if (!range.isEmpty) {
				context.report({
					message: "Unreachable code.",
					loc: range.location,
					node: range.startNode
				});
			}
			range.reset(nextNode);
		}

		return {
			onCodePathStart: function onCodePathStart(codePath) {
				currentCodePath = codePath;
			},
			onCodePathEnd: function onCodePathEnd() {
				currentCodePath = currentCodePath.upper;
			},
			BlockStatement: reportIfUnreachable,
			BreakStatement: reportIfUnreachable,
			ClassDeclaration: reportIfUnreachable,
			ContinueStatement: reportIfUnreachable,
			DebuggerStatement: reportIfUnreachable,
			DoWhileStatement: reportIfUnreachable,
			EmptyStatement: reportIfUnreachable,
			ExpressionStatement: reportIfUnreachable,
			ForInStatement: reportIfUnreachable,
			ForOfStatement: reportIfUnreachable,
			ForStatement: reportIfUnreachable,
			IfStatement: reportIfUnreachable,
			ImportDeclaration: reportIfUnreachable,
			LabeledStatement: reportIfUnreachable,
			ReturnStatement: reportIfUnreachable,
			SwitchStatement: reportIfUnreachable,
			ThrowStatement: reportIfUnreachable,
			TryStatement: reportIfUnreachable,

			VariableDeclaration: function VariableDeclaration(node) {
				if (node.kind !== "var" || node.declarations.some(isInitialized)) {
					reportIfUnreachable(node);
				}
			},


			WhileStatement: reportIfUnreachable,
			WithStatement: reportIfUnreachable,
			ExportNamedDeclaration: reportIfUnreachable,
			ExportDefaultDeclaration: reportIfUnreachable,
			ExportAllDeclaration: reportIfUnreachable,

			"Program:exit": function ProgramExit() {
				reportIfUnreachable();
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var SENTINEL_NODE_TYPE_RETURN_THROW = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression)$/;
var SENTINEL_NODE_TYPE_BREAK = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement|SwitchStatement)$/;
var SENTINEL_NODE_TYPE_CONTINUE = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement)$/;
module.exports = {
	meta: {
		docs: {
			description: "disallow control flow statements in `finally` blocks",
			category: "Possible Errors",
			recommended: true
		},

		schema: []
	},
	create: function create(context) {
		function isFinallyBlock(node) {
			return node.parent.type === "TryStatement" && node.parent.finalizer === node;
		}
		function isInFinallyBlock(node, label) {
			var labelInside = false;
			var sentinelNodeType = void 0;

			if (node.type === "BreakStatement" && !node.label) {
				sentinelNodeType = SENTINEL_NODE_TYPE_BREAK;
			} else if (node.type === "ContinueStatement") {
				sentinelNodeType = SENTINEL_NODE_TYPE_CONTINUE;
			} else {
				sentinelNodeType = SENTINEL_NODE_TYPE_RETURN_THROW;
			}

			while (node && !sentinelNodeType.test(node.type)) {
				if (node.parent.label && label && node.parent.label.name === label.name) {
					labelInside = true;
				}
				if (isFinallyBlock(node)) {
					if (label && labelInside) {
						return false;
					}
					return true;
				}
				node = node.parent;
			}
			return false;
		}
		function check(node) {
			if (isInFinallyBlock(node, node.label)) {
				context.report({
					message: "Unsafe usage of {{nodeType}}.",
					data: {
						nodeType: node.type
					},
					node: node,
					line: node.loc.line,
					column: node.loc.column
				});
			}
		}

		return {
			ReturnStatement: check,
			ThrowStatement: check,
			BreakStatement: check,
			ContinueStatement: check
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
function isRelationalOperator(op) {
	return op === "in" || op === "instanceof";
}
function isNegation(node) {
	return node.type === "UnaryExpression" && node.operator === "!";
}
module.exports = {
	meta: {
		docs: {
			description: "disallow negating the left operand of relational operators",
			category: "Possible Errors",
			recommended: true
		},
		schema: [],
		fixable: "code"
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		return {
			BinaryExpression: function BinaryExpression(node) {
				if (isRelationalOperator(node.operator) && isNegation(node.left) && !astUtils.isParenthesised(sourceCode, node.left)) {
					context.report({
						node: node,
						loc: node.left.loc,
						message: "Unexpected negating the left operand of '{{operator}}' operator.",
						data: node,

						fix: function fix(fixer) {
							var negationToken = sourceCode.getFirstToken(node.left);
							var fixRange = [negationToken.range[1], node.range[1]];
							var text = sourceCode.text.slice(fixRange[0], fixRange[1]);

							return fixer.replaceTextRange(fixRange, "(" + text + ")");
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow unused expressions",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				allowShortCircuit: {
					type: "boolean"
				},
				allowTernary: {
					type: "boolean"
				},
				allowTaggedTemplates: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var config = context.options[0] || {},
			allowShortCircuit = config.allowShortCircuit || false,
			allowTernary = config.allowTernary || false,
			allowTaggedTemplates = config.allowTaggedTemplates || false;
		function looksLikeDirective(node) {
			return node.type === "ExpressionStatement" && node.expression.type === "Literal" && typeof node.expression.value === "string";
		}
		function takeWhile(predicate, list) {
			for (var i = 0; i < list.length; ++i) {
				if (!predicate(list[i])) {
					return list.slice(0, i);
				}
			}
			return list.slice();
		}
		function directives(node) {
			return takeWhile(looksLikeDirective, node.body);
		}
		function isDirective(node, ancestors) {
			var parent = ancestors[ancestors.length - 1],
				grandparent = ancestors[ancestors.length - 2];

			return (parent.type === "Program" || parent.type === "BlockStatement" && /Function/.test(grandparent.type)) && directives(parent).indexOf(node) >= 0;
		}
		function isValidExpression(node) {
			if (allowTernary) {
				if (node.type === "ConditionalExpression") {
					return isValidExpression(node.consequent) && isValidExpression(node.alternate);
				}
			}

			if (allowShortCircuit) {
				if (node.type === "LogicalExpression") {
					return isValidExpression(node.right);
				}
			}

			if (allowTaggedTemplates && node.type === "TaggedTemplateExpression") {
				return true;
			}

			return (/^(?:Assignment|Call|New|Update|Yield|Await)Expression$/.test(node.type) || node.type === "UnaryExpression" && ["delete", "void"].indexOf(node.operator) >= 0
			);
		}

		return {
			ExpressionStatement: function ExpressionStatement(node) {
				if (!isValidExpression(node.expression) && !isDirective(node, context.getAncestors())) {
					context.report({ node: node, message: "Expected an assignment or function call and instead saw an expression." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow unused labels",
			category: "Best Practices",
			recommended: true
		},

		schema: [],

		fixable: "code"
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var scopeInfo = null;
		function enterLabeledScope(node) {
			scopeInfo = {
				label: node.label.name,
				used: false,
				upper: scopeInfo
			};
		}
		function exitLabeledScope(node) {
			if (!scopeInfo.used) {
				context.report({
					node: node.label,
					message: "'{{name}}:' is defined but never used.",
					data: node.label,
					fix: function fix(fixer) {
						if (sourceCode.getTokenAfter(node.label, { includeComments: true }) === sourceCode.getTokenBefore(node.body, { includeComments: true })) {
							return fixer.removeRange([node.range[0], node.body.range[0]]);
						}

						return null;
					}
				});
			}

			scopeInfo = scopeInfo.upper;
		}
		function markAsUsed(node) {
			if (!node.label) {
				return;
			}

			var label = node.label.name;
			var info = scopeInfo;

			while (info) {
				if (info.label === label) {
					info.used = true;
					break;
				}
				info = info.upper;
			}
		}

		return {
			LabeledStatement: enterLabeledScope,
			"LabeledStatement:exit": exitLabeledScope,
			BreakStatement: markAsUsed,
			ContinueStatement: markAsUsed
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var lodash = __webpack_require__(10);
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow unused variables",
			category: "Variables",
			recommended: true
		},

		schema: [{
			oneOf: [{
				enum: ["all", "local"]
			}, {
				type: "object",
				properties: {
					vars: {
						enum: ["all", "local"]
					},
					varsIgnorePattern: {
						type: "string"
					},
					args: {
						enum: ["all", "after-used", "none"]
					},
					ignoreRestSiblings: {
						type: "boolean"
					},
					argsIgnorePattern: {
						type: "string"
					},
					caughtErrors: {
						enum: ["all", "none"]
					},
					caughtErrorsIgnorePattern: {
						type: "string"
					}
				}
			}]
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		var REST_PROPERTY_TYPE = /^(?:Experimental)?RestProperty$/;

		var config = {
			vars: "all",
			args: "after-used",
			ignoreRestSiblings: false,
			caughtErrors: "none"
		};

		var firstOption = context.options[0];

		if (firstOption) {
			if (typeof firstOption === "string") {
				config.vars = firstOption;
			} else {
				config.vars = firstOption.vars || config.vars;
				config.args = firstOption.args || config.args;
				config.ignoreRestSiblings = firstOption.ignoreRestSiblings || config.ignoreRestSiblings;
				config.caughtErrors = firstOption.caughtErrors || config.caughtErrors;

				if (firstOption.varsIgnorePattern) {
					config.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern);
				}

				if (firstOption.argsIgnorePattern) {
					config.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern);
				}

				if (firstOption.caughtErrorsIgnorePattern) {
					config.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern);
				}
			}
		}
		function getDefinedMessage(unusedVar) {
			var type = void 0;
			var pattern = void 0;

			if (config.varsIgnorePattern) {
				type = "vars";
				pattern = config.varsIgnorePattern.toString();
			}

			if (unusedVar.defs && unusedVar.defs[0] && unusedVar.defs[0].type) {
				var defType = unusedVar.defs[0].type;

				if (defType === "CatchClause" && config.caughtErrorsIgnorePattern) {
					type = "args";
					pattern = config.caughtErrorsIgnorePattern.toString();
				} else if (defType === "Parameter" && config.argsIgnorePattern) {
					type = "args";
					pattern = config.argsIgnorePattern.toString();
				}
			}

			var additional = type ? " Allowed unused " + type + " must match " + pattern + "." : "";

			return "'{{name}}' is defined but never used." + additional;
		}
		function getAssignedMessage() {
			var additional = config.varsIgnorePattern ? " Allowed unused vars must match " + config.varsIgnorePattern.toString() + "." : "";

			return "'{{name}}' is assigned a value but never used." + additional;
		}
		var STATEMENT_TYPE = /(?:Statement|Declaration)$/;
		function isExported(variable) {

			var definition = variable.defs[0];

			if (definition) {

				var node = definition.node;

				if (node.type === "VariableDeclarator") {
					node = node.parent;
				} else if (definition.type === "Parameter") {
					return false;
				}

				return node.parent.type.indexOf("Export") === 0;
			}
			return false;
		}
		function hasRestSpreadSibling(variable) {
			if (config.ignoreRestSiblings) {
				return variable.defs.some(function (def) {
					var propertyNode = def.name.parent;
					var patternNode = propertyNode.parent;

					return propertyNode.type === "Property" && patternNode.type === "ObjectPattern" && REST_PROPERTY_TYPE.test(patternNode.properties[patternNode.properties.length - 1].type);
				});
			}

			return false;
		}
		function isReadRef(ref) {
			return ref.isRead();
		}
		function isSelfReference(ref, nodes) {
			var scope = ref.from;

			while (scope) {
				if (nodes.indexOf(scope.block) >= 0) {
					return true;
				}

				scope = scope.upper;
			}

			return false;
		}
		function isInside(inner, outer) {
			return inner.range[0] >= outer.range[0] && inner.range[1] <= outer.range[1];
		}
		function getRhsNode(ref, prevRhsNode) {
			var id = ref.identifier;
			var parent = id.parent;
			var granpa = parent.parent;
			var refScope = ref.from.variableScope;
			var varScope = ref.resolved.scope.variableScope;
			var canBeUsedLater = refScope !== varScope || astUtils.isInLoop(id);
			if (prevRhsNode && isInside(id, prevRhsNode)) {
				return prevRhsNode;
			}

			if (parent.type === "AssignmentExpression" && granpa.type === "ExpressionStatement" && id === parent.left && !canBeUsedLater) {
				return parent.right;
			}
			return null;
		}
		function isStorableFunction(funcNode, rhsNode) {
			var node = funcNode;
			var parent = funcNode.parent;

			while (parent && isInside(parent, rhsNode)) {
				switch (parent.type) {
					case "SequenceExpression":
						if (parent.expressions[parent.expressions.length - 1] !== node) {
							return false;
						}
						break;

					case "CallExpression":
					case "NewExpression":
						return parent.callee !== node;

					case "AssignmentExpression":
					case "TaggedTemplateExpression":
					case "YieldExpression":
						return true;

					default:
						if (STATEMENT_TYPE.test(parent.type)) {
							return true;
						}
				}

				node = parent;
				parent = parent.parent;
			}

			return false;
		}
		function isInsideOfStorableFunction(id, rhsNode) {
			var funcNode = astUtils.getUpperFunction(id);

			return funcNode && isInside(funcNode, rhsNode) && isStorableFunction(funcNode, rhsNode);
		}
		function isReadForItself(ref, rhsNode) {
			var id = ref.identifier;
			var parent = id.parent;
			var granpa = parent.parent;

			return ref.isRead() && (
			parent.type === "AssignmentExpression" && granpa.type === "ExpressionStatement" && parent.left === id || parent.type === "UpdateExpression" && granpa.type === "ExpressionStatement" ||
			rhsNode && isInside(id, rhsNode) && !isInsideOfStorableFunction(id, rhsNode));
		}
		function isForInRef(ref) {
			var target = ref.identifier.parent;
			if (target.type === "VariableDeclarator") {
				target = target.parent.parent;
			}

			if (target.type !== "ForInStatement") {
				return false;
			}
			if (target.body.type === "BlockStatement") {
				target = target.body.body[0];
			} else {
				target = target.body;
			}
			if (!target) {
				return false;
			}

			return target.type === "ReturnStatement";
		}
		function isUsedVariable(variable) {
			var functionNodes = variable.defs.filter(function (def) {
				return def.type === "FunctionName";
			}).map(function (def) {
				return def.node;
			}),
				isFunctionDefinition = functionNodes.length > 0;
			var rhsNode = null;

			return variable.references.some(function (ref) {
				if (isForInRef(ref)) {
					return true;
				}

				var forItself = isReadForItself(ref, rhsNode);

				rhsNode = getRhsNode(ref, rhsNode);

				return isReadRef(ref) && !forItself && !(isFunctionDefinition && isSelfReference(ref, functionNodes));
			});
		}
		function isLastInNonIgnoredParameters(variable) {
			var def = variable.defs[0];
			if (def.index === def.node.params.length - 1) {
				return true;
			}
			if (config.argsIgnorePattern) {
				var params = context.getDeclaredVariables(def.node);
				var posteriorParams = params.slice(params.indexOf(variable) + 1);

				if (posteriorParams.every(function (v) {
					return v.references.length === 0 && config.argsIgnorePattern.test(v.name);
				})) {
					return true;
				}
			}

			return false;
		}
		function collectUnusedVariables(scope, unusedVars) {
			var variables = scope.variables;
			var childScopes = scope.childScopes;
			var i = void 0,
				l = void 0;

			if (scope.type !== "TDZ" && (scope.type !== "global" || config.vars === "all")) {
				for (i = 0, l = variables.length; i < l; ++i) {
					var variable = variables[i];
					if (scope.type === "class" && scope.block.id === variable.identifiers[0]) {
						continue;
					}
					if (scope.functionExpressionScope || variable.eslintUsed) {
						continue;
					}
					if (scope.type === "function" && variable.name === "arguments" && variable.identifiers.length === 0) {
						continue;
					}
					var def = variable.defs[0];

					if (def) {
						var type = def.type;
						if (type === "CatchClause") {
							if (config.caughtErrors === "none") {
								continue;
							}
							if (config.caughtErrorsIgnorePattern && config.caughtErrorsIgnorePattern.test(def.name.name)) {
								continue;
							}
						}

						if (type === "Parameter") {
							if ((def.node.parent.type === "Property" || def.node.parent.type === "MethodDefinition") && def.node.parent.kind === "set") {
								continue;
							}
							if (config.args === "none") {
								continue;
							}
							if (config.argsIgnorePattern && config.argsIgnorePattern.test(def.name.name)) {
								continue;
							}
							if (config.args === "after-used" && astUtils.isFunction(def.name.parent) && !isLastInNonIgnoredParameters(variable)) {
								continue;
							}
						} else {
							if (config.varsIgnorePattern && config.varsIgnorePattern.test(def.name.name)) {
								continue;
							}
						}
					}

					if (!isUsedVariable(variable) && !isExported(variable) && !hasRestSpreadSibling(variable)) {
						unusedVars.push(variable);
					}
				}
			}

			for (i = 0, l = childScopes.length; i < l; ++i) {
				collectUnusedVariables(childScopes[i], unusedVars);
			}

			return unusedVars;
		}
		function getColumnInComment(variable, comment) {
			var namePattern = new RegExp("[\\s,]" + lodash.escapeRegExp(variable.name) + "(?:$|[\\s,:])", "g");
			namePattern.lastIndex = comment.value.indexOf("global") + 6;
			var match = namePattern.exec(comment.value);

			return match ? match.index + 1 : 0;
		}
		function getLocation(variable) {
			var comment = variable.eslintExplicitGlobalComment;

			return sourceCode.getLocFromIndex(comment.range[0] + 2 + getColumnInComment(variable, comment));
		}
		return {
			"Program:exit": function ProgramExit(programNode) {
				var unusedVars = collectUnusedVariables(context.getScope(), []);

				for (var i = 0, l = unusedVars.length; i < l; ++i) {
					var unusedVar = unusedVars[i];

					if (unusedVar.eslintExplicitGlobal) {
						context.report({
							node: programNode,
							loc: getLocation(unusedVar),
							message: getDefinedMessage(unusedVar),
							data: unusedVar
						});
					} else if (unusedVar.defs.length > 0) {
						context.report({
							node: unusedVar.identifiers[0],
							message: unusedVar.references.some(function (ref) {
								return ref.isWrite();
							}) ? getAssignedMessage() : getDefinedMessage(unusedVar),
							data: unusedVar
						});
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/;
var FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/;
function parseOptions(options) {
	var functions = true;
	var classes = true;
	var variables = true;

	if (typeof options === "string") {
		functions = options !== "nofunc";
	} else if ((typeof options === "undefined" ? "undefined" : _typeof(options)) === "object" && options !== null) {
		functions = options.functions !== false;
		classes = options.classes !== false;
		variables = options.variables !== false;
	}

	return { functions: functions, classes: classes, variables: variables };
}
function isFunction(variable) {
	return variable.defs[0].type === "FunctionName";
}
function isOuterClass(variable, reference) {
	return variable.defs[0].type === "ClassName" && variable.scope.variableScope !== reference.from.variableScope;
}
function isOuterVariable(variable, reference) {
	return variable.defs[0].type === "Variable" && variable.scope.variableScope !== reference.from.variableScope;
}
function isInRange(node, location) {
	return node && node.range[0] <= location && location <= node.range[1];
}
function isInInitializer(variable, reference) {
	if (variable.scope !== reference.from) {
		return false;
	}

	var node = variable.identifiers[0].parent;
	var location = reference.identifier.range[1];

	while (node) {
		if (node.type === "VariableDeclarator") {
			if (isInRange(node.init, location)) {
				return true;
			}
			if (FOR_IN_OF_TYPE.test(node.parent.parent.type) && isInRange(node.parent.parent.right, location)) {
				return true;
			}
			break;
		} else if (node.type === "AssignmentPattern") {
			if (isInRange(node.right, location)) {
				return true;
			}
		} else if (SENTINEL_TYPE.test(node.type)) {
			break;
		}

		node = node.parent;
	}

	return false;
}
module.exports = {
	meta: {
		docs: {
			description: "disallow the use of variables before they are defined",
			category: "Variables",
			recommended: false
		},

		schema: [{
			oneOf: [{
				enum: ["nofunc"]
			}, {
				type: "object",
				properties: {
					functions: { type: "boolean" },
					classes: { type: "boolean" },
					variables: { type: "boolean" }
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {
		var options = parseOptions(context.options[0]);
		function isForbidden(variable, reference) {
			if (isFunction(variable)) {
				return options.functions;
			}
			if (isOuterClass(variable, reference)) {
				return options.classes;
			}
			if (isOuterVariable(variable, reference)) {
				return options.variables;
			}
			return true;
		}
		function findVariablesInScope(scope) {
			scope.references.forEach(function (reference) {
				var variable = reference.resolved;
				if (reference.init || !variable || variable.identifiers.length === 0 || variable.identifiers[0].range[1] < reference.identifier.range[1] && !isInInitializer(variable, reference) || !isForbidden(variable, reference)) {
					return;
				}
				context.report({
					node: reference.identifier,
					message: "'{{name}}' was used before it was defined.",
					data: reference.identifier
				});
			});
		}
		function findVariables() {
			var scope = context.getScope();

			findVariablesInScope(scope);
		}

		var ruleDefinition = {
			"Program:exit": function ProgramExit(node) {
				var scope = context.getScope(),
					ecmaFeatures = context.parserOptions.ecmaFeatures || {};

				findVariablesInScope(scope);
				if (ecmaFeatures.globalReturn || node.sourceType === "module") {
					findVariablesInScope(scope.childScopes[0]);
				}
			}
		};

		if (context.parserOptions.ecmaVersion >= 6) {
			ruleDefinition["BlockStatement:exit"] = ruleDefinition["SwitchStatement:exit"] = findVariables;

			ruleDefinition["ArrowFunctionExpression:exit"] = function (node) {
				if (node.body.type !== "BlockStatement") {
					findVariables();
				}
			};
		} else {
			ruleDefinition["FunctionExpression:exit"] = ruleDefinition["FunctionDeclaration:exit"] = ruleDefinition["ArrowFunctionExpression:exit"] = findVariables;
		}

		return ruleDefinition;
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
function isCallOrNonVariadicApply(node) {
	return node.callee.type === "MemberExpression" && node.callee.property.type === "Identifier" && node.callee.computed === false && (node.callee.property.name === "call" && node.arguments.length >= 1 || node.callee.property.name === "apply" && node.arguments.length === 2 && node.arguments[1].type === "ArrayExpression");
}
function isValidThisArg(expectedThis, thisArg, sourceCode) {
	if (!expectedThis) {
		return astUtils.isNullOrUndefined(thisArg);
	}
	return astUtils.equalTokens(expectedThis, thisArg, sourceCode);
}
module.exports = {
	meta: {
		docs: {
			description: "disallow unnecessary calls to `.call()` and `.apply()`",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		return {
			CallExpression: function CallExpression(node) {
				if (!isCallOrNonVariadicApply(node)) {
					return;
				}

				var applied = node.callee.object;
				var expectedThis = applied.type === "MemberExpression" ? applied.object : null;
				var thisArg = node.arguments[0];

				if (isValidThisArg(expectedThis, thisArg, sourceCode)) {
					context.report({ node: node, message: "unnecessary '.{{name}}()'.", data: { name: node.callee.property.name } });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var astUtils = __webpack_require__(0);
var MESSAGE_UNNECESSARY_COMPUTED = "Unnecessarily computed property [{{property}}] found.";

module.exports = {
	meta: {
		docs: {
			description: "disallow unnecessary computed property keys in object literals",
			category: "ECMAScript 6",
			recommended: false
		},

		schema: [],

		fixable: "code"
	},
	create: function create(context) {
		var sourceCode = context.getSourceCode();

		return {
			Property: function Property(node) {
				if (!node.computed) {
					return;
				}

				var key = node.key,
					nodeType = _typeof(key.value);

				if (key.type === "Literal" && (nodeType === "string" || nodeType === "number") && key.value !== "__proto__") {
					context.report({
						node: node,
						message: MESSAGE_UNNECESSARY_COMPUTED,
						data: { property: sourceCode.getText(key) },
						fix: function fix(fixer) {
							var leftSquareBracket = sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken);
							var rightSquareBracket = sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken);
							var tokensBetween = sourceCode.getTokensBetween(leftSquareBracket, rightSquareBracket, 1);

							if (tokensBetween.slice(0, -1).some(function (token, index) {
								return sourceCode.getText().slice(token.range[1], tokensBetween[index + 1].range[0]).trim();
							})) {
								return null;
							}

							var tokenBeforeLeftBracket = sourceCode.getTokenBefore(leftSquareBracket);
							var needsSpaceBeforeKey = tokenBeforeLeftBracket.range[1] === leftSquareBracket.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeLeftBracket, sourceCode.getFirstToken(key));

							var replacementKey = (needsSpaceBeforeKey ? " " : "") + key.raw;

							return fixer.replaceTextRange([leftSquareBracket.range[0], rightSquareBracket.range[1]], replacementKey);
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
function isConcatenation(node) {
	return node.type === "BinaryExpression" && node.operator === "+";
}
function isConcatOperatorToken(token) {
	return token.value === "+" && token.type === "Punctuator";
}
function getLeft(node) {
	var left = node.left;

	while (isConcatenation(left)) {
		left = left.right;
	}
	return left;
}
function getRight(node) {
	var right = node.right;

	while (isConcatenation(right)) {
		right = right.left;
	}
	return right;
}
module.exports = {
	meta: {
		docs: {
			description: "disallow unnecessary concatenation of literals or template literals",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		return {
			BinaryExpression: function BinaryExpression(node) {
				if (node.operator !== "+") {
					return;
				}
				var left = getLeft(node);
				var right = getRight(node);

				if (astUtils.isStringLiteral(left) && astUtils.isStringLiteral(right) && astUtils.isTokenOnSameLine(left, right)) {
					var operatorToken = sourceCode.getFirstTokenBetween(left, right, isConcatOperatorToken);

					context.report({
						node: node,
						loc: operatorToken.loc.start,
						message: "Unexpected string concatenation of literals."
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function isSingleSuperCall(body) {
	return body.length === 1 && body[0].type === "ExpressionStatement" && body[0].expression.type === "CallExpression" && body[0].expression.callee.type === "Super";
}
function isSimple(node) {
	return node.type === "Identifier" || node.type === "RestElement";
}
function isSpreadArguments(superArgs) {
	return superArgs.length === 1 && superArgs[0].type === "SpreadElement" && superArgs[0].argument.type === "Identifier" && superArgs[0].argument.name === "arguments";
}
function isValidIdentifierPair(ctorParam, superArg) {
	return ctorParam.type === "Identifier" && superArg.type === "Identifier" && ctorParam.name === superArg.name;
}
function isValidRestSpreadPair(ctorParam, superArg) {
	return ctorParam.type === "RestElement" && superArg.type === "SpreadElement" && isValidIdentifierPair(ctorParam.argument, superArg.argument);
}
function isValidPair(ctorParam, superArg) {
	return isValidIdentifierPair(ctorParam, superArg) || isValidRestSpreadPair(ctorParam, superArg);
}
function isPassingThrough(ctorParams, superArgs) {
	if (ctorParams.length !== superArgs.length) {
		return false;
	}

	for (var i = 0; i < ctorParams.length; ++i) {
		if (!isValidPair(ctorParams[i], superArgs[i])) {
			return false;
		}
	}

	return true;
}
function isRedundantSuperCall(body, ctorParams) {
	return isSingleSuperCall(body) && ctorParams.every(isSimple) && (isSpreadArguments(body[0].expression.arguments) || isPassingThrough(ctorParams, body[0].expression.arguments));
}
module.exports = {
	meta: {
		docs: {
			description: "disallow unnecessary constructors",
			category: "ECMAScript 6",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		function checkForConstructor(node) {
			if (node.kind !== "constructor") {
				return;
			}

			var body = node.value.body.body;
			var ctorParams = node.value.params;
			var superClass = node.parent.parent.superClass;

			if (superClass ? isRedundantSuperCall(body, ctorParams) : body.length === 0) {
				context.report({
					node: node,
					message: "Useless constructor."
				});
			}
		}

		return {
			MethodDefinition: checkForConstructor
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
function union(setA, setB) {
	return new Set( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
		return regeneratorRuntime.wrap(function _callee$(_context) {
			while (1) {
				switch (_context.prev = _context.next) {
					case 0:
						return _context.delegateYield(setA, "t0", 1);

					case 1:
						return _context.delegateYield(setB, "t1", 2);

					case 2:
					case "end":
						return _context.stop();
				}
			}
		}, _callee, this);
	})());
}

var VALID_STRING_ESCAPES = union(new Set("\\nrvtbfux"), astUtils.LINEBREAKS);
var REGEX_GENERAL_ESCAPES = new Set("\\bcdDfnrsStvwWxu0123456789]");
var REGEX_NON_CHARCLASS_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set("^/.$*+?[{}|()B"));
function parseRegExp(regExpText) {
	var charList = [];

	regExpText.split("").reduce(function (state, char, index) {
		if (!state.escapeNextChar) {
			if (char === "\\") {
				return Object.assign(state, { escapeNextChar: true });
			}
			if (char === "[" && !state.inCharClass) {
				return Object.assign(state, { inCharClass: true, startingCharClass: true });
			}
			if (char === "]" && state.inCharClass) {
				if (charList.length && charList[charList.length - 1].inCharClass) {
					charList[charList.length - 1].endsCharClass = true;
				}
				return Object.assign(state, { inCharClass: false, startingCharClass: false });
			}
		}
		charList.push({
			text: char,
			index: index,
			escaped: state.escapeNextChar,
			inCharClass: state.inCharClass,
			startsCharClass: state.startingCharClass,
			endsCharClass: false
		});
		return Object.assign(state, { escapeNextChar: false, startingCharClass: false });
	}, { escapeNextChar: false, inCharClass: false, startingCharClass: false });

	return charList;
}

module.exports = {
	meta: {
		docs: {
			description: "disallow unnecessary escape characters",
			category: "Best Practices",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		function report(node, startOffset, character) {
			context.report({
				node: node,
				loc: sourceCode.getLocFromIndex(sourceCode.getIndexFromLoc(node.loc.start) + startOffset),
				message: "Unnecessary escape character: \\{{character}}.",
				data: { character: character }
			});
		}
		function validateString(node, match) {
			var isTemplateElement = node.type === "TemplateElement";
			var escapedChar = match[0][1];
			var isUnnecessaryEscape = !VALID_STRING_ESCAPES.has(escapedChar);
			var isQuoteEscape = void 0;

			if (isTemplateElement) {
				isQuoteEscape = escapedChar === "`";

				if (escapedChar === "$") {
					isUnnecessaryEscape = match.input[match.index + 2] !== "{";
				} else if (escapedChar === "{") {
					isUnnecessaryEscape = match.input[match.index - 1] !== "$";
				}
			} else {
				isQuoteEscape = escapedChar === node.raw[0];
			}

			if (isUnnecessaryEscape && !isQuoteEscape) {
				report(node, match.index + 1, match[0].slice(1));
			}
		}
		function check(node) {
			var isTemplateElement = node.type === "TemplateElement";

			if (isTemplateElement && node.parent && node.parent.parent && node.parent.parent.type === "TaggedTemplateExpression" && node.parent === node.parent.parent.quasi) {
				return;
			}

			if (typeof node.value === "string" || isTemplateElement) {
				if (node.parent.type === "JSXAttribute" || node.parent.type === "JSXElement") {
					return;
				}

				var value = isTemplateElement ? node.value.raw : node.raw.slice(1, -1);
				var pattern = /\\[^\d]/g;
				var match = void 0;

				while (match = pattern.exec(value)) {
					validateString(node, match);
				}
			} else if (node.regex) {
				parseRegExp(node.regex.pattern)
				.filter(function (charInfo) {
					return !(charInfo.text === "-" && charInfo.inCharClass && !charInfo.startsCharClass && !charInfo.endsCharClass);
				})
				.filter(function (charInfo) {
					return !(charInfo.text === "^" && charInfo.startsCharClass);
				})
				.filter(function (charInfo) {
					return charInfo.escaped;
				})
				.filter(function (charInfo) {
					return !(charInfo.inCharClass ? REGEX_GENERAL_ESCAPES : REGEX_NON_CHARCLASS_ESCAPES).has(charInfo.text);
				})
				.forEach(function (charInfo) {
					return report(node, charInfo.index, charInfo.text);
				});
			}
		}

		return {
			Literal: check,
			TemplateElement: check
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow renaming import, export, and destructured assignments to the same name",
			category: "ECMAScript 6",
			recommended: false
		},
		fixable: "code",
		schema: [{
			type: "object",
			properties: {
				ignoreDestructuring: { type: "boolean" },
				ignoreImport: { type: "boolean" },
				ignoreExport: { type: "boolean" }
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = context.options[0] || {},
			ignoreDestructuring = options.ignoreDestructuring === true,
			ignoreImport = options.ignoreImport === true,
			ignoreExport = options.ignoreExport === true;
		function reportError(node, initial, result, type) {
			var name = initial.type === "Identifier" ? initial.name : initial.value;

			return context.report({
				node: node,
				message: "{{type}} {{name}} unnecessarily renamed.",
				data: {
					name: name,
					type: type
				},
				fix: function fix(fixer) {
					return fixer.replaceTextRange([initial.range[0], result.range[1]], name);
				}
			});
		}
		function checkDestructured(node) {
			if (ignoreDestructuring) {
				return;
			}

			var properties = node.properties;

			for (var i = 0; i < properties.length; i++) {
				if (properties[i].shorthand) {
					continue;
				}
				if (properties[i].computed || !properties[i].key) {
					continue;
				}

				if (properties[i].key.type === "Identifier" && properties[i].key.name === properties[i].value.name || properties[i].key.type === "Literal" && properties[i].key.value === properties[i].value.name) {
					reportError(properties[i], properties[i].key, properties[i].value, "Destructuring assignment");
				}
			}
		}
		function checkImport(node) {
			if (ignoreImport) {
				return;
			}

			if (node.imported.name === node.local.name && node.imported.range[0] !== node.local.range[0]) {
				reportError(node, node.imported, node.local, "Import");
			}
		}
		function checkExport(node) {
			if (ignoreExport) {
				return;
			}

			if (node.local.name === node.exported.name && node.local.range[0] !== node.exported.range[0]) {
				reportError(node, node.local, node.exported, "Export");
			}
		}
		return {
			ObjectPattern: checkDestructured,
			ImportSpecifier: checkImport,
			ExportSpecifier: checkExport
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0),
	FixTracker = __webpack_require__(70);
var pushAll = Function.apply.bind(Array.prototype.push);
function remove(array, element) {
	var index = array.indexOf(element);

	if (index !== -1) {
		array.splice(index, 1);
	}
}
function isRemovable(node) {
	return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);
}
function isInFinally(node) {
	while (node && node.parent && !astUtils.isFunction(node)) {
		if (node.parent.type === "TryStatement" && node.parent.finalizer === node) {
			return true;
		}

		node = node.parent;
	}

	return false;
}
module.exports = {
	meta: {
		docs: {
			description: "disallow redundant return statements",
			category: "Best Practices",
			recommended: false
		},
		fixable: "code",
		schema: []
	},

	create: function create(context) {
		var segmentInfoMap = new WeakMap();
		var usedUnreachableSegments = new WeakSet();
		var scopeInfo = null;
		function isReturned(segment) {
			var info = segmentInfoMap.get(segment);

			return !info || info.returned;
		}
		function getUselessReturns(uselessReturns, prevSegments, traversedSegments) {
			if (!traversedSegments) {
				traversedSegments = new WeakSet();
			}
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = prevSegments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var segment = _step.value;

					if (!segment.reachable) {
						if (!traversedSegments.has(segment)) {
							traversedSegments.add(segment);
							getUselessReturns(uselessReturns, segment.allPrevSegments.filter(isReturned), traversedSegments);
						}
						continue;
					}

					pushAll(uselessReturns, segmentInfoMap.get(segment).uselessReturns);
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			return uselessReturns;
		}
		function markReturnStatementsOnSegmentAsUsed(segment) {
			if (!segment.reachable) {
				usedUnreachableSegments.add(segment);
				segment.allPrevSegments.filter(isReturned).filter(function (prevSegment) {
					return !usedUnreachableSegments.has(prevSegment);
				}).forEach(markReturnStatementsOnSegmentAsUsed);
				return;
			}

			var info = segmentInfoMap.get(segment);

			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = info.uselessReturns[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var node = _step2.value;

					remove(scopeInfo.uselessReturns, node);
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			info.uselessReturns = [];
		}
		function markReturnStatementsOnCurrentSegmentsAsUsed() {
			scopeInfo.codePath.currentSegments.forEach(markReturnStatementsOnSegmentAsUsed);
		}
		return {
			onCodePathStart: function onCodePathStart(codePath) {
				scopeInfo = {
					upper: scopeInfo,
					uselessReturns: [],
					codePath: codePath
				};
			},
			onCodePathEnd: function onCodePathEnd() {
				var _iteratorNormalCompletion3 = true;
				var _didIteratorError3 = false;
				var _iteratorError3 = undefined;

				try {
					var _loop = function _loop() {
						var node = _step3.value;

						context.report({
							node: node,
							loc: node.loc,
							message: "Unnecessary return statement.",
							fix: function fix(fixer) {
								if (isRemovable(node)) {
									return new FixTracker(fixer, context.getSourceCode()).retainEnclosingFunction(node).remove(node);
								}
								return null;
							}
						});
					};

					for (var _iterator3 = scopeInfo.uselessReturns[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
						_loop();
					}
				} catch (err) {
					_didIteratorError3 = true;
					_iteratorError3 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion3 && _iterator3.return) {
							_iterator3.return();
						}
					} finally {
						if (_didIteratorError3) {
							throw _iteratorError3;
						}
					}
				}

				scopeInfo = scopeInfo.upper;
			},
			onCodePathSegmentStart: function onCodePathSegmentStart(segment) {
				var info = {
					uselessReturns: getUselessReturns([], segment.allPrevSegments),
					returned: false
				};
				segmentInfoMap.set(segment, info);
			},
			ReturnStatement: function ReturnStatement(node) {
				if (node.argument) {
					markReturnStatementsOnCurrentSegmentsAsUsed();
				}
				if (node.argument || astUtils.isInLoop(node) || isInFinally(node)) {
					return;
				}

				var _iteratorNormalCompletion4 = true;
				var _didIteratorError4 = false;
				var _iteratorError4 = undefined;

				try {
					for (var _iterator4 = scopeInfo.codePath.currentSegments[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
						var segment = _step4.value;

						var info = segmentInfoMap.get(segment);

						if (info) {
							info.uselessReturns.push(node);
							info.returned = true;
						}
					}
				} catch (err) {
					_didIteratorError4 = true;
					_iteratorError4 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion4 && _iterator4.return) {
							_iterator4.return();
						}
					} finally {
						if (_didIteratorError4) {
							throw _iteratorError4;
						}
					}
				}

				scopeInfo.uselessReturns.push(node);
			},
			ClassDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
			ContinueStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			DebuggerStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			DoWhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			EmptyStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			ExpressionStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			ForInStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			ForOfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			ForStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			IfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			ImportDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
			LabeledStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			SwitchStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			ThrowStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			TryStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			VariableDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
			WhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			WithStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			ExportNamedDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
			ExportDefaultDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
			ExportAllDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
function isGlobal(variable) {
	return Boolean(variable.scope) && variable.scope.type === "global";
}
function getEnclosingFunctionScope(scope) {
	while (scope.type !== "function" && scope.type !== "global") {
		scope = scope.upper;
	}
	return scope;
}
function isReferencedInClosure(variable) {
	var enclosingFunctionScope = getEnclosingFunctionScope(variable.scope);

	return variable.references.some(function (reference) {
		return getEnclosingFunctionScope(reference.from) !== enclosingFunctionScope;
	});
}
function isLoopAssignee(node) {
	return (node.parent.type === "ForOfStatement" || node.parent.type === "ForInStatement") && node === node.parent.left;
}
function isDeclarationInitialized(node) {
	return node.declarations.every(function (declarator) {
		return declarator.init !== null;
	});
}

var SCOPE_NODE_TYPE = /^(?:Program|BlockStatement|SwitchStatement|ForStatement|ForInStatement|ForOfStatement)$/;
function getScopeNode(node) {
	while (node) {
		if (SCOPE_NODE_TYPE.test(node.type)) {
			return node;
		}

		node = node.parent;
	}
	return null;
}
function isRedeclared(variable) {
	return variable.defs.length >= 2;
}
function isUsedFromOutsideOf(scopeNode) {
	function isOutsideOfScope(reference) {
		var scope = scopeNode.range;
		var id = reference.identifier.range;

		return id[0] < scope[0] || id[1] > scope[1];
	}

	return function (variable) {
		return variable.references.some(isOutsideOfScope);
	};
}
function hasReferenceInTDZ(node) {
	var initStart = node.range[0];
	var initEnd = node.range[1];

	return function (variable) {
		var id = variable.defs[0].name;
		var idStart = id.range[0];
		var defaultValue = id.parent.type === "AssignmentPattern" ? id.parent.right : null;
		var defaultStart = defaultValue && defaultValue.range[0];
		var defaultEnd = defaultValue && defaultValue.range[1];

		return variable.references.some(function (reference) {
			var start = reference.identifier.range[0];
			var end = reference.identifier.range[1];

			return !reference.init && (start < idStart || defaultValue !== null && start >= defaultStart && end <= defaultEnd || start >= initStart && end <= initEnd);
		});
	};
}
module.exports = {
	meta: {
		docs: {
			description: "require `let` or `const` instead of `var`",
			category: "ECMAScript 6",
			recommended: false
		},

		schema: [],
		fixable: "code"
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		function hasSelfReferenceInTDZ(declarator) {
			if (!declarator.init) {
				return false;
			}
			var variables = context.getDeclaredVariables(declarator);

			return variables.some(hasReferenceInTDZ(declarator.init));
		}
		function canFix(node) {
			var variables = context.getDeclaredVariables(node);
			var scopeNode = getScopeNode(node);

			if (node.parent.type === "SwitchCase" || node.declarations.some(hasSelfReferenceInTDZ) || variables.some(isGlobal) || variables.some(isRedeclared) || variables.some(isUsedFromOutsideOf(scopeNode))) {
				return false;
			}

			if (astUtils.isInLoop(node)) {
				if (variables.some(isReferencedInClosure)) {
					return false;
				}
				if (!isLoopAssignee(node) && !isDeclarationInitialized(node)) {
					return false;
				}
			}

			if (!isLoopAssignee(node) && !(node.parent.type === "ForStatement" && node.parent.init === node) && !astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {
				return false;
			}

			return true;
		}
		function report(node) {
			var varToken = sourceCode.getFirstToken(node);

			context.report({
				node: node,
				message: "Unexpected var, use let or const instead.",

				fix: function fix(fixer) {
					if (canFix(node)) {
						return fixer.replaceText(varToken, "let");
					}
					return null;
				}
			});
		}

		return {
			"VariableDeclaration:exit": function VariableDeclarationExit(node) {
				if (node.kind === "var") {
					report(node);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow `void` operators",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		return {
			UnaryExpression: function UnaryExpression(node) {
				if (node.operator === "void") {
					context.report({ node: node, message: "Expected 'undefined' and instead saw 'void'." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow specified warning terms in comments",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				terms: {
					type: "array",
					items: {
						type: "string"
					}
				},
				location: {
					enum: ["start", "anywhere"]
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var sourceCode = context.getSourceCode(),
			configuration = context.options[0] || {},
			warningTerms = configuration.terms || ["todo", "fixme", "xxx"],
			location = configuration.location || "start",
			selfConfigRegEx = /\bno-warning-comments\b/;
		function convertToRegExp(term) {
			var escaped = term.replace(/[-/\\$^*+?.()|[\]{}]/g, "\\$&");
			var prefix = void 0;
			var suffix = /\w$/.test(term) ? "\\b" : "";

			if (location === "start") {
				prefix = "^\\s*";
			} else if (/^\w/.test(term)) {
				prefix = "\\b";
			} else {
				prefix = "";
			}

			return new RegExp(prefix + escaped + suffix, "i");
		}

		var warningRegExps = warningTerms.map(convertToRegExp);
		function commentContainsWarningTerm(comment) {
			var matches = [];

			warningRegExps.forEach(function (regex, index) {
				if (regex.test(comment)) {
					matches.push(warningTerms[index]);
				}
			});

			return matches;
		}
		function checkComment(node) {
			if (astUtils.isDirectiveComment(node) && selfConfigRegEx.test(node.value)) {
				return;
			}

			var matches = commentContainsWarningTerm(node.value);

			matches.forEach(function (matchedTerm) {
				context.report({
					node: node,
					message: "Unexpected '{{matchedTerm}}' comment.",
					data: {
						matchedTerm: matchedTerm
					}
				});
			});
		}

		return {
			Program: function Program() {
				var comments = sourceCode.getAllComments();

				comments.filter(function (token) {
					return token.type !== "Shebang";
				}).forEach(checkComment);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "disallow whitespace before properties",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",
		schema: []
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		function reportError(node, leftToken, rightToken) {
			var replacementText = node.computed ? "" : ".";

			context.report({
				node: node,
				message: "Unexpected whitespace before property {{propName}}.",
				data: {
					propName: sourceCode.getText(node.property)
				},
				fix: function fix(fixer) {
					if (!node.computed && astUtils.isDecimalInteger(node.object)) {
						return null;
					}
					return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], replacementText);
				}
			});
		}
		return {
			MemberExpression: function MemberExpression(node) {
				var rightToken = void 0;
				var leftToken = void 0;

				if (!astUtils.isTokenOnSameLine(node.object, node.property)) {
					return;
				}

				if (node.computed) {
					rightToken = sourceCode.getTokenBefore(node.property, astUtils.isOpeningBracketToken);
					leftToken = sourceCode.getTokenBefore(rightToken);
				} else {
					rightToken = sourceCode.getFirstToken(node.property);
					leftToken = sourceCode.getTokenBefore(rightToken, 1);
				}

				if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken)) {
					reportError(node, leftToken, rightToken);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "disallow `with` statements",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {

		return {
			WithStatement: function WithStatement(node) {
				context.report({ node: node, message: "Unexpected use of 'with' statement." });
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var POSITION_SCHEMA = { enum: ["beside", "below", "any"] };

module.exports = {
	meta: {
		docs: {
			description: "enforce the location of single-line statements",
			category: "Stylistic Issues",
			recommended: false
		},
		fixable: "whitespace",
		schema: [POSITION_SCHEMA, {
			properties: {
				overrides: {
					properties: {
						if: POSITION_SCHEMA,
						else: POSITION_SCHEMA,
						while: POSITION_SCHEMA,
						do: POSITION_SCHEMA,
						for: POSITION_SCHEMA
					},
					additionalProperties: false
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		function getOption(keywordName) {
			return context.options[1] && context.options[1].overrides && context.options[1].overrides[keywordName] || context.options[0] || "beside";
		}
		function validateStatement(node, keywordName) {
			var option = getOption(keywordName);

			if (node.type === "BlockStatement" || option === "any") {
				return;
			}

			var tokenBefore = sourceCode.getTokenBefore(node);

			if (tokenBefore.loc.end.line === node.loc.start.line && option === "below") {
				context.report({
					node: node,
					message: "Expected a linebreak before this statement.",
					fix: function fix(fixer) {
						return fixer.insertTextBefore(node, "\n");
					}
				});
			} else if (tokenBefore.loc.end.line !== node.loc.start.line && option === "beside") {
				context.report({
					node: node,
					message: "Expected no linebreak before this statement.",
					fix: function fix(fixer) {
						if (sourceCode.getText().slice(tokenBefore.range[1], node.range[0]).trim()) {
							return null;
						}
						return fixer.replaceTextRange([tokenBefore.range[1], node.range[0]], " ");
					}
				});
			}
		}
		return {
			IfStatement: function IfStatement(node) {
				validateStatement(node.consequent, "if");
				if (node.alternate && node.alternate.type !== "IfStatement") {
					validateStatement(node.alternate, "else");
				}
			},

			WhileStatement: function WhileStatement(node) {
				return validateStatement(node.body, "while");
			},
			DoWhileStatement: function DoWhileStatement(node) {
				return validateStatement(node.body, "do");
			},
			ForStatement: function ForStatement(node) {
				return validateStatement(node.body, "for");
			},
			ForInStatement: function ForInStatement(node) {
				return validateStatement(node.body, "for");
			},
			ForOfStatement: function ForOfStatement(node) {
				return validateStatement(node.body, "for");
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
var OPTION_VALUE = {
	oneOf: [{
		enum: ["always", "never"]
	}, {
		type: "object",
		properties: {
			multiline: {
				type: "boolean"
			},
			minProperties: {
				type: "integer",
				minimum: 0
			},
			consistent: {
				type: "boolean"
			}
		},
		additionalProperties: false,
		minProperties: 1
	}]
};
function normalizeOptionValue(value) {
	var multiline = false;
	var minProperties = Number.POSITIVE_INFINITY;
	var consistent = false;

	if (value) {
		if (value === "always") {
			minProperties = 0;
		} else if (value === "never") {
			minProperties = Number.POSITIVE_INFINITY;
		} else {
			multiline = Boolean(value.multiline);
			minProperties = value.minProperties || Number.POSITIVE_INFINITY;
			consistent = Boolean(value.consistent);
		}
	} else {
		multiline = true;
	}

	return { multiline: multiline, minProperties: minProperties, consistent: consistent };
}
function normalizeOptions(options) {
	if (options && (options.ObjectExpression || options.ObjectPattern)) {
		return {
			ObjectExpression: normalizeOptionValue(options.ObjectExpression),
			ObjectPattern: normalizeOptionValue(options.ObjectPattern)
		};
	}

	var value = normalizeOptionValue(options);

	return { ObjectExpression: value, ObjectPattern: value };
}
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent line breaks inside braces",
			category: "Stylistic Issues",
			recommended: false
		},
		fixable: "whitespace",
		schema: [{
			oneOf: [OPTION_VALUE, {
				type: "object",
				properties: {
					ObjectExpression: OPTION_VALUE,
					ObjectPattern: OPTION_VALUE
				},
				additionalProperties: false,
				minProperties: 1
			}]
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var normalizedOptions = normalizeOptions(context.options[0]);
		function check(node) {
			var options = normalizedOptions[node.type];
			var openBrace = sourceCode.getFirstToken(node, function (token) {
				return token.value === "{";
			});
			var closeBrace = void 0;

			if (node.typeAnnotation) {
				closeBrace = sourceCode.getTokenBefore(node.typeAnnotation);
			} else {
				closeBrace = sourceCode.getLastToken(node);
			}

			var first = sourceCode.getTokenAfter(openBrace, { includeComments: true });
			var last = sourceCode.getTokenBefore(closeBrace, { includeComments: true });
			var needsLinebreaks = node.properties.length >= options.minProperties || options.multiline && node.properties.length > 0 && first.loc.start.line !== last.loc.end.line;
			var hasCommentsFirstToken = astUtils.isCommentToken(first);
			var hasCommentsLastToken = astUtils.isCommentToken(last);
			first = sourceCode.getTokenAfter(openBrace);
			last = sourceCode.getTokenBefore(closeBrace);

			if (needsLinebreaks) {
				if (astUtils.isTokenOnSameLine(openBrace, first)) {
					context.report({
						message: "Expected a line break after this opening brace.",
						node: node,
						loc: openBrace.loc.start,
						fix: function fix(fixer) {
							if (hasCommentsFirstToken) {
								return null;
							}

							return fixer.insertTextAfter(openBrace, "\n");
						}
					});
				}
				if (astUtils.isTokenOnSameLine(last, closeBrace)) {
					context.report({
						message: "Expected a line break before this closing brace.",
						node: node,
						loc: closeBrace.loc.start,
						fix: function fix(fixer) {
							if (hasCommentsLastToken) {
								return null;
							}

							return fixer.insertTextBefore(closeBrace, "\n");
						}
					});
				}
			} else {
				var consistent = options.consistent;
				var hasLineBreakBetweenOpenBraceAndFirst = !astUtils.isTokenOnSameLine(openBrace, first);
				var hasLineBreakBetweenCloseBraceAndLast = !astUtils.isTokenOnSameLine(last, closeBrace);

				if (!consistent && hasLineBreakBetweenOpenBraceAndFirst || consistent && hasLineBreakBetweenOpenBraceAndFirst && !hasLineBreakBetweenCloseBraceAndLast) {
					context.report({
						message: "Unexpected line break after this opening brace.",
						node: node,
						loc: openBrace.loc.start,
						fix: function fix(fixer) {
							if (hasCommentsFirstToken) {
								return null;
							}

							return fixer.removeRange([openBrace.range[1], first.range[0]]);
						}
					});
				}
				if (!consistent && hasLineBreakBetweenCloseBraceAndLast || consistent && !hasLineBreakBetweenOpenBraceAndFirst && hasLineBreakBetweenCloseBraceAndLast) {
					context.report({
						message: "Unexpected line break before this closing brace.",
						node: node,
						loc: closeBrace.loc.start,
						fix: function fix(fixer) {
							if (hasCommentsLastToken) {
								return null;
							}

							return fixer.removeRange([last.range[1], closeBrace.range[0]]);
						}
					});
				}
			}
		}

		return {
			ObjectExpression: check,
			ObjectPattern: check
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent spacing inside braces",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			enum: ["always", "never"]
		}, {
			type: "object",
			properties: {
				arraysInObjects: {
					type: "boolean"
				},
				objectsInObjects: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var spaced = context.options[0] === "always",
			sourceCode = context.getSourceCode();
		function isOptionSet(option) {
			return context.options[1] ? context.options[1][option] === !spaced : false;
		}

		var options = {
			spaced: spaced,
			arraysInObjectsException: isOptionSet("arraysInObjects"),
			objectsInObjectsException: isOptionSet("objectsInObjects")
		};
		function reportNoBeginningSpace(node, token) {
			context.report({
				node: node,
				loc: token.loc.start,
				message: "There should be no space after '{{token}}'.",
				data: {
					token: token.value
				},
				fix: function fix(fixer) {
					var nextToken = context.getSourceCode().getTokenAfter(token);

					return fixer.removeRange([token.range[1], nextToken.range[0]]);
				}
			});
		}
		function reportNoEndingSpace(node, token) {
			context.report({
				node: node,
				loc: token.loc.start,
				message: "There should be no space before '{{token}}'.",
				data: {
					token: token.value
				},
				fix: function fix(fixer) {
					var previousToken = context.getSourceCode().getTokenBefore(token);

					return fixer.removeRange([previousToken.range[1], token.range[0]]);
				}
			});
		}
		function reportRequiredBeginningSpace(node, token) {
			context.report({
				node: node,
				loc: token.loc.start,
				message: "A space is required after '{{token}}'.",
				data: {
					token: token.value
				},
				fix: function fix(fixer) {
					return fixer.insertTextAfter(token, " ");
				}
			});
		}
		function reportRequiredEndingSpace(node, token) {
			context.report({
				node: node,
				loc: token.loc.start,
				message: "A space is required before '{{token}}'.",
				data: {
					token: token.value
				},
				fix: function fix(fixer) {
					return fixer.insertTextBefore(token, " ");
				}
			});
		}
		function validateBraceSpacing(node, first, second, penultimate, last) {
			if (astUtils.isTokenOnSameLine(first, second)) {
				var firstSpaced = sourceCode.isSpaceBetweenTokens(first, second);

				if (options.spaced && !firstSpaced) {
					reportRequiredBeginningSpace(node, first);
				}
				if (!options.spaced && firstSpaced) {
					reportNoBeginningSpace(node, first);
				}
			}

			if (astUtils.isTokenOnSameLine(penultimate, last)) {
				var shouldCheckPenultimate = options.arraysInObjectsException && astUtils.isClosingBracketToken(penultimate) || options.objectsInObjectsException && astUtils.isClosingBraceToken(penultimate);
				var penultimateType = shouldCheckPenultimate && sourceCode.getNodeByRangeIndex(penultimate.range[0]).type;

				var closingCurlyBraceMustBeSpaced = options.arraysInObjectsException && penultimateType === "ArrayExpression" || options.objectsInObjectsException && (penultimateType === "ObjectExpression" || penultimateType === "ObjectPattern") ? !options.spaced : options.spaced;

				var lastSpaced = sourceCode.isSpaceBetweenTokens(penultimate, last);

				if (closingCurlyBraceMustBeSpaced && !lastSpaced) {
					reportRequiredEndingSpace(node, last);
				}
				if (!closingCurlyBraceMustBeSpaced && lastSpaced) {
					reportNoEndingSpace(node, last);
				}
			}
		}
		function getClosingBraceOfObject(node) {
			var lastProperty = node.properties[node.properties.length - 1];

			return sourceCode.getTokenAfter(lastProperty, astUtils.isClosingBraceToken);
		}
		function checkForObject(node) {
			if (node.properties.length === 0) {
				return;
			}

			var first = sourceCode.getFirstToken(node),
				last = getClosingBraceOfObject(node),
				second = sourceCode.getTokenAfter(first),
				penultimate = sourceCode.getTokenBefore(last);

			validateBraceSpacing(node, first, second, penultimate, last);
		}
		function checkForImport(node) {
			if (node.specifiers.length === 0) {
				return;
			}

			var firstSpecifier = node.specifiers[0];
			var lastSpecifier = node.specifiers[node.specifiers.length - 1];

			if (lastSpecifier.type !== "ImportSpecifier") {
				return;
			}
			if (firstSpecifier.type !== "ImportSpecifier") {
				firstSpecifier = node.specifiers[1];
			}

			var first = sourceCode.getTokenBefore(firstSpecifier),
				last = sourceCode.getTokenAfter(lastSpecifier, astUtils.isNotCommaToken),
				second = sourceCode.getTokenAfter(first),
				penultimate = sourceCode.getTokenBefore(last);

			validateBraceSpacing(node, first, second, penultimate, last);
		}
		function checkForExport(node) {
			if (node.specifiers.length === 0) {
				return;
			}

			var firstSpecifier = node.specifiers[0],
				lastSpecifier = node.specifiers[node.specifiers.length - 1],
				first = sourceCode.getTokenBefore(firstSpecifier),
				last = sourceCode.getTokenAfter(lastSpecifier, astUtils.isNotCommaToken),
				second = sourceCode.getTokenAfter(first),
				penultimate = sourceCode.getTokenBefore(last);

			validateBraceSpacing(node, first, second, penultimate, last);
		}
		return {
			ObjectPattern: checkForObject,
			ObjectExpression: checkForObject,
			ImportDeclaration: checkForImport,
			ExportNamedDeclaration: checkForExport
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "enforce placing object properties on separate lines",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				allowMultiplePropertiesPerLine: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}],

		fixable: "whitespace"
	},

	create: function create(context) {
		var allowSameLine = context.options[0] && Boolean(context.options[0].allowMultiplePropertiesPerLine);
		var errorMessage = allowSameLine ? "Object properties must go on a new line if they aren't all on the same line." : "Object properties must go on a new line.";

		var sourceCode = context.getSourceCode();

		return {
			ObjectExpression: function ObjectExpression(node) {
				if (allowSameLine) {
					if (node.properties.length > 1) {
						var firstTokenOfFirstProperty = sourceCode.getFirstToken(node.properties[0]);
						var lastTokenOfLastProperty = sourceCode.getLastToken(node.properties[node.properties.length - 1]);

						if (firstTokenOfFirstProperty.loc.end.line === lastTokenOfLastProperty.loc.start.line) {
							return;
						}
					}
				}

				var _loop = function _loop(i) {
					var lastTokenOfPreviousProperty = sourceCode.getLastToken(node.properties[i - 1]);
					var firstTokenOfCurrentProperty = sourceCode.getFirstToken(node.properties[i]);

					if (lastTokenOfPreviousProperty.loc.end.line === firstTokenOfCurrentProperty.loc.start.line) {
						context.report({
							node: node,
							loc: firstTokenOfCurrentProperty.loc.start,
							message: errorMessage,
							fix: function fix(fixer) {
								var comma = sourceCode.getTokenBefore(firstTokenOfCurrentProperty);
								var rangeAfterComma = [comma.range[1], firstTokenOfCurrentProperty.range[0]];
								if (sourceCode.text.slice(rangeAfterComma[0], rangeAfterComma[1]).trim()) {
									return null;
								}

								return fixer.replaceTextRange(rangeAfterComma, "\n");
							}
						});
					}
				};

				for (var i = 1; i < node.properties.length; i++) {
					_loop(i);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var OPTIONS = {
	always: "always",
	never: "never",
	methods: "methods",
	properties: "properties",
	consistent: "consistent",
	consistentAsNeeded: "consistent-as-needed"
};
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "require or disallow method and property shorthand syntax for object literals",
			category: "ECMAScript 6",
			recommended: false
		},

		fixable: "code",

		schema: {
			anyOf: [{
				type: "array",
				items: [{
					enum: ["always", "methods", "properties", "never", "consistent", "consistent-as-needed"]
				}],
				minItems: 0,
				maxItems: 1
			}, {
				type: "array",
				items: [{
					enum: ["always", "methods", "properties"]
				}, {
					type: "object",
					properties: {
						avoidQuotes: {
							type: "boolean"
						}
					},
					additionalProperties: false
				}],
				minItems: 0,
				maxItems: 2
			}, {
				type: "array",
				items: [{
					enum: ["always", "methods"]
				}, {
					type: "object",
					properties: {
						ignoreConstructors: {
							type: "boolean"
						},
						avoidQuotes: {
							type: "boolean"
						},
						avoidExplicitReturnArrows: {
							type: "boolean"
						}
					},
					additionalProperties: false
				}],
				minItems: 0,
				maxItems: 2
			}]
		}
	},

	create: function create(context) {
		var APPLY = context.options[0] || OPTIONS.always;
		var APPLY_TO_METHODS = APPLY === OPTIONS.methods || APPLY === OPTIONS.always;
		var APPLY_TO_PROPS = APPLY === OPTIONS.properties || APPLY === OPTIONS.always;
		var APPLY_NEVER = APPLY === OPTIONS.never;
		var APPLY_CONSISTENT = APPLY === OPTIONS.consistent;
		var APPLY_CONSISTENT_AS_NEEDED = APPLY === OPTIONS.consistentAsNeeded;

		var PARAMS = context.options[1] || {};
		var IGNORE_CONSTRUCTORS = PARAMS.ignoreConstructors;
		var AVOID_QUOTES = PARAMS.avoidQuotes;
		var AVOID_EXPLICIT_RETURN_ARROWS = !!PARAMS.avoidExplicitReturnArrows;
		var sourceCode = context.getSourceCode();
		function isConstructor(name) {
			var firstChar = name.charAt(0);

			return firstChar === firstChar.toUpperCase();
		}
		function canHaveShorthand(property) {
			return property.kind !== "set" && property.kind !== "get" && property.type !== "SpreadProperty" && property.type !== "ExperimentalSpreadProperty";
		}
		function isStringLiteral(node) {
			return node.type === "Literal" && typeof node.value === "string";
		}
		function isShorthand(property) {
			return property.shorthand || property.method;
		}
		function isRedundant(property) {
			var value = property.value;

			if (value.type === "FunctionExpression") {
				return !value.id; // Only anonymous should be shorthand method.
			}
			if (value.type === "Identifier") {
				return astUtils.getStaticPropertyName(property) === value.name;
			}

			return false;
		}
		function checkConsistency(node, checkRedundancy) {
			var properties = node.properties.filter(canHaveShorthand);
			if (properties.length > 0) {
				var shorthandProperties = properties.filter(isShorthand);
				if (shorthandProperties.length !== properties.length) {
					if (shorthandProperties.length > 0) {
						context.report({ node: node, message: "Unexpected mix of shorthand and non-shorthand properties." });
					} else if (checkRedundancy) {
						var canAlwaysUseShorthand = properties.every(isRedundant);

						if (canAlwaysUseShorthand) {
							context.report({ node: node, message: "Expected shorthand for all properties." });
						}
					}
				}
			}
		}
		function makeFunctionShorthand(fixer, node) {
			var firstKeyToken = node.computed ? sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken) : sourceCode.getFirstToken(node.key);
			var lastKeyToken = node.computed ? sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken) : sourceCode.getLastToken(node.key);
			var keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);
			var keyPrefix = "";

			if (node.value.generator) {
				keyPrefix = "*";
			} else if (node.value.async) {
				keyPrefix = "async ";
			}

			if (node.value.type === "FunctionExpression") {
				var functionToken = sourceCode.getTokens(node.value).find(function (token) {
					return token.type === "Keyword" && token.value === "function";
				});
				var tokenBeforeParams = node.value.generator ? sourceCode.getTokenAfter(functionToken) : functionToken;

				return fixer.replaceTextRange([firstKeyToken.range[0], node.range[1]], keyPrefix + keyText + sourceCode.text.slice(tokenBeforeParams.range[1], node.value.range[1]));
			}
			var arrowToken = sourceCode.getTokens(node.value).find(function (token) {
				return token.value === "=>";
			});
			var tokenBeforeArrow = sourceCode.getTokenBefore(arrowToken);
			var hasParensAroundParameters = tokenBeforeArrow.type === "Punctuator" && tokenBeforeArrow.value === ")";
			var oldParamText = sourceCode.text.slice(sourceCode.getFirstToken(node.value, node.value.async ? 1 : 0).range[0], tokenBeforeArrow.range[1]);
			var newParamText = hasParensAroundParameters ? oldParamText : "(" + oldParamText + ")";

			return fixer.replaceTextRange([firstKeyToken.range[0], node.range[1]], keyPrefix + keyText + newParamText + sourceCode.text.slice(arrowToken.range[1], node.value.range[1]));
		}
		function makeFunctionLongform(fixer, node) {
			var firstKeyToken = node.computed ? sourceCode.getTokens(node).find(function (token) {
				return token.value === "[";
			}) : sourceCode.getFirstToken(node.key);
			var lastKeyToken = node.computed ? sourceCode.getTokensBetween(node.key, node.value).find(function (token) {
				return token.value === "]";
			}) : sourceCode.getLastToken(node.key);
			var keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);
			var functionHeader = "function";

			if (node.value.generator) {
				functionHeader = "function*";
			} else if (node.value.async) {
				functionHeader = "async function";
			}

			return fixer.replaceTextRange([node.range[0], lastKeyToken.range[1]], keyText + ": " + functionHeader);
		}
		var lexicalScopeStack = [];
		var arrowsWithLexicalIdentifiers = new WeakSet();
		var argumentsIdentifiers = new WeakSet();
		function enterFunction() {
			lexicalScopeStack.unshift(new Set());
			context.getScope().variables.filter(function (variable) {
				return variable.name === "arguments";
			}).forEach(function (variable) {
				variable.references.map(function (ref) {
					return ref.identifier;
				}).forEach(function (identifier) {
					return argumentsIdentifiers.add(identifier);
				});
			});
		}
		function exitFunction() {
			lexicalScopeStack.shift();
		}
		function reportLexicalIdentifier() {
			lexicalScopeStack[0].forEach(function (arrowFunction) {
				return arrowsWithLexicalIdentifiers.add(arrowFunction);
			});
		}
		return {
			Program: enterFunction,
			FunctionDeclaration: enterFunction,
			FunctionExpression: enterFunction,
			"Program:exit": exitFunction,
			"FunctionDeclaration:exit": exitFunction,
			"FunctionExpression:exit": exitFunction,

			ArrowFunctionExpression: function ArrowFunctionExpression(node) {
				lexicalScopeStack[0].add(node);
			},
			"ArrowFunctionExpression:exit": function ArrowFunctionExpressionExit(node) {
				lexicalScopeStack[0].delete(node);
			},


			ThisExpression: reportLexicalIdentifier,
			Super: reportLexicalIdentifier,
			MetaProperty: function MetaProperty(node) {
				if (node.meta.name === "new" && node.property.name === "target") {
					reportLexicalIdentifier();
				}
			},
			Identifier: function Identifier(node) {
				if (argumentsIdentifiers.has(node)) {
					reportLexicalIdentifier();
				}
			},
			ObjectExpression: function ObjectExpression(node) {
				if (APPLY_CONSISTENT) {
					checkConsistency(node, false);
				} else if (APPLY_CONSISTENT_AS_NEEDED) {
					checkConsistency(node, true);
				}
			},
			"Property:exit": function PropertyExit(node) {
				var isConciseProperty = node.method || node.shorthand;
				if (node.parent.type === "ObjectPattern") {
					return;
				}
				if (node.kind === "get" || node.kind === "set") {
					return;
				}
				if (node.computed && node.value.type !== "FunctionExpression" && node.value.type !== "ArrowFunctionExpression") {
					return;
				}
				if (isConciseProperty) {
					if (node.method && (APPLY_NEVER || AVOID_QUOTES && isStringLiteral(node.key))) {
						var message = APPLY_NEVER ? "Expected longform method syntax." : "Expected longform method syntax for string literal keys.";
						context.report({
							node: node,
							message: message,
							fix: function fix(fixer) {
								return makeFunctionLongform(fixer, node);
							}
						});
					} else if (APPLY_NEVER) {
						context.report({
							node: node,
							message: "Expected longform property syntax.",
							fix: function fix(fixer) {
								return fixer.insertTextAfter(node.key, ": " + node.key.name);
							}
						});
					}
				} else if (APPLY_TO_METHODS && !node.value.id && (node.value.type === "FunctionExpression" || node.value.type === "ArrowFunctionExpression")) {
					if (IGNORE_CONSTRUCTORS && node.key.type === "Identifier" && isConstructor(node.key.name)) {
						return;
					}
					if (AVOID_QUOTES && isStringLiteral(node.key)) {
						return;
					}
					if (node.value.type === "FunctionExpression" || node.value.type === "ArrowFunctionExpression" && node.value.body.type === "BlockStatement" && AVOID_EXPLICIT_RETURN_ARROWS && !arrowsWithLexicalIdentifiers.has(node.value)) {
						context.report({
							node: node,
							message: "Expected method shorthand.",
							fix: function fix(fixer) {
								return makeFunctionShorthand(fixer, node);
							}
						});
					}
				} else if (node.value.type === "Identifier" && node.key.name === node.value.name && APPLY_TO_PROPS) {
					context.report({
						node: node,
						message: "Expected property shorthand.",
						fix: function fix(fixer) {
							return fixer.replaceText(node, node.value.name);
						}
					});
				} else if (node.value.type === "Identifier" && node.key.type === "Literal" && node.key.value === node.value.name && APPLY_TO_PROPS) {
					if (AVOID_QUOTES) {
						return;
					}
					context.report({
						node: node,
						message: "Expected property shorthand.",
						fix: function fix(fixer) {
							return fixer.replaceText(node, node.value.name);
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require or disallow newlines around variable declarations",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			enum: ["always", "initializations"]
		}],

		fixable: "whitespace"
	},

	create: function create(context) {

		var ERROR_MESSAGE = "Expected variable declaration to be on a new line.";
		var always = context.options[0] === "always";
		function isForTypeSpecifier(keyword) {
			return keyword === "ForStatement" || keyword === "ForInStatement" || keyword === "ForOfStatement";
		}
		function checkForNewLine(node) {
			if (isForTypeSpecifier(node.parent.type)) {
				return;
			}

			var declarations = node.declarations;
			var prev = void 0;

			declarations.forEach(function (current) {
				if (prev && prev.loc.end.line === current.loc.start.line) {
					if (always || prev.init || current.init) {
						context.report({
							node: node,
							message: ERROR_MESSAGE,
							loc: current.loc.start,
							fix: function fix(fixer) {
								return fixer.insertTextBefore(current, "\n");
							}
						});
					}
				}
				prev = current;
			});
		}
		return {
			VariableDeclaration: checkForNewLine
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = {
	meta: {
		docs: {
			description: "enforce variables to be declared either together or separately in functions",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			oneOf: [{
				enum: ["always", "never"]
			}, {
				type: "object",
				properties: {
					var: {
						enum: ["always", "never"]
					},
					let: {
						enum: ["always", "never"]
					},
					const: {
						enum: ["always", "never"]
					}
				},
				additionalProperties: false
			}, {
				type: "object",
				properties: {
					initialized: {
						enum: ["always", "never"]
					},
					uninitialized: {
						enum: ["always", "never"]
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {

		var MODE_ALWAYS = "always",
			MODE_NEVER = "never";

		var mode = context.options[0] || MODE_ALWAYS;

		var options = {};

		if (typeof mode === "string") {
			options.var = { uninitialized: mode, initialized: mode };
			options.let = { uninitialized: mode, initialized: mode };
			options.const = { uninitialized: mode, initialized: mode };
		} else if ((typeof mode === "undefined" ? "undefined" : _typeof(mode)) === "object") {
			if (mode.hasOwnProperty("var") && typeof mode.var === "string") {
				options.var = { uninitialized: mode.var, initialized: mode.var };
			}
			if (mode.hasOwnProperty("let") && typeof mode.let === "string") {
				options.let = { uninitialized: mode.let, initialized: mode.let };
			}
			if (mode.hasOwnProperty("const") && typeof mode.const === "string") {
				options.const = { uninitialized: mode.const, initialized: mode.const };
			}
			if (mode.hasOwnProperty("uninitialized")) {
				if (!options.var) {
					options.var = {};
				}
				if (!options.let) {
					options.let = {};
				}
				if (!options.const) {
					options.const = {};
				}
				options.var.uninitialized = mode.uninitialized;
				options.let.uninitialized = mode.uninitialized;
				options.const.uninitialized = mode.uninitialized;
			}
			if (mode.hasOwnProperty("initialized")) {
				if (!options.var) {
					options.var = {};
				}
				if (!options.let) {
					options.let = {};
				}
				if (!options.const) {
					options.const = {};
				}
				options.var.initialized = mode.initialized;
				options.let.initialized = mode.initialized;
				options.const.initialized = mode.initialized;
			}
		}
		var functionStack = [];
		var blockStack = [];
		function startBlock() {
			blockStack.push({
				let: { initialized: false, uninitialized: false },
				const: { initialized: false, uninitialized: false }
			});
		}
		function startFunction() {
			functionStack.push({ initialized: false, uninitialized: false });
			startBlock();
		}
		function endBlock() {
			blockStack.pop();
		}
		function endFunction() {
			functionStack.pop();
			endBlock();
		}
		function recordTypes(statementType, declarations, currentScope) {
			for (var i = 0; i < declarations.length; i++) {
				if (declarations[i].init === null) {
					if (options[statementType] && options[statementType].uninitialized === MODE_ALWAYS) {
						currentScope.uninitialized = true;
					}
				} else {
					if (options[statementType] && options[statementType].initialized === MODE_ALWAYS) {
						currentScope.initialized = true;
					}
				}
			}
		}
		function getCurrentScope(statementType) {
			var currentScope = void 0;

			if (statementType === "var") {
				currentScope = functionStack[functionStack.length - 1];
			} else if (statementType === "let") {
				currentScope = blockStack[blockStack.length - 1].let;
			} else if (statementType === "const") {
				currentScope = blockStack[blockStack.length - 1].const;
			}
			return currentScope;
		}
		function countDeclarations(declarations) {
			var counts = { uninitialized: 0, initialized: 0 };

			for (var i = 0; i < declarations.length; i++) {
				if (declarations[i].init === null) {
					counts.uninitialized++;
				} else {
					counts.initialized++;
				}
			}
			return counts;
		}
		function hasOnlyOneStatement(statementType, declarations) {

			var declarationCounts = countDeclarations(declarations);
			var currentOptions = options[statementType] || {};
			var currentScope = getCurrentScope(statementType);

			if (currentOptions.uninitialized === MODE_ALWAYS && currentOptions.initialized === MODE_ALWAYS) {
				if (currentScope.uninitialized || currentScope.initialized) {
					return false;
				}
			}

			if (declarationCounts.uninitialized > 0) {
				if (currentOptions.uninitialized === MODE_ALWAYS && currentScope.uninitialized) {
					return false;
				}
			}
			if (declarationCounts.initialized > 0) {
				if (currentOptions.initialized === MODE_ALWAYS && currentScope.initialized) {
					return false;
				}
			}
			recordTypes(statementType, declarations, currentScope);
			return true;
		}
		return {
			Program: startFunction,
			FunctionDeclaration: startFunction,
			FunctionExpression: startFunction,
			ArrowFunctionExpression: startFunction,
			BlockStatement: startBlock,
			ForStatement: startBlock,
			ForInStatement: startBlock,
			ForOfStatement: startBlock,
			SwitchStatement: startBlock,

			VariableDeclaration: function VariableDeclaration(node) {
				var parent = node.parent;
				var type = node.kind;

				if (!options[type]) {
					return;
				}

				var declarations = node.declarations;
				var declarationCounts = countDeclarations(declarations);
				if (!hasOnlyOneStatement(type, declarations)) {
					if (options[type].initialized === MODE_ALWAYS && options[type].uninitialized === MODE_ALWAYS) {
						context.report({
							node: node,
							message: "Combine this with the previous '{{type}}' statement.",
							data: {
								type: type
							}
						});
					} else {
						if (options[type].initialized === MODE_ALWAYS) {
							context.report({
								node: node,
								message: "Combine this with the previous '{{type}}' statement with initialized variables.",
								data: {
									type: type
								}
							});
						}
						if (options[type].uninitialized === MODE_ALWAYS) {
							if (node.parent.left === node && (node.parent.type === "ForInStatement" || node.parent.type === "ForOfStatement")) {
								return;
							}
							context.report({
								node: node,
								message: "Combine this with the previous '{{type}}' statement with uninitialized variables.",
								data: {
									type: type
								}
							});
						}
					}
				}
				if (parent.type !== "ForStatement" || parent.init !== node) {
					var totalDeclarations = declarationCounts.uninitialized + declarationCounts.initialized;

					if (totalDeclarations > 1) {

						if (options[type].initialized === MODE_NEVER && options[type].uninitialized === MODE_NEVER) {
							context.report({
								node: node,
								message: "Split '{{type}}' declarations into multiple statements.",
								data: {
									type: type
								}
							});
						} else if (options[type].initialized === MODE_NEVER && declarationCounts.initialized > 0) {
							context.report({
								node: node,
								message: "Split initialized '{{type}}' declarations into multiple statements.",
								data: {
									type: type
								}
							});
						} else if (options[type].uninitialized === MODE_NEVER && declarationCounts.uninitialized > 0) {
							context.report({
								node: node,
								message: "Split uninitialized '{{type}}' declarations into multiple statements.",
								data: {
									type: type
								}
							});
						}
					}
				}
			},


			"ForStatement:exit": endBlock,
			"ForOfStatement:exit": endBlock,
			"ForInStatement:exit": endBlock,
			"SwitchStatement:exit": endBlock,
			"BlockStatement:exit": endBlock,
			"Program:exit": endFunction,
			"FunctionDeclaration:exit": endFunction,
			"FunctionExpression:exit": endFunction,
			"ArrowFunctionExpression:exit": endFunction
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
function isCommutativeOperatorWithShorthand(operator) {
	return ["*", "&", "^", "|"].indexOf(operator) >= 0;
}
function isNonCommutativeOperatorWithShorthand(operator) {
	return ["+", "-", "/", "%", "<<", ">>", ">>>", "**"].indexOf(operator) >= 0;
}
function same(a, b) {
	if (a.type !== b.type) {
		return false;
	}

	switch (a.type) {
		case "Identifier":
			return a.name === b.name;

		case "Literal":
			return a.value === b.value;

		case "MemberExpression":
			return same(a.object, b.object) && same(a.property, b.property);

		default:
			return false;
	}
}
function canBeFixed(node) {
	return node.type === "Identifier" || node.type === "MemberExpression" && node.object.type === "Identifier" && (!node.computed || node.property.type === "Literal");
}

module.exports = {
	meta: {
		docs: {
			description: "require or disallow assignment operator shorthand where possible",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			enum: ["always", "never"]
		}],

		fixable: "code"
	},

	create: function create(context) {

		var sourceCode = context.getSourceCode();
		function getOperatorToken(node) {
			return sourceCode.getFirstTokenBetween(node.left, node.right, function (token) {
				return token.value === node.operator;
			});
		}
		function verify(node) {
			if (node.operator !== "=" || node.right.type !== "BinaryExpression") {
				return;
			}

			var left = node.left;
			var expr = node.right;
			var operator = expr.operator;

			if (isCommutativeOperatorWithShorthand(operator) || isNonCommutativeOperatorWithShorthand(operator)) {
				if (same(left, expr.left)) {
					context.report({
						node: node,
						message: "Assignment can be replaced with operator assignment.",
						fix: function fix(fixer) {
							if (canBeFixed(left)) {
								var equalsToken = getOperatorToken(node);
								var operatorToken = getOperatorToken(expr);
								var leftText = sourceCode.getText().slice(node.range[0], equalsToken.range[0]);
								var rightText = sourceCode.getText().slice(operatorToken.range[1], node.right.range[1]);

								return fixer.replaceText(node, "" + leftText + expr.operator + "=" + rightText);
							}
							return null;
						}
					});
				} else if (same(left, expr.right) && isCommutativeOperatorWithShorthand(operator)) {
					context.report({
						node: node,
						message: "Assignment can be replaced with operator assignment."
					});
				}
			}
		}
		function prohibit(node) {
			if (node.operator !== "=") {
				context.report({
					node: node,
					message: "Unexpected operator assignment shorthand.",
					fix: function fix(fixer) {
						if (canBeFixed(node.left)) {
							var operatorToken = getOperatorToken(node);
							var leftText = sourceCode.getText().slice(node.range[0], operatorToken.range[0]);
							var newOperator = node.operator.slice(0, -1);
							var rightText = void 0;
							if (astUtils.getPrecedence(node.right) <= astUtils.getPrecedence({ type: "BinaryExpression", operator: newOperator }) && !astUtils.isParenthesised(sourceCode, node.right)) {
								rightText = sourceCode.text.slice(operatorToken.range[1], node.right.range[0]) + "(" + sourceCode.getText(node.right) + ")";
							} else {
								rightText = sourceCode.text.slice(operatorToken.range[1], node.range[1]);
							}

							return fixer.replaceText(node, leftText + "= " + leftText + newOperator + rightText);
						}
						return null;
					}
				});
			}
		}

		return {
			AssignmentExpression: context.options[0] !== "never" ? verify : prohibit
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent linebreak style for operators",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			enum: ["after", "before", "none", null]
		}, {
			type: "object",
			properties: {
				overrides: {
					type: "object",
					properties: {
						anyOf: {
							type: "string",
							enum: ["after", "before", "none", "ignore"]
						}
					}
				}
			},
			additionalProperties: false
		}],

		fixable: "code"
	},

	create: function create(context) {

		var usedDefaultGlobal = !context.options[0];
		var globalStyle = context.options[0] || "after";
		var options = context.options[1] || {};
		var styleOverrides = options.overrides ? Object.assign({}, options.overrides) : {};

		if (usedDefaultGlobal && !styleOverrides["?"]) {
			styleOverrides["?"] = "before";
		}

		if (usedDefaultGlobal && !styleOverrides[":"]) {
			styleOverrides[":"] = "before";
		}

		var sourceCode = context.getSourceCode();
		function getFixer(operatorToken, desiredStyle) {
			return function (fixer) {
				var tokenBefore = sourceCode.getTokenBefore(operatorToken);
				var tokenAfter = sourceCode.getTokenAfter(operatorToken);
				var textBefore = sourceCode.text.slice(tokenBefore.range[1], operatorToken.range[0]);
				var textAfter = sourceCode.text.slice(operatorToken.range[1], tokenAfter.range[0]);
				var hasLinebreakBefore = !astUtils.isTokenOnSameLine(tokenBefore, operatorToken);
				var hasLinebreakAfter = !astUtils.isTokenOnSameLine(operatorToken, tokenAfter);
				var newTextBefore = void 0,
					newTextAfter = void 0;

				if (hasLinebreakBefore !== hasLinebreakAfter && desiredStyle !== "none") {
					if (sourceCode.getTokenBefore(operatorToken, { includeComments: true }) !== tokenBefore && sourceCode.getTokenAfter(operatorToken, { includeComments: true }) !== tokenAfter) {

						return null;
					}
					newTextBefore = textAfter;
					newTextAfter = textBefore;
				} else {
					var LINEBREAK_REGEX = astUtils.createGlobalLinebreakMatcher();
					newTextBefore = desiredStyle === "before" || textBefore.trim() ? textBefore : textBefore.replace(LINEBREAK_REGEX, "");
					newTextAfter = desiredStyle === "after" || textAfter.trim() ? textAfter : textAfter.replace(LINEBREAK_REGEX, "");
					if (newTextBefore === textBefore && newTextAfter === textAfter) {
						return null;
					}
				}

				if (newTextAfter === "" && tokenAfter.type === "Punctuator" && "+-".includes(operatorToken.value) && tokenAfter.value === operatorToken.value) {
					newTextAfter += " ";
				}

				return fixer.replaceTextRange([tokenBefore.range[1], tokenAfter.range[0]], newTextBefore + operatorToken.value + newTextAfter);
			};
		}
		function validateNode(node, leftSide) {
			var operatorToken = sourceCode.getTokenAfter(leftSide, astUtils.isNotClosingParenToken);
			var leftToken = sourceCode.getTokenBefore(operatorToken);
			var rightToken = sourceCode.getTokenAfter(operatorToken);
			var operator = operatorToken.value;
			var operatorStyleOverride = styleOverrides[operator];
			var style = operatorStyleOverride || globalStyle;
			var fix = getFixer(operatorToken, style);
			if (astUtils.isTokenOnSameLine(leftToken, operatorToken) && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {
			} else if (operatorStyleOverride !== "ignore" && !astUtils.isTokenOnSameLine(leftToken, operatorToken) && !astUtils.isTokenOnSameLine(operatorToken, rightToken)) {
				context.report({
					node: node,
					loc: {
						line: operatorToken.loc.end.line,
						column: operatorToken.loc.end.column
					},
					message: "Bad line breaking before and after '{{operator}}'.",
					data: {
						operator: operator
					},
					fix: fix
				});
			} else if (style === "before" && astUtils.isTokenOnSameLine(leftToken, operatorToken)) {

				context.report({
					node: node,
					loc: {
						line: operatorToken.loc.end.line,
						column: operatorToken.loc.end.column
					},
					message: "'{{operator}}' should be placed at the beginning of the line.",
					data: {
						operator: operator
					},
					fix: fix
				});
			} else if (style === "after" && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {

				context.report({
					node: node,
					loc: {
						line: operatorToken.loc.end.line,
						column: operatorToken.loc.end.column
					},
					message: "'{{operator}}' should be placed at the end of the line.",
					data: {
						operator: operator
					},
					fix: fix
				});
			} else if (style === "none") {

				context.report({
					node: node,
					loc: {
						line: operatorToken.loc.end.line,
						column: operatorToken.loc.end.column
					},
					message: "There should be no line break before or after '{{operator}}'.",
					data: {
						operator: operator
					},
					fix: fix
				});
			}
		}
		function validateBinaryExpression(node) {
			validateNode(node, node.left);
		}
		return {
			BinaryExpression: validateBinaryExpression,
			LogicalExpression: validateBinaryExpression,
			AssignmentExpression: validateBinaryExpression,
			VariableDeclarator: function VariableDeclarator(node) {
				if (node.init) {
					validateNode(node, node.id);
				}
			},
			ConditionalExpression: function ConditionalExpression(node) {
				validateNode(node, node.test);
				validateNode(node, node.consequent);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require or disallow padding within blocks",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			oneOf: [{
				enum: ["always", "never"]
			}, {
				type: "object",
				properties: {
					blocks: {
						enum: ["always", "never"]
					},
					switches: {
						enum: ["always", "never"]
					},
					classes: {
						enum: ["always", "never"]
					}
				},
				additionalProperties: false,
				minProperties: 1
			}]
		}]
	},

	create: function create(context) {
		var options = {};
		var config = context.options[0] || "always";

		if (typeof config === "string") {
			var shouldHavePadding = config === "always";

			options.blocks = shouldHavePadding;
			options.switches = shouldHavePadding;
			options.classes = shouldHavePadding;
		} else {
			if (config.hasOwnProperty("blocks")) {
				options.blocks = config.blocks === "always";
			}
			if (config.hasOwnProperty("switches")) {
				options.switches = config.switches === "always";
			}
			if (config.hasOwnProperty("classes")) {
				options.classes = config.classes === "always";
			}
		}

		var ALWAYS_MESSAGE = "Block must be padded by blank lines.",
			NEVER_MESSAGE = "Block must not be padded by blank lines.";

		var sourceCode = context.getSourceCode();
		function getOpenBrace(node) {
			if (node.type === "SwitchStatement") {
				return sourceCode.getTokenBefore(node.cases[0]);
			}
			return sourceCode.getFirstToken(node);
		}
		function isComment(node) {
			return node.type === "Line" || node.type === "Block";
		}
		function isPaddingBetweenTokens(first, second) {
			return second.loc.start.line - first.loc.end.line >= 2;
		}
		function getFirstBlockToken(token) {
			var prev = void 0,
				first = token;

			do {
				prev = first;
				first = sourceCode.getTokenAfter(first, { includeComments: true });
			} while (isComment(first) && first.loc.start.line === prev.loc.end.line);

			return first;
		}
		function getLastBlockToken(token) {
			var last = token,
				next = void 0;

			do {
				next = last;
				last = sourceCode.getTokenBefore(last, { includeComments: true });
			} while (isComment(last) && last.loc.end.line === next.loc.start.line);

			return last;
		}
		function requirePaddingFor(node) {
			switch (node.type) {
				case "BlockStatement":
					return options.blocks;
				case "SwitchStatement":
					return options.switches;
				case "ClassBody":
					return options.classes;
				default:
					throw new Error("unreachable");
			}
		}
		function checkPadding(node) {
			var openBrace = getOpenBrace(node),
				firstBlockToken = getFirstBlockToken(openBrace),
				tokenBeforeFirst = sourceCode.getTokenBefore(firstBlockToken, { includeComments: true }),
				closeBrace = sourceCode.getLastToken(node),
				lastBlockToken = getLastBlockToken(closeBrace),
				tokenAfterLast = sourceCode.getTokenAfter(lastBlockToken, { includeComments: true }),
				blockHasTopPadding = isPaddingBetweenTokens(tokenBeforeFirst, firstBlockToken),
				blockHasBottomPadding = isPaddingBetweenTokens(lastBlockToken, tokenAfterLast);

			if (requirePaddingFor(node)) {
				if (!blockHasTopPadding) {
					context.report({
						node: node,
						loc: { line: tokenBeforeFirst.loc.start.line, column: tokenBeforeFirst.loc.start.column },
						fix: function fix(fixer) {
							return fixer.insertTextAfter(tokenBeforeFirst, "\n");
						},

						message: ALWAYS_MESSAGE
					});
				}
				if (!blockHasBottomPadding) {
					context.report({
						node: node,
						loc: { line: tokenAfterLast.loc.end.line, column: tokenAfterLast.loc.end.column - 1 },
						fix: function fix(fixer) {
							return fixer.insertTextBefore(tokenAfterLast, "\n");
						},

						message: ALWAYS_MESSAGE
					});
				}
			} else {
				if (blockHasTopPadding) {

					context.report({
						node: node,
						loc: { line: tokenBeforeFirst.loc.start.line, column: tokenBeforeFirst.loc.start.column },
						fix: function fix(fixer) {
							return fixer.replaceTextRange([tokenBeforeFirst.range[1], firstBlockToken.range[0] - firstBlockToken.loc.start.column], "\n");
						},

						message: NEVER_MESSAGE
					});
				}

				if (blockHasBottomPadding) {

					context.report({
						node: node,
						loc: { line: tokenAfterLast.loc.end.line, column: tokenAfterLast.loc.end.column - 1 },
						message: NEVER_MESSAGE,
						fix: function fix(fixer) {
							return fixer.replaceTextRange([lastBlockToken.range[1], tokenAfterLast.range[0] - tokenAfterLast.loc.start.column], "\n");
						}
					});
				}
			}
		}

		var rule = {};

		if (options.hasOwnProperty("switches")) {
			rule.SwitchStatement = function (node) {
				if (node.cases.length === 0) {
					return;
				}
				checkPadding(node);
			};
		}

		if (options.hasOwnProperty("blocks")) {
			rule.BlockStatement = function (node) {
				if (node.body.length === 0) {
					return;
				}
				checkPadding(node);
			};
		}

		if (options.hasOwnProperty("classes")) {
			rule.ClassBody = function (node) {
				if (node.body.length === 0) {
					return;
				}
				checkPadding(node);
			};
		}

		return rule;
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _templateObject = _taggedTemplateLiteral(["^(s*?", ")s*", "(s*;?)$"], ["^(\\s*?", ")\\s*", "(\\s*;?)$"]);

function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var astUtils = __webpack_require__(0);
var LT = "[" + Array.from(astUtils.LINEBREAKS).join("") + "]";
var PADDING_LINE_SEQUENCE = new RegExp(String.raw(_templateObject, LT, LT));
var CJS_EXPORT = /^(?:module\s*\.\s*)?exports(?:\s*\.|\s*\[|$)/;
var CJS_IMPORT = /^require\(/;
function newKeywordTester(keyword) {
	return {
		test: function test(node, sourceCode) {
			return sourceCode.getFirstToken(node).value === keyword;
		}
	};
}
function newNodeTypeTester(type) {
	return {
		test: function test(node) {
			return node.type === type;
		}
	};
}
function isIIFEStatement(node) {
	if (node.type === "ExpressionStatement") {
		var call = node.expression;

		if (call.type === "UnaryExpression") {
			call = call.argument;
		}
		return call.type === "CallExpression" && astUtils.isFunction(call.callee);
	}
	return false;
}
function isBlockLikeStatement(sourceCode, node) {
	if (node.type === "DoWhileStatement" && node.body.type === "BlockStatement") {
		return true;
	}
	if (isIIFEStatement(node)) {
		return true;
	}
	var lastToken = sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);
	var belongingNode = lastToken && astUtils.isClosingBraceToken(lastToken) ? sourceCode.getNodeByRangeIndex(lastToken.range[0]) : null;

	return Boolean(belongingNode) && (belongingNode.type === "BlockStatement" || belongingNode.type === "SwitchStatement");
}
function isDirective(node, sourceCode) {
	return node.type === "ExpressionStatement" && (node.parent.type === "Program" || node.parent.type === "BlockStatement" && astUtils.isFunction(node.parent.parent)) && node.expression.type === "Literal" && typeof node.expression.value === "string" && !astUtils.isParenthesised(sourceCode, node.expression);
}
function isDirectivePrologue(node, sourceCode) {
	if (isDirective(node, sourceCode)) {
		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;

		try {
			for (var _iterator = node.parent.body[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var sibling = _step.value;

				if (sibling === node) {
					break;
				}
				if (!isDirective(sibling, sourceCode)) {
					return false;
				}
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator.return) {
					_iterator.return();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}

		return true;
	}
	return false;
}
function getActualLastToken(sourceCode, node) {
	var semiToken = sourceCode.getLastToken(node);
	var prevToken = sourceCode.getTokenBefore(semiToken);
	var nextToken = sourceCode.getTokenAfter(semiToken);
	var isSemicolonLessStyle = Boolean(prevToken && nextToken && prevToken.range[0] >= node.range[0] && astUtils.isSemicolonToken(semiToken) && semiToken.loc.start.line !== prevToken.loc.end.line && semiToken.loc.end.line === nextToken.loc.start.line);

	return isSemicolonLessStyle ? prevToken : semiToken;
}
function replacerToRemovePaddingLines(_, trailingSpaces, indentSpaces) {
	return trailingSpaces + indentSpaces;
}
function verifyForAny() {}
function verifyForNever(context, _, nextNode, paddingLines) {
	if (paddingLines.length === 0) {
		return;
	}

	context.report({
		node: nextNode,
		message: "Unexpected blank line before this statement.",
		fix: function fix(fixer) {
			if (paddingLines.length >= 2) {
				return null;
			}

			var prevToken = paddingLines[0][0];
			var nextToken = paddingLines[0][1];
			var start = prevToken.range[1];
			var end = nextToken.range[0];
			var text = context.getSourceCode().text.slice(start, end).replace(PADDING_LINE_SEQUENCE, replacerToRemovePaddingLines);

			return fixer.replaceTextRange([start, end], text);
		}
	});
}
function verifyForAlways(context, prevNode, nextNode, paddingLines) {
	if (paddingLines.length > 0) {
		return;
	}

	context.report({
		node: nextNode,
		message: "Expected blank line before this statement.",
		fix: function fix(fixer) {
			var sourceCode = context.getSourceCode();
			var prevToken = getActualLastToken(sourceCode, prevNode);
			var nextToken = sourceCode.getFirstTokenBetween(prevToken, nextNode, {
				includeComments: true,
				filter: function filter(token) {
					if (astUtils.isTokenOnSameLine(prevToken, token)) {
						prevToken = token;
						return false;
					}
					return true;
				}
			}) || nextNode;
			var insertText = astUtils.isTokenOnSameLine(prevToken, nextToken) ? "\n\n" : "\n";

			return fixer.insertTextAfter(prevToken, insertText);
		}
	});
}
var PaddingTypes = {
	any: { verify: verifyForAny },
	never: { verify: verifyForNever },
	always: { verify: verifyForAlways }
};
var StatementTypes = {
	"*": { test: function test() {
			return true;
		} },
	"block-like": {
		test: function test(node, sourceCode) {
			return isBlockLikeStatement(sourceCode, node);
		}
	},
	"cjs-export": {
		test: function test(node, sourceCode) {
			return node.type === "ExpressionStatement" && node.expression.type === "AssignmentExpression" && CJS_EXPORT.test(sourceCode.getText(node.expression.left));
		}
	},
	"cjs-import": {
		test: function test(node, sourceCode) {
			return node.type === "VariableDeclaration" && node.declarations.length > 0 && Boolean(node.declarations[0].init) && CJS_IMPORT.test(sourceCode.getText(node.declarations[0].init));
		}
	},
	directive: {
		test: isDirectivePrologue
	},
	expression: {
		test: function test(node, sourceCode) {
			return node.type === "ExpressionStatement" && !isDirectivePrologue(node, sourceCode);
		}
	},
	"multiline-block-like": {
		test: function test(node, sourceCode) {
			return node.loc.start.line !== node.loc.end.line && isBlockLikeStatement(sourceCode, node);
		}
	},

	block: newNodeTypeTester("BlockStatement"),
	empty: newNodeTypeTester("EmptyStatement"),

	break: newKeywordTester("break"),
	case: newKeywordTester("case"),
	class: newKeywordTester("class"),
	const: newKeywordTester("const"),
	continue: newKeywordTester("continue"),
	debugger: newKeywordTester("debugger"),
	default: newKeywordTester("default"),
	do: newKeywordTester("do"),
	export: newKeywordTester("export"),
	for: newKeywordTester("for"),
	function: newKeywordTester("function"),
	if: newKeywordTester("if"),
	import: newKeywordTester("import"),
	let: newKeywordTester("let"),
	return: newKeywordTester("return"),
	switch: newKeywordTester("switch"),
	throw: newKeywordTester("throw"),
	try: newKeywordTester("try"),
	var: newKeywordTester("var"),
	while: newKeywordTester("while"),
	with: newKeywordTester("with")
};
module.exports = {
	meta: {
		docs: {
			description: "require or disallow padding lines between statements",
			category: "Stylistic Issues",
			recommended: false
		},
		fixable: "whitespace",
		schema: {
			definitions: {
				paddingType: {
					enum: Object.keys(PaddingTypes)
				},
				statementType: {
					anyOf: [{ enum: Object.keys(StatementTypes) }, {
						type: "array",
						items: { enum: Object.keys(StatementTypes) },
						minItems: 1,
						uniqueItems: true,
						additionalItems: false
					}]
				}
			},
			type: "array",
			items: {
				type: "object",
				properties: {
					blankLine: { $ref: "#/definitions/paddingType" },
					prev: { $ref: "#/definitions/statementType" },
					next: { $ref: "#/definitions/statementType" }
				},
				additionalProperties: false,
				required: ["blankLine", "prev", "next"]
			},
			additionalItems: false
		}
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var configureList = context.options || [];
		var scopeInfo = null;
		function enterScope() {
			scopeInfo = {
				upper: scopeInfo,
				prevNode: null
			};
		}
		function exitScope() {
			scopeInfo = scopeInfo.upper;
		}
		function match(node, type) {
			while (node.type === "LabeledStatement") {
				node = node.body;
			}
			if (Array.isArray(type)) {
				return type.some(match.bind(null, node));
			}
			return StatementTypes[type].test(node, sourceCode);
		}
		function getPaddingType(prevNode, nextNode) {
			for (var i = configureList.length - 1; i >= 0; --i) {
				var configure = configureList[i];
				var matched = match(prevNode, configure.prev) && match(nextNode, configure.next);

				if (matched) {
					return PaddingTypes[configure.blankLine];
				}
			}
			return PaddingTypes.any;
		}
		function getPaddingLineSequences(prevNode, nextNode) {
			var pairs = [];
			var prevToken = getActualLastToken(sourceCode, prevNode);

			if (nextNode.loc.start.line - prevToken.loc.end.line >= 2) {
				do {
					var token = sourceCode.getTokenAfter(prevToken, { includeComments: true });

					if (token.loc.start.line - prevToken.loc.end.line >= 2) {
						pairs.push([prevToken, token]);
					}
					prevToken = token;
				} while (prevToken.range[0] < nextNode.range[0]);
			}

			return pairs;
		}
		function verify(node) {
			var parentType = node.parent.type;
			var validParent = astUtils.STATEMENT_LIST_PARENTS.has(parentType) || parentType === "SwitchStatement";

			if (!validParent) {
				return;
			}
			var prevNode = scopeInfo.prevNode;
			if (prevNode) {
				var type = getPaddingType(prevNode, node);
				var paddingLines = getPaddingLineSequences(prevNode, node);

				type.verify(context, prevNode, node, paddingLines);
			}

			scopeInfo.prevNode = node;
		}
		function verifyThenEnterScope(node) {
			verify(node);
			enterScope();
		}

		return {
			Program: enterScope,
			BlockStatement: enterScope,
			SwitchStatement: enterScope,
			"Program:exit": exitScope,
			"BlockStatement:exit": exitScope,
			"SwitchStatement:exit": exitScope,

			":statement": verify,

			SwitchCase: verifyThenEnterScope,
			"SwitchCase:exit": exitScope
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function isFunctionName(variable) {
	return variable && variable.defs[0].type === "FunctionName";
}
function checkMetaProperty(node, metaName, propertyName) {
	return node.meta.name === metaName && node.property.name === propertyName;
}
function getVariableOfArguments(scope) {
	var variables = scope.variables;

	for (var i = 0; i < variables.length; ++i) {
		var variable = variables[i];

		if (variable.name === "arguments") {
			return variable.identifiers.length === 0 ? variable : null;
		}
	}
	return null;
}
function getCallbackInfo(node) {
	var retv = { isCallback: false, isLexicalThis: false };
	var parent = node.parent;

	while (node) {
		switch (parent.type) {
			case "LogicalExpression":
			case "ConditionalExpression":
				break;
			case "MemberExpression":
				if (parent.object === node && !parent.property.computed && parent.property.type === "Identifier" && parent.property.name === "bind" && parent.parent.type === "CallExpression" && parent.parent.callee === parent) {
					retv.isLexicalThis = parent.parent.arguments.length === 1 && parent.parent.arguments[0].type === "ThisExpression";
					parent = parent.parent;
				} else {
					return retv;
				}
				break;
			case "CallExpression":
			case "NewExpression":
				if (parent.callee !== node) {
					retv.isCallback = true;
				}
				return retv;

			default:
				return retv;
		}

		node = parent;
		parent = parent.parent;
	}
	throw new Error("unreachable");
}
function hasDuplicateParams(paramsList) {
	return paramsList.every(function (param) {
		return param.type === "Identifier";
	}) && paramsList.length !== new Set(paramsList.map(function (param) {
		return param.name;
	})).size;
}
module.exports = {
	meta: {
		docs: {
			description: "require using arrow functions for callbacks",
			category: "ECMAScript 6",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				allowNamedFunctions: {
					type: "boolean"
				},
				allowUnboundThis: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}],

		fixable: "code"
	},

	create: function create(context) {
		var options = context.options[0] || {};

		var allowUnboundThis = options.allowUnboundThis !== false; // default to true
		var allowNamedFunctions = options.allowNamedFunctions;
		var sourceCode = context.getSourceCode();
		var stack = [];
		function enterScope() {
			stack.push({ this: false, super: false, meta: false });
		}
		function exitScope() {
			return stack.pop();
		}

		return {
			Program: function Program() {
				stack = [];
			},
			ThisExpression: function ThisExpression() {
				var info = stack[stack.length - 1];

				if (info) {
					info.this = true;
				}
			},
			Super: function Super() {
				var info = stack[stack.length - 1];

				if (info) {
					info.super = true;
				}
			},
			MetaProperty: function MetaProperty(node) {
				var info = stack[stack.length - 1];

				if (info && checkMetaProperty(node, "new", "target")) {
					info.meta = true;
				}
			},
			FunctionDeclaration: enterScope,
			"FunctionDeclaration:exit": exitScope,
			FunctionExpression: enterScope,
			"FunctionExpression:exit": function FunctionExpressionExit(node) {
				var scopeInfo = exitScope();
				if (allowNamedFunctions && node.id && node.id.name) {
					return;
				}
				if (node.generator) {
					return;
				}
				var nameVar = context.getDeclaredVariables(node)[0];

				if (isFunctionName(nameVar) && nameVar.references.length > 0) {
					return;
				}
				var variable = getVariableOfArguments(context.getScope());

				if (variable && variable.references.length > 0) {
					return;
				}
				var callbackInfo = getCallbackInfo(node);

				if (callbackInfo.isCallback && (!allowUnboundThis || !scopeInfo.this || callbackInfo.isLexicalThis) && !scopeInfo.super && !scopeInfo.meta) {
					context.report({
						node: node,
						message: "Unexpected function expression.",
						fix: function fix(fixer) {
							if (!callbackInfo.isLexicalThis && scopeInfo.this || hasDuplicateParams(node.params)) {
								return null;
							}

							var paramsLeftParen = node.params.length ? sourceCode.getTokenBefore(node.params[0]) : sourceCode.getTokenBefore(node.body, 1);
							var paramsRightParen = sourceCode.getTokenBefore(node.body);
							var asyncKeyword = node.async ? "async " : "";
							var paramsFullText = sourceCode.text.slice(paramsLeftParen.range[0], paramsRightParen.range[1]);
							var arrowFunctionText = "" + asyncKeyword + paramsFullText + " => " + sourceCode.getText(node.body);
							var replacedNode = callbackInfo.isLexicalThis ? node.parent.parent : node;
							var needsParens = replacedNode.parent.type !== "CallExpression" && replacedNode.parent.type !== "ConditionalExpression";
							var replacementText = needsParens ? "(" + arrowFunctionText + ")" : arrowFunctionText;

							return fixer.replaceText(replacedNode, replacementText);
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var PATTERN_TYPE = /^(?:.+?Pattern|RestElement|SpreadProperty|ExperimentalRestProperty|Property)$/;
var DECLARATION_HOST_TYPE = /^(?:Program|BlockStatement|SwitchCase)$/;
var DESTRUCTURING_HOST_TYPE = /^(?:VariableDeclarator|AssignmentExpression)$/;
var pushAll = Function.apply.bind(Array.prototype.push);
function isInitOfForStatement(node) {
	return node.parent.type === "ForStatement" && node.parent.init === node;
}
function canBecomeVariableDeclaration(identifier) {
	var node = identifier.parent;

	while (PATTERN_TYPE.test(node.type)) {
		node = node.parent;
	}

	return node.type === "VariableDeclarator" || node.type === "AssignmentExpression" && node.parent.type === "ExpressionStatement" && DECLARATION_HOST_TYPE.test(node.parent.parent.type);
}
function getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign) {
	if (variable.eslintUsed && variable.scope.type === "global") {
		return null;
	}
	var writer = null;
	var isReadBeforeInit = false;
	var references = variable.references;

	for (var i = 0; i < references.length; ++i) {
		var reference = references[i];

		if (reference.isWrite()) {
			var isReassigned = writer !== null && writer.identifier !== reference.identifier;

			if (isReassigned) {
				return null;
			}
			writer = reference;
		} else if (reference.isRead() && writer === null) {
			if (ignoreReadBeforeAssign) {
				return null;
			}
			isReadBeforeInit = true;
		}
	}
	var shouldBeConst = writer !== null && writer.from === variable.scope && canBecomeVariableDeclaration(writer.identifier);

	if (!shouldBeConst) {
		return null;
	}
	if (isReadBeforeInit) {
		return variable.defs[0].name;
	}
	return writer.identifier;
}
function getDestructuringHost(reference) {
	if (!reference.isWrite()) {
		return null;
	}
	var node = reference.identifier.parent;

	while (PATTERN_TYPE.test(node.type)) {
		node = node.parent;
	}

	if (!DESTRUCTURING_HOST_TYPE.test(node.type)) {
		return null;
	}
	return node;
}
function groupByDestructuring(variables, ignoreReadBeforeAssign) {
	var identifierMap = new Map();

	for (var i = 0; i < variables.length; ++i) {
		var variable = variables[i];
		var references = variable.references;
		var identifier = getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign);
		var prevId = null;

		for (var j = 0; j < references.length; ++j) {
			var reference = references[j];
			var id = reference.identifier;
			if (id === prevId) {
				continue;
			}
			prevId = id;
			var group = getDestructuringHost(reference);

			if (group) {
				if (identifierMap.has(group)) {
					identifierMap.get(group).push(identifier);
				} else {
					identifierMap.set(group, [identifier]);
				}
			}
		}
	}

	return identifierMap;
}
function findUp(node, type, shouldStop) {
	if (!node || shouldStop(node)) {
		return null;
	}
	if (node.type === type) {
		return node;
	}
	return findUp(node.parent, type, shouldStop);
}
module.exports = {
	meta: {
		docs: {
			description: "require `const` declarations for variables that are never reassigned after declared",
			category: "ECMAScript 6",
			recommended: false
		},

		fixable: "code",

		schema: [{
			type: "object",
			properties: {
				destructuring: { enum: ["any", "all"] },
				ignoreReadBeforeAssign: { type: "boolean" }
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = context.options[0] || {};
		var sourceCode = context.getSourceCode();
		var checkingMixedDestructuring = options.destructuring !== "all";
		var ignoreReadBeforeAssign = options.ignoreReadBeforeAssign === true;
		var variables = [];
		function checkGroup(nodes) {
			var nodesToReport = nodes.filter(Boolean);

			if (nodes.length && (checkingMixedDestructuring || nodesToReport.length === nodes.length)) {
				var varDeclParent = findUp(nodes[0], "VariableDeclaration", function (parentNode) {
					return parentNode.type.endsWith("Statement");
				});
				var shouldFix = varDeclParent &&
				varDeclParent.declarations.length === 1 && (
				varDeclParent.parent.type === "ForInStatement" || varDeclParent.parent.type === "ForOfStatement" || varDeclParent.declarations[0].init) &&
				nodesToReport.length === nodes.length;

				nodesToReport.forEach(function (node) {
					context.report({
						node: node,
						message: "'{{name}}' is never reassigned. Use 'const' instead.",
						data: node,
						fix: shouldFix ? function (fixer) {
							return fixer.replaceText(sourceCode.getFirstToken(varDeclParent), "const");
						} : null
					});
				});
			}
		}

		return {
			"Program:exit": function ProgramExit() {
				groupByDestructuring(variables, ignoreReadBeforeAssign).forEach(checkGroup);
			},
			VariableDeclaration: function VariableDeclaration(node) {
				if (node.kind === "let" && !isInitOfForStatement(node)) {
					pushAll(variables, context.getDeclaredVariables(node));
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require destructuring from arrays and/or objects",
			category: "ECMAScript 6",
			recommended: false
		},
		schema: [{
			oneOf: [{
				type: "object",
				properties: {
					VariableDeclarator: {
						type: "object",
						properties: {
							array: {
								type: "boolean"
							},
							object: {
								type: "boolean"
							}
						},
						additionalProperties: false
					},
					AssignmentExpression: {
						type: "object",
						properties: {
							array: {
								type: "boolean"
							},
							object: {
								type: "boolean"
							}
						},
						additionalProperties: false
					}
				},
				additionalProperties: false
			}, {
				type: "object",
				properties: {
					array: {
						type: "boolean"
					},
					object: {
						type: "boolean"
					}
				},
				additionalProperties: false
			}]
		}, {
			type: "object",
			properties: {
				enforceForRenamedProperties: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},
	create: function create(context) {

		var enabledTypes = context.options[0];
		var enforceForRenamedProperties = context.options[1] && context.options[1].enforceForRenamedProperties;
		var normalizedOptions = {
			VariableDeclarator: { array: true, object: true },
			AssignmentExpression: { array: true, object: true }
		};

		if (enabledTypes) {
			normalizedOptions = typeof enabledTypes.array !== "undefined" || typeof enabledTypes.object !== "undefined" ? { VariableDeclarator: enabledTypes, AssignmentExpression: enabledTypes } : enabledTypes;
		}
		function shouldCheck(nodeType, destructuringType) {
			return normalizedOptions && normalizedOptions[nodeType] && normalizedOptions[nodeType][destructuringType];
		}
		function isArrayIndexAccess(node) {
			return Number.isInteger(node.property.value);
		}
		function report(reportNode, type) {
			context.report({ node: reportNode, message: "Use {{type}} destructuring.", data: { type: type } });
		}
		function performCheck(leftNode, rightNode, reportNode) {
			if (rightNode.type !== "MemberExpression" || rightNode.object.type === "Super") {
				return;
			}

			if (isArrayIndexAccess(rightNode)) {
				if (shouldCheck(reportNode.type, "array")) {
					report(reportNode, "array");
				}
				return;
			}

			if (shouldCheck(reportNode.type, "object") && enforceForRenamedProperties) {
				report(reportNode, "object");
				return;
			}

			if (shouldCheck(reportNode.type, "object")) {
				var property = rightNode.property;

				if (property.type === "Literal" && leftNode.name === property.value || property.type === "Identifier" && leftNode.name === property.name) {
					report(reportNode, "object");
				}
			}
		}
		function checkVariableDeclarator(node) {
			if (!node.init) {
				return;
			}
			if (node.init.type !== "MemberExpression") {
				return;
			}

			performCheck(node.id, node.init, node);
		}
		function checkAssigmentExpression(node) {
			if (node.operator === "=") {
				performCheck(node.left, node.right, node);
			}
		}
		return {
			VariableDeclarator: checkVariableDeclarator,
			AssignmentExpression: checkAssigmentExpression
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function isParseInt(calleeNode) {
	switch (calleeNode.type) {
		case "Identifier":
			return calleeNode.name === "parseInt";
		case "MemberExpression":
			return calleeNode.object.type === "Identifier" && calleeNode.object.name === "Number" && calleeNode.property.type === "Identifier" && calleeNode.property.name === "parseInt";
	}

	return false;
}
module.exports = {
	meta: {
		docs: {
			description: "disallow `parseInt()` and `Number.parseInt()` in favor of binary, octal, and hexadecimal literals",
			category: "ECMAScript 6",
			recommended: false
		},

		schema: [],

		fixable: "code"
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		var radixMap = {
			2: "binary",
			8: "octal",
			16: "hexadecimal"
		};

		var prefixMap = {
			2: "0b",
			8: "0o",
			16: "0x"
		};
		return {
			CallExpression: function CallExpression(node) {
				if (node.arguments.length !== 2) {
					return;
				}
				var radixName = radixMap[node.arguments[1].value];

				if (isParseInt(node.callee) && radixName && node.arguments[0].type === "Literal") {
					context.report({
						node: node,
						message: "Use {{radixName}} literals instead of {{functionName}}().",
						data: {
							radixName: radixName,
							functionName: sourceCode.getText(node.callee)
						},
						fix: function fix(fixer) {
							var newPrefix = prefixMap[node.arguments[1].value];

							if (+(newPrefix + node.arguments[0].value) !== parseInt(node.arguments[0].value, node.arguments[1].value)) {
								return null;
							}
							return fixer.replaceText(node, prefixMap[node.arguments[1].value] + node.arguments[0].value);
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "require using Error objects as Promise rejection reasons",
			category: "Best Practices",
			recommended: false
		},
		fixable: null,
		schema: [{
			type: "object",
			properties: {
				allowEmptyReject: { type: "boolean" }
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var ALLOW_EMPTY_REJECT = context.options.length && context.options[0].allowEmptyReject;
		function checkRejectCall(callExpression) {
			if (!callExpression.arguments.length && ALLOW_EMPTY_REJECT) {
				return;
			}
			if (!callExpression.arguments.length || !astUtils.couldBeError(callExpression.arguments[0]) || callExpression.arguments[0].type === "Identifier" && callExpression.arguments[0].name === "undefined") {
				context.report({
					node: callExpression,
					message: "Expected the Promise rejection reason to be an Error."
				});
			}
		}
		function isPromiseRejectCall(node) {
			return node.callee.type === "MemberExpression" && node.callee.object.type === "Identifier" && node.callee.object.name === "Promise" && node.callee.property.type === "Identifier" && node.callee.property.name === "reject";
		}
		return {
			CallExpression: function CallExpression(node) {
				if (isPromiseRejectCall(node)) {
					checkRejectCall(node);
				}
			},
			"NewExpression:exit": function NewExpressionExit(node) {
				if (node.callee.type === "Identifier" && node.callee.name === "Promise" && node.arguments.length && astUtils.isFunction(node.arguments[0]) && node.arguments[0].params.length > 1 && node.arguments[0].params[1].type === "Identifier") {
					context.getDeclaredVariables(node.arguments[0])
					.find(function (variable) {
						return variable.name === node.arguments[0].params[1].name;
					})
					.references
					.filter(function (ref) {
						return ref.isRead();
					})
					.filter(function (ref) {
						return ref.identifier.parent.type === "CallExpression" && ref.identifier === ref.identifier.parent.callee;
					})
					.forEach(function (ref) {
						return checkRejectCall(ref.identifier.parent);
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require `Reflect` methods where applicable",
			category: "ECMAScript 6",
			recommended: false,
			replacedBy: []
		},

		deprecated: true,

		schema: [{
			type: "object",
			properties: {
				exceptions: {
					type: "array",
					items: {
						enum: ["apply", "call", "delete", "defineProperty", "getOwnPropertyDescriptor", "getPrototypeOf", "setPrototypeOf", "isExtensible", "getOwnPropertyNames", "preventExtensions"]
					},
					uniqueItems: true
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var existingNames = {
			apply: "Function.prototype.apply",
			call: "Function.prototype.call",
			defineProperty: "Object.defineProperty",
			getOwnPropertyDescriptor: "Object.getOwnPropertyDescriptor",
			getPrototypeOf: "Object.getPrototypeOf",
			setPrototypeOf: "Object.setPrototypeOf",
			isExtensible: "Object.isExtensible",
			getOwnPropertyNames: "Object.getOwnPropertyNames",
			preventExtensions: "Object.preventExtensions"
		};

		var reflectSubsitutes = {
			apply: "Reflect.apply",
			call: "Reflect.apply",
			defineProperty: "Reflect.defineProperty",
			getOwnPropertyDescriptor: "Reflect.getOwnPropertyDescriptor",
			getPrototypeOf: "Reflect.getPrototypeOf",
			setPrototypeOf: "Reflect.setPrototypeOf",
			isExtensible: "Reflect.isExtensible",
			getOwnPropertyNames: "Reflect.getOwnPropertyNames",
			preventExtensions: "Reflect.preventExtensions"
		};

		var exceptions = (context.options[0] || {}).exceptions || [];
		function report(node, existing, substitute) {
			context.report({
				node: node,
				message: "Avoid using {{existing}}, instead use {{substitute}}.",
				data: {
					existing: existing,
					substitute: substitute
				}
			});
		}

		return {
			CallExpression: function CallExpression(node) {
				var methodName = (node.callee.property || {}).name;
				var isReflectCall = (node.callee.object || {}).name === "Reflect";
				var hasReflectSubsitute = reflectSubsitutes.hasOwnProperty(methodName);
				var userConfiguredException = exceptions.indexOf(methodName) !== -1;

				if (hasReflectSubsitute && !isReflectCall && !userConfiguredException) {
					report(node, existingNames[methodName], reflectSubsitutes[methodName]);
				}
			},
			UnaryExpression: function UnaryExpression(node) {
				var isDeleteOperator = node.operator === "delete";
				var targetsIdentifier = node.argument.type === "Identifier";
				var userConfiguredException = exceptions.indexOf("delete") !== -1;

				if (isDeleteOperator && !targetsIdentifier && !userConfiguredException) {
					report(node, "the delete keyword", "Reflect.deleteProperty");
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function getVariableOfArguments(scope) {
	var variables = scope.variables;

	for (var i = 0; i < variables.length; ++i) {
		var variable = variables[i];

		if (variable.name === "arguments") {
			return variable.identifiers.length === 0 ? variable : null;
		}
	}
	return null;
}
function isNotNormalMemberAccess(reference) {
	var id = reference.identifier;
	var parent = id.parent;

	return !(parent.type === "MemberExpression" && parent.object === id && !parent.computed);
}
module.exports = {
	meta: {
		docs: {
			description: "require rest parameters instead of `arguments`",
			category: "ECMAScript 6",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		function report(reference) {
			context.report({
				node: reference.identifier,
				loc: reference.identifier.loc,
				message: "Use the rest parameters instead of 'arguments'."
			});
		}
		function checkForArguments() {
			var argumentsVar = getVariableOfArguments(context.getScope());

			if (argumentsVar) {
				argumentsVar.references.filter(isNotNormalMemberAccess).forEach(report);
			}
		}

		return {
			"FunctionDeclaration:exit": checkForArguments,
			"FunctionExpression:exit": checkForArguments
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var astUtils = __webpack_require__(0);
function isVariadicApplyCalling(node) {
	return node.callee.type === "MemberExpression" && node.callee.property.type === "Identifier" && node.callee.property.name === "apply" && node.callee.computed === false && node.arguments.length === 2 && node.arguments[1].type !== "ArrayExpression" && node.arguments[1].type !== "SpreadElement";
}
function isValidThisArg(expectedThis, thisArg, context) {
	if (!expectedThis) {
		return astUtils.isNullOrUndefined(thisArg);
	}
	return astUtils.equalTokens(expectedThis, thisArg, context);
}
module.exports = {
	meta: {
		docs: {
			description: "require spread operators instead of `.apply()`",
			category: "ECMAScript 6",
			recommended: false
		},

		schema: [],

		fixable: "code"
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		return {
			CallExpression: function CallExpression(node) {
				if (!isVariadicApplyCalling(node)) {
					return;
				}

				var applied = node.callee.object;
				var expectedThis = applied.type === "MemberExpression" ? applied.object : null;
				var thisArg = node.arguments[0];

				if (isValidThisArg(expectedThis, thisArg, sourceCode)) {
					context.report({
						node: node,
						message: "Use the spread operator instead of '.apply()'.",
						fix: function fix(fixer) {
							if (expectedThis && expectedThis.type !== "Identifier") {
								return null;
							}

							var propertyDot = sourceCode.getFirstTokenBetween(applied, node.callee.property, function (token) {
								return token.value === ".";
							});

							return fixer.replaceTextRange([propertyDot.range[0], node.range[1]], "(..." + sourceCode.getText(node.arguments[1]) + ")");
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
function isConcatenation(node) {
	return node.type === "BinaryExpression" && node.operator === "+";
}
function getTopConcatBinaryExpression(node) {
	while (isConcatenation(node.parent)) {
		node = node.parent;
	}
	return node;
}
function hasStringLiteral(node) {
	if (isConcatenation(node)) {
		return hasStringLiteral(node.right) || hasStringLiteral(node.left);
	}
	return astUtils.isStringLiteral(node);
}
function hasNonStringLiteral(node) {
	if (isConcatenation(node)) {
		return hasNonStringLiteral(node.right) || hasNonStringLiteral(node.left);
	}
	return !astUtils.isStringLiteral(node);
}
function startsWithTemplateCurly(node) {
	if (node.type === "BinaryExpression") {
		return startsWithTemplateCurly(node.left);
	}
	if (node.type === "TemplateLiteral") {
		return node.expressions.length && node.quasis.length && node.quasis[0].range[0] === node.quasis[0].range[1];
	}
	return node.type !== "Literal" || typeof node.value !== "string";
}
function endsWithTemplateCurly(node) {
	if (node.type === "BinaryExpression") {
		return startsWithTemplateCurly(node.right);
	}
	if (node.type === "TemplateLiteral") {
		return node.expressions.length && node.quasis.length && node.quasis[node.quasis.length - 1].range[0] === node.quasis[node.quasis.length - 1].range[1];
	}
	return node.type !== "Literal" || typeof node.value !== "string";
}
module.exports = {
	meta: {
		docs: {
			description: "require template literals instead of string concatenation",
			category: "ECMAScript 6",
			recommended: false
		},

		schema: [],

		fixable: "code"
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var done = Object.create(null);
		function getTextBetween(node1, node2) {
			var allTokens = [node1].concat(sourceCode.getTokensBetween(node1, node2)).concat(node2);
			var sourceText = sourceCode.getText();

			return allTokens.slice(0, -1).reduce(function (accumulator, token, index) {
				return accumulator + sourceText.slice(token.range[1], allTokens[index + 1].range[0]);
			}, "");
		}
		function getTemplateLiteral(currentNode, textBeforeNode, textAfterNode) {
			if (currentNode.type === "Literal" && typeof currentNode.value === "string") {
				return "`" + currentNode.raw.slice(1, -1).replace(/\\*(\${|`)/g, function (matched) {
					if (matched.lastIndexOf("\\") % 2) {
						return "\\" + matched;
					}
					return matched;
				}).replace(new RegExp("\\\\" + currentNode.raw[0], "g"), currentNode.raw[0]) + "`";
			}

			if (currentNode.type === "TemplateLiteral") {
				return sourceCode.getText(currentNode);
			}

			if (isConcatenation(currentNode) && hasStringLiteral(currentNode) && hasNonStringLiteral(currentNode)) {
				var plusSign = sourceCode.getFirstTokenBetween(currentNode.left, currentNode.right, function (token) {
					return token.value === "+";
				});
				var textBeforePlus = getTextBetween(currentNode.left, plusSign);
				var textAfterPlus = getTextBetween(plusSign, currentNode.right);
				var leftEndsWithCurly = endsWithTemplateCurly(currentNode.left);
				var rightStartsWithCurly = startsWithTemplateCurly(currentNode.right);

				if (leftEndsWithCurly) {
					return getTemplateLiteral(currentNode.left, textBeforeNode, textBeforePlus + textAfterPlus).slice(0, -1) + getTemplateLiteral(currentNode.right, null, textAfterNode).slice(1);
				}
				if (rightStartsWithCurly) {
					return getTemplateLiteral(currentNode.left, textBeforeNode, null).slice(0, -1) + getTemplateLiteral(currentNode.right, textBeforePlus + textAfterPlus, textAfterNode).slice(1);
				}
				return "" + getTemplateLiteral(currentNode.left, textBeforeNode, null) + textBeforePlus + "+" + textAfterPlus + getTemplateLiteral(currentNode.right, textAfterNode, null);
			}

			return "`${" + (textBeforeNode || "") + sourceCode.getText(currentNode) + (textAfterNode || "") + "}`";
		}
		function checkForStringConcat(node) {
			if (!astUtils.isStringLiteral(node) || !isConcatenation(node.parent)) {
				return;
			}

			var topBinaryExpr = getTopConcatBinaryExpression(node.parent);
			if (done[topBinaryExpr.range[0]]) {
				return;
			}
			done[topBinaryExpr.range[0]] = true;

			if (hasNonStringLiteral(topBinaryExpr)) {
				context.report({
					node: topBinaryExpr,
					message: "Unexpected string concatenation.",
					fix: function fix(fixer) {
						return fixer.replaceText(topBinaryExpr, getTemplateLiteral(topBinaryExpr, null, null));
					}
				});
			}
		}

		return {
			Program: function Program() {
				done = Object.create(null);
			},


			Literal: checkForStringConcat,
			TemplateLiteral: checkForStringConcat
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var espree = __webpack_require__(69),
	keywords = __webpack_require__(107);
module.exports = {
	meta: {
		docs: {
			description: "require quotes around object literal property names",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: {
			anyOf: [{
				type: "array",
				items: [{
					enum: ["always", "as-needed", "consistent", "consistent-as-needed"]
				}],
				minItems: 0,
				maxItems: 1
			}, {
				type: "array",
				items: [{
					enum: ["always", "as-needed", "consistent", "consistent-as-needed"]
				}, {
					type: "object",
					properties: {
						keywords: {
							type: "boolean"
						},
						unnecessary: {
							type: "boolean"
						},
						numbers: {
							type: "boolean"
						}
					},
					additionalProperties: false
				}],
				minItems: 0,
				maxItems: 2
			}]
		},

		fixable: "code"
	},

	create: function create(context) {

		var MODE = context.options[0],
			KEYWORDS = context.options[1] && context.options[1].keywords,
			CHECK_UNNECESSARY = !context.options[1] || context.options[1].unnecessary !== false,
			NUMBERS = context.options[1] && context.options[1].numbers,
			MESSAGE_UNNECESSARY = "Unnecessarily quoted property '{{property}}' found.",
			MESSAGE_UNQUOTED = "Unquoted property '{{property}}' found.",
			MESSAGE_NUMERIC = "Unquoted number literal '{{property}}' used as key.",
			MESSAGE_RESERVED = "Unquoted reserved word '{{property}}' used as key.",
			sourceCode = context.getSourceCode();
		function isKeyword(tokenStr) {
			return keywords.indexOf(tokenStr) >= 0;
		}
		function areQuotesRedundant(rawKey, tokens, skipNumberLiterals) {
			return tokens.length === 1 && tokens[0].start === 0 && tokens[0].end === rawKey.length && (["Identifier", "Keyword", "Null", "Boolean"].indexOf(tokens[0].type) >= 0 || tokens[0].type === "Numeric" && !skipNumberLiterals && String(+tokens[0].value) === tokens[0].value);
		}
		function getUnquotedKey(key) {
			return key.type === "Identifier" ? key.name : key.value;
		}
		function getQuotedKey(key) {
			if (key.type === "Literal" && typeof key.value === "string") {
				return sourceCode.getText(key);
			}
			return "\"" + (key.type === "Identifier" ? key.name : key.value) + "\"";
		}
		function checkUnnecessaryQuotes(node) {
			var key = node.key;

			if (node.method || node.computed || node.shorthand) {
				return;
			}

			if (key.type === "Literal" && typeof key.value === "string") {
				var tokens = void 0;

				try {
					tokens = espree.tokenize(key.value);
				} catch (e) {
					return;
				}

				if (tokens.length !== 1) {
					return;
				}

				var isKeywordToken = isKeyword(tokens[0].value);

				if (isKeywordToken && KEYWORDS) {
					return;
				}

				if (CHECK_UNNECESSARY && areQuotesRedundant(key.value, tokens, NUMBERS)) {
					context.report({
						node: node,
						message: MESSAGE_UNNECESSARY,
						data: { property: key.value },
						fix: function fix(fixer) {
							return fixer.replaceText(key, getUnquotedKey(key));
						}
					});
				}
			} else if (KEYWORDS && key.type === "Identifier" && isKeyword(key.name)) {
				context.report({
					node: node,
					message: MESSAGE_RESERVED,
					data: { property: key.name },
					fix: function fix(fixer) {
						return fixer.replaceText(key, getQuotedKey(key));
					}
				});
			} else if (NUMBERS && key.type === "Literal" && typeof key.value === "number") {
				context.report({
					node: node,
					message: MESSAGE_NUMERIC,
					data: { property: key.value },
					fix: function fix(fixer) {
						return fixer.replaceText(key, getQuotedKey(key));
					}
				});
			}
		}
		function checkOmittedQuotes(node) {
			var key = node.key;

			if (!node.method && !node.computed && !node.shorthand && !(key.type === "Literal" && typeof key.value === "string")) {
				context.report({
					node: node,
					message: MESSAGE_UNQUOTED,
					data: { property: key.name || key.value },
					fix: function fix(fixer) {
						return fixer.replaceText(key, getQuotedKey(key));
					}
				});
			}
		}
		function checkConsistency(node, checkQuotesRedundancy) {
			var quotedProps = [],
				unquotedProps = [];
			var keywordKeyName = null,
				necessaryQuotes = false;

			node.properties.forEach(function (property) {
				var key = property.key;

				if (!key || property.method || property.computed || property.shorthand) {
					return;
				}

				if (key.type === "Literal" && typeof key.value === "string") {

					quotedProps.push(property);

					if (checkQuotesRedundancy) {
						var tokens = void 0;

						try {
							tokens = espree.tokenize(key.value);
						} catch (e) {
							necessaryQuotes = true;
							return;
						}

						necessaryQuotes = necessaryQuotes || !areQuotesRedundant(key.value, tokens) || KEYWORDS && isKeyword(tokens[0].value);
					}
				} else if (KEYWORDS && checkQuotesRedundancy && key.type === "Identifier" && isKeyword(key.name)) {
					unquotedProps.push(property);
					necessaryQuotes = true;
					keywordKeyName = key.name;
				} else {
					unquotedProps.push(property);
				}
			});

			if (checkQuotesRedundancy && quotedProps.length && !necessaryQuotes) {
				quotedProps.forEach(function (property) {
					context.report({
						node: property,
						message: "Properties shouldn't be quoted as all quotes are redundant.",
						fix: function fix(fixer) {
							return fixer.replaceText(property.key, getUnquotedKey(property.key));
						}
					});
				});
			} else if (unquotedProps.length && keywordKeyName) {
				unquotedProps.forEach(function (property) {
					context.report({
						node: property,
						message: "Properties should be quoted as '{{property}}' is a reserved word.",
						data: { property: keywordKeyName },
						fix: function fix(fixer) {
							return fixer.replaceText(property.key, getQuotedKey(property.key));
						}
					});
				});
			} else if (quotedProps.length && unquotedProps.length) {
				unquotedProps.forEach(function (property) {
					context.report({
						node: property,
						message: "Inconsistently quoted property '{{key}}' found.",
						data: { key: property.key.name || property.key.value },
						fix: function fix(fixer) {
							return fixer.replaceText(property.key, getQuotedKey(property.key));
						}
					});
				});
			}
		}

		return {
			Property: function Property(node) {
				if (MODE === "always" || !MODE) {
					checkOmittedQuotes(node);
				}
				if (MODE === "as-needed") {
					checkUnnecessaryQuotes(node);
				}
			},
			ObjectExpression: function ObjectExpression(node) {
				if (MODE === "consistent") {
					checkConsistency(node, false);
				}
				if (MODE === "consistent-as-needed") {
					checkConsistency(node, true);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _templateObject = _taggedTemplateLiteral(["(^|[^\\])(\\\\)*[", "]"], ["(^|[^\\\\])(\\\\\\\\)*[", "]"]);

function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

var astUtils = __webpack_require__(0);
var QUOTE_SETTINGS = {
	double: {
		quote: "\"",
		alternateQuote: "'",
		description: "doublequote"
	},
	single: {
		quote: "'",
		alternateQuote: "\"",
		description: "singlequote"
	},
	backtick: {
		quote: "`",
		alternateQuote: "\"",
		description: "backtick"
	}
};
var UNESCAPED_LINEBREAK_PATTERN = new RegExp(String.raw(_templateObject, Array.from(astUtils.LINEBREAKS).join("")));
QUOTE_SETTINGS.double.convert = QUOTE_SETTINGS.single.convert = QUOTE_SETTINGS.backtick.convert = function (str) {
	var newQuote = this.quote;
	var oldQuote = str[0];

	if (newQuote === oldQuote) {
		return str;
	}
	return newQuote + str.slice(1, -1).replace(/\\(\${|\r\n?|\n|.)|["'`]|\${|(\r\n?|\n)/g, function (match, escaped, newline) {
		if (escaped === oldQuote || oldQuote === "`" && escaped === "${") {
			return escaped; // unescape
		}
		if (match === newQuote || newQuote === "`" && match === "${") {
			return "\\" + match; // escape
		}
		if (newline && oldQuote === "`") {
			return "\\n"; // escape newlines
		}
		return match;
	}) + newQuote;
};

var AVOID_ESCAPE = "avoid-escape";
module.exports = {
	meta: {
		docs: {
			description: "enforce the consistent use of either backticks, double, or single quotes",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "code",

		schema: [{
			enum: ["single", "double", "backtick"]
		}, {
			anyOf: [{
				enum: ["avoid-escape"]
			}, {
				type: "object",
				properties: {
					avoidEscape: {
						type: "boolean"
					},
					allowTemplateLiterals: {
						type: "boolean"
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {

		var quoteOption = context.options[0],
			settings = QUOTE_SETTINGS[quoteOption || "double"],
			options = context.options[1],
			allowTemplateLiterals = options && options.allowTemplateLiterals === true,
			sourceCode = context.getSourceCode();
		var avoidEscape = options && options.avoidEscape === true;
		if (options === AVOID_ESCAPE) {
			avoidEscape = true;
		}
		function isJSXLiteral(node) {
			return node.parent.type === "JSXAttribute" || node.parent.type === "JSXElement";
		}
		function isDirective(node) {
			return node.type === "ExpressionStatement" && node.expression.type === "Literal" && typeof node.expression.value === "string";
		}
		function isPartOfDirectivePrologue(node) {
			var block = node.parent.parent;

			if (block.type !== "Program" && (block.type !== "BlockStatement" || !astUtils.isFunction(block.parent))) {
				return false;
			}
			for (var i = 0; i < block.body.length; ++i) {
				var statement = block.body[i];

				if (statement === node.parent) {
					return true;
				}
				if (!isDirective(statement)) {
					break;
				}
			}

			return false;
		}
		function isAllowedAsNonBacktick(node) {
			var parent = node.parent;

			switch (parent.type) {
				case "ExpressionStatement":
					return isPartOfDirectivePrologue(node);
				case "Property":
				case "MethodDefinition":
					return parent.key === node && !parent.computed;
				case "ImportDeclaration":
				case "ExportNamedDeclaration":
				case "ExportAllDeclaration":
					return parent.source === node;
				default:
					return false;
			}
		}

		return {
			Literal: function Literal(node) {
				var val = node.value,
					rawVal = node.raw;

				if (settings && typeof val === "string") {
					var isValid = quoteOption === "backtick" && isAllowedAsNonBacktick(node) || isJSXLiteral(node) || astUtils.isSurroundedBy(rawVal, settings.quote);

					if (!isValid && avoidEscape) {
						isValid = astUtils.isSurroundedBy(rawVal, settings.alternateQuote) && rawVal.indexOf(settings.quote) >= 0;
					}

					if (!isValid) {
						context.report({
							node: node,
							message: "Strings must use {{description}}.",
							data: {
								description: settings.description
							},
							fix: function fix(fixer) {
								return fixer.replaceText(node, settings.convert(node.raw));
							}
						});
					}
				}
			},
			TemplateLiteral: function TemplateLiteral(node) {
				if (allowTemplateLiterals || quoteOption === "backtick" || node.parent.type === "TaggedTemplateExpression" && node === node.parent.quasi) {
					return;
				}
				var shouldWarn = node.quasis.length === 1 && !UNESCAPED_LINEBREAK_PATTERN.test(node.quasis[0].value.raw);

				if (shouldWarn) {
					context.report({
						node: node,
						message: "Strings must use {{description}}.",
						data: {
							description: settings.description
						},
						fix: function fix(fixer) {
							if (isPartOfDirectivePrologue(node)) {
								return null;
							}
							return fixer.replaceText(node, settings.convert(sourceCode.getText(node)));
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
var MODE_ALWAYS = "always",
	MODE_AS_NEEDED = "as-needed";
function isShadowed(variable) {
	return variable.defs.length >= 1;
}
function isParseIntMethod(node) {
	return node.type === "MemberExpression" && !node.computed && node.property.type === "Identifier" && node.property.name === "parseInt";
}
function isValidRadix(radix) {
	return !(radix.type === "Literal" && typeof radix.value !== "number" || radix.type === "Identifier" && radix.name === "undefined");
}
function isDefaultRadix(radix) {
	return radix.type === "Literal" && radix.value === 10;
}
module.exports = {
	meta: {
		docs: {
			description: "enforce the consistent use of the radix argument when using `parseInt()`",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			enum: ["always", "as-needed"]
		}]
	},

	create: function create(context) {
		var mode = context.options[0] || MODE_ALWAYS;
		function checkArguments(node) {
			var args = node.arguments;

			switch (args.length) {
				case 0:
					context.report({
						node: node,
						message: "Missing parameters."
					});
					break;

				case 1:
					if (mode === MODE_ALWAYS) {
						context.report({
							node: node,
							message: "Missing radix parameter."
						});
					}
					break;

				default:
					if (mode === MODE_AS_NEEDED && isDefaultRadix(args[1])) {
						context.report({
							node: node,
							message: "Redundant radix parameter."
						});
					} else if (!isValidRadix(args[1])) {
						context.report({
							node: node,
							message: "Invalid radix parameter."
						});
					}
					break;
			}
		}

		return {
			"Program:exit": function ProgramExit() {
				var scope = context.getScope();
				var variable = void 0;
				variable = astUtils.getVariableByName(scope, "parseInt");
				if (!isShadowed(variable)) {
					variable.references.forEach(function (reference) {
						var node = reference.identifier;

						if (astUtils.isCallee(node)) {
							checkArguments(node.parent);
						}
					});
				}
				variable = astUtils.getVariableByName(scope, "Number");
				if (!isShadowed(variable)) {
					variable.references.forEach(function (reference) {
						var node = reference.identifier.parent;

						if (isParseIntMethod(node) && astUtils.isCallee(node)) {
							checkArguments(node.parent);
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
function capitalizeFirstLetter(text) {
	return text[0].toUpperCase() + text.slice(1);
}
module.exports = {
	meta: {
		docs: {
			description: "disallow async functions which have no `await` expression",
			category: "Best Practices",
			recommended: false
		},
		schema: []
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var scopeInfo = null;
		function enterFunction() {
			scopeInfo = {
				upper: scopeInfo,
				hasAwait: false
			};
		}
		function exitFunction(node) {
			if (node.async && !scopeInfo.hasAwait && !astUtils.isEmptyFunction(node)) {
				context.report({
					node: node,
					loc: astUtils.getFunctionHeadLoc(node, sourceCode),
					message: "{{name}} has no 'await' expression.",
					data: {
						name: capitalizeFirstLetter(astUtils.getFunctionNameWithKind(node))
					}
				});
			}

			scopeInfo = scopeInfo.upper;
		}

		return {
			FunctionDeclaration: enterFunction,
			FunctionExpression: enterFunction,
			ArrowFunctionExpression: enterFunction,
			"FunctionDeclaration:exit": exitFunction,
			"FunctionExpression:exit": exitFunction,
			"ArrowFunctionExpression:exit": exitFunction,

			AwaitExpression: function AwaitExpression() {
				scopeInfo.hasAwait = true;
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
	meta: {
		docs: {
			description: "require JSDoc comments",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				require: {
					type: "object",
					properties: {
						ClassDeclaration: {
							type: "boolean"
						},
						MethodDefinition: {
							type: "boolean"
						},
						FunctionDeclaration: {
							type: "boolean"
						},
						ArrowFunctionExpression: {
							type: "boolean"
						},
						FunctionExpression: {
							type: "boolean"
						}
					},
					additionalProperties: false
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var source = context.getSourceCode();
		var DEFAULT_OPTIONS = {
			FunctionDeclaration: true,
			MethodDefinition: false,
			ClassDeclaration: false,
			ArrowFunctionExpression: false,
			FunctionExpression: false
		};
		var options = Object.assign(DEFAULT_OPTIONS, context.options[0] && context.options[0].require || {});
		function report(node) {
			context.report({ node: node, message: "Missing JSDoc comment." });
		}
		function checkJsDoc(node) {
			var jsdocComment = source.getJSDocComment(node);

			if (!jsdocComment) {
				report(node);
			}
		}

		return {
			FunctionDeclaration: function FunctionDeclaration(node) {
				if (options.FunctionDeclaration) {
					checkJsDoc(node);
				}
			},
			FunctionExpression: function FunctionExpression(node) {
				if (options.MethodDefinition && node.parent.type === "MethodDefinition" || options.FunctionExpression && (node.parent.type === "VariableDeclarator" || node.parent.type === "Property" && node === node.parent.value)) {
					checkJsDoc(node);
				}
			},
			ClassDeclaration: function ClassDeclaration(node) {
				if (options.ClassDeclaration) {
					checkJsDoc(node);
				}
			},
			ArrowFunctionExpression: function ArrowFunctionExpression(node) {
				if (options.ArrowFunctionExpression && node.parent.type === "VariableDeclarator") {
					checkJsDoc(node);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require generator functions to contain `yield`",
			category: "ECMAScript 6",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {
		var stack = [];
		function beginChecking(node) {
			if (node.generator) {
				stack.push(0);
			}
		}
		function endChecking(node) {
			if (!node.generator) {
				return;
			}

			var countYield = stack.pop();

			if (countYield === 0 && node.body.body.length > 0) {
				context.report({ node: node, message: "This generator function does not have 'yield'." });
			}
		}

		return {
			FunctionDeclaration: beginChecking,
			"FunctionDeclaration:exit": endChecking,
			FunctionExpression: beginChecking,
			"FunctionExpression:exit": endChecking,
			YieldExpression: function YieldExpression() {
				if (stack.length > 0) {
					stack[stack.length - 1] += 1;
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "enforce spacing between rest and spread operators and their expressions",
			category: "ECMAScript 6",
			recommended: false
		},
		fixable: "whitespace",
		schema: [{
			enum: ["always", "never"]
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode(),
			alwaysSpace = context.options[0] === "always";
		function checkWhiteSpace(node) {
			var operator = sourceCode.getFirstToken(node),
				nextToken = sourceCode.getTokenAfter(operator),
				hasWhitespace = sourceCode.isSpaceBetweenTokens(operator, nextToken);
			var type = void 0;

			switch (node.type) {
				case "SpreadElement":
					type = "spread";
					break;
				case "RestElement":
					type = "rest";
					break;
				case "ExperimentalSpreadProperty":
					type = "spread property";
					break;
				case "ExperimentalRestProperty":
					type = "rest property";
					break;
				default:
					return;
			}

			if (alwaysSpace && !hasWhitespace) {
				context.report({
					node: node,
					loc: {
						line: operator.loc.end.line,
						column: operator.loc.end.column
					},
					message: "Expected whitespace after {{type}} operator.",
					data: {
						type: type
					},
					fix: function fix(fixer) {
						return fixer.replaceTextRange([operator.range[1], nextToken.range[0]], " ");
					}
				});
			} else if (!alwaysSpace && hasWhitespace) {
				context.report({
					node: node,
					loc: {
						line: operator.loc.end.line,
						column: operator.loc.end.column
					},
					message: "Unexpected whitespace after {{type}} operator.",
					data: {
						type: type
					},
					fix: function fix(fixer) {
						return fixer.removeRange([operator.range[1], nextToken.range[0]]);
					}
				});
			}
		}
		return {
			SpreadElement: checkWhiteSpace,
			RestElement: checkWhiteSpace,
			ExperimentalSpreadProperty: checkWhiteSpace,
			ExperimentalRestProperty: checkWhiteSpace
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent spacing before and after semicolons",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			type: "object",
			properties: {
				before: {
					type: "boolean"
				},
				after: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var config = context.options[0],
			sourceCode = context.getSourceCode();
		var requireSpaceBefore = false,
			requireSpaceAfter = true;

		if ((typeof config === "undefined" ? "undefined" : _typeof(config)) === "object") {
			if (config.hasOwnProperty("before")) {
				requireSpaceBefore = config.before;
			}
			if (config.hasOwnProperty("after")) {
				requireSpaceAfter = config.after;
			}
		}
		function hasLeadingSpace(token) {
			var tokenBefore = sourceCode.getTokenBefore(token);

			return tokenBefore && astUtils.isTokenOnSameLine(tokenBefore, token) && sourceCode.isSpaceBetweenTokens(tokenBefore, token);
		}
		function hasTrailingSpace(token) {
			var tokenAfter = sourceCode.getTokenAfter(token);

			return tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter) && sourceCode.isSpaceBetweenTokens(token, tokenAfter);
		}
		function isLastTokenInCurrentLine(token) {
			var tokenAfter = sourceCode.getTokenAfter(token);

			return !(tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter));
		}
		function isFirstTokenInCurrentLine(token) {
			var tokenBefore = sourceCode.getTokenBefore(token);

			return !(tokenBefore && astUtils.isTokenOnSameLine(token, tokenBefore));
		}
		function isBeforeClosingParen(token) {
			var nextToken = sourceCode.getTokenAfter(token);

			return nextToken && astUtils.isClosingBraceToken(nextToken) || astUtils.isClosingParenToken(nextToken);
		}
		function checkSemicolonSpacing(token, node) {
			if (astUtils.isSemicolonToken(token)) {
				var location = token.loc.start;

				if (hasLeadingSpace(token)) {
					if (!requireSpaceBefore) {
						context.report({
							node: node,
							loc: location,
							message: "Unexpected whitespace before semicolon.",
							fix: function fix(fixer) {
								var tokenBefore = sourceCode.getTokenBefore(token);

								return fixer.removeRange([tokenBefore.range[1], token.range[0]]);
							}
						});
					}
				} else {
					if (requireSpaceBefore) {
						context.report({
							node: node,
							loc: location,
							message: "Missing whitespace before semicolon.",
							fix: function fix(fixer) {
								return fixer.insertTextBefore(token, " ");
							}
						});
					}
				}

				if (!isFirstTokenInCurrentLine(token) && !isLastTokenInCurrentLine(token) && !isBeforeClosingParen(token)) {
					if (hasTrailingSpace(token)) {
						if (!requireSpaceAfter) {
							context.report({
								node: node,
								loc: location,
								message: "Unexpected whitespace after semicolon.",
								fix: function fix(fixer) {
									var tokenAfter = sourceCode.getTokenAfter(token);

									return fixer.removeRange([token.range[1], tokenAfter.range[0]]);
								}
							});
						}
					} else {
						if (requireSpaceAfter) {
							context.report({
								node: node,
								loc: location,
								message: "Missing whitespace after semicolon.",
								fix: function fix(fixer) {
									return fixer.insertTextAfter(token, " ");
								}
							});
						}
					}
				}
			}
		}
		function checkNode(node) {
			var token = sourceCode.getLastToken(node);

			checkSemicolonSpacing(token, node);
		}

		return {
			VariableDeclaration: checkNode,
			ExpressionStatement: checkNode,
			BreakStatement: checkNode,
			ContinueStatement: checkNode,
			DebuggerStatement: checkNode,
			ReturnStatement: checkNode,
			ThrowStatement: checkNode,
			ImportDeclaration: checkNode,
			ExportNamedDeclaration: checkNode,
			ExportAllDeclaration: checkNode,
			ExportDefaultDeclaration: checkNode,
			ForStatement: function ForStatement(node) {
				if (node.init) {
					checkSemicolonSpacing(sourceCode.getTokenAfter(node.init), node);
				}

				if (node.test) {
					checkSemicolonSpacing(sourceCode.getTokenAfter(node.test), node);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var astUtils = __webpack_require__(0);
var SELECTOR = ":matches(" + ["BreakStatement", "ContinueStatement", "DebuggerStatement", "DoWhileStatement", "ExportAllDeclaration", "ExportDefaultDeclaration", "ExportNamedDeclaration", "ExpressionStatement", "ImportDeclaration", "ReturnStatement", "ThrowStatement", "VariableDeclaration"].join(",") + ")";
function getChildren(node) {
	var t = node.type;

	if (t === "BlockStatement" || t === "Program") {
		return node.body;
	}
	if (t === "SwitchCase") {
		return node.consequent;
	}
	return null;
}
function isLastChild(node) {
	var t = node.parent.type;

	if (t === "IfStatement" && node.parent.consequent === node && node.parent.alternate) {
		return true;
	}
	if (t === "DoWhileStatement") {
		return true;
	}
	var nodeList = getChildren(node.parent);

	return nodeList !== null && nodeList[nodeList.length - 1] === node; // before `}` or etc.
}

module.exports = {
	meta: {
		docs: {
			description: "enforce location of semicolons",
			category: "Stylistic Issues",
			recommended: false
		},
		schema: [{ enum: ["last", "first"] }],
		fixable: "whitespace"
	},

	create: function create(context) {
		var _ref;

		var sourceCode = context.getSourceCode();
		var option = context.options[0] || "last";
		function check(semiToken, expected) {
			var prevToken = sourceCode.getTokenBefore(semiToken);
			var nextToken = sourceCode.getTokenAfter(semiToken);
			var prevIsSameLine = !prevToken || astUtils.isTokenOnSameLine(prevToken, semiToken);
			var nextIsSameLine = !nextToken || astUtils.isTokenOnSameLine(semiToken, nextToken);

			if (expected === "last" && !prevIsSameLine || expected === "first" && !nextIsSameLine) {
				context.report({
					loc: semiToken.loc,
					message: "Expected this semicolon to be at {{pos}}.",
					data: {
						pos: expected === "last" ? "the end of the previous line" : "the beginning of the next line"
					},
					fix: function fix(fixer) {
						if (prevToken && nextToken && sourceCode.commentsExistBetween(prevToken, nextToken)) {
							return null;
						}

						var start = prevToken ? prevToken.range[1] : semiToken.range[0];
						var end = nextToken ? nextToken.range[0] : semiToken.range[1];
						var text = expected === "last" ? ";\n" : "\n;";

						return fixer.replaceTextRange([start, end], text);
					}
				});
			}
		}

		return _ref = {}, _defineProperty(_ref, SELECTOR, function (node) {
			if (option === "first" && isLastChild(node)) {
				return;
			}

			var lastToken = sourceCode.getLastToken(node);

			if (astUtils.isSemicolonToken(lastToken)) {
				check(lastToken, option);
			}
		}), _defineProperty(_ref, "ForStatement", function ForStatement(node) {
			var firstSemi = node.init && sourceCode.getTokenAfter(node.init, astUtils.isSemicolonToken);
			var secondSemi = node.test && sourceCode.getTokenAfter(node.test, astUtils.isSemicolonToken);

			if (firstSemi) {
				check(firstSemi, "last");
			}
			if (secondSemi) {
				check(secondSemi, "last");
			}
		}), _ref;
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var FixTracker = __webpack_require__(70);
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "require or disallow semicolons instead of ASI",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "code",

		schema: {
			anyOf: [{
				type: "array",
				items: [{
					enum: ["never"]
				}, {
					type: "object",
					properties: {
						beforeStatementContinuationChars: {
							enum: ["always", "any", "never"]
						}
					},
					additionalProperties: false
				}],
				minItems: 0,
				maxItems: 2
			}, {
				type: "array",
				items: [{
					enum: ["always"]
				}, {
					type: "object",
					properties: {
						omitLastInOneLineBlock: { type: "boolean" }
					},
					additionalProperties: false
				}],
				minItems: 0,
				maxItems: 2
			}]
		}
	},

	create: function create(context) {

		var OPT_OUT_PATTERN = /^[-[(/+`]/; // One of [(/+-`
		var options = context.options[1];
		var never = context.options[0] === "never";
		var exceptOneLine = Boolean(options && options.omitLastInOneLineBlock);
		var beforeStatementContinuationChars = options && options.beforeStatementContinuationChars || "any";
		var sourceCode = context.getSourceCode();
		function report(node, missing) {
			var lastToken = sourceCode.getLastToken(node);
			var message = void 0,
				fix = void 0,
				loc = lastToken.loc;

			if (!missing) {
				message = "Missing semicolon.";
				loc = loc.end;
				fix = function fix(fixer) {
					return fixer.insertTextAfter(lastToken, ";");
				};
			} else {
				message = "Extra semicolon.";
				loc = loc.start;
				fix = function fix(fixer) {
					return new FixTracker(fixer, sourceCode).retainSurroundingTokens(lastToken).remove(lastToken);
				};
			}

			context.report({
				node: node,
				loc: loc,
				message: message,
				fix: fix
			});
		}
		function isRedundantSemi(semiToken) {
			var nextToken = sourceCode.getTokenAfter(semiToken);

			return !nextToken || astUtils.isClosingBraceToken(nextToken) || astUtils.isSemicolonToken(nextToken);
		}
		function isEndOfArrowBlock(lastToken) {
			if (!astUtils.isClosingBraceToken(lastToken)) {
				return false;
			}
			var node = sourceCode.getNodeByRangeIndex(lastToken.range[0]);

			return node.type === "BlockStatement" && node.parent.type === "ArrowFunctionExpression";
		}
		function isOnSameLineWithNextToken(node) {
			var prevToken = sourceCode.getLastToken(node, 1);
			var nextToken = sourceCode.getTokenAfter(node);

			return !!nextToken && astUtils.isTokenOnSameLine(prevToken, nextToken);
		}
		function maybeAsiHazardAfter(node) {
			var t = node.type;

			if (t === "DoWhileStatement" || t === "BreakStatement" || t === "ContinueStatement" || t === "DebuggerStatement" || t === "ImportDeclaration" || t === "ExportAllDeclaration") {
				return false;
			}
			if (t === "ReturnStatement") {
				return Boolean(node.argument);
			}
			if (t === "ExportNamedDeclaration") {
				return Boolean(node.declaration);
			}
			if (isEndOfArrowBlock(sourceCode.getLastToken(node, 1))) {
				return false;
			}

			return true;
		}
		function maybeAsiHazardBefore(token) {
			return Boolean(token) && OPT_OUT_PATTERN.test(token.value) && token.value !== "++" && token.value !== "--";
		}
		function canRemoveSemicolon(node) {
			if (isRedundantSemi(sourceCode.getLastToken(node))) {
				return true; // `;;` or `;}`
			}
			if (isOnSameLineWithNextToken(node)) {
				return false; // One liner.
			}
			if (beforeStatementContinuationChars === "never" && !maybeAsiHazardAfter(node)) {
				return true; // ASI works. This statement doesn't connect to the next.
			}
			if (!maybeAsiHazardBefore(sourceCode.getTokenAfter(node))) {
				return true; // ASI works. The next token doesn't connect to this statement.
			}

			return false;
		}
		function isOneLinerBlock(node) {
			var parent = node.parent;
			var nextToken = sourceCode.getTokenAfter(node);

			if (!nextToken || nextToken.value !== "}") {
				return false;
			}
			return !!parent && parent.type === "BlockStatement" && parent.loc.start.line === parent.loc.end.line;
		}
		function checkForSemicolon(node) {
			var isSemi = astUtils.isSemicolonToken(sourceCode.getLastToken(node));

			if (never) {
				if (isSemi && canRemoveSemicolon(node)) {
					report(node, true);
				} else if (!isSemi && beforeStatementContinuationChars === "always" && maybeAsiHazardBefore(sourceCode.getTokenAfter(node))) {
					report(node);
				}
			} else {
				var oneLinerBlock = exceptOneLine && isOneLinerBlock(node);

				if (isSemi && oneLinerBlock) {
					report(node, true);
				} else if (!isSemi && !oneLinerBlock) {
					report(node);
				}
			}
		}
		function checkForSemicolonForVariableDeclaration(node) {
			var parent = node.parent;

			if ((parent.type !== "ForStatement" || parent.init !== node) && (!/^For(?:In|Of)Statement/.test(parent.type) || parent.left !== node)) {
				checkForSemicolon(node);
			}
		}
		return {
			VariableDeclaration: checkForSemicolonForVariableDeclaration,
			ExpressionStatement: checkForSemicolon,
			ReturnStatement: checkForSemicolon,
			ThrowStatement: checkForSemicolon,
			DoWhileStatement: checkForSemicolon,
			DebuggerStatement: checkForSemicolon,
			BreakStatement: checkForSemicolon,
			ContinueStatement: checkForSemicolon,
			ImportDeclaration: checkForSemicolon,
			ExportAllDeclaration: checkForSemicolon,
			ExportNamedDeclaration: function ExportNamedDeclaration(node) {
				if (!node.declaration) {
					checkForSemicolon(node);
				}
			},
			ExportDefaultDeclaration: function ExportDefaultDeclaration(node) {
				if (!/(?:Class|Function)Declaration/.test(node.declaration.type)) {
					checkForSemicolon(node);
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "enforce sorted import declarations within modules",
			category: "ECMAScript 6",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				ignoreCase: {
					type: "boolean"
				},
				memberSyntaxSortOrder: {
					type: "array",
					items: {
						enum: ["none", "all", "multiple", "single"]
					},
					uniqueItems: true,
					minItems: 4,
					maxItems: 4
				},
				ignoreMemberSort: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}],

		fixable: "code"
	},

	create: function create(context) {

		var configuration = context.options[0] || {},
			ignoreCase = configuration.ignoreCase || false,
			ignoreMemberSort = configuration.ignoreMemberSort || false,
			memberSyntaxSortOrder = configuration.memberSyntaxSortOrder || ["none", "all", "multiple", "single"],
			sourceCode = context.getSourceCode();
		var previousDeclaration = null;
		function usedMemberSyntax(node) {
			if (node.specifiers.length === 0) {
				return "none";
			}
			if (node.specifiers[0].type === "ImportNamespaceSpecifier") {
				return "all";
			}
			if (node.specifiers.length === 1) {
				return "single";
			}
			return "multiple";
		}
		function getMemberParameterGroupIndex(node) {
			return memberSyntaxSortOrder.indexOf(usedMemberSyntax(node));
		}
		function getFirstLocalMemberName(node) {
			if (node.specifiers[0]) {
				return node.specifiers[0].local.name;
			}
			return null;
		}

		return {
			ImportDeclaration: function ImportDeclaration(node) {
				if (previousDeclaration) {
					var currentMemberSyntaxGroupIndex = getMemberParameterGroupIndex(node),
						previousMemberSyntaxGroupIndex = getMemberParameterGroupIndex(previousDeclaration);
					var currentLocalMemberName = getFirstLocalMemberName(node),
						previousLocalMemberName = getFirstLocalMemberName(previousDeclaration);

					if (ignoreCase) {
						previousLocalMemberName = previousLocalMemberName && previousLocalMemberName.toLowerCase();
						currentLocalMemberName = currentLocalMemberName && currentLocalMemberName.toLowerCase();
					}
					if (currentMemberSyntaxGroupIndex !== previousMemberSyntaxGroupIndex) {
						if (currentMemberSyntaxGroupIndex < previousMemberSyntaxGroupIndex) {
							context.report({
								node: node,
								message: "Expected '{{syntaxA}}' syntax before '{{syntaxB}}' syntax.",
								data: {
									syntaxA: memberSyntaxSortOrder[currentMemberSyntaxGroupIndex],
									syntaxB: memberSyntaxSortOrder[previousMemberSyntaxGroupIndex]
								}
							});
						}
					} else {
						if (previousLocalMemberName && currentLocalMemberName && currentLocalMemberName < previousLocalMemberName) {
							context.report({
								node: node,
								message: "Imports should be sorted alphabetically."
							});
						}
					}
				}

				if (!ignoreMemberSort) {
					var importSpecifiers = node.specifiers.filter(function (specifier) {
						return specifier.type === "ImportSpecifier";
					});
					var getSortableName = ignoreCase ? function (specifier) {
						return specifier.local.name.toLowerCase();
					} : function (specifier) {
						return specifier.local.name;
					};
					var firstUnsortedIndex = importSpecifiers.map(getSortableName).findIndex(function (name, index, array) {
						return array[index - 1] > name;
					});

					if (firstUnsortedIndex !== -1) {
						context.report({
							node: importSpecifiers[firstUnsortedIndex],
							message: "Member '{{memberName}}' of the import declaration should be sorted alphabetically.",
							data: { memberName: importSpecifiers[firstUnsortedIndex].local.name },
							fix: function fix(fixer) {
								if (importSpecifiers.some(function (specifier) {
									return sourceCode.getCommentsBefore(specifier).length || sourceCode.getCommentsAfter(specifier).length;
								})) {
									return null;
								}

								return fixer.replaceTextRange([importSpecifiers[0].range[0], importSpecifiers[importSpecifiers.length - 1].range[1]], importSpecifiers
								.slice()
								.sort(function (specifierA, specifierB) {
									var aName = getSortableName(specifierA);
									var bName = getSortableName(specifierB);

									return aName > bName ? 1 : -1;
								})
								.reduce(function (sourceText, specifier, index) {
									var textAfterSpecifier = index === importSpecifiers.length - 1 ? "" : sourceCode.getText().slice(importSpecifiers[index].range[1], importSpecifiers[index + 1].range[0]);

									return sourceText + sourceCode.getText(specifier) + textAfterSpecifier;
								}, ""));
							}
						});
					}
				}

				previousDeclaration = node;
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0),
	naturalCompare = __webpack_require__(630);
function getPropertyName(node) {
	return astUtils.getStaticPropertyName(node) || node.key.name || null;
}
var isValidOrders = {
	asc: function asc(a, b) {
		return a <= b;
	},
	ascI: function ascI(a, b) {
		return a.toLowerCase() <= b.toLowerCase();
	},
	ascN: function ascN(a, b) {
		return naturalCompare(a, b) <= 0;
	},
	ascIN: function ascIN(a, b) {
		return naturalCompare(a.toLowerCase(), b.toLowerCase()) <= 0;
	},
	desc: function desc(a, b) {
		return isValidOrders.asc(b, a);
	},
	descI: function descI(a, b) {
		return isValidOrders.ascI(b, a);
	},
	descN: function descN(a, b) {
		return isValidOrders.ascN(b, a);
	},
	descIN: function descIN(a, b) {
		return isValidOrders.ascIN(b, a);
	}
};
module.exports = {
	meta: {
		docs: {
			description: "require object keys to be sorted",
			category: "Stylistic Issues",
			recommended: false
		},
		schema: [{
			enum: ["asc", "desc"]
		}, {
			type: "object",
			properties: {
				caseSensitive: {
					type: "boolean"
				},
				natural: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var order = context.options[0] || "asc";
		var options = context.options[1];
		var insensitive = (options && options.caseSensitive) === false;
		var natual = Boolean(options && options.natural);
		var isValidOrder = isValidOrders[order + (insensitive ? "I" : "") + (natual ? "N" : "")];
		var stack = null;

		return {
			ObjectExpression: function ObjectExpression() {
				stack = {
					upper: stack,
					prevName: null
				};
			},
			"ObjectExpression:exit": function ObjectExpressionExit() {
				stack = stack.upper;
			},
			Property: function Property(node) {
				if (node.parent.type === "ObjectPattern") {
					return;
				}

				var prevName = stack.prevName;
				var thisName = getPropertyName(node);

				stack.prevName = thisName || prevName;

				if (!prevName || !thisName) {
					return;
				}

				if (!isValidOrder(prevName, thisName)) {
					context.report({
						node: node,
						loc: node.key.loc,
						message: "Expected object keys to be in {{natual}}{{insensitive}}{{order}}ending order. '{{thisName}}' should be before '{{prevName}}'.",
						data: {
							thisName: thisName,
							prevName: prevName,
							order: order,
							insensitive: insensitive ? "insensitive " : "",
							natual: natual ? "natural " : ""
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var naturalCompare = function naturalCompare(a, b) {
	var i,
	    codeA,
	    codeB = 1,
	    posA = 0,
	    posB = 0,
	    alphabet = String.alphabet;

	function getCode(str, pos, code) {
		if (code) {
			for (i = pos; code = getCode(str, i), code < 76 && code > 65;) {
				++i;
			}return +str.slice(pos - 1, i);
		}
		code = alphabet && alphabet.indexOf(str.charAt(pos));
		return code > -1 ? code + 76 : (code = str.charCodeAt(pos) || 0, code < 45 || code > 127) ? code : code < 46 ? 65 // -
		: code < 48 ? code - 1 : code < 58 ? code + 18 // 0-9
		: code < 65 ? code - 11 : code < 91 ? code + 11 // A-Z
		: code < 97 ? code - 37 : code < 123 ? code + 5 // a-z
		: code - 63;
	}

	if ((a += "") != (b += "")) for (; codeB;) {
		codeA = getCode(a, posA++);
		codeB = getCode(b, posB++);

		if (codeA < 76 && codeB < 76 && codeA > 66 && codeB > 66) {
			codeA = getCode(a, posA, posA);
			codeB = getCode(b, posB, posA = i);
			posB = i;
		}

		if (codeA != codeB) return codeA < codeB ? -1 : 1;
	}
	return 0;
};

try {
	module.exports = naturalCompare;
} catch (e) {
	String.naturalCompare = naturalCompare;
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require variables within the same declaration block to be sorted",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				ignoreCase: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}],

		fixable: "code"
	},

	create: function create(context) {

		var configuration = context.options[0] || {},
			ignoreCase = configuration.ignoreCase || false,
			sourceCode = context.getSourceCode();

		return {
			VariableDeclaration: function VariableDeclaration(node) {
				var idDeclarations = node.declarations.filter(function (decl) {
					return decl.id.type === "Identifier";
				});
				var getSortableName = ignoreCase ? function (decl) {
					return decl.id.name.toLowerCase();
				} : function (decl) {
					return decl.id.name;
				};
				var unfixable = idDeclarations.some(function (decl) {
					return decl.init !== null && decl.init.type !== "Literal";
				});
				var fixed = false;

				idDeclarations.slice(1).reduce(function (memo, decl) {
					var lastVariableName = getSortableName(memo),
						currentVariableName = getSortableName(decl);

					if (currentVariableName < lastVariableName) {
						context.report({
							node: decl,
							message: "Variables within the same declaration block should be sorted alphabetically.",
							fix: function fix(fixer) {
								if (unfixable || fixed) {
									return null;
								}
								return fixer.replaceTextRange([idDeclarations[0].range[0], idDeclarations[idDeclarations.length - 1].range[1]], idDeclarations
								.slice()
								.sort(function (declA, declB) {
									var aName = getSortableName(declA);
									var bName = getSortableName(declB);

									return aName > bName ? 1 : -1;
								})
								.reduce(function (sourceText, identifier, index) {
									var textAfterIdentifier = index === idDeclarations.length - 1 ? "" : sourceCode.getText().slice(idDeclarations[index].range[1], idDeclarations[index + 1].range[0]);

									return sourceText + sourceCode.getText(identifier) + textAfterIdentifier;
								}, ""));
							}
						});
						fixed = true;
						return memo;
					}
					return decl;
				}, idDeclarations[0]);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent spacing before blocks",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			oneOf: [{
				enum: ["always", "never"]
			}, {
				type: "object",
				properties: {
					keywords: {
						enum: ["always", "never"]
					},
					functions: {
						enum: ["always", "never"]
					},
					classes: {
						enum: ["always", "never"]
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {
		var config = context.options[0],
			sourceCode = context.getSourceCode();
		var checkFunctions = true,
			checkKeywords = true,
			checkClasses = true;

		if ((typeof config === "undefined" ? "undefined" : _typeof(config)) === "object") {
			checkFunctions = config.functions !== "never";
			checkKeywords = config.keywords !== "never";
			checkClasses = config.classes !== "never";
		} else if (config === "never") {
			checkFunctions = false;
			checkKeywords = false;
			checkClasses = false;
		}
		function isConflicted(token) {
			return token.type === "Punctuator" && token.value === "=>" || token.type === "Keyword";
		}
		function checkPrecedingSpace(node) {
			var precedingToken = sourceCode.getTokenBefore(node);

			if (precedingToken && !isConflicted(precedingToken) && astUtils.isTokenOnSameLine(precedingToken, node)) {
				var hasSpace = sourceCode.isSpaceBetweenTokens(precedingToken, node);
				var parent = context.getAncestors().pop();
				var requireSpace = void 0;

				if (parent.type === "FunctionExpression" || parent.type === "FunctionDeclaration") {
					requireSpace = checkFunctions;
				} else if (node.type === "ClassBody") {
					requireSpace = checkClasses;
				} else {
					requireSpace = checkKeywords;
				}

				if (requireSpace) {
					if (!hasSpace) {
						context.report({
							node: node,
							message: "Missing space before opening brace.",
							fix: function fix(fixer) {
								return fixer.insertTextBefore(node, " ");
							}
						});
					}
				} else {
					if (hasSpace) {
						context.report({
							node: node,
							message: "Unexpected space before opening brace.",
							fix: function fix(fixer) {
								return fixer.removeRange([precedingToken.range[1], node.range[0]]);
							}
						});
					}
				}
			}
		}
		function checkSpaceBeforeCaseBlock(node) {
			var cases = node.cases;
			var openingBrace = void 0;

			if (cases.length > 0) {
				openingBrace = sourceCode.getTokenBefore(cases[0]);
			} else {
				openingBrace = sourceCode.getLastToken(node, 1);
			}

			checkPrecedingSpace(openingBrace);
		}

		return {
			BlockStatement: checkPrecedingSpace,
			ClassBody: checkPrecedingSpace,
			SwitchStatement: checkSpaceBeforeCaseBlock
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent spacing before `function` definition opening parenthesis",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			oneOf: [{
				enum: ["always", "never"]
			}, {
				type: "object",
				properties: {
					anonymous: {
						enum: ["always", "never", "ignore"]
					},
					named: {
						enum: ["always", "never", "ignore"]
					},
					asyncArrow: {
						enum: ["always", "never", "ignore"]
					}
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var baseConfig = typeof context.options[0] === "string" ? context.options[0] : "always";
		var overrideConfig = _typeof(context.options[0]) === "object" ? context.options[0] : {};
		function isNamedFunction(node) {
			if (node.id) {
				return true;
			}

			var parent = node.parent;

			return parent.type === "MethodDefinition" || parent.type === "Property" && (parent.kind === "get" || parent.kind === "set" || parent.method);
		}
		function getConfigForFunction(node) {
			if (node.type === "ArrowFunctionExpression") {
				if (node.async && astUtils.isOpeningParenToken(sourceCode.getFirstToken(node, { skip: 1 }))) {
					return overrideConfig.asyncArrow || baseConfig;
				}
			} else if (isNamedFunction(node)) {
				return overrideConfig.named || baseConfig;
			} else if (!node.generator) {
				return overrideConfig.anonymous || baseConfig;
			}

			return "ignore";
		}
		function checkFunction(node) {
			var functionConfig = getConfigForFunction(node);

			if (functionConfig === "ignore") {
				return;
			}

			var rightToken = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);
			var leftToken = sourceCode.getTokenBefore(rightToken);
			var hasSpacing = sourceCode.isSpaceBetweenTokens(leftToken, rightToken);

			if (hasSpacing && functionConfig === "never") {
				context.report({
					node: node,
					loc: leftToken.loc.end,
					message: "Unexpected space before function parentheses.",
					fix: function fix(fixer) {
						return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
					}
				});
			} else if (!hasSpacing && functionConfig === "always") {
				context.report({
					node: node,
					loc: leftToken.loc.end,
					message: "Missing space before function parentheses.",
					fix: function fix(fixer) {
						return fixer.insertTextAfter(leftToken, " ");
					}
				});
			}
		}

		return {
			ArrowFunctionExpression: checkFunction,
			FunctionDeclaration: checkFunction,
			FunctionExpression: checkFunction
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent spacing inside parentheses",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			enum: ["always", "never"]
		}, {
			type: "object",
			properties: {
				exceptions: {
					type: "array",
					items: {
						enum: ["{}", "[]", "()", "empty"]
					},
					uniqueItems: true
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var MISSING_SPACE_MESSAGE = "There must be a space inside this paren.",
			REJECTED_SPACE_MESSAGE = "There should be no spaces inside this paren.",
			ALWAYS = context.options[0] === "always",
			exceptionsArrayOptions = context.options[1] && context.options[1].exceptions || [],
			options = {};
		var exceptions = void 0;

		if (exceptionsArrayOptions.length) {
			options.braceException = exceptionsArrayOptions.indexOf("{}") !== -1;
			options.bracketException = exceptionsArrayOptions.indexOf("[]") !== -1;
			options.parenException = exceptionsArrayOptions.indexOf("()") !== -1;
			options.empty = exceptionsArrayOptions.indexOf("empty") !== -1;
		}
		function getExceptions() {
			var openers = [],
				closers = [];

			if (options.braceException) {
				openers.push("{");
				closers.push("}");
			}

			if (options.bracketException) {
				openers.push("[");
				closers.push("]");
			}

			if (options.parenException) {
				openers.push("(");
				closers.push(")");
			}

			if (options.empty) {
				openers.push(")");
				closers.push("(");
			}

			return {
				openers: openers,
				closers: closers
			};
		}
		var sourceCode = context.getSourceCode();
		function isOpenerException(token) {
			return token.type === "Punctuator" && exceptions.openers.indexOf(token.value) >= 0;
		}
		function isCloserException(token) {
			return token.type === "Punctuator" && exceptions.closers.indexOf(token.value) >= 0;
		}
		function shouldOpenerHaveSpace(left, right) {
			if (sourceCode.isSpaceBetweenTokens(left, right)) {
				return false;
			}

			if (ALWAYS) {
				if (astUtils.isClosingParenToken(right)) {
					return false;
				}
				return !isOpenerException(right);
			}
			return isOpenerException(right);
		}
		function shouldCloserHaveSpace(left, right) {
			if (astUtils.isOpeningParenToken(left)) {
				return false;
			}

			if (sourceCode.isSpaceBetweenTokens(left, right)) {
				return false;
			}

			if (ALWAYS) {
				return !isCloserException(left);
			}
			return isCloserException(left);
		}
		function shouldOpenerRejectSpace(left, right) {
			if (right.type === "Line") {
				return false;
			}

			if (!astUtils.isTokenOnSameLine(left, right)) {
				return false;
			}

			if (!sourceCode.isSpaceBetweenTokens(left, right)) {
				return false;
			}

			if (ALWAYS) {
				return isOpenerException(right);
			}
			return !isOpenerException(right);
		}
		function shouldCloserRejectSpace(left, right) {
			if (astUtils.isOpeningParenToken(left)) {
				return false;
			}

			if (!astUtils.isTokenOnSameLine(left, right)) {
				return false;
			}

			if (!sourceCode.isSpaceBetweenTokens(left, right)) {
				return false;
			}

			if (ALWAYS) {
				return isCloserException(left);
			}
			return !isCloserException(left);
		}
		return {
			Program: function checkParenSpaces(node) {
				exceptions = getExceptions();
				var tokens = sourceCode.tokensAndComments;

				tokens.forEach(function (token, i) {
					var prevToken = tokens[i - 1];
					var nextToken = tokens[i + 1];

					if (!astUtils.isOpeningParenToken(token) && !astUtils.isClosingParenToken(token)) {
						return;
					}

					if (token.value === "(" && shouldOpenerHaveSpace(token, nextToken)) {
						context.report({
							node: node,
							loc: token.loc.start,
							message: MISSING_SPACE_MESSAGE,
							fix: function fix(fixer) {
								return fixer.insertTextAfter(token, " ");
							}
						});
					} else if (token.value === "(" && shouldOpenerRejectSpace(token, nextToken)) {
						context.report({
							node: node,
							loc: token.loc.start,
							message: REJECTED_SPACE_MESSAGE,
							fix: function fix(fixer) {
								return fixer.removeRange([token.range[1], nextToken.range[0]]);
							}
						});
					} else if (token.value === ")" && shouldCloserHaveSpace(prevToken, token)) {
						context.report({
							node: node,
							loc: token.loc.start,
							message: MISSING_SPACE_MESSAGE,
							fix: function fix(fixer) {
								return fixer.insertTextBefore(token, " ");
							}
						});
					} else if (token.value === ")" && shouldCloserRejectSpace(prevToken, token)) {
						context.report({
							node: node,
							loc: token.loc.start,
							message: REJECTED_SPACE_MESSAGE,
							fix: function fix(fixer) {
								return fixer.removeRange([prevToken.range[1], token.range[0]]);
							}
						});
					}
				});
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require spacing around infix operators",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			type: "object",
			properties: {
				int32Hint: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var int32Hint = context.options[0] ? context.options[0].int32Hint === true : false;

		var OPERATORS = ["*", "/", "%", "+", "-", "<<", ">>", ">>>", "<", "<=", ">", ">=", "in", "instanceof", "==", "!=", "===", "!==", "&", "^", "|", "&&", "||", "=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "&=", "^=", "|=", "?", ":", ",", "**"];

		var sourceCode = context.getSourceCode();
		function getFirstNonSpacedToken(left, right) {
			var tokens = sourceCode.getTokensBetween(left, right, 1);

			for (var i = 1, l = tokens.length - 1; i < l; ++i) {
				var op = tokens[i];

				if ((op.type === "Punctuator" || op.type === "Keyword") && OPERATORS.indexOf(op.value) >= 0 && (tokens[i - 1].range[1] >= op.range[0] || op.range[1] >= tokens[i + 1].range[0])) {
					return op;
				}
			}
			return null;
		}
		function report(mainNode, culpritToken) {
			context.report({
				node: mainNode,
				loc: culpritToken.loc.start,
				message: "Infix operators must be spaced.",
				fix: function fix(fixer) {
					var previousToken = sourceCode.getTokenBefore(culpritToken);
					var afterToken = sourceCode.getTokenAfter(culpritToken);
					var fixString = "";

					if (culpritToken.range[0] - previousToken.range[1] === 0) {
						fixString = " ";
					}

					fixString += culpritToken.value;

					if (afterToken.range[0] - culpritToken.range[1] === 0) {
						fixString += " ";
					}

					return fixer.replaceText(culpritToken, fixString);
				}
			});
		}
		function checkBinary(node) {
			var leftNode = node.left.typeAnnotation ? node.left.typeAnnotation : node.left;
			var rightNode = node.right;

			var nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode);

			if (nonSpacedNode) {
				if (!(int32Hint && sourceCode.getText(node).endsWith("|0"))) {
					report(node, nonSpacedNode);
				}
			}
		}
		function checkConditional(node) {
			var nonSpacedConsequesntNode = getFirstNonSpacedToken(node.test, node.consequent);
			var nonSpacedAlternateNode = getFirstNonSpacedToken(node.consequent, node.alternate);

			if (nonSpacedConsequesntNode) {
				report(node, nonSpacedConsequesntNode);
			} else if (nonSpacedAlternateNode) {
				report(node, nonSpacedAlternateNode);
			}
		}
		function checkVar(node) {
			var leftNode = node.id.typeAnnotation ? node.id.typeAnnotation : node.id;
			var rightNode = node.init;

			if (rightNode) {
				var nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode);

				if (nonSpacedNode) {
					report(node, nonSpacedNode);
				}
			}
		}

		return {
			AssignmentExpression: checkBinary,
			AssignmentPattern: checkBinary,
			BinaryExpression: checkBinary,
			LogicalExpression: checkBinary,
			ConditionalExpression: checkConditional,
			VariableDeclarator: checkVar
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent spacing before or after unary operators",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			type: "object",
			properties: {
				words: {
					type: "boolean"
				},
				nonwords: {
					type: "boolean"
				},
				overrides: {
					type: "object",
					additionalProperties: {
						type: "boolean"
					}
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {
		var options = context.options && Array.isArray(context.options) && context.options[0] || { words: true, nonwords: false };

		var sourceCode = context.getSourceCode();
		function isFirstBangInBangBangExpression(node) {
			return node && node.type === "UnaryExpression" && node.argument.operator === "!" && node.argument && node.argument.type === "UnaryExpression" && node.argument.operator === "!";
		}
		function isArgumentObjectExpression(node) {
			return node.argument && node.argument.type && node.argument.type === "ObjectExpression";
		}
		function overrideExistsForOperator(operator) {
			return options.overrides && options.overrides.hasOwnProperty(operator);
		}
		function overrideEnforcesSpaces(operator) {
			return options.overrides[operator];
		}
		function verifyWordHasSpaces(node, firstToken, secondToken, word) {
			if (secondToken.range[0] === firstToken.range[1]) {
				context.report({
					node: node,
					message: "Unary word operator '{{word}}' must be followed by whitespace.",
					data: {
						word: word
					},
					fix: function fix(fixer) {
						return fixer.insertTextAfter(firstToken, " ");
					}
				});
			}
		}
		function verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word) {
			if (isArgumentObjectExpression(node)) {
				if (secondToken.range[0] > firstToken.range[1]) {
					context.report({
						node: node,
						message: "Unexpected space after unary word operator '{{word}}'.",
						data: {
							word: word
						},
						fix: function fix(fixer) {
							return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
						}
					});
				}
			}
		}
		function checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, word) {
			word = word || firstToken.value;

			if (overrideExistsForOperator(word)) {
				if (overrideEnforcesSpaces(word)) {
					verifyWordHasSpaces(node, firstToken, secondToken, word);
				} else {
					verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);
				}
			} else if (options.words) {
				verifyWordHasSpaces(node, firstToken, secondToken, word);
			} else {
				verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);
			}
		}
		function checkForSpacesAfterYield(node) {
			var tokens = sourceCode.getFirstTokens(node, 3),
				word = "yield";

			if (!node.argument || node.delegate) {
				return;
			}

			checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], word);
		}
		function checkForSpacesAfterAwait(node) {
			var tokens = sourceCode.getFirstTokens(node, 3);

			checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], "await");
		}
		function verifyNonWordsHaveSpaces(node, firstToken, secondToken) {
			if (node.prefix) {
				if (isFirstBangInBangBangExpression(node)) {
					return;
				}
				if (firstToken.range[1] === secondToken.range[0]) {
					context.report({
						node: node,
						message: "Unary operator '{{operator}}' must be followed by whitespace.",
						data: {
							operator: firstToken.value
						},
						fix: function fix(fixer) {
							return fixer.insertTextAfter(firstToken, " ");
						}
					});
				}
			} else {
				if (firstToken.range[1] === secondToken.range[0]) {
					context.report({
						node: node,
						message: "Space is required before unary expressions '{{token}}'.",
						data: {
							token: secondToken.value
						},
						fix: function fix(fixer) {
							return fixer.insertTextBefore(secondToken, " ");
						}
					});
				}
			}
		}
		function verifyNonWordsDontHaveSpaces(node, firstToken, secondToken) {
			if (node.prefix) {
				if (secondToken.range[0] > firstToken.range[1]) {
					context.report({
						node: node,
						message: "Unexpected space after unary operator '{{operator}}'.",
						data: {
							operator: firstToken.value
						},
						fix: function fix(fixer) {
							if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {
								return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
							}
							return null;
						}
					});
				}
			} else {
				if (secondToken.range[0] > firstToken.range[1]) {
					context.report({
						node: node,
						message: "Unexpected space before unary operator '{{operator}}'.",
						data: {
							operator: secondToken.value
						},
						fix: function fix(fixer) {
							return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
						}
					});
				}
			}
		}
		function checkForSpaces(node) {
			var tokens = node.type === "UpdateExpression" && !node.prefix ? sourceCode.getLastTokens(node, 2) : sourceCode.getFirstTokens(node, 2);
			var firstToken = tokens[0];
			var secondToken = tokens[1];

			if ((node.type === "NewExpression" || node.prefix) && firstToken.type === "Keyword") {
				checkUnaryWordOperatorForSpaces(node, firstToken, secondToken);
				return;
			}

			var operator = node.prefix ? tokens[0].value : tokens[1].value;

			if (overrideExistsForOperator(operator)) {
				if (overrideEnforcesSpaces(operator)) {
					verifyNonWordsHaveSpaces(node, firstToken, secondToken);
				} else {
					verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);
				}
			} else if (options.nonwords) {
				verifyNonWordsHaveSpaces(node, firstToken, secondToken);
			} else {
				verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);
			}
		}
		return {
			UnaryExpression: checkForSpaces,
			UpdateExpression: checkForSpaces,
			NewExpression: checkForSpaces,
			YieldExpression: checkForSpacesAfterYield,
			AwaitExpression: checkForSpacesAfterAwait
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var lodash = __webpack_require__(10);
var astUtils = __webpack_require__(0);
function escape(s) {
	var isOneChar = s.length === 1;

	s = lodash.escapeRegExp(s);
	return isOneChar ? s : "(?:" + s + ")";
}
function escapeAndRepeat(s) {
	return escape(s) + "+";
}
function parseMarkersOption(markers) {
	markers = markers ? markers.slice(0) : [];
	if (markers.indexOf("*") === -1) {
		markers.push("*");
	}

	return markers;
}
function createExceptionsPattern(exceptions) {
	var pattern = "";
	if (exceptions.length === 0) {
		pattern += "\\s";
	} else {
		pattern += "(?:\\s|";

		if (exceptions.length === 1) {
			pattern += escapeAndRepeat(exceptions[0]);
		} else {
			pattern += "(?:";
			pattern += exceptions.map(escapeAndRepeat).join("|");
			pattern += ")";
		}
		pattern += "(?:$|[" + Array.from(astUtils.LINEBREAKS).join("") + "]))";
	}

	return pattern;
}
function createAlwaysStylePattern(markers, exceptions) {
	var pattern = "^";
	if (markers.length === 1) {
		pattern += escape(markers[0]);
	} else {
		pattern += "(?:";
		pattern += markers.map(escape).join("|");
		pattern += ")";
	}

	pattern += "?"; // or nothing.
	pattern += createExceptionsPattern(exceptions);

	return new RegExp(pattern);
}
function createNeverStylePattern(markers) {
	var pattern = "^(" + markers.map(escape).join("|") + ")?[ \t]+";

	return new RegExp(pattern);
}
module.exports = {
	meta: {
		docs: {
			description: "enforce consistent spacing after the `//` or `/*` in a comment",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			enum: ["always", "never"]
		}, {
			type: "object",
			properties: {
				exceptions: {
					type: "array",
					items: {
						type: "string"
					}
				},
				markers: {
					type: "array",
					items: {
						type: "string"
					}
				},
				line: {
					type: "object",
					properties: {
						exceptions: {
							type: "array",
							items: {
								type: "string"
							}
						},
						markers: {
							type: "array",
							items: {
								type: "string"
							}
						}
					},
					additionalProperties: false
				},
				block: {
					type: "object",
					properties: {
						exceptions: {
							type: "array",
							items: {
								type: "string"
							}
						},
						markers: {
							type: "array",
							items: {
								type: "string"
							}
						},
						balanced: {
							type: "boolean"
						}
					},
					additionalProperties: false
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var sourceCode = context.getSourceCode();
		var requireSpace = context.options[0] !== "never";
		var config = context.options[1] || {};
		var balanced = config.block && config.block.balanced;

		var styleRules = ["block", "line"].reduce(function (rule, type) {
			var markers = parseMarkersOption(config[type] && config[type].markers || config.markers);
			var exceptions = config[type] && config[type].exceptions || config.exceptions || [];
			var endNeverPattern = "[ \t]+$";
			rule[type] = {
				beginRegex: requireSpace ? createAlwaysStylePattern(markers, exceptions) : createNeverStylePattern(markers),
				endRegex: balanced && requireSpace ? new RegExp(createExceptionsPattern(exceptions) + "$") : new RegExp(endNeverPattern),
				hasExceptions: exceptions.length > 0,
				markers: new RegExp("^(" + markers.map(escape).join("|") + ")")
			};

			return rule;
		}, {});
		function reportBegin(node, message, match, refChar) {
			var type = node.type.toLowerCase(),
				commentIdentifier = type === "block" ? "/*" : "//";

			context.report({
				node: node,
				fix: function fix(fixer) {
					var start = node.range[0];
					var end = start + 2;

					if (requireSpace) {
						if (match) {
							end += match[0].length;
						}
						return fixer.insertTextAfterRange([start, end], " ");
					}
					end += match[0].length;
					return fixer.replaceTextRange([start, end], commentIdentifier + (match[1] ? match[1] : ""));
				},

				message: message,
				data: { refChar: refChar }
			});
		}
		function reportEnd(node, message, match) {
			context.report({
				node: node,
				fix: function fix(fixer) {
					if (requireSpace) {
						return fixer.insertTextAfterRange([node.range[0], node.range[1] - 2], " ");
					}
					var end = node.range[1] - 2,
						start = end - match[0].length;

					return fixer.replaceTextRange([start, end], "");
				},

				message: message
			});
		}
		function checkCommentForSpace(node) {
			var type = node.type.toLowerCase(),
				rule = styleRules[type],
				commentIdentifier = type === "block" ? "/*" : "//";
			if (node.value.length === 0) {
				return;
			}

			var beginMatch = rule.beginRegex.exec(node.value);
			var endMatch = rule.endRegex.exec(node.value);
			if (requireSpace) {
				if (!beginMatch) {
					var hasMarker = rule.markers.exec(node.value);
					var marker = hasMarker ? commentIdentifier + hasMarker[0] : commentIdentifier;

					if (rule.hasExceptions) {
						reportBegin(node, "Expected exception block, space or tab after '{{refChar}}' in comment.", hasMarker, marker);
					} else {
						reportBegin(node, "Expected space or tab after '{{refChar}}' in comment.", hasMarker, marker);
					}
				}

				if (balanced && type === "block" && !endMatch) {
					reportEnd(node, "Expected space or tab before '*/' in comment.");
				}
			} else {
				if (beginMatch) {
					if (!beginMatch[1]) {
						reportBegin(node, "Unexpected space or tab after '{{refChar}}' in comment.", beginMatch, commentIdentifier);
					} else {
						reportBegin(node, "Unexpected space or tab after marker ({{refChar}}) in comment.", beginMatch, beginMatch[1]);
					}
				}

				if (balanced && type === "block" && endMatch) {
					reportEnd(node, "Unexpected space or tab before '*/' in comment.", endMatch);
				}
			}
		}

		return {
			Program: function Program() {
				var comments = sourceCode.getAllComments();

				comments.filter(function (token) {
					return token.type !== "Shebang";
				}).forEach(checkCommentForSpace);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
var messages = {
	function: "Use the function form of 'use strict'.",
	global: "Use the global form of 'use strict'.",
	multiple: "Multiple 'use strict' directives.",
	never: "Strict mode is not permitted.",
	unnecessary: "Unnecessary 'use strict' directive.",
	module: "'use strict' is unnecessary inside of modules.",
	implied: "'use strict' is unnecessary when implied strict mode is enabled.",
	unnecessaryInClasses: "'use strict' is unnecessary inside of classes.",
	nonSimpleParameterList: "'use strict' directive inside a function with non-simple parameter list throws a syntax error since ES2016.",
	wrap: "Wrap {{name}} in a function with 'use strict' directive."
};
function getUseStrictDirectives(statements) {
	var directives = [];

	for (var i = 0; i < statements.length; i++) {
		var statement = statements[i];

		if (statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && statement.expression.value === "use strict") {
			directives[i] = statement;
		} else {
			break;
		}
	}

	return directives;
}
function isSimpleParameter(node) {
	return node.type === "Identifier";
}
function isSimpleParameterList(params) {
	return params.every(isSimpleParameter);
}
module.exports = {
	meta: {
		docs: {
			description: "require or disallow strict mode directives",
			category: "Strict Mode",
			recommended: false
		},

		schema: [{
			enum: ["never", "global", "function", "safe"]
		}],

		fixable: "code"
	},

	create: function create(context) {

		var ecmaFeatures = context.parserOptions.ecmaFeatures || {},
			scopes = [],
			classScopes = [];
		var mode = context.options[0] || "safe";

		if (ecmaFeatures.impliedStrict) {
			mode = "implied";
		} else if (mode === "safe") {
			mode = ecmaFeatures.globalReturn ? "global" : "function";
		}
		function shouldFix(errorType) {
			return errorType === "multiple" || errorType === "unnecessary" || errorType === "module" || errorType === "implied" || errorType === "unnecessaryInClasses";
		}
		function getFixFunction(node) {
			return function (fixer) {
				return fixer.remove(node);
			};
		}
		function reportSlice(nodes, start, end, message, fix) {
			nodes.slice(start, end).forEach(function (node) {
				context.report({ node: node, message: message, fix: fix ? getFixFunction(node) : null });
			});
		}
		function reportAll(nodes, message, fix) {
			reportSlice(nodes, 0, nodes.length, message, fix);
		}
		function reportAllExceptFirst(nodes, message, fix) {
			reportSlice(nodes, 1, nodes.length, message, fix);
		}
		function enterFunctionInFunctionMode(node, useStrictDirectives) {
			var isInClass = classScopes.length > 0,
				isParentGlobal = scopes.length === 0 && classScopes.length === 0,
				isParentStrict = scopes.length > 0 && scopes[scopes.length - 1],
				isStrict = useStrictDirectives.length > 0;

			if (isStrict) {
				if (!isSimpleParameterList(node.params)) {
					context.report({ node: useStrictDirectives[0], message: messages.nonSimpleParameterList });
				} else if (isParentStrict) {
					context.report({ node: useStrictDirectives[0], message: messages.unnecessary, fix: getFixFunction(useStrictDirectives[0]) });
				} else if (isInClass) {
					context.report({ node: useStrictDirectives[0], message: messages.unnecessaryInClasses, fix: getFixFunction(useStrictDirectives[0]) });
				}

				reportAllExceptFirst(useStrictDirectives, messages.multiple, true);
			} else if (isParentGlobal) {
				if (isSimpleParameterList(node.params)) {
					context.report({ node: node, message: messages.function });
				} else {
					context.report({
						node: node,
						message: messages.wrap,
						data: { name: astUtils.getFunctionNameWithKind(node) }
					});
				}
			}

			scopes.push(isParentStrict || isStrict);
		}
		function exitFunctionInFunctionMode() {
			scopes.pop();
		}
		function enterFunction(node) {
			var isBlock = node.body.type === "BlockStatement",
				useStrictDirectives = isBlock ? getUseStrictDirectives(node.body.body) : [];

			if (mode === "function") {
				enterFunctionInFunctionMode(node, useStrictDirectives);
			} else if (useStrictDirectives.length > 0) {
				if (isSimpleParameterList(node.params)) {
					reportAll(useStrictDirectives, messages[mode], shouldFix(mode));
				} else {
					context.report({ node: useStrictDirectives[0], message: messages.nonSimpleParameterList });
					reportAllExceptFirst(useStrictDirectives, messages.multiple, true);
				}
			}
		}

		var rule = {
			Program: function Program(node) {
				var useStrictDirectives = getUseStrictDirectives(node.body);

				if (node.sourceType === "module") {
					mode = "module";
				}

				if (mode === "global") {
					if (node.body.length > 0 && useStrictDirectives.length === 0) {
						context.report({ node: node, message: messages.global });
					}
					reportAllExceptFirst(useStrictDirectives, messages.multiple, true);
				} else {
					reportAll(useStrictDirectives, messages[mode], shouldFix(mode));
				}
			},

			FunctionDeclaration: enterFunction,
			FunctionExpression: enterFunction,
			ArrowFunctionExpression: enterFunction
		};

		if (mode === "function") {
			Object.assign(rule, {
				ClassBody: function ClassBody() {
					classScopes.push(true);
				},
				"ClassBody:exit": function ClassBodyExit() {
					classScopes.pop();
				},


				"FunctionDeclaration:exit": exitFunctionInFunctionMode,
				"FunctionExpression:exit": exitFunctionInFunctionMode,
				"ArrowFunctionExpression:exit": exitFunctionInFunctionMode
			});
		}

		return rule;
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "enforce spacing around colons of switch statements",
			category: "Stylistic Issues",
			recommended: false
		},
		schema: [{
			type: "object",
			properties: {
				before: { type: "boolean" },
				after: { type: "boolean" }
			},
			additionalProperties: false
		}],
		fixable: "whitespace"
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var options = context.options[0] || {};
		var beforeSpacing = options.before === true; // false by default
		var afterSpacing = options.after !== false; // true by default
		function getColonToken(node) {
			if (node.test) {
				return sourceCode.getTokenAfter(node.test, astUtils.isColonToken);
			}
			return sourceCode.getFirstToken(node, 1);
		}
		function isValidSpacing(left, right, expected) {
			return astUtils.isClosingBraceToken(right) || !astUtils.isTokenOnSameLine(left, right) || sourceCode.isSpaceBetweenTokens(left, right) === expected;
		}
		function commentsExistBetween(left, right) {
			return sourceCode.getFirstTokenBetween(left, right, {
				includeComments: true,
				filter: astUtils.isCommentToken
			}) !== null;
		}
		function _fix(fixer, left, right, spacing) {
			if (commentsExistBetween(left, right)) {
				return null;
			}
			if (spacing) {
				return fixer.insertTextAfter(left, " ");
			}
			return fixer.removeRange([left.range[1], right.range[0]]);
		}

		return {
			SwitchCase: function SwitchCase(node) {
				var colonToken = getColonToken(node);
				var beforeToken = sourceCode.getTokenBefore(colonToken);
				var afterToken = sourceCode.getTokenAfter(colonToken);

				if (!isValidSpacing(beforeToken, colonToken, beforeSpacing)) {
					context.report({
						node: node,
						loc: colonToken.loc,
						message: "{{verb}} space(s) before this colon.",
						data: { verb: beforeSpacing ? "Expected" : "Unexpected" },
						fix: function fix(fixer) {
							return _fix(fixer, beforeToken, colonToken, beforeSpacing);
						}
					});
				}
				if (!isValidSpacing(colonToken, afterToken, afterSpacing)) {
					context.report({
						node: node,
						loc: colonToken.loc,
						message: "{{verb}} space(s) after this colon.",
						data: { verb: afterSpacing ? "Expected" : "Unexpected" },
						fix: function fix(fixer) {
							return _fix(fixer, colonToken, afterToken, afterSpacing);
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);

module.exports = {
	meta: {
		docs: {
			description: "require symbol descriptions",
			category: "ECMAScript 6",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		function checkArgument(node) {
			if (node.arguments.length === 0) {
				context.report({
					node: node,
					message: "Expected Symbol to have a description."
				});
			}
		}

		return {
			"Program:exit": function ProgramExit() {
				var scope = context.getScope();
				var variable = astUtils.getVariableByName(scope, "Symbol");

				if (variable && variable.defs.length === 0) {
					variable.references.forEach(function (reference) {
						var node = reference.identifier;

						if (astUtils.isCallee(node)) {
							checkArgument(node.parent);
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
var OPEN_PAREN = /\$\{$/;
var CLOSE_PAREN = /^\}/;
module.exports = {
	meta: {
		docs: {
			description: "require or disallow spacing around embedded expressions of template strings",
			category: "ECMAScript 6",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{ enum: ["always", "never"] }]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();
		var always = context.options[0] === "always";
		var prefix = always ? "Expected" : "Unexpected";
		function checkSpacingBefore(token) {
			var prevToken = sourceCode.getTokenBefore(token);

			if (prevToken && CLOSE_PAREN.test(token.value) && astUtils.isTokenOnSameLine(prevToken, token) && sourceCode.isSpaceBetweenTokens(prevToken, token) !== always) {
				context.report({
					loc: token.loc.start,
					message: "{{prefix}} space(s) before '}'.",
					data: {
						prefix: prefix
					},
					fix: function fix(fixer) {
						if (always) {
							return fixer.insertTextBefore(token, " ");
						}
						return fixer.removeRange([prevToken.range[1], token.range[0]]);
					}
				});
			}
		}
		function checkSpacingAfter(token) {
			var nextToken = sourceCode.getTokenAfter(token);

			if (nextToken && OPEN_PAREN.test(token.value) && astUtils.isTokenOnSameLine(token, nextToken) && sourceCode.isSpaceBetweenTokens(token, nextToken) !== always) {
				context.report({
					loc: {
						line: token.loc.end.line,
						column: token.loc.end.column - 2
					},
					message: "{{prefix}} space(s) after '${'.",
					data: {
						prefix: prefix
					},
					fix: function fix(fixer) {
						if (always) {
							return fixer.insertTextAfter(token, " ");
						}
						return fixer.removeRange([token.range[1], nextToken.range[0]]);
					}
				});
			}
		}

		return {
			TemplateElement: function TemplateElement(node) {
				var token = sourceCode.getFirstToken(node);

				checkSpacingBefore(token);
				checkSpacingAfter(token);
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require or disallow spacing between template tags and their literals",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{ enum: ["always", "never"] }]
	},

	create: function create(context) {
		var never = context.options[0] !== "always";
		var sourceCode = context.getSourceCode();
		function checkSpacing(node) {
			var tagToken = sourceCode.getTokenBefore(node.quasi);
			var literalToken = sourceCode.getFirstToken(node.quasi);
			var hasWhitespace = sourceCode.isSpaceBetweenTokens(tagToken, literalToken);

			if (never && hasWhitespace) {
				context.report({
					node: node,
					loc: tagToken.loc.start,
					message: "Unexpected space between template tag and template literal.",
					fix: function fix(fixer) {
						var comments = sourceCode.getCommentsBefore(node.quasi);
						if (comments.some(function (comment) {
							return comment.type === "Line";
						})) {
							return null;
						}

						return fixer.replaceTextRange([tagToken.range[1], literalToken.range[0]], comments.reduce(function (text, comment) {
							return text + sourceCode.getText(comment);
						}, ""));
					}
				});
			} else if (!never && !hasWhitespace) {
				context.report({
					node: node,
					loc: tagToken.loc.start,
					message: "Missing space between template tag and template literal.",
					fix: function fix(fixer) {
						return fixer.insertTextAfter(tagToken, " ");
					}
				});
			}
		}

		return {
			TaggedTemplateExpression: checkSpacing
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require or disallow Unicode byte order mark (BOM)",
			category: "Stylistic Issues",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			enum: ["always", "never"]
		}]
	},

	create: function create(context) {
		return {

			Program: function checkUnicodeBOM(node) {

				var sourceCode = context.getSourceCode(),
					location = { column: 0, line: 1 },
					requireBOM = context.options[0] || "never";

				if (!sourceCode.hasBOM && requireBOM === "always") {
					context.report({
						node: node,
						loc: location,
						message: "Expected Unicode BOM (Byte Order Mark).",
						fix: function fix(fixer) {
							return fixer.insertTextBeforeRange([0, 1], "\uFEFF");
						}
					});
				} else if (sourceCode.hasBOM && requireBOM === "never") {
					context.report({
						node: node,
						loc: location,
						message: "Unexpected Unicode BOM (Byte Order Mark).",
						fix: function fix(fixer) {
							return fixer.removeRange([-1, 0]);
						}
					});
				}
			}

		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require calls to `isNaN()` when checking for `NaN`",
			category: "Possible Errors",
			recommended: true
		},

		schema: []
	},

	create: function create(context) {

		return {
			BinaryExpression: function BinaryExpression(node) {
				if (/^(?:[<>]|[!=]=)=?$/.test(node.operator) && (node.left.name === "NaN" || node.right.name === "NaN")) {
					context.report({ node: node, message: "Use the isNaN function to compare with NaN." });
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var doctrine = __webpack_require__(164);
module.exports = {
	meta: {
		docs: {
			description: "enforce valid JSDoc comments",
			category: "Possible Errors",
			recommended: false
		},

		schema: [{
			type: "object",
			properties: {
				prefer: {
					type: "object",
					additionalProperties: {
						type: "string"
					}
				},
				preferType: {
					type: "object",
					additionalProperties: {
						type: "string"
					}
				},
				requireReturn: {
					type: "boolean"
				},
				requireParamDescription: {
					type: "boolean"
				},
				requireReturnDescription: {
					type: "boolean"
				},
				matchDescription: {
					type: "string"
				},
				requireReturnType: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var options = context.options[0] || {},
			prefer = options.prefer || {},
			sourceCode = context.getSourceCode(),
		requireReturn = options.requireReturn !== false,
			requireParamDescription = options.requireParamDescription !== false,
			requireReturnDescription = options.requireReturnDescription !== false,
			requireReturnType = options.requireReturnType !== false,
			preferType = options.preferType || {},
			checkPreferType = Object.keys(preferType).length !== 0;
		var fns = [];
		function isTypeClass(node) {
			return node.type === "ClassExpression" || node.type === "ClassDeclaration";
		}
		function startFunction(node) {
			fns.push({
				returnPresent: node.type === "ArrowFunctionExpression" && node.body.type !== "BlockStatement" || isTypeClass(node)
			});
		}
		function addReturn(node) {
			var functionState = fns[fns.length - 1];

			if (functionState && node.argument !== null) {
				functionState.returnPresent = true;
			}
		}
		function isValidReturnType(tag) {
			return tag.type === null || tag.type.name === "void" || tag.type.type === "UndefinedLiteral";
		}
		function canTypeBeValidated(type) {
			return type !== "UndefinedLiteral" && // {undefined} as there is no name property available.
			type !== "NullLiteral" && // {null}
			type !== "NullableLiteral" && // {?}
			type !== "FunctionType" && // {function(a)}
			type !== "AllLiteral"; // {*}
		}
		function getCurrentExpectedTypes(type) {
			var currentType = void 0;

			if (type.name) {
				currentType = type.name;
			} else if (type.expression) {
				currentType = type.expression.name;
			}

			var expectedType = currentType && preferType[currentType];

			return {
				currentType: currentType,
				expectedType: expectedType
			};
		}
		function validateType(jsdocNode, type) {
			if (!type || !canTypeBeValidated(type.type)) {
				return;
			}

			var typesToCheck = [];
			var elements = [];

			switch (type.type) {
				case "TypeApplication":
					elements = type.applications[0].type === "UnionType" ? type.applications[0].elements : type.applications;
					typesToCheck.push(getCurrentExpectedTypes(type));
					break;
				case "RecordType":
					elements = type.fields;
					break;
				case "UnionType": // {String|number|Test}
				case "ArrayType":
					elements = type.elements;
					break;
				case "FieldType":
					if (type.value) {
						typesToCheck.push(getCurrentExpectedTypes(type.value));
					}
					break;
				default:
					typesToCheck.push(getCurrentExpectedTypes(type));
			}

			elements.forEach(validateType.bind(null, jsdocNode));

			typesToCheck.forEach(function (typeToCheck) {
				if (typeToCheck.expectedType && typeToCheck.expectedType !== typeToCheck.currentType) {
					context.report({
						node: jsdocNode,
						message: "Use '{{expectedType}}' instead of '{{currentType}}'.",
						data: {
							currentType: typeToCheck.currentType,
							expectedType: typeToCheck.expectedType
						}
					});
				}
			});
		}
		function checkJSDoc(node) {
			var jsdocNode = sourceCode.getJSDocComment(node),
				functionData = fns.pop(),
				params = Object.create(null),
				paramsTags = [];
			var hasReturns = false,
				returnsTag = void 0,
				hasConstructor = false,
				isInterface = false,
				isOverride = false,
				isAbstract = false;
			if (jsdocNode) {
				var jsdoc = void 0;

				try {
					jsdoc = doctrine.parse(jsdocNode.value, {
						strict: true,
						unwrap: true,
						sloppy: true
					});
				} catch (ex) {

					if (/braces/i.test(ex.message)) {
						context.report({ node: jsdocNode, message: "JSDoc type missing brace." });
					} else {
						context.report({ node: jsdocNode, message: "JSDoc syntax error." });
					}

					return;
				}

				jsdoc.tags.forEach(function (tag) {

					switch (tag.title.toLowerCase()) {

						case "param":
						case "arg":
						case "argument":
							paramsTags.push(tag);
							break;

						case "return":
						case "returns":
							hasReturns = true;
							returnsTag = tag;
							break;

						case "constructor":
						case "class":
							hasConstructor = true;
							break;

						case "override":
						case "inheritdoc":
							isOverride = true;
							break;

						case "abstract":
						case "virtual":
							isAbstract = true;
							break;

						case "interface":
							isInterface = true;
							break;
					}
					if (prefer.hasOwnProperty(tag.title) && tag.title !== prefer[tag.title]) {
						context.report({ node: jsdocNode, message: "Use @{{name}} instead.", data: { name: prefer[tag.title] } });
					}
					if (checkPreferType && tag.type) {
						validateType(jsdocNode, tag.type);
					}
				});

				paramsTags.forEach(function (param) {
					if (!param.type) {
						context.report({ node: jsdocNode, message: "Missing JSDoc parameter type for '{{name}}'.", data: { name: param.name } });
					}
					if (!param.description && requireParamDescription) {
						context.report({ node: jsdocNode, message: "Missing JSDoc parameter description for '{{name}}'.", data: { name: param.name } });
					}
					if (params[param.name]) {
						context.report({ node: jsdocNode, message: "Duplicate JSDoc parameter '{{name}}'.", data: { name: param.name } });
					} else if (param.name.indexOf(".") === -1) {
						params[param.name] = 1;
					}
				});

				if (hasReturns) {
					if (!requireReturn && !functionData.returnPresent && (returnsTag.type === null || !isValidReturnType(returnsTag)) && !isAbstract) {
						context.report({
							node: jsdocNode,
							message: "Unexpected @{{title}} tag; function has no return statement.",
							data: {
								title: returnsTag.title
							}
						});
					} else {
						if (requireReturnType && !returnsTag.type) {
							context.report({ node: jsdocNode, message: "Missing JSDoc return type." });
						}

						if (!isValidReturnType(returnsTag) && !returnsTag.description && requireReturnDescription) {
							context.report({ node: jsdocNode, message: "Missing JSDoc return description." });
						}
					}
				}
				if (!isOverride && !hasReturns && !hasConstructor && !isInterface && node.parent.kind !== "get" && node.parent.kind !== "constructor" && node.parent.kind !== "set" && !isTypeClass(node)) {
					if (requireReturn || functionData.returnPresent) {
						context.report({
							node: jsdocNode,
							message: "Missing JSDoc @{{returns}} for function.",
							data: {
								returns: prefer.returns || "returns"
							}
						});
					}
				}
				var jsdocParams = Object.keys(params);

				if (node.params) {
					node.params.forEach(function (param, i) {
						if (param.type === "AssignmentPattern") {
							param = param.left;
						}

						var name = param.name;
						if (param.type === "Identifier") {
							if (jsdocParams[i] && name !== jsdocParams[i]) {
								context.report({
									node: jsdocNode,
									message: "Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.",
									data: {
										name: name,
										jsdocName: jsdocParams[i]
									}
								});
							} else if (!params[name] && !isOverride) {
								context.report({
									node: jsdocNode,
									message: "Missing JSDoc for parameter '{{name}}'.",
									data: {
										name: name
									}
								});
							}
						}
					});
				}

				if (options.matchDescription) {
					var regex = new RegExp(options.matchDescription);

					if (!regex.test(jsdoc.description)) {
						context.report({ node: jsdocNode, message: "JSDoc description does not satisfy the regex pattern." });
					}
				}
			}
		}
		return {
			ArrowFunctionExpression: startFunction,
			FunctionExpression: startFunction,
			FunctionDeclaration: startFunction,
			ClassExpression: startFunction,
			ClassDeclaration: startFunction,
			"ArrowFunctionExpression:exit": checkJSDoc,
			"FunctionExpression:exit": checkJSDoc,
			"FunctionDeclaration:exit": checkJSDoc,
			"ClassExpression:exit": checkJSDoc,
			"ClassDeclaration:exit": checkJSDoc,
			ReturnStatement: addReturn
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function () {
	'use strict';

	var Syntax, Token, source, length, index, previous, token, value, esutils, utility;

	esutils = __webpack_require__(68);
	utility = __webpack_require__(165);

	Syntax = {
		NullableLiteral: 'NullableLiteral',
		AllLiteral: 'AllLiteral',
		NullLiteral: 'NullLiteral',
		UndefinedLiteral: 'UndefinedLiteral',
		VoidLiteral: 'VoidLiteral',
		UnionType: 'UnionType',
		ArrayType: 'ArrayType',
		RecordType: 'RecordType',
		FieldType: 'FieldType',
		FunctionType: 'FunctionType',
		ParameterType: 'ParameterType',
		RestType: 'RestType',
		NonNullableType: 'NonNullableType',
		OptionalType: 'OptionalType',
		NullableType: 'NullableType',
		NameExpression: 'NameExpression',
		TypeApplication: 'TypeApplication',
		StringLiteralType: 'StringLiteralType',
		NumericLiteralType: 'NumericLiteralType',
		BooleanLiteralType: 'BooleanLiteralType'
	};

	Token = {
		ILLEGAL: 0, // ILLEGAL
		DOT_LT: 1, // .<
		REST: 2, // ...
		LT: 3, // <
		GT: 4, // >
		LPAREN: 5, // (
		RPAREN: 6, // )
		LBRACE: 7, // {
		RBRACE: 8, // }
		LBRACK: 9, // [
		RBRACK: 10, // ]
		COMMA: 11, // ,
		COLON: 12, // :
		STAR: 13, // *
		PIPE: 14, // |
		QUESTION: 15, // ?
		BANG: 16, // !
		EQUAL: 17, // =
		NAME: 18, // name token
		STRING: 19, // string
		NUMBER: 20, // number
		EOF: 21
	};

	function isTypeName(ch) {
		return '><(){}[],:*|?!='.indexOf(String.fromCharCode(ch)) === -1 && !esutils.code.isWhiteSpace(ch) && !esutils.code.isLineTerminator(ch);
	}

	function Context(previous, index, token, value) {
		this._previous = previous;
		this._index = index;
		this._token = token;
		this._value = value;
	}

	Context.prototype.restore = function () {
		previous = this._previous;
		index = this._index;
		token = this._token;
		value = this._value;
	};

	Context.save = function () {
		return new Context(previous, index, token, value);
	};

	function advance() {
		var ch = source.charAt(index);
		index += 1;
		return ch;
	}

	function scanHexEscape(prefix) {
		var i,
			len,
			ch,
			code = 0;

		len = prefix === 'u' ? 4 : 2;
		for (i = 0; i < len; ++i) {
			if (index < length && esutils.code.isHexDigit(source.charCodeAt(index))) {
				ch = advance();
				code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
			} else {
				return '';
			}
		}
		return String.fromCharCode(code);
	}

	function scanString() {
		var str = '',
			quote,
			ch,
			code,
			unescaped,
			restore; //TODO review removal octal = false
		quote = source.charAt(index);
		++index;

		while (index < length) {
			ch = advance();

			if (ch === quote) {
				quote = '';
				break;
			} else if (ch === '\\') {
				ch = advance();
				if (!esutils.code.isLineTerminator(ch.charCodeAt(0))) {
					switch (ch) {
						case 'n':
							str += '\n';
							break;
						case 'r':
							str += '\r';
							break;
						case 't':
							str += '\t';
							break;
						case 'u':
						case 'x':
							restore = index;
							unescaped = scanHexEscape(ch);
							if (unescaped) {
								str += unescaped;
							} else {
								index = restore;
								str += ch;
							}
							break;
						case 'b':
							str += '\b';
							break;
						case 'f':
							str += '\f';
							break;
						case 'v':
							str += '\v';
							break;

						default:
							if (esutils.code.isOctalDigit(ch.charCodeAt(0))) {
								code = '01234567'.indexOf(ch);
								if (index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {
									code = code * 8 + '01234567'.indexOf(advance());
									if ('0123'.indexOf(ch) >= 0 && index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {
										code = code * 8 + '01234567'.indexOf(advance());
									}
								}
								str += String.fromCharCode(code);
							} else {
								str += ch;
							}
							break;
					}
				} else {
					if (ch === '\r' && source.charCodeAt(index) === 0x0A /* '\n' */) {
							++index;
						}
				}
			} else if (esutils.code.isLineTerminator(ch.charCodeAt(0))) {
				break;
			} else {
				str += ch;
			}
		}

		if (quote !== '') {
			utility.throwError('unexpected quote');
		}

		value = str;
		return Token.STRING;
	}

	function scanNumber() {
		var number, ch;

		number = '';
		ch = source.charCodeAt(index);

		if (ch !== 0x2E /* '.' */) {
				number = advance();
				ch = source.charCodeAt(index);

				if (number === '0') {
					if (ch === 0x78 /* 'x' */ || ch === 0x58 /* 'X' */) {
							number += advance();
							while (index < length) {
								ch = source.charCodeAt(index);
								if (!esutils.code.isHexDigit(ch)) {
									break;
								}
								number += advance();
							}

							if (number.length <= 2) {
								utility.throwError('unexpected token');
							}

							if (index < length) {
								ch = source.charCodeAt(index);
								if (esutils.code.isIdentifierStartES5(ch)) {
									utility.throwError('unexpected token');
								}
							}
							value = parseInt(number, 16);
							return Token.NUMBER;
						}

					if (esutils.code.isOctalDigit(ch)) {
						number += advance();
						while (index < length) {
							ch = source.charCodeAt(index);
							if (!esutils.code.isOctalDigit(ch)) {
								break;
							}
							number += advance();
						}

						if (index < length) {
							ch = source.charCodeAt(index);
							if (esutils.code.isIdentifierStartES5(ch) || esutils.code.isDecimalDigit(ch)) {
								utility.throwError('unexpected token');
							}
						}
						value = parseInt(number, 8);
						return Token.NUMBER;
					}

					if (esutils.code.isDecimalDigit(ch)) {
						utility.throwError('unexpected token');
					}
				}

				while (index < length) {
					ch = source.charCodeAt(index);
					if (!esutils.code.isDecimalDigit(ch)) {
						break;
					}
					number += advance();
				}
			}

		if (ch === 0x2E /* '.' */) {
				number += advance();
				while (index < length) {
					ch = source.charCodeAt(index);
					if (!esutils.code.isDecimalDigit(ch)) {
						break;
					}
					number += advance();
				}
			}

		if (ch === 0x65 /* 'e' */ || ch === 0x45 /* 'E' */) {
				number += advance();

				ch = source.charCodeAt(index);
				if (ch === 0x2B /* '+' */ || ch === 0x2D /* '-' */) {
						number += advance();
					}

				ch = source.charCodeAt(index);
				if (esutils.code.isDecimalDigit(ch)) {
					number += advance();
					while (index < length) {
						ch = source.charCodeAt(index);
						if (!esutils.code.isDecimalDigit(ch)) {
							break;
						}
						number += advance();
					}
				} else {
					utility.throwError('unexpected token');
				}
			}

		if (index < length) {
			ch = source.charCodeAt(index);
			if (esutils.code.isIdentifierStartES5(ch)) {
				utility.throwError('unexpected token');
			}
		}

		value = parseFloat(number);
		return Token.NUMBER;
	}

	function scanTypeName() {
		var ch, ch2;

		value = advance();
		while (index < length && isTypeName(source.charCodeAt(index))) {
			ch = source.charCodeAt(index);
			if (ch === 0x2E /* '.' */) {
					if (index + 1 >= length) {
						return Token.ILLEGAL;
					}
					ch2 = source.charCodeAt(index + 1);
					if (ch2 === 0x3C /* '<' */) {
							break;
						}
				}
			value += advance();
		}
		return Token.NAME;
	}

	function next() {
		var ch;

		previous = index;

		while (index < length && esutils.code.isWhiteSpace(source.charCodeAt(index))) {
			advance();
		}
		if (index >= length) {
			token = Token.EOF;
			return token;
		}

		ch = source.charCodeAt(index);
		switch (ch) {
			case 0x27: /* ''' */
			case 0x22:
				token = scanString();
				return token;

			case 0x3A:
				advance();
				token = Token.COLON;
				return token;

			case 0x2C:
				advance();
				token = Token.COMMA;
				return token;

			case 0x28:
				advance();
				token = Token.LPAREN;
				return token;

			case 0x29:
				advance();
				token = Token.RPAREN;
				return token;

			case 0x5B:
				advance();
				token = Token.LBRACK;
				return token;

			case 0x5D:
				advance();
				token = Token.RBRACK;
				return token;

			case 0x7B:
				advance();
				token = Token.LBRACE;
				return token;

			case 0x7D:
				advance();
				token = Token.RBRACE;
				return token;

			case 0x2E:
				if (index + 1 < length) {
					ch = source.charCodeAt(index + 1);
					if (ch === 0x3C /* '<' */) {
							advance(); // '.'
							advance(); // '<'
							token = Token.DOT_LT;
							return token;
						}

					if (ch === 0x2E /* '.' */ && index + 2 < length && source.charCodeAt(index + 2) === 0x2E /* '.' */) {
							advance(); // '.'
							advance(); // '.'
							advance(); // '.'
							token = Token.REST;
							return token;
						}

					if (esutils.code.isDecimalDigit(ch)) {
						token = scanNumber();
						return token;
					}
				}
				token = Token.ILLEGAL;
				return token;

			case 0x3C:
				advance();
				token = Token.LT;
				return token;

			case 0x3E:
				advance();
				token = Token.GT;
				return token;

			case 0x2A:
				advance();
				token = Token.STAR;
				return token;

			case 0x7C:
				advance();
				token = Token.PIPE;
				return token;

			case 0x3F:
				advance();
				token = Token.QUESTION;
				return token;

			case 0x21:
				advance();
				token = Token.BANG;
				return token;

			case 0x3D:
				advance();
				token = Token.EQUAL;
				return token;

			case 0x2D:
				token = scanNumber();
				return token;

			default:
				if (esutils.code.isDecimalDigit(ch)) {
					token = scanNumber();
					return token;
				}
				//
				//
				utility.assert(isTypeName(ch));
				token = scanTypeName();
				return token;
		}
	}

	function consume(target, text) {
		utility.assert(token === target, text || 'consumed token not matched');
		next();
	}

	function expect(target, message) {
		if (token !== target) {
			utility.throwError(message || 'unexpected token');
		}
		next();
	}
	//
	//
	function parseUnionType() {
		var elements;
		consume(Token.LPAREN, 'UnionType should start with (');
		elements = [];
		if (token !== Token.RPAREN) {
			while (true) {
				elements.push(parseTypeExpression());
				if (token === Token.RPAREN) {
					break;
				}
				expect(Token.PIPE);
			}
		}
		consume(Token.RPAREN, 'UnionType should end with )');
		return {
			type: Syntax.UnionType,
			elements: elements
		};
	}
	//
	function parseArrayType() {
		var elements;
		consume(Token.LBRACK, 'ArrayType should start with [');
		elements = [];
		while (token !== Token.RBRACK) {
			if (token === Token.REST) {
				consume(Token.REST);
				elements.push({
					type: Syntax.RestType,
					expression: parseTypeExpression()
				});
				break;
			} else {
				elements.push(parseTypeExpression());
			}
			if (token !== Token.RBRACK) {
				expect(Token.COMMA);
			}
		}
		expect(Token.RBRACK);
		return {
			type: Syntax.ArrayType,
			elements: elements
		};
	}

	function parseFieldName() {
		var v = value;
		if (token === Token.NAME || token === Token.STRING) {
			next();
			return v;
		}

		if (token === Token.NUMBER) {
			consume(Token.NUMBER);
			return String(v);
		}

		utility.throwError('unexpected token');
	}
	//
	function parseFieldType() {
		var key;

		key = parseFieldName();
		if (token === Token.COLON) {
			consume(Token.COLON);
			return {
				type: Syntax.FieldType,
				key: key,
				value: parseTypeExpression()
			};
		}
		return {
			type: Syntax.FieldType,
			key: key,
			value: null
		};
	}
	//
	function parseRecordType() {
		var fields;

		consume(Token.LBRACE, 'RecordType should start with {');
		fields = [];
		if (token === Token.COMMA) {
			consume(Token.COMMA);
		} else {
			while (token !== Token.RBRACE) {
				fields.push(parseFieldType());
				if (token !== Token.RBRACE) {
					expect(Token.COMMA);
				}
			}
		}
		expect(Token.RBRACE);
		return {
			type: Syntax.RecordType,
			fields: fields
		};
	}
	//
	function parseNameExpression() {
		var name = value;
		expect(Token.NAME);

		if (token === Token.COLON && (name === 'module' || name === 'external' || name === 'event')) {
			consume(Token.COLON);
			name += ':' + value;
			expect(Token.NAME);
		}

		return {
			type: Syntax.NameExpression,
			name: name
		};
	}
	function parseTypeExpressionList() {
		var elements = [];

		elements.push(parseTop());
		while (token === Token.COMMA) {
			consume(Token.COMMA);
			elements.push(parseTop());
		}
		return elements;
	}
	//
	function parseTypeName() {
		var expr, applications;

		expr = parseNameExpression();
		if (token === Token.DOT_LT || token === Token.LT) {
			next();
			applications = parseTypeExpressionList();
			expect(Token.GT);
			return {
				type: Syntax.TypeApplication,
				expression: expr,
				applications: applications
			};
		}
		return expr;
	}
	//
	function parseResultType() {
		consume(Token.COLON, 'ResultType should start with :');
		if (token === Token.NAME && value === 'void') {
			consume(Token.NAME);
			return {
				type: Syntax.VoidLiteral
			};
		}
		return parseTypeExpression();
	}
	//
	//
	//
	//
	//
	//
	function parseParametersType() {
		var params = [],
			optionalSequence = false,
			expr,
			rest = false;

		while (token !== Token.RPAREN) {
			if (token === Token.REST) {
				consume(Token.REST);
				rest = true;
			}

			expr = parseTypeExpression();
			if (expr.type === Syntax.NameExpression && token === Token.COLON) {
				consume(Token.COLON);
				expr = {
					type: Syntax.ParameterType,
					name: expr.name,
					expression: parseTypeExpression()
				};
			}
			if (token === Token.EQUAL) {
				consume(Token.EQUAL);
				expr = {
					type: Syntax.OptionalType,
					expression: expr
				};
				optionalSequence = true;
			} else {
				if (optionalSequence) {
					utility.throwError('unexpected token');
				}
			}
			if (rest) {
				expr = {
					type: Syntax.RestType,
					expression: expr
				};
			}
			params.push(expr);
			if (token !== Token.RPAREN) {
				expect(Token.COMMA);
			}
		}
		return params;
	}
	//
	function parseFunctionType() {
		var isNew, thisBinding, params, result, fnType;
		utility.assert(token === Token.NAME && value === 'function', 'FunctionType should start with \'function\'');
		consume(Token.NAME);
		expect(Token.LPAREN);

		isNew = false;
		params = [];
		thisBinding = null;
		if (token !== Token.RPAREN) {
			if (token === Token.NAME && (value === 'this' || value === 'new')) {
				isNew = value === 'new';
				consume(Token.NAME);
				expect(Token.COLON);
				thisBinding = parseTypeName();
				if (token === Token.COMMA) {
					consume(Token.COMMA);
					params = parseParametersType();
				}
			} else {
				params = parseParametersType();
			}
		}

		expect(Token.RPAREN);

		result = null;
		if (token === Token.COLON) {
			result = parseResultType();
		}

		fnType = {
			type: Syntax.FunctionType,
			params: params,
			result: result
		};
		if (thisBinding) {
			fnType['this'] = thisBinding;
			if (isNew) {
				fnType['new'] = true;
			}
		}
		return fnType;
	}
	function parseBasicTypeExpression() {
		var context;
		switch (token) {
			case Token.STAR:
				consume(Token.STAR);
				return {
					type: Syntax.AllLiteral
				};

			case Token.LPAREN:
				return parseUnionType();

			case Token.LBRACK:
				return parseArrayType();

			case Token.LBRACE:
				return parseRecordType();

			case Token.NAME:
				if (value === 'null') {
					consume(Token.NAME);
					return {
						type: Syntax.NullLiteral
					};
				}

				if (value === 'undefined') {
					consume(Token.NAME);
					return {
						type: Syntax.UndefinedLiteral
					};
				}

				if (value === 'true' || value === 'false') {
					consume(Token.NAME);
					return {
						type: Syntax.BooleanLiteralType,
						value: value === 'true'
					};
				}

				context = Context.save();
				if (value === 'function') {
					try {
						return parseFunctionType();
					} catch (e) {
						context.restore();
					}
				}

				return parseTypeName();

			case Token.STRING:
				next();
				return {
					type: Syntax.StringLiteralType,
					value: value
				};

			case Token.NUMBER:
				next();
				return {
					type: Syntax.NumericLiteralType,
					value: value
				};

			default:
				utility.throwError('unexpected token');
		}
	}
	function parseTypeExpression() {
		var expr;

		if (token === Token.QUESTION) {
			consume(Token.QUESTION);
			if (token === Token.COMMA || token === Token.EQUAL || token === Token.RBRACE || token === Token.RPAREN || token === Token.PIPE || token === Token.EOF || token === Token.RBRACK || token === Token.GT) {
				return {
					type: Syntax.NullableLiteral
				};
			}
			return {
				type: Syntax.NullableType,
				expression: parseBasicTypeExpression(),
				prefix: true
			};
		}

		if (token === Token.BANG) {
			consume(Token.BANG);
			return {
				type: Syntax.NonNullableType,
				expression: parseBasicTypeExpression(),
				prefix: true
			};
		}

		expr = parseBasicTypeExpression();
		if (token === Token.BANG) {
			consume(Token.BANG);
			return {
				type: Syntax.NonNullableType,
				expression: expr,
				prefix: false
			};
		}

		if (token === Token.QUESTION) {
			consume(Token.QUESTION);
			return {
				type: Syntax.NullableType,
				expression: expr,
				prefix: false
			};
		}

		if (token === Token.LBRACK) {
			consume(Token.LBRACK);
			expect(Token.RBRACK, 'expected an array-style type declaration (' + value + '[])');
			return {
				type: Syntax.TypeApplication,
				expression: {
					type: Syntax.NameExpression,
					name: 'Array'
				},
				applications: [expr]
			};
		}

		return expr;
	}
	//
	function parseTop() {
		var expr, elements;

		expr = parseTypeExpression();
		if (token !== Token.PIPE) {
			return expr;
		}

		elements = [expr];
		consume(Token.PIPE);
		while (true) {
			elements.push(parseTypeExpression());
			if (token !== Token.PIPE) {
				break;
			}
			consume(Token.PIPE);
		}

		return {
			type: Syntax.UnionType,
			elements: elements
		};
	}

	function parseTopParamType() {
		var expr;

		if (token === Token.REST) {
			consume(Token.REST);
			return {
				type: Syntax.RestType,
				expression: parseTop()
			};
		}

		expr = parseTop();
		if (token === Token.EQUAL) {
			consume(Token.EQUAL);
			return {
				type: Syntax.OptionalType,
				expression: expr
			};
		}

		return expr;
	}

	function parseType(src, opt) {
		var expr;

		source = src;
		length = source.length;
		index = 0;
		previous = 0;

		next();
		expr = parseTop();

		if (opt && opt.midstream) {
			return {
				expression: expr,
				index: previous
			};
		}

		if (token !== Token.EOF) {
			utility.throwError('not reach to EOF');
		}

		return expr;
	}

	function parseParamType(src, opt) {
		var expr;

		source = src;
		length = source.length;
		index = 0;
		previous = 0;

		next();
		expr = parseTopParamType();

		if (opt && opt.midstream) {
			return {
				expression: expr,
				index: previous
			};
		}

		if (token !== Token.EOF) {
			utility.throwError('not reach to EOF');
		}

		return expr;
	}

	function stringifyImpl(node, compact, topLevel) {
		var result, i, iz;

		switch (node.type) {
			case Syntax.NullableLiteral:
				result = '?';
				break;

			case Syntax.AllLiteral:
				result = '*';
				break;

			case Syntax.NullLiteral:
				result = 'null';
				break;

			case Syntax.UndefinedLiteral:
				result = 'undefined';
				break;

			case Syntax.VoidLiteral:
				result = 'void';
				break;

			case Syntax.UnionType:
				if (!topLevel) {
					result = '(';
				} else {
					result = '';
				}

				for (i = 0, iz = node.elements.length; i < iz; ++i) {
					result += stringifyImpl(node.elements[i], compact);
					if (i + 1 !== iz) {
						result += compact ? '|' : ' | ';
					}
				}

				if (!topLevel) {
					result += ')';
				}
				break;

			case Syntax.ArrayType:
				result = '[';
				for (i = 0, iz = node.elements.length; i < iz; ++i) {
					result += stringifyImpl(node.elements[i], compact);
					if (i + 1 !== iz) {
						result += compact ? ',' : ', ';
					}
				}
				result += ']';
				break;

			case Syntax.RecordType:
				result = '{';
				for (i = 0, iz = node.fields.length; i < iz; ++i) {
					result += stringifyImpl(node.fields[i], compact);
					if (i + 1 !== iz) {
						result += compact ? ',' : ', ';
					}
				}
				result += '}';
				break;

			case Syntax.FieldType:
				if (node.value) {
					result = node.key + (compact ? ':' : ': ') + stringifyImpl(node.value, compact);
				} else {
					result = node.key;
				}
				break;

			case Syntax.FunctionType:
				result = compact ? 'function(' : 'function (';

				if (node['this']) {
					if (node['new']) {
						result += compact ? 'new:' : 'new: ';
					} else {
						result += compact ? 'this:' : 'this: ';
					}

					result += stringifyImpl(node['this'], compact);

					if (node.params.length !== 0) {
						result += compact ? ',' : ', ';
					}
				}

				for (i = 0, iz = node.params.length; i < iz; ++i) {
					result += stringifyImpl(node.params[i], compact);
					if (i + 1 !== iz) {
						result += compact ? ',' : ', ';
					}
				}

				result += ')';

				if (node.result) {
					result += (compact ? ':' : ': ') + stringifyImpl(node.result, compact);
				}
				break;

			case Syntax.ParameterType:
				result = node.name + (compact ? ':' : ': ') + stringifyImpl(node.expression, compact);
				break;

			case Syntax.RestType:
				result = '...';
				if (node.expression) {
					result += stringifyImpl(node.expression, compact);
				}
				break;

			case Syntax.NonNullableType:
				if (node.prefix) {
					result = '!' + stringifyImpl(node.expression, compact);
				} else {
					result = stringifyImpl(node.expression, compact) + '!';
				}
				break;

			case Syntax.OptionalType:
				result = stringifyImpl(node.expression, compact) + '=';
				break;

			case Syntax.NullableType:
				if (node.prefix) {
					result = '?' + stringifyImpl(node.expression, compact);
				} else {
					result = stringifyImpl(node.expression, compact) + '?';
				}
				break;

			case Syntax.NameExpression:
				result = node.name;
				break;

			case Syntax.TypeApplication:
				result = stringifyImpl(node.expression, compact) + '.<';
				for (i = 0, iz = node.applications.length; i < iz; ++i) {
					result += stringifyImpl(node.applications[i], compact);
					if (i + 1 !== iz) {
						result += compact ? ',' : ', ';
					}
				}
				result += '>';
				break;

			case Syntax.StringLiteralType:
				result = '"' + node.value + '"';
				break;

			case Syntax.NumericLiteralType:
				result = String(node.value);
				break;

			case Syntax.BooleanLiteralType:
				result = String(node.value);
				break;

			default:
				utility.throwError('Unknown type ' + node.type);
		}

		return result;
	}

	function stringify(node, options) {
		if (options == null) {
			options = {};
		}
		return stringifyImpl(node, options.compact, options.topLevel);
	}

	exports.parseType = parseType;
	exports.parseParamType = parseParamType;
	exports.stringify = stringify;
	exports.Syntax = Syntax;
})();
 }),
 (function(module, exports) {

module.exports = {"_from":"doctrine@^2.0.2","_id":"doctrine@2.0.2","_inBundle":false,"_integrity":"sha512-y0tm5Pq6ywp3qSTZ1vPgVdAnbDEoeoc5wlOHXoY1c4Wug/a7JvqHIl7BTvwodaHmejWkK/9dSb3sCYfyo/om8A==","_location":"/doctrine","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"doctrine@^2.0.2","name":"doctrine","escapedName":"doctrine","rawSpec":"^2.0.2","saveSpec":null,"fetchSpec":"^2.0.2"},"_requiredBy":["/eslint","/eslint-plugin-react"],"_resolved":"https://registry.npmjs.org/doctrine/-/doctrine-2.0.2.tgz","_shasum":"68f96ce8efc56cc42651f1faadb4f175273b0075","_spec":"doctrine@^2.0.2","_where":"J:\\Chromium\\newclient\\plugins\\c9.ide.language.javascript.eslint\\packager\\node_modules\\eslint","bugs":{"url":"https://github.com/eslint/doctrine/issues"},"bundleDependencies":false,"dependencies":{"esutils":"^2.0.2"},"deprecated":false,"description":"JSDoc parser","devDependencies":{"coveralls":"^2.11.2","dateformat":"^1.0.11","eslint":"^1.10.3","eslint-release":"^0.10.0","linefix":"^0.1.1","mocha":"^3.4.2","npm-license":"^0.3.1","nyc":"^10.3.2","semver":"^5.0.3","shelljs":"^0.5.3","shelljs-nodecli":"^0.1.1","should":"^5.0.1"},"directories":{"lib":"./lib"},"engines":{"node":">=0.10.0"},"files":["lib"],"homepage":"https://github.com/eslint/doctrine","license":"Apache-2.0","main":"lib/doctrine.js","maintainers":[{"name":"Nicholas C. Zakas","email":"nicholas+npm@nczconsulting.com","url":"https://www.nczonline.net"},{"name":"Yusuke Suzuki","email":"utatane.tea@gmail.com","url":"https://github.com/Constellation"}],"name":"doctrine","repository":{"type":"git","url":"git+https://github.com/eslint/doctrine.git"},"scripts":{"alpharelease":"eslint-prerelease alpha","betarelease":"eslint-prerelease beta","ci-release":"eslint-ci-release","coveralls":"nyc report --reporter=text-lcov | coveralls","lint":"eslint lib/","pretest":"npm run lint","release":"eslint-release","test":"nyc mocha"},"version":"2.0.2"}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function(global) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function compare(a, b) {
  if (a === b) {
	return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	if (a[i] !== b[i]) {
			x = a[i];
			y = b[i];
			break;
	}
  }

  if (x < y) {
	return -1;
  }
  if (y < x) {
	return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
	return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}
//
//
//
//
//
var util = __webpack_require__(108);
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = function () {
  return function foo() {}.name === 'foo';
}();
function pToString(obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
	return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
	return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
	return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
	return false;
  }
  if (arrbuf instanceof DataView) {
	return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
	return true;
  }
  return false;
}
var assert = module.exports = ok;
var regex = /\s*function\s+([^\(\s]*)\s*/;
function getName(func) {
  if (!util.isFunction(func)) {
	return;
  }
  if (functionsHaveNames) {
	return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
	this.message = options.message;
	this.generatedMessage = false;
  } else {
	this.message = getMessage(this);
	this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
	Error.captureStackTrace(this, stackStartFunction);
  } else {
	var err = new Error();
	if (err.stack) {
			var out = err.stack;
			var fn_name = getName(stackStartFunction);
			var idx = out.indexOf('\n' + fn_name);
			if (idx >= 0) {
		var next_line = out.indexOf('\n', idx + 1);
		out = out.substring(next_line + 1);
			}

			this.stack = out;
	}
  }
};
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
	return s.length < n ? s : s.slice(0, n);
  } else {
	return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
	return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' + name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' + self.operator + ' ' + truncate(inspect(self.expected), 128);
}
function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
	message: message,
	actual: actual,
	expected: expected,
	operator: operator,
	stackStartFunction: stackStartFunction
  });
}
assert.fail = fail;
function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;
assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};
assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
	fail(actual, expected, message, '!=', assert.notEqual);
  }
};
assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
	fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
	fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  if (actual === expected) {
	return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
	return compare(actual, expected) === 0;
  } else if (util.isDate(actual) && util.isDate(expected)) {
	return actual.getTime() === expected.getTime();
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
	return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
  } else if ((actual === null || (typeof actual === 'undefined' ? 'undefined' : _typeof(actual)) !== 'object') && (expected === null || (typeof expected === 'undefined' ? 'undefined' : _typeof(expected)) !== 'object')) {
	return strict ? actual === expected : actual == expected;
  } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
	return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0;
  } else if (isBuffer(actual) !== isBuffer(expected)) {
	return false;
  } else {
	memos = memos || { actual: [], expected: [] };

	var actualIndex = memos.actual.indexOf(actual);
	if (actualIndex !== -1) {
			if (actualIndex === memos.expected.indexOf(expected)) {
		return true;
			}
	}

	memos.actual.push(actual);
	memos.expected.push(expected);

	return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined) return false;
  if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false;
  if (aIsArgs) {
	a = pSlice.call(a);
	b = pSlice.call(b);
	return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  if (ka.length !== kb.length) return false;
  ka.sort();
  kb.sort();
  for (i = ka.length - 1; i >= 0; i--) {
	if (ka[i] !== kb[i]) return false;
  }
  for (i = ka.length - 1; i >= 0; i--) {
	key = ka[i];
	if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return false;
  }
  return true;
}
assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
	fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
	fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}
assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
	fail(actual, expected, message, '===', assert.strictEqual);
  }
};
assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
	fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
	return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
	return expected.test(actual);
  }

  try {
	if (actual instanceof expected) {
			return true;
	}
  } catch (e) {
  }

  if (Error.isPrototypeOf(expected)) {
	return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
	block();
  } catch (e) {
	error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
	throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
	message = expected;
	expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
	fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
	fail(actual, expected, 'Got unwanted exception' + message);
  }

  if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
	throw actual;
  }
}
assert.throws = function (block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};
assert.doesNotThrow = function (block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function (err) {
  if (err) throw err;
};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
	if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};
}.call(exports, __webpack_require__(101)))
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = function isBuffer(arg) {
  return arg && (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


if (typeof Object.create === 'function') {
  module.exports = function inherits(ctor, superCtor) {
	ctor.super_ = superCtor;
	ctor.prototype = Object.create(superCtor.prototype, {
			constructor: {
		value: ctor,
		enumerable: false,
		writable: true,
		configurable: true
			}
	});
  };
} else {
  module.exports = function inherits(ctor, superCtor) {
	ctor.super_ = superCtor;
	var TempCtor = function TempCtor() {};
	TempCtor.prototype = superCtor.prototype;
	ctor.prototype = new TempCtor();
	ctor.prototype.constructor = ctor;
  };
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "enforce comparing `typeof` expressions against valid strings",
			category: "Possible Errors",
			recommended: true
		},

		schema: [{
			type: "object",
			properties: {
				requireStringLiterals: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}]
	},

	create: function create(context) {

		var VALID_TYPES = ["symbol", "undefined", "object", "boolean", "number", "string", "function"],
			OPERATORS = ["==", "===", "!=", "!=="];

		var requireStringLiterals = context.options[0] && context.options[0].requireStringLiterals;
		function isTypeofExpression(node) {
			return node.type === "UnaryExpression" && node.operator === "typeof";
		}
		return {
			UnaryExpression: function UnaryExpression(node) {
				if (isTypeofExpression(node)) {
					var parent = context.getAncestors().pop();

					if (parent.type === "BinaryExpression" && OPERATORS.indexOf(parent.operator) !== -1) {
						var sibling = parent.left === node ? parent.right : parent.left;

						if (sibling.type === "Literal" || sibling.type === "TemplateLiteral" && !sibling.expressions.length) {
							var value = sibling.type === "Literal" ? sibling.value : sibling.quasis[0].value.cooked;

							if (VALID_TYPES.indexOf(value) === -1) {
								context.report({ node: sibling, message: "Invalid typeof comparison value." });
							}
						} else if (requireStringLiterals && !isTypeofExpression(sibling)) {
							context.report({ node: sibling, message: "Typeof comparisons should be to string literals." });
						}
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require `var` declarations be placed at the top of their containing scope",
			category: "Best Practices",
			recommended: false
		},

		schema: []
	},

	create: function create(context) {
		var errorMessage = "All 'var' declarations must be at the top of the function scope.";
		function looksLikeDirective(node) {
			return node.type === "ExpressionStatement" && node.expression.type === "Literal" && typeof node.expression.value === "string";
		}
		function looksLikeImport(node) {
			return node.type === "ImportDeclaration" || node.type === "ImportSpecifier" || node.type === "ImportDefaultSpecifier" || node.type === "ImportNamespaceSpecifier";
		}
		function isVariableDeclaration(node) {
			return node.type === "VariableDeclaration" || node.type === "ExportNamedDeclaration" && node.declaration && node.declaration.type === "VariableDeclaration";
		}
		function isVarOnTop(node, statements) {
			var l = statements.length;
			var i = 0;
			for (; i < l; ++i) {
				if (!looksLikeDirective(statements[i]) && !looksLikeImport(statements[i])) {
					break;
				}
			}

			for (; i < l; ++i) {
				if (!isVariableDeclaration(statements[i])) {
					return false;
				}
				if (statements[i] === node) {
					return true;
				}
			}

			return false;
		}
		function globalVarCheck(node, parent) {
			if (!isVarOnTop(node, parent.body)) {
				context.report({ node: node, message: errorMessage });
			}
		}
		function blockScopeVarCheck(node, parent, grandParent) {
			if (!(/Function/.test(grandParent.type) && parent.type === "BlockStatement" && isVarOnTop(node, parent.body))) {
				context.report({ node: node, message: errorMessage });
			}
		}
		return {
			VariableDeclaration: function VariableDeclaration(node) {
				var ancestors = context.getAncestors();
				var parent = ancestors.pop();
				var grandParent = ancestors.pop();

				if (node.kind === "var") {
					if (parent.type === "ExportNamedDeclaration") {
						node = parent;
						parent = grandParent;
						grandParent = ancestors.pop();
					}

					if (parent.type === "Program") {
						globalVarCheck(node, parent);
					} else {
						blockScopeVarCheck(node, parent, grandParent);
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
module.exports = {
	meta: {
		docs: {
			description: "require parentheses around immediate `function` invocations",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			enum: ["outside", "inside", "any"]
		}, {
			type: "object",
			properties: {
				functionPrototypeMethods: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}],

		fixable: "code"
	},

	create: function create(context) {

		var style = context.options[0] || "outside";
		var includeFunctionPrototypeMethods = context.options[1] && context.options[1].functionPrototypeMethods || false;

		var sourceCode = context.getSourceCode();
		function wrapped(node) {
			return astUtils.isParenthesised(sourceCode, node);
		}
		function getFunctionNodeFromIIFE(node) {
			var callee = node.callee;

			if (callee.type === "FunctionExpression") {
				return callee;
			}

			if (includeFunctionPrototypeMethods && callee.type === "MemberExpression" && callee.object.type === "FunctionExpression" && (astUtils.getStaticPropertyName(callee) === "call" || astUtils.getStaticPropertyName(callee) === "apply")) {
				return callee.object;
			}

			return null;
		}

		return {
			CallExpression: function CallExpression(node) {
				var innerNode = getFunctionNodeFromIIFE(node);

				if (!innerNode) {
					return;
				}

				var callExpressionWrapped = wrapped(node),
					functionExpressionWrapped = wrapped(innerNode);

				if (!callExpressionWrapped && !functionExpressionWrapped) {
					context.report({
						node: node,
						message: "Wrap an immediate function invocation in parentheses.",
						fix: function fix(fixer) {
							var nodeToSurround = style === "inside" ? innerNode : node;

							return fixer.replaceText(nodeToSurround, "(" + sourceCode.getText(nodeToSurround) + ")");
						}
					});
				} else if (style === "inside" && !functionExpressionWrapped) {
					context.report({
						node: node,
						message: "Wrap only the function expression in parens.",
						fix: function fix(fixer) {
							var parenAfter = sourceCode.getTokenAfter(node);

							return fixer.replaceTextRange([innerNode.range[1], parenAfter.range[1]], ")" + sourceCode.getText().slice(innerNode.range[1], parenAfter.range[0]));
						}
					});
				} else if (style === "outside" && !callExpressionWrapped) {
					context.report({
						node: node,
						message: "Move the invocation into the parens that contain the function.",
						fix: function fix(fixer) {
							var parenAfter = sourceCode.getTokenAfter(innerNode);

							return fixer.replaceTextRange([parenAfter.range[0], node.range[1]], sourceCode.getText().slice(parenAfter.range[1], node.range[1]) + ")");
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require parenthesis around regex literals",
			category: "Stylistic Issues",
			recommended: false
		},

		schema: [],

		fixable: "code"
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		return {
			Literal: function Literal(node) {
				var token = sourceCode.getFirstToken(node),
					nodeType = token.type;

				if (nodeType === "RegularExpression") {
					var source = sourceCode.getTokenBefore(node);
					var ancestors = context.getAncestors();
					var grandparent = ancestors[ancestors.length - 1];

					if (grandparent.type === "MemberExpression" && grandparent.object === node && (!source || source.value !== "(")) {
						context.report({
							node: node,
							message: "Wrap the regexp literal in parens to disambiguate the slash.",
							fix: function fix(fixer) {
								return fixer.replaceText(node, "(" + sourceCode.getText(node) + ")");
							}
						});
					}
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
	meta: {
		docs: {
			description: "require or disallow spacing around the `*` in `yield*` expressions",
			category: "ECMAScript 6",
			recommended: false
		},

		fixable: "whitespace",

		schema: [{
			oneOf: [{
				enum: ["before", "after", "both", "neither"]
			}, {
				type: "object",
				properties: {
					before: { type: "boolean" },
					after: { type: "boolean" }
				},
				additionalProperties: false
			}]
		}]
	},

	create: function create(context) {
		var sourceCode = context.getSourceCode();

		var mode = function (option) {
			if (!option || typeof option === "string") {
				return {
					before: { before: true, after: false },
					after: { before: false, after: true },
					both: { before: true, after: true },
					neither: { before: false, after: false }
				}[option || "after"];
			}
			return option;
		}(context.options[0]);
		function checkSpacing(side, leftToken, rightToken) {
			if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken) !== mode[side]) {
				var after = leftToken.value === "*";
				var spaceRequired = mode[side];
				var node = after ? leftToken : rightToken;
				var type = spaceRequired ? "Missing" : "Unexpected";
				var message = "{{type}} space {{side}} *.";

				context.report({
					node: node,
					message: message,
					data: {
						type: type,
						side: side
					},
					fix: function fix(fixer) {
						if (spaceRequired) {
							if (after) {
								return fixer.insertTextAfter(node, " ");
							}
							return fixer.insertTextBefore(node, " ");
						}
						return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
					}
				});
			}
		}
		function checkExpression(node) {
			if (!node.delegate) {
				return;
			}

			var tokens = sourceCode.getFirstTokens(node, 3);
			var yieldToken = tokens[0];
			var starToken = tokens[1];
			var nextToken = tokens[2];

			checkSpacing("before", yieldToken, starToken);
			checkSpacing("after", starToken, nextToken);
		}

		return {
			YieldExpression: checkExpression
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var astUtils = __webpack_require__(0);
function isComparisonOperator(operator) {
	return (/^(==|===|!=|!==|<|>|<=|>=)$/.test(operator)
	);
}
function isEqualityOperator(operator) {
	return (/^(==|===)$/.test(operator)
	);
}
function isRangeTestOperator(operator) {
	return ["<", "<="].indexOf(operator) >= 0;
}
function looksLikeLiteral(node) {
	return node.type === "UnaryExpression" && node.operator === "-" && node.prefix && node.argument.type === "Literal" && typeof node.argument.value === "number";
}
function getNormalizedLiteral(node, defaultValue) {
	if (node.type === "Literal") {
		return node;
	}

	if (looksLikeLiteral(node)) {
		return {
			type: "Literal",
			value: -node.argument.value,
			raw: "-" + node.argument.value
		};
	}

	if (defaultValue) {
		return {
			type: "Literal",
			value: defaultValue,
			raw: String(defaultValue)
		};
	}

	return null;
}
function same(a, b) {
	if (a.type !== b.type) {
		return false;
	}

	switch (a.type) {
		case "Identifier":
			return a.name === b.name;

		case "Literal":
			return a.value === b.value;

		case "MemberExpression":
			{
				var nameA = astUtils.getStaticPropertyName(a);
				if (nameA) {
					return same(a.object, b.object) && nameA === astUtils.getStaticPropertyName(b);
				}
				return a.computed === b.computed && same(a.object, b.object) && same(a.property, b.property);
			}

		case "ThisExpression":
			return true;

		default:
			return false;
	}
}
module.exports = {
	meta: {
		docs: {
			description: "require or disallow \"Yoda\" conditions",
			category: "Best Practices",
			recommended: false
		},

		schema: [{
			enum: ["always", "never"]
		}, {
			type: "object",
			properties: {
				exceptRange: {
					type: "boolean"
				},
				onlyEquality: {
					type: "boolean"
				}
			},
			additionalProperties: false
		}],

		fixable: "code"
	},

	create: function create(context) {
		var always = context.options[0] === "always";
		var exceptRange = context.options[1] && context.options[1].exceptRange;
		var onlyEquality = context.options[1] && context.options[1].onlyEquality;

		var sourceCode = context.getSourceCode();
		function isRangeTest(node) {
			var left = node.left,
				right = node.right;
			function isBetweenTest() {
				var leftLiteral = void 0,
					rightLiteral = void 0;

				return node.operator === "&&" && (leftLiteral = getNormalizedLiteral(left.left)) && (rightLiteral = getNormalizedLiteral(right.right, Number.POSITIVE_INFINITY)) && leftLiteral.value <= rightLiteral.value && same(left.right, right.left);
			}
			function isOutsideTest() {
				var leftLiteral = void 0,
					rightLiteral = void 0;

				return node.operator === "||" && (leftLiteral = getNormalizedLiteral(left.right, Number.NEGATIVE_INFINITY)) && (rightLiteral = getNormalizedLiteral(right.left)) && leftLiteral.value <= rightLiteral.value && same(left.left, right.right);
			}
			function isParenWrapped() {
				return astUtils.isParenthesised(sourceCode, node);
			}

			return node.type === "LogicalExpression" && left.type === "BinaryExpression" && right.type === "BinaryExpression" && isRangeTestOperator(left.operator) && isRangeTestOperator(right.operator) && (isBetweenTest() || isOutsideTest()) && isParenWrapped();
		}

		var OPERATOR_FLIP_MAP = {
			"===": "===",
			"!==": "!==",
			"==": "==",
			"!=": "!=",
			"<": ">",
			">": "<",
			"<=": ">=",
			">=": "<="
		};
		function getFlippedString(node) {
			var operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, function (token) {
				return token.value === node.operator;
			});
			var textBeforeOperator = sourceCode.getText().slice(sourceCode.getTokenBefore(operatorToken).range[1], operatorToken.range[0]);
			var textAfterOperator = sourceCode.getText().slice(operatorToken.range[1], sourceCode.getTokenAfter(operatorToken).range[0]);
			var leftText = sourceCode.getText().slice(node.range[0], sourceCode.getTokenBefore(operatorToken).range[1]);
			var rightText = sourceCode.getText().slice(sourceCode.getTokenAfter(operatorToken).range[0], node.range[1]);

			return rightText + textBeforeOperator + OPERATOR_FLIP_MAP[operatorToken.value] + textAfterOperator + leftText;
		}
		return {
			BinaryExpression: function BinaryExpression(node) {
				var expectedLiteral = always ? node.left : node.right;
				var expectedNonLiteral = always ? node.right : node.left;
				if ((expectedNonLiteral.type === "Literal" || looksLikeLiteral(expectedNonLiteral)) && !(expectedLiteral.type === "Literal" || looksLikeLiteral(expectedLiteral)) && !(!isEqualityOperator(node.operator) && onlyEquality) && isComparisonOperator(node.operator) && !(exceptRange && isRangeTest(context.getAncestors().pop()))) {
					context.report({
						node: node,
						message: "Expected literal to be on the {{expectedSide}} side of {{operator}}.",
						data: {
							operator: node.operator,
							expectedSide: always ? "left" : "right"
						},
						fix: function fix(fixer) {
							return fixer.replaceText(node, getFlippedString(node));
						}
					});
				}
			}
		};
	}
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);

var allRules = {
  'boolean-prop-naming': __webpack_require__(660),
  'default-props-match-prop-types': __webpack_require__(661),
  'display-name': __webpack_require__(662),
  'forbid-component-props': __webpack_require__(663),
  'forbid-elements': __webpack_require__(664),
  'forbid-prop-types': __webpack_require__(665),
  'forbid-foreign-prop-types': __webpack_require__(666),
  'jsx-boolean-value': __webpack_require__(667),
  'jsx-closing-bracket-location': __webpack_require__(668),
  'jsx-closing-tag-location': __webpack_require__(669),
  'jsx-curly-spacing': __webpack_require__(670),
  'jsx-equals-spacing': __webpack_require__(671),
  'jsx-filename-extension': __webpack_require__(672),
  'jsx-first-prop-new-line': __webpack_require__(673),
  'jsx-handler-names': __webpack_require__(674),
  'jsx-indent': __webpack_require__(675),
  'jsx-indent-props': __webpack_require__(676),
  'jsx-key': __webpack_require__(677),
  'jsx-max-props-per-line': __webpack_require__(700),
  'jsx-no-bind': __webpack_require__(701),
  'jsx-no-comment-textnodes': __webpack_require__(702),
  'jsx-no-duplicate-props': __webpack_require__(703),
  'jsx-no-literals': __webpack_require__(704),
  'jsx-no-target-blank': __webpack_require__(705),
  'jsx-no-undef': __webpack_require__(706),
  'jsx-curly-brace-presence': __webpack_require__(707),
  'jsx-pascal-case': __webpack_require__(708),
  'jsx-sort-props': __webpack_require__(709),
  'jsx-space-before-closing': __webpack_require__(710),
  'jsx-tag-spacing': __webpack_require__(711),
  'jsx-uses-react': __webpack_require__(712),
  'jsx-uses-vars': __webpack_require__(713),
  'jsx-wrap-multilines': __webpack_require__(714),
  'no-array-index-key': __webpack_require__(715),
  'no-children-prop': __webpack_require__(716),
  'no-danger': __webpack_require__(717),
  'no-danger-with-children': __webpack_require__(718),
  'no-deprecated': __webpack_require__(719),
  'no-did-mount-set-state': __webpack_require__(720),
  'no-did-update-set-state': __webpack_require__(721),
  'no-direct-mutation-state': __webpack_require__(722),
  'no-find-dom-node': __webpack_require__(723),
  'no-is-mounted': __webpack_require__(724),
  'no-multi-comp': __webpack_require__(725),
  'no-set-state': __webpack_require__(726),
  'no-string-refs': __webpack_require__(727),
  'no-redundant-should-component-update': __webpack_require__(728),
  'no-render-return-value': __webpack_require__(729),
  'no-typos': __webpack_require__(730),
  'no-unescaped-entities': __webpack_require__(735),
  'no-unknown-property': __webpack_require__(736),
  'no-unused-prop-types': __webpack_require__(737),
  'no-unused-state': __webpack_require__(738),
  'no-will-update-set-state': __webpack_require__(739),
  'prefer-es6-class': __webpack_require__(740),
  'prefer-stateless-function': __webpack_require__(741),
  'prop-types': __webpack_require__(742),
  'react-in-jsx-scope': __webpack_require__(743),
  'require-default-props': __webpack_require__(744),
  'require-optimization': __webpack_require__(745),
  'require-render-return': __webpack_require__(746),
  'self-closing-comp': __webpack_require__(747),
  'sort-comp': __webpack_require__(748),
  'sort-prop-types': __webpack_require__(749),
  'style-prop-object': __webpack_require__(750),
  'void-dom-elements-no-children': __webpack_require__(751)
};

function filterRules(rules, predicate) {
  var result = {};
  for (var key in rules) {
	if (has(rules, key) && predicate(rules[key])) {
			result[key] = rules[key];
	}
  }
  return result;
}

function configureAsError(rules) {
  var result = {};
  for (var key in rules) {
	if (!has(rules, key)) {
			continue;
	}
	result['react/' + key] = 2;
  }
  return result;
}

var activeRules = filterRules(allRules, function (rule) {
  return !rule.meta.deprecated;
});
var activeRulesConfig = configureAsError(activeRules);

var deprecatedRules = filterRules(allRules, function (rule) {
  return rule.meta.deprecated;
});

module.exports = {
  deprecatedRules: deprecatedRules,
  rules: allRules,
  configs: {
	recommended: {
			plugins: ['react'],
			parserOptions: {
		ecmaFeatures: {
					jsx: true
		}
			},
			rules: {
		'react/display-name': 2,
		'react/jsx-key': 2,
		'react/jsx-no-comment-textnodes': 2,
		'react/jsx-no-duplicate-props': 2,
		'react/jsx-no-target-blank': 2,
		'react/jsx-no-undef': 2,
		'react/jsx-uses-react': 2,
		'react/jsx-uses-vars': 2,
		'react/no-children-prop': 2,
		'react/no-danger-with-children': 2,
		'react/no-deprecated': 2,
		'react/no-direct-mutation-state': 2,
		'react/no-find-dom-node': 2,
		'react/no-is-mounted': 2,
		'react/no-render-return-value': 2,
		'react/no-string-refs': 2,
		'react/no-unescaped-entities': 2,
		'react/no-unknown-property': 2,
		'react/prop-types': 2,
		'react/react-in-jsx-scope': 2,
		'react/require-render-return': 2
			}
	},
	all: {
			plugins: ['react'],
			parserOptions: {
		ecmaFeatures: {
					jsx: true
		}
			},
			rules: activeRulesConfig
	}
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var implementation = __webpack_require__(659);

module.exports = Function.prototype.bind || implementation;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
	var target = this;
	if (typeof target !== 'function' || toStr.call(target) !== funcType) {
		throw new TypeError(ERROR_MESSAGE + target);
	}
	var args = slice.call(arguments, 1);

	var bound;
	var binder = function binder() {
		if (this instanceof bound) {
			var result = target.apply(this, args.concat(slice.call(arguments)));
			if (Object(result) === result) {
				return result;
			}
			return this;
		} else {
			return target.apply(that, args.concat(slice.call(arguments)));
		}
	};

	var boundLength = Math.max(0, target.length - args.length);
	var boundArgs = [];
	for (var i = 0; i < boundLength; i++) {
		boundArgs.push('$' + i);
	}

	bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

	if (target.prototype) {
		var Empty = function Empty() {};
		Empty.prototype = target.prototype;
		bound.prototype = new Empty();
		Empty.prototype = null;
	}

	return bound;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
var Components = __webpack_require__(8);
module.exports = {
  meta: {
	docs: {
			category: 'Stylistic Issues',
			description: 'Enforces consistent naming for boolean props',
			recommended: false
	},

	schema: [{
			additionalProperties: false,
			properties: {
		propTypeNames: {
					items: {
			type: 'string'
					},
					minItems: 1,
					type: 'array',
					uniqueItems: true
		},
		rule: {
					default: '^(is|has)[A-Z]([A-Za-z0-9]?)+',
					minLength: 1,
					type: 'string'
		}
			},
			type: 'object'
	}]
  },

  create: Components.detect(function (context, components, utils) {
	var sourceCode = context.getSourceCode();
	var config = context.options[0] || {};
	var rule = config.rule ? new RegExp(config.rule) : null;
	var propTypeNames = config.propTypeNames || ['bool'];
	var objectTypeAnnotations = new Map();
	function isPropTypesDeclaration(node) {
			if (node && node.type === 'ClassProperty') {
		var tokens = context.getFirstTokens(node, 2);
		if (tokens[0].value === 'propTypes' || tokens[1] && tokens[1].value === 'propTypes') {
					return true;
		}
		if (node.typeAnnotation && node.key.name === 'props') {
					return true;
		}
		return false;
			}

			return Boolean(node && node.name === 'propTypes');
	}
	function getPropKey(node) {
			if (node.value.property) {
		return node.value.property.name;
			}
			if (node.value.type === 'Identifier') {
		return node.value.name;
			}
			return null;
	}
	function getPropName(node) {
			if (node.type === 'ObjectTypeProperty') {
		return sourceCode.getFirstToken(node).value;
			}

			return node.key.name;
	}
	function validatePropNaming(node, proptypes) {
			var component = components.get(node) || node;
			var invalidProps = component.invalidProps || [];

			(proptypes || []).forEach(function (prop) {
		var propKey = getPropKey(prop);
		var flowCheck = prop.type === 'ObjectTypeProperty' && prop.value.type === 'BooleanTypeAnnotation' && rule.test(getPropName(prop)) === false;
		var regularCheck = propKey && propTypeNames.indexOf(propKey) >= 0 && rule.test(getPropName(prop)) === false;

		if (flowCheck || regularCheck) {
					invalidProps.push(prop);
		}
			});

			components.set(node, {
		invalidProps: invalidProps
			});
	}
	function reportInvalidNaming(component) {
			component.invalidProps.forEach(function (propNode) {
		var propName = getPropName(propNode);
		context.report({
					node: propNode,
					message: 'Prop name (' + propName + ') doesn\'t match rule (' + config.rule + ')',
					data: {
			component: propName
					}
		});
			});
	}
	return {
			ClassProperty: function ClassProperty(node) {
		if (!rule || !isPropTypesDeclaration(node)) {
					return;
		}
		if (node.value && node.value.properties) {
					validatePropNaming(node, node.value.properties);
		}
		if (node.typeAnnotation && node.typeAnnotation.typeAnnotation) {
					validatePropNaming(node, node.typeAnnotation.typeAnnotation.properties);
		}
			},

			MemberExpression: function MemberExpression(node) {
		if (!rule || !isPropTypesDeclaration(node.property)) {
					return;
		}
		var component = utils.getRelatedComponent(node);
		if (!component || !node.parent.right.properties) {
					return;
		}
		validatePropNaming(component.node, node.parent.right.properties);
			},

			ObjectExpression: function ObjectExpression(node) {
		if (!rule) {
					return;
		}
		node.properties.forEach(function (property) {
					if (!isPropTypesDeclaration(property.key)) {
			return;
					}
					validatePropNaming(node, property.value.properties);
		});
			},

			TypeAlias: function TypeAlias(node) {
		if (node.right.type === 'ObjectTypeAnnotation') {
					objectTypeAnnotations.set(node.id.name, node.right);
		}
			},

			'Program:exit': function ProgramExit() {
		if (!rule) {
					return;
		}

		var list = components.list();
		Object.keys(list).forEach(function (component) {
					if (list[component].node.type === 'FunctionDeclaration' && list[component].node.params && list[component].node.params.length && list[component].node.params[0].typeAnnotation) {
			var typeNode = list[component].node.params[0].typeAnnotation;
			var propType = objectTypeAnnotations.get(typeNode.typeAnnotation.id.name);
			if (propType) {
							validatePropNaming(list[component].node, propType.properties);
			}
					}

					if (!has(list, component) || (list[component].invalidProps || []).length) {
			reportInvalidNaming(list[component]);
					}
		});
		objectTypeAnnotations.clear();
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
var Components = __webpack_require__(8);
var variableUtil = __webpack_require__(27);
var annotations = __webpack_require__(72);
module.exports = {
  meta: {
	docs: {
			description: 'Enforce all defaultProps are defined and not "required" in propTypes.',
			category: 'Best Practices'
	},

	schema: [{
			type: 'object',
			properties: {
		allowRequiredDefaults: {
					default: false,
					type: 'boolean'
		}
			},
			additionalProperties: false
	}]
  },

  create: Components.detect(function (context, components, utils) {
	var configuration = context.options[0] || {};
	var allowRequiredDefaults = configuration.allowRequiredDefaults || false;
	var propWrapperFunctions = new Set(context.settings.propWrapperFunctions || []);
	function getPropertyName(node) {
			if (node.key || ['MethodDefinition', 'Property'].indexOf(node.type) !== -1) {
		return node.key.name;
			} else if (node.type === 'MemberExpression') {
		return node.property.name;
			} else if (node.type === 'ClassProperty') {
		var tokens = context.getFirstTokens(node, 2);
		return tokens[1] && tokens[1].type === 'Identifier' ? tokens[1].value : tokens[0].value;
			}
			return '';
	}
	function isPropTypesDeclaration(node) {
			return getPropertyName(node) === 'propTypes';
	}
	function isDefaultPropsDeclaration(node) {
			var propName = getPropertyName(node);
			return propName === 'defaultProps' || propName === 'getDefaultProps';
	}
	function isRequiredPropType(propTypeExpression) {
			return propTypeExpression.type === 'MemberExpression' && propTypeExpression.property.name === 'isRequired';
	}
	function findVariableByName(name) {
			var variable = variableUtil.variablesInScope(context).find(function (item) {
		return item.name === name;
			});

			if (!variable || !variable.defs[0] || !variable.defs[0].node) {
		return null;
			}

			if (variable.defs[0].node.type === 'TypeAlias') {
		return variable.defs[0].node.right;
			}

			return variable.defs[0].node.init;
	}
	function resolveNodeValue(node) {
			if (node.type === 'Identifier') {
		return findVariableByName(node.name);
			}
			if (node.type === 'CallExpression' && propWrapperFunctions.has(node.callee.name) && node.arguments && node.arguments[0]) {
		return resolveNodeValue(node.arguments[0]);
			}
			return node;
	}
	function resolveGenericTypeAnnotation(node) {
			if (node.type !== 'GenericTypeAnnotation' || node.id.type !== 'Identifier') {
		return null;
			}

			return findVariableByName(node.id.name);
	}

	function resolveUnionTypeAnnotation(node) {
			return node.types.map(function (annotation) {
		if (annotation.type === 'GenericTypeAnnotation') {
					return resolveGenericTypeAnnotation(annotation);
		}

		return annotation;
			});
	}
	function getPropTypesFromObjectExpression(objectExpression) {
			var props = objectExpression.properties.filter(function (property) {
		return property.type !== 'ExperimentalSpreadProperty';
			});

			return props.map(function (property) {
		return {
					name: property.key.name,
					isRequired: isRequiredPropType(property.value),
					node: property
		};
			});
	}
	function getPropertiesFromIntersectionTypeAnnotationNode(annotation) {
			return annotation.types.reduce(function (properties, type) {
		annotation = resolveGenericTypeAnnotation(type);

		if (annotation && annotation.id) {
					annotation = findVariableByName(annotation.id.name);
		}

		return properties.concat(annotation.properties);
			}, []);
	}
	function getPropTypesFromTypeAnnotation(node) {
			var properties = [];

			switch (node.typeAnnotation.type) {
		case 'GenericTypeAnnotation':
					var annotation = resolveGenericTypeAnnotation(node.typeAnnotation);

					if (annotation && annotation.type === 'IntersectionTypeAnnotation') {
			properties = getPropertiesFromIntersectionTypeAnnotationNode(annotation);
					} else {
			if (annotation && annotation.id) {
							annotation = findVariableByName(annotation.id.name);
			}

			properties = annotation ? annotation.properties || [] : [];
					}

					break;

		case 'UnionTypeAnnotation':
					var union = resolveUnionTypeAnnotation(node.typeAnnotation);
					properties = union.reduce(function (acc, curr) {
			if (!curr) {
							return acc;
			}

			return acc.concat(curr.properties);
					}, []);
					break;

		case 'ObjectTypeAnnotation':
					properties = node.typeAnnotation.properties;
					break;

		default:
					properties = [];
					break;
			}

			var props = properties.filter(function (property) {
		return property.type === 'ObjectTypeProperty';
			});

			return props.map(function (property) {
		var tokens = context.getFirstTokens(property, 1);
		var name = tokens[0].value;

		return {
					name: name,
					isRequired: !property.optional,
					node: property
		};
			});
	}
	function getDefaultPropsFromObjectExpression(objectExpression) {
			var hasSpread = objectExpression.properties.find(function (property) {
		return property.type === 'ExperimentalSpreadProperty';
			});

			if (hasSpread) {
		return 'unresolved';
			}

			return objectExpression.properties.map(function (defaultProp) {
		return {
					name: defaultProp.key.name,
					node: defaultProp
		};
			});
	}
	function markDefaultPropsAsUnresolved(component) {
			components.set(component.node, {
		defaultProps: 'unresolved'
			});
	}
	function addPropTypesToComponent(component, propTypes) {
			var props = component.propTypes || [];

			components.set(component.node, {
		propTypes: props.concat(propTypes)
			});
	}
	function addDefaultPropsToComponent(component, defaultProps) {
			if (component.defaultProps === 'unresolved') {
		return;
			}

			if (defaultProps === 'unresolved') {
		markDefaultPropsAsUnresolved(component);
		return;
			}

			var defaults = component.defaultProps || [];

			components.set(component.node, {
		defaultProps: defaults.concat(defaultProps)
			});
	}
	function handleStatelessComponent(node) {
			if (!node.params || !node.params.length || !annotations.isAnnotatedFunctionPropsDeclaration(node, context)) {
		return;
			}
			var component = components.get(utils.getParentStatelessComponent());
			if (!component) {
		return;
			}

			addPropTypesToComponent(component, getPropTypesFromTypeAnnotation(node.params[0].typeAnnotation, context));
	}

	function handlePropTypeAnnotationClassProperty(node) {
			var component = components.get(utils.getParentES6Component());
			if (!component) {
		return;
			}
			addPropTypesToComponent(component, getPropTypesFromTypeAnnotation(node.typeAnnotation, context));
	}

	function isPropTypeAnnotation(node) {
			return getPropertyName(node) === 'props' && !!node.typeAnnotation;
	}

	function propFromName(propTypes, name) {
			return propTypes.find(function (prop) {
		return prop.name === name;
			});
	}
	function reportInvalidDefaultProps(propTypes, defaultProps) {
			if (defaultProps === 'unresolved' || !propTypes) {
		return;
			}

			defaultProps.forEach(function (defaultProp) {
		var prop = propFromName(propTypes, defaultProp.name);

		if (prop && (allowRequiredDefaults || !prop.isRequired)) {
					return;
		}

		if (prop) {
					context.report(defaultProp.node, 'defaultProp "{{name}}" defined for isRequired propType.', { name: defaultProp.name });
		} else {
					context.report(defaultProp.node, 'defaultProp "{{name}}" has no corresponding propTypes declaration.', { name: defaultProp.name });
		}
			});
	}
	return {
			MemberExpression: function MemberExpression(node) {
		var isPropType = isPropTypesDeclaration(node);
		var isDefaultProp = isDefaultPropsDeclaration(node);

		if (!isPropType && !isDefaultProp) {
					return;
		}
		var component = utils.getRelatedComponent(node);
		if (!component) {
					return;
		}
		//
		//
		if (node.parent.type === 'AssignmentExpression') {
					var expression = resolveNodeValue(node.parent.right);
					if (!expression || expression.type !== 'ObjectExpression') {
			if (isDefaultProp) {
							markDefaultPropsAsUnresolved(component);
			}

			return;
					}

					if (isPropType) {
			addPropTypesToComponent(component, getPropTypesFromObjectExpression(expression));
					} else {
			addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(expression));
					}

					return;
		}
		if (node.parent.type === 'MemberExpression' && node.parent.parent && node.parent.parent.type === 'AssignmentExpression') {
					if (isPropType) {
			addPropTypesToComponent(component, [{
							name: node.parent.property.name,
							isRequired: isRequiredPropType(node.parent.parent.right),
							node: node.parent.parent
			}]);
					} else {
			addDefaultPropsToComponent(component, [{
							name: node.parent.property.name,
							node: node.parent.parent
			}]);
					}

					return;
		}
			},
			MethodDefinition: function MethodDefinition(node) {
		if (!node.static || node.kind !== 'get') {
					return;
		}

		var isPropType = isPropTypesDeclaration(node);
		var isDefaultProp = isDefaultPropsDeclaration(node);

		if (!isPropType && !isDefaultProp) {
					return;
		}
		var component = components.get(utils.getParentES6Component());
		if (!component) {
					return;
		}

		var returnStatement = utils.findReturnStatement(node);
		if (!returnStatement) {
					return;
		}

		var expression = resolveNodeValue(returnStatement.argument);
		if (!expression || expression.type !== 'ObjectExpression') {
					return;
		}

		if (isPropType) {
					addPropTypesToComponent(component, getPropTypesFromObjectExpression(expression));
		} else {
					addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(expression));
		}
			},
			ClassProperty: function ClassProperty(node) {
		if (isPropTypeAnnotation(node)) {
					handlePropTypeAnnotationClassProperty(node);
					return;
		}

		if (!node.static) {
					return;
		}

		if (!node.value) {
					return;
		}

		var propName = getPropertyName(node);
		var isPropType = propName === 'propTypes';
		var isDefaultProp = propName === 'defaultProps' || propName === 'getDefaultProps';

		if (!isPropType && !isDefaultProp) {
					return;
		}
		var component = components.get(utils.getParentES6Component());
		if (!component) {
					return;
		}

		var expression = resolveNodeValue(node.value);
		if (!expression || expression.type !== 'ObjectExpression') {
					return;
		}

		if (isPropType) {
					addPropTypesToComponent(component, getPropTypesFromObjectExpression(expression));
		} else {
					addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(expression));
		}
			},
			ObjectExpression: function ObjectExpression(node) {
		var component = utils.isES5Component(node) && components.get(node);
		if (!component) {
					return;
		}
		node.properties.forEach(function (property) {
					if (property.type === 'ExperimentalSpreadProperty') {
			return;
					}

					var isPropType = isPropTypesDeclaration(property);
					var isDefaultProp = isDefaultPropsDeclaration(property);

					if (!isPropType && !isDefaultProp) {
			return;
					}

					if (isPropType && property.value.type === 'ObjectExpression') {
			addPropTypesToComponent(component, getPropTypesFromObjectExpression(property.value));
			return;
					}

					if (isDefaultProp && property.value.type === 'FunctionExpression') {
			var returnStatement = utils.findReturnStatement(property);
			if (!returnStatement || returnStatement.argument.type !== 'ObjectExpression') {
							return;
			}

			addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(returnStatement.argument));
					}
		});
			},
			FunctionDeclaration: handleStatelessComponent,
			ArrowFunctionExpression: handleStatelessComponent,
			FunctionExpression: handleStatelessComponent,

			'Program:exit': function ProgramExit() {
		var list = components.list();

		for (var component in list) {
					if (!has(list, component)) {
			continue;
					}
					if (!list[component].defaultProps) {
			return;
					}

					reportInvalidDefaultProps(list[component].propTypes, list[component].defaultProps || {});
		}
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
var Components = __webpack_require__(8);
module.exports = {
  meta: {
	docs: {
			description: 'Prevent missing displayName in a React component definition',
			category: 'Best Practices',
			recommended: true
	},

	schema: [{
			type: 'object',
			properties: {
		ignoreTranspilerName: {
					type: 'boolean'
		}
			},
			additionalProperties: false
	}]
  },

  create: Components.detect(function (context, components, utils) {
	var sourceCode = context.getSourceCode();
	var config = context.options[0] || {};
	var ignoreTranspilerName = config.ignoreTranspilerName || false;

	var MISSING_MESSAGE = 'Component definition is missing display name';
	function isDisplayNameDeclaration(node) {
			switch (node.type) {
		case 'ClassProperty':
					var tokens = sourceCode.getFirstTokens(node, 2);
					if (tokens[0].value === 'displayName' || tokens[1] && tokens[1].value === 'displayName') {
			return true;
					}
					return false;
		case 'Identifier':
					return node.name === 'displayName';
		case 'Literal':
					return node.value === 'displayName';
		default:
					return false;
			}
	}
	function markDisplayNameAsDeclared(node) {
			components.set(node, {
		hasDisplayName: true
			});
	}
	function reportMissingDisplayName(component) {
			context.report({
		node: component.node,
		message: MISSING_MESSAGE,
		data: {
					component: component.name
		}
			});
	}
	function hasTranspilerName(node) {
			var namedObjectAssignment = node.type === 'ObjectExpression' && node.parent && node.parent.parent && node.parent.parent.type === 'AssignmentExpression' && (!node.parent.parent.left.object || node.parent.parent.left.object.name !== 'module' || node.parent.parent.left.property.name !== 'exports');
			var namedObjectDeclaration = node.type === 'ObjectExpression' && node.parent && node.parent.parent && node.parent.parent.type === 'VariableDeclarator';
			var namedClass = (node.type === 'ClassDeclaration' || node.type === 'ClassExpression') && node.id && node.id.name;

			var namedFunctionDeclaration = (node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression') && node.id && node.id.name;

			var namedFunctionExpression = (node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression') && node.parent && (node.parent.type === 'VariableDeclarator' || node.parent.method === true) && (!node.parent.parent || !utils.isES5Component(node.parent.parent));

			if (namedObjectAssignment || namedObjectDeclaration || namedClass || namedFunctionDeclaration || namedFunctionExpression) {
		return true;
			}
			return false;
	}
	return {

			ClassProperty: function ClassProperty(node) {
		if (!isDisplayNameDeclaration(node)) {
					return;
		}
		markDisplayNameAsDeclared(node);
			},

			MemberExpression: function MemberExpression(node) {
		if (!isDisplayNameDeclaration(node.property)) {
					return;
		}
		var component = utils.getRelatedComponent(node);
		if (!component) {
					return;
		}
		markDisplayNameAsDeclared(component.node);
			},

			FunctionExpression: function FunctionExpression(node) {
		if (ignoreTranspilerName || !hasTranspilerName(node)) {
					return;
		}
		markDisplayNameAsDeclared(node);
			},

			FunctionDeclaration: function FunctionDeclaration(node) {
		if (ignoreTranspilerName || !hasTranspilerName(node)) {
					return;
		}
		markDisplayNameAsDeclared(node);
			},

			ArrowFunctionExpression: function ArrowFunctionExpression(node) {
		if (ignoreTranspilerName || !hasTranspilerName(node)) {
					return;
		}
		markDisplayNameAsDeclared(node);
			},

			MethodDefinition: function MethodDefinition(node) {
		if (!isDisplayNameDeclaration(node.key)) {
					return;
		}
		markDisplayNameAsDeclared(node);
			},

			ClassExpression: function ClassExpression(node) {
		if (ignoreTranspilerName || !hasTranspilerName(node)) {
					return;
		}
		markDisplayNameAsDeclared(node);
			},

			ClassDeclaration: function ClassDeclaration(node) {
		if (ignoreTranspilerName || !hasTranspilerName(node)) {
					return;
		}
		markDisplayNameAsDeclared(node);
			},

			ObjectExpression: function ObjectExpression(node) {
		if (ignoreTranspilerName || !hasTranspilerName(node)) {
					node.properties.forEach(function (property) {
			if (!property.key || !isDisplayNameDeclaration(property.key)) {
							return;
			}
			markDisplayNameAsDeclared(node);
					});
					return;
		}
		markDisplayNameAsDeclared(node);
			},

			'Program:exit': function ProgramExit() {
		var list = components.list();
		for (var component in list) {
					if (!has(list, component) || list[component].hasDisplayName) {
			continue;
					}
					reportMissingDisplayName(list[component]);
		}
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var DEFAULTS = ['className', 'style'];
module.exports = {
  meta: {
	docs: {
			description: 'Forbid certain props on components',
			category: 'Best Practices',
			recommended: false
	},

	schema: [{
			type: 'object',
			properties: {
		forbid: {
					type: 'array',
					items: {
			type: 'string'
					}
		}
			},
			additionalProperties: true
	}]
  },

  create: function create(context) {
	function isForbidden(prop) {
			var configuration = context.options[0] || {};

			var forbid = configuration.forbid || DEFAULTS;
			return forbid.indexOf(prop) >= 0;
	}

	return {
			JSXAttribute: function JSXAttribute(node) {
		var tag = node.parent.name.name;
		if (tag && tag[0] !== tag[0].toUpperCase()) {
					return;
		}

		var prop = node.name.name;

		if (!isForbidden(prop)) {
					return;
		}

		context.report({
					node: node,
					message: 'Prop `' + prop + '` is forbidden on Components'
		});
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
module.exports = {
  meta: {
	docs: {
			description: 'Forbid certain elements',
			category: 'Best Practices',
			recommended: false
	},

	schema: [{
			type: 'object',
			properties: {
		forbid: {
					type: 'array',
					items: {
			anyOf: [{ type: 'string' }, {
							type: 'object',
							properties: {
				element: { type: 'string' },
				message: { type: 'string' }
							},
							required: ['element'],
							additionalProperties: false
			}]
					}
		}
			},
			additionalProperties: false
	}]
  },

  create: function create(context) {
	var sourceCode = context.getSourceCode();
	var configuration = context.options[0] || {};
	var forbidConfiguration = configuration.forbid || [];

	var indexedForbidConfigs = {};

	forbidConfiguration.forEach(function (item) {
			if (typeof item === 'string') {
		indexedForbidConfigs[item] = { element: item };
			} else {
		indexedForbidConfigs[item.element] = item;
			}
	});

	function errorMessageForElement(name) {
			var message = '<' + name + '> is forbidden';
			var additionalMessage = indexedForbidConfigs[name].message;

			if (additionalMessage) {
		return message + ', ' + additionalMessage;
			}

			return message;
	}

	function isValidCreateElement(node) {
			return node.callee && node.callee.type === 'MemberExpression' && node.callee.object.name === 'React' && node.callee.property.name === 'createElement' && node.arguments.length > 0;
	}

	function reportIfForbidden(element, node) {
			if (has(indexedForbidConfigs, element)) {
		context.report({
					node: node,
					message: errorMessageForElement(element)
		});
			}
	}

	return {
			JSXOpeningElement: function JSXOpeningElement(node) {
		reportIfForbidden(sourceCode.getText(node.name), node.name);
			},

			CallExpression: function CallExpression(node) {
		if (!isValidCreateElement(node)) {
					return;
		}

		var argument = node.arguments[0];
		var argType = argument.type;

		if (argType === 'Identifier' && /^[A-Z_]/.test(argument.name)) {
					reportIfForbidden(argument.name, argument);
		} else if (argType === 'Literal' && /^[a-z][^\.]*$/.test(argument.value)) {
					reportIfForbidden(argument.value, argument);
		} else if (argType === 'MemberExpression') {
					reportIfForbidden(sourceCode.getText(argument), argument);
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var variableUtil = __webpack_require__(27);
var DEFAULTS = ['any', 'array', 'object'];
module.exports = {
  meta: {
	docs: {
			description: 'Forbid certain propTypes',
			category: 'Best Practices',
			recommended: false
	},

	schema: [{
			type: 'object',
			properties: {
		forbid: {
					type: 'array',
					items: {
			type: 'string'
					}
		}
			},
			additionalProperties: true
	}]
  },

  create: function create(context) {
	var propWrapperFunctions = new Set(context.settings.propWrapperFunctions || []);

	function isForbidden(type) {
			var configuration = context.options[0] || {};

			var forbid = configuration.forbid || DEFAULTS;
			return forbid.indexOf(type) >= 0;
	}
	function isPropTypesDeclaration(node) {
			if (node.type === 'ClassProperty') {
		var tokens = context.getFirstTokens(node, 2);
		if (tokens[0].value === 'propTypes' || tokens[1] && tokens[1].value === 'propTypes') {
					return true;
		}
		return false;
			}

			return Boolean(node && node.name === 'propTypes');
	}
	function findVariableByName(name) {
			var variable = variableUtil.variablesInScope(context).find(function (item) {
		return item.name === name;
			});

			if (!variable || !variable.defs[0] || !variable.defs[0].node) {
		return null;
			}

			if (variable.defs[0].node.type === 'TypeAlias') {
		return variable.defs[0].node.right;
			}

			return variable.defs[0].node.init;
	}
	function checkProperties(declarations) {
			declarations.forEach(function (declaration) {
		if (declaration.type !== 'Property') {
					return;
		}
		var target = void 0;
		var value = declaration.value;
		if (value.type === 'MemberExpression' && value.property && value.property.name && value.property.name === 'isRequired') {
					value = value.object;
		}
		if (value.type === 'CallExpression' && value.callee.type === 'MemberExpression') {
					value = value.callee;
		}
		if (value.property) {
					target = value.property.name;
		} else if (value.type === 'Identifier') {
					target = value.name;
		}
		if (isForbidden(target)) {
					context.report({
			node: declaration,
			message: 'Prop type `' + target + '` is forbidden'
					});
		}
			});
	}

	function checkNode(node) {
			switch (node && node.type) {
		case 'ObjectExpression':
					checkProperties(node.properties);
					break;
		case 'Identifier':
					var propTypesObject = findVariableByName(node.name);
					if (propTypesObject && propTypesObject.properties) {
			checkProperties(propTypesObject.properties);
					}
					break;
		case 'CallExpression':
					var innerNode = node.arguments && node.arguments[0];
					if (propWrapperFunctions.has(node.callee.name) && innerNode) {
			checkNode(innerNode);
					}
					break;
		default:
					break;
			}
	}

	return {
			ClassProperty: function ClassProperty(node) {
		if (!isPropTypesDeclaration(node)) {
					return;
		}
		checkNode(node.value);
			},

			MemberExpression: function MemberExpression(node) {
		if (!isPropTypesDeclaration(node.property)) {
					return;
		}

		checkNode(node.parent.right);
			},

			ObjectExpression: function ObjectExpression(node) {
		node.properties.forEach(function (property) {
					if (!property.key) {
			return;
					}

					if (!isPropTypesDeclaration(property.key)) {
			return;
					}
					if (property.value.type === 'ObjectExpression') {
			checkProperties(property.value.properties);
					}
		});
			}

	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
  meta: {
	docs: {
			description: 'Forbid using another component\'s propTypes',
			category: 'Best Practices',
			recommended: false
	}
  },

  create: function create(context) {
	function isLeftSideOfAssignment(node) {
			return node.parent.type === 'AssignmentExpression' && node.parent.left === node;
	}

	return {
			MemberExpression: function MemberExpression(node) {
		if (!node.computed && node.property && node.property.type === 'Identifier' && node.property.name === 'propTypes' && !isLeftSideOfAssignment(node) || node.property && node.property.type === 'Literal' && node.property.value === 'propTypes' && !isLeftSideOfAssignment(node)) {
					context.report({
			node: node.property,
			message: 'Using another component\'s propTypes is forbidden'
					});
		}
			},

			ObjectPattern: function ObjectPattern(node) {
		var propTypesNode = node.properties.find(function (property) {
					return property.type === 'Property' && property.key.name === 'propTypes';
		});

		if (propTypesNode) {
					context.report({
			node: propTypesNode,
			message: 'Using another component\'s propTypes is forbidden'
					});
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var exceptionsSchema = {
  type: 'array',
  items: { type: 'string', minLength: 1 },
  uniqueItems: true
};

var ALWAYS = 'always';
var NEVER = 'never';

var errorData = new WeakMap();
function getErrorData(exceptions) {
  if (!errorData.has(exceptions)) {
	var exceptionProps = Array.from(exceptions, function (name) {
			return '`' + name + '`';
	}).join(', ');
	var exceptionsMessage = exceptions.size > 0 ? ' for the following props: ' + exceptionProps : '';
	errorData.set(exceptions, { exceptionsMessage: exceptionsMessage });
  }
  return errorData.get(exceptions);
}

function isAlways(configuration, exceptions, propName) {
  var isException = exceptions.has(propName);
  if (configuration === ALWAYS) {
	return !isException;
  }
  return isException;
}

function isNever(configuration, exceptions, propName) {
  var isException = exceptions.has(propName);
  if (configuration === NEVER) {
	return !isException;
  }
  return isException;
}

module.exports = {
  meta: {
	docs: {
			description: 'Enforce boolean attributes notation in JSX',
			category: 'Stylistic Issues',
			recommended: false
	},
	fixable: 'code',

	schema: {
			anyOf: [{
		type: 'array',
		items: [{ enum: [ALWAYS, NEVER] }],
		additionalItems: false
			}, {
		type: 'array',
		items: [{
					enum: [ALWAYS]
		}, {
					type: 'object',
					additionalProperties: false,
					properties: _defineProperty({}, NEVER, exceptionsSchema)
		}],
		additionalItems: false
			}, {
		type: 'array',
		items: [{
					enum: [NEVER]
		}, {
					type: 'object',
					additionalProperties: false,
					properties: _defineProperty({}, ALWAYS, exceptionsSchema)
		}],
		additionalItems: false
			}]
	}
  },

  create: function create(context) {
	var configuration = context.options[0] || NEVER;
	var configObject = context.options[1] || {};
	var exceptions = new Set((configuration === ALWAYS ? configObject[NEVER] : configObject[ALWAYS]) || []);

	var NEVER_MESSAGE = 'Value must be omitted for boolean attributes{{exceptionsMessage}}';
	var ALWAYS_MESSAGE = 'Value must be set for boolean attributes{{exceptionsMessage}}';

	return {
			JSXAttribute: function JSXAttribute(node) {
		var propName = node.name && node.name.name;
		var value = node.value;

		if (isAlways(configuration, exceptions, propName) && value === null) {
					var data = getErrorData(exceptions);
					context.report({
			node: node,
			message: ALWAYS_MESSAGE,
			data: data,
			fix: function fix(fixer) {
							return fixer.insertTextAfter(node, '={true}');
			}
					});
		}
		if (isNever(configuration, exceptions, propName) && value && value.type === 'JSXExpressionContainer' && value.expression.value === true) {
					var _data = getErrorData(exceptions);
					context.report({
			node: node,
			message: NEVER_MESSAGE,
			data: _data,
			fix: function fix(fixer) {
							return fixer.removeRange([node.name.range[1], value.range[1]]);
			}
					});
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var has = __webpack_require__(7);
module.exports = {
  meta: {
	docs: {
			description: 'Validate closing bracket location in JSX',
			category: 'Stylistic Issues',
			recommended: false
	},
	fixable: 'code',

	schema: [{
			oneOf: [{
		enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned']
			}, {
		type: 'object',
		properties: {
					location: {
			enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned']
					}
		},
		additionalProperties: false
			}, {
		type: 'object',
		properties: {
					nonEmpty: {
			enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned', false]
					},
					selfClosing: {
			enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned', false]
					}
		},
		additionalProperties: false
			}]
	}]
  },

  create: function create(context) {
	var MESSAGE = 'The closing bracket must be {{location}}{{details}}';
	var MESSAGE_LOCATION = {
			'after-props': 'placed after the last prop',
			'after-tag': 'placed after the opening tag',
			'props-aligned': 'aligned with the last prop',
			'tag-aligned': 'aligned with the opening tag',
			'line-aligned': 'aligned with the line containing the opening tag'
	};
	var DEFAULT_LOCATION = 'tag-aligned';

	var sourceCode = context.getSourceCode();
	var config = context.options[0];
	var options = {
			nonEmpty: DEFAULT_LOCATION,
			selfClosing: DEFAULT_LOCATION
	};

	if (typeof config === 'string') {
			options.nonEmpty = config;
			options.selfClosing = config;
	} else if ((typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object') {
			if (has(config, 'location')) {
		options.nonEmpty = config.location;
		options.selfClosing = config.location;
			}
			if (has(config, 'nonEmpty')) {
		options.nonEmpty = config.nonEmpty;
			}
			if (has(config, 'selfClosing')) {
		options.selfClosing = config.selfClosing;
			}
	}
	function getExpectedLocation(tokens) {
			var location = void 0;
			if (typeof tokens.lastProp === 'undefined') {
		location = 'after-tag';
			} else if (tokens.opening.line === tokens.lastProp.lastLine) {
		location = 'after-props';
			} else {
		location = tokens.selfClosing ? options.selfClosing : options.nonEmpty;
			}
			return location;
	}
	function getCorrectColumn(tokens, expectedLocation) {
			switch (expectedLocation) {
		case 'props-aligned':
					return tokens.lastProp.column;
		case 'tag-aligned':
					return tokens.opening.column;
		case 'line-aligned':
					return tokens.openingStartOfLine.column;
		default:
					return null;
			}
	}
	function hasCorrectLocation(tokens, expectedLocation) {
			switch (expectedLocation) {
		case 'after-tag':
					return tokens.tag.line === tokens.closing.line;
		case 'after-props':
					return tokens.lastProp.lastLine === tokens.closing.line;
		case 'props-aligned':
		case 'tag-aligned':
		case 'line-aligned':
					var correctColumn = getCorrectColumn(tokens, expectedLocation);
					return correctColumn === tokens.closing.column;
		default:
					return true;
			}
	}
	function getIndentation(tokens, expectedLocation, correctColumn) {
			var indentation = void 0,
					spaces = [];
			switch (expectedLocation) {
		case 'props-aligned':
					indentation = /^\s*/.exec(sourceCode.lines[tokens.lastProp.firstLine - 1])[0];
					break;
		case 'tag-aligned':
		case 'line-aligned':
					indentation = /^\s*/.exec(sourceCode.lines[tokens.opening.line - 1])[0];
					break;
		default:
					indentation = '';
			}
			if (indentation.length + 1 < correctColumn) {
		spaces = new Array(+correctColumn + 1 - indentation.length);
			}
			return indentation + spaces.join(' ');
	}
	function getTokensLocations(node) {
			var opening = sourceCode.getFirstToken(node).loc.start;
			var closing = sourceCode.getLastTokens(node, node.selfClosing ? 2 : 1)[0].loc.start;
			var tag = sourceCode.getFirstToken(node.name).loc.start;
			var lastProp = void 0;
			if (node.attributes.length) {
		lastProp = node.attributes[node.attributes.length - 1];
		lastProp = {
					column: sourceCode.getFirstToken(lastProp).loc.start.column,
					firstLine: sourceCode.getFirstToken(lastProp).loc.start.line,
					lastLine: sourceCode.getLastToken(lastProp).loc.end.line
		};
			}
			var openingLine = sourceCode.lines[opening.line - 1];
			var openingStartOfLine = {
		column: /^\s*/.exec(openingLine)[0].length,
		line: opening.line
			};
			return {
		tag: tag,
		opening: opening,
		closing: closing,
		lastProp: lastProp,
		selfClosing: node.selfClosing,
		openingStartOfLine: openingStartOfLine
			};
	}
	function getOpeningElementId(node) {
			return node.range.join(':');
	}

	var lastAttributeNode = {};

	return {
			JSXAttribute: function JSXAttribute(node) {
		lastAttributeNode[getOpeningElementId(node.parent)] = node;
			},

			JSXSpreadAttribute: function JSXSpreadAttribute(node) {
		lastAttributeNode[getOpeningElementId(node.parent)] = node;
			},

			'JSXOpeningElement:exit': function JSXOpeningElementExit(node) {
		var attributeNode = lastAttributeNode[getOpeningElementId(node)];
		var cachedLastAttributeEndPos = attributeNode ? attributeNode.end : null;
		var expectedNextLine = void 0;
		var tokens = getTokensLocations(node);
		var expectedLocation = getExpectedLocation(tokens);

		if (hasCorrectLocation(tokens, expectedLocation)) {
					return;
		}

		var data = { location: MESSAGE_LOCATION[expectedLocation], details: '' };
		var correctColumn = getCorrectColumn(tokens, expectedLocation);

		if (correctColumn !== null) {
					expectedNextLine = tokens.lastProp && tokens.lastProp.lastLine === tokens.closing.line;
					data.details = ' (expected column ' + (correctColumn + 1) + (expectedNextLine ? ' on the next line)' : ')');
		}

		context.report({
					node: node,
					loc: tokens.closing,
					message: MESSAGE,
					data: data,
					fix: function fix(fixer) {
			var closingTag = tokens.selfClosing ? '/>' : '>';
			switch (expectedLocation) {
							case 'after-tag':
				if (cachedLastAttributeEndPos) {
									return fixer.replaceTextRange([cachedLastAttributeEndPos, node.end], (expectedNextLine ? '\n' : '') + closingTag);
				}
				return fixer.replaceTextRange([node.name.range[1], node.end], (expectedNextLine ? '\n' : ' ') + closingTag);
							case 'after-props':
				return fixer.replaceTextRange([cachedLastAttributeEndPos, node.end], (expectedNextLine ? '\n' : '') + closingTag);
							case 'props-aligned':
							case 'tag-aligned':
							case 'line-aligned':
				return fixer.replaceTextRange([cachedLastAttributeEndPos, node.end], '\n' + getIndentation(tokens, expectedLocation, correctColumn) + closingTag);
							default:
				return true;
			}
					}
		});
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
  meta: {
	docs: {
			description: 'Validate closing tag location for multiline JSX',
			category: 'Stylistic Issues',
			recommended: false
	},
	fixable: 'whitespace'
  },

  create: function create(context) {
	var sourceCode = context.getSourceCode();
	function isNodeFirstInLine(node) {
			var token = node;
			var lines = void 0;
			do {
		token = sourceCode.getTokenBefore(token);
		lines = token.type === 'JSXText' ? token.value.split('\n') : null;
			} while (token.type === 'JSXText' && /^\s*$/.test(lines[lines.length - 1]));

			var startLine = node.loc.start.line;
			var endLine = token ? token.loc.end.line : -1;
			return startLine !== endLine;
	}

	return {
			JSXClosingElement: function JSXClosingElement(node) {
		if (!node.parent) {
					return;
		}

		var opening = node.parent.openingElement;
		if (opening.loc.start.line === node.loc.start.line) {
					return;
		}

		if (opening.loc.start.column === node.loc.start.column) {
					return;
		}

		var message = void 0;
		if (!isNodeFirstInLine(node)) {
					message = 'Closing tag of a multiline JSX expression must be on its own line.';
		} else {
					message = 'Expected closing tag to match indentation of opening.';
		}

		context.report({
					node: node,
					loc: node.loc,
					message: message,
					fix: function fix(fixer) {
			var indent = Array(opening.loc.start.column + 1).join(' ');
			if (isNodeFirstInLine(node)) {
							return fixer.replaceTextRange([node.start - node.loc.start.column, node.start], indent);
			}

			return fixer.insertTextBefore(node, '\n' + indent);
					}
		});
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
var SPACING = {
  always: 'always',
  never: 'never'
};
var SPACING_VALUES = [SPACING.always, SPACING.never];

module.exports = {
  meta: {
	docs: {
			description: 'Enforce or disallow spaces inside of curly braces in JSX attributes',
			category: 'Stylistic Issues',
			recommended: false
	},
	fixable: 'code',

	schema: {
			definitions: {
		basicConfig: {
					type: 'object',
					properties: {
			when: {
							enum: SPACING_VALUES
			},
			allowMultiline: {
							type: 'boolean'
			},
			spacing: {
							type: 'object',
							properties: {
				objectLiterals: {
									enum: SPACING_VALUES
				}
							}
			}
					}
		},
		basicConfigOrBoolean: {
					oneOf: [{
			$ref: '#/definitions/basicConfig'
					}, {
			type: 'boolean'
					}]
		}
			},
			type: 'array',
			items: [{
		oneOf: [{
					allOf: [{
			$ref: '#/definitions/basicConfig'
					}, {
			type: 'object',
			properties: {
							attributes: {
				$ref: '#/definitions/basicConfigOrBoolean'
							},
							children: {
				$ref: '#/definitions/basicConfigOrBoolean'
							}
			}
					}]
		}, {
					enum: SPACING_VALUES
		}]
			}, {
		type: 'object',
		properties: {
					allowMultiline: {
			type: 'boolean'
					},
					spacing: {
			type: 'object',
			properties: {
							objectLiterals: {
				enum: SPACING_VALUES
							}
			}
					}
		},
		additionalProperties: false
			}]
	}
  },

  create: function create(context) {
	function normalizeConfig(configOrTrue, defaults, lastPass) {
			var config = configOrTrue === true ? {} : configOrTrue;
			var when = config.when || defaults.when;
			var allowMultiline = has(config, 'allowMultiline') ? config.allowMultiline : defaults.allowMultiline;
			var spacing = config.spacing || {};
			var objectLiteralSpaces = spacing.objectLiterals || defaults.objectLiteralSpaces;
			if (lastPass) {
		objectLiteralSpaces = objectLiteralSpaces || when;
			}

			return {
		when: when,
		allowMultiline: allowMultiline,
		objectLiteralSpaces: objectLiteralSpaces
			};
	}

	var DEFAULT_WHEN = SPACING.never;
	var DEFAULT_ALLOW_MULTILINE = true;
	var DEFAULT_ATTRIBUTES = true;
	var DEFAULT_CHILDREN = false;

	var sourceCode = context.getSourceCode();
	var originalConfig = context.options[0] || {};
	if (SPACING_VALUES.indexOf(originalConfig) !== -1) {
			originalConfig = Object.assign({ when: context.options[0] }, context.options[1]);
	}
	var defaultConfig = normalizeConfig(originalConfig, {
			when: DEFAULT_WHEN,
			allowMultiline: DEFAULT_ALLOW_MULTILINE
	});
	var attributes = has(originalConfig, 'attributes') ? originalConfig.attributes : DEFAULT_ATTRIBUTES;
	var attributesConfig = attributes ? normalizeConfig(attributes, defaultConfig, true) : null;
	var children = has(originalConfig, 'children') ? originalConfig.children : DEFAULT_CHILDREN;
	var childrenConfig = children ? normalizeConfig(children, defaultConfig, true) : null;
	function isMultiline(left, right) {
			return left.loc.start.line !== right.loc.start.line;
	}
	function reportNoBeginningNewline(node, token, spacing) {
			context.report({
		node: node,
		loc: token.loc.start,
		message: 'There should be no newline after \'' + token.value + '\'',
		fix: function fix(fixer) {
					var nextToken = sourceCode.getTokenAfter(token);
					return fixer.replaceTextRange([token.range[1], nextToken.range[0]], spacing === SPACING.always ? ' ' : '');
		}
			});
	}
	function reportNoEndingNewline(node, token, spacing) {
			context.report({
		node: node,
		loc: token.loc.start,
		message: 'There should be no newline before \'' + token.value + '\'',
		fix: function fix(fixer) {
					var previousToken = sourceCode.getTokenBefore(token);
					return fixer.replaceTextRange([previousToken.range[1], token.range[0]], spacing === SPACING.always ? ' ' : '');
		}
			});
	}
	function reportNoBeginningSpace(node, token) {
			context.report({
		node: node,
		loc: token.loc.start,
		message: 'There should be no space after \'' + token.value + '\'',
		fix: function fix(fixer) {
					var nextToken = sourceCode.getTokenAfter(token);
					var nextNode = sourceCode.getNodeByRangeIndex(nextToken.range[0]);
					var leadingComments = sourceCode.getComments(nextNode).leading;
					var rangeEndRef = leadingComments.length ? leadingComments[0] : nextToken;
					return fixer.removeRange([token.range[1], rangeEndRef.range[0]]);
		}
			});
	}
	function reportNoEndingSpace(node, token) {
			context.report({
		node: node,
		loc: token.loc.start,
		message: 'There should be no space before \'' + token.value + '\'',
		fix: function fix(fixer) {
					var previousToken = sourceCode.getTokenBefore(token);
					var previousNode = sourceCode.getNodeByRangeIndex(previousToken.range[0]);
					var trailingComments = sourceCode.getComments(previousNode).trailing;
					var rangeStartRef = trailingComments.length ? trailingComments[trailingComments.length - 1] : previousToken;
					return fixer.removeRange([rangeStartRef.range[1], token.range[0]]);
		}
			});
	}
	function reportRequiredBeginningSpace(node, token) {
			context.report({
		node: node,
		loc: token.loc.start,
		message: 'A space is required after \'' + token.value + '\'',
		fix: function fix(fixer) {
					return fixer.insertTextAfter(token, ' ');
		}
			});
	}
	function reportRequiredEndingSpace(node, token) {
			context.report({
		node: node,
		loc: token.loc.start,
		message: 'A space is required before \'' + token.value + '\'',
		fix: function fix(fixer) {
					return fixer.insertTextBefore(token, ' ');
		}
			});
	}
	function validateBraceSpacing(node) {
			var config = void 0;
			switch (node.parent.type) {
		case 'JSXAttribute':
		case 'JSXOpeningElement':
					config = attributesConfig;
					break;

		case 'JSXElement':
					config = childrenConfig;
					break;

		default:
					return;
			}
			if (config === null) {
		return;
			}

			var first = context.getFirstToken(node);
			var last = sourceCode.getLastToken(node);
			var second = context.getTokenAfter(first, { includeComments: true });
			var penultimate = sourceCode.getTokenBefore(last, { includeComments: true });

			if (!second) {
		second = context.getTokenAfter(first);
		var leadingComments = sourceCode.getNodeByRangeIndex(second.range[0]).leadingComments;
		second = leadingComments ? leadingComments[0] : second;
			}
			if (!penultimate) {
		penultimate = sourceCode.getTokenBefore(last);
		var trailingComments = sourceCode.getNodeByRangeIndex(penultimate.range[0]).trailingComments;
		penultimate = trailingComments ? trailingComments[trailingComments.length - 1] : penultimate;
			}

			var isObjectLiteral = first.value === second.value;
			var spacing = isObjectLiteral ? config.objectLiteralSpaces : config.when;
			if (spacing === SPACING.always) {
		if (!sourceCode.isSpaceBetweenTokens(first, second)) {
					reportRequiredBeginningSpace(node, first);
		} else if (!config.allowMultiline && isMultiline(first, second)) {
					reportNoBeginningNewline(node, first, spacing);
		}
		if (!sourceCode.isSpaceBetweenTokens(penultimate, last)) {
					reportRequiredEndingSpace(node, last);
		} else if (!config.allowMultiline && isMultiline(penultimate, last)) {
					reportNoEndingNewline(node, last, spacing);
		}
			} else if (spacing === SPACING.never) {
		if (isMultiline(first, second)) {
					if (!config.allowMultiline) {
			reportNoBeginningNewline(node, first, spacing);
					}
		} else if (sourceCode.isSpaceBetweenTokens(first, second)) {
					reportNoBeginningSpace(node, first);
		}
		if (isMultiline(penultimate, last)) {
					if (!config.allowMultiline) {
			reportNoEndingNewline(node, last, spacing);
					}
		} else if (sourceCode.isSpaceBetweenTokens(penultimate, last)) {
					reportNoEndingSpace(node, last);
		}
			}
	}
	return {
			JSXExpressionContainer: validateBraceSpacing,
			JSXSpreadAttribute: validateBraceSpacing
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
  meta: {
	docs: {
			description: 'Disallow or enforce spaces around equal signs in JSX attributes',
			category: 'Stylistic Issues',
			recommended: false
	},
	fixable: 'code',

	schema: [{
			enum: ['always', 'never']
	}]
  },

  create: function create(context) {
	var config = context.options[0];
	var sourceCode = context.getSourceCode();
	function hasEqual(attrNode) {
			return attrNode.type !== 'JSXSpreadAttribute' && attrNode.value !== null;
	}
	return {
			JSXOpeningElement: function JSXOpeningElement(node) {
		node.attributes.forEach(function (attrNode) {
					if (!hasEqual(attrNode)) {
			return;
					}

					var equalToken = sourceCode.getTokenAfter(attrNode.name);
					var spacedBefore = sourceCode.isSpaceBetweenTokens(attrNode.name, equalToken);
					var spacedAfter = sourceCode.isSpaceBetweenTokens(equalToken, attrNode.value);

					switch (config) {
			default:
			case 'never':
							if (spacedBefore) {
				context.report({
									node: attrNode,
									loc: equalToken.loc.start,
									message: 'There should be no space before \'=\'',
									fix: function fix(fixer) {
					return fixer.removeRange([attrNode.name.range[1], equalToken.start]);
									}
				});
							}
							if (spacedAfter) {
				context.report({
									node: attrNode,
									loc: equalToken.loc.start,
									message: 'There should be no space after \'=\'',
									fix: function fix(fixer) {
					return fixer.removeRange([equalToken.end, attrNode.value.range[0]]);
									}
				});
							}
							break;
			case 'always':
							if (!spacedBefore) {
				context.report({
									node: attrNode,
									loc: equalToken.loc.start,
									message: 'A space is required before \'=\'',
									fix: function fix(fixer) {
					return fixer.insertTextBefore(equalToken, ' ');
									}
				});
							}
							if (!spacedAfter) {
				context.report({
									node: attrNode,
									loc: equalToken.loc.start,
									message: 'A space is required after \'=\'',
									fix: function fix(fixer) {
					return fixer.insertTextAfter(equalToken, ' ');
									}
				});
							}
							break;
					}
		});
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var path = __webpack_require__(103);
var DEFAULTS = {
  extensions: ['.jsx']
};
module.exports = {
  meta: {
	docs: {
			description: 'Restrict file extensions that may contain JSX',
			category: 'Stylistic Issues',
			recommended: false
	},

	schema: [{
			type: 'object',
			properties: {
		extensions: {
					type: 'array',
					items: {
			type: 'string'
					}
		}
			},
			additionalProperties: false
	}]
  },

  create: function create(context) {
	function getExtensionsConfig() {
			return context.options[0] && context.options[0].extensions || DEFAULTS.extensions;
	}

	var invalidExtension = void 0;
	var invalidNode = void 0;
	return {
			JSXElement: function JSXElement(node) {
		var filename = context.getFilename();
		if (filename === '<text>') {
					return;
		}

		if (invalidNode) {
					return;
		}

		var allowedExtensions = getExtensionsConfig();
		var isAllowedExtension = allowedExtensions.some(function (extension) {
					return filename.slice(-extension.length) === extension;
		});

		if (isAllowedExtension) {
					return;
		}

		invalidNode = node;
		invalidExtension = path.extname(filename);
			},

			'Program:exit': function ProgramExit() {
		if (!invalidNode) {
					return;
		}

		context.report({
					node: invalidNode,
					message: 'JSX not allowed in files with extension \'' + invalidExtension + '\''
		});
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
  meta: {
	docs: {
			description: 'Ensure proper position of the first property in JSX',
			category: 'Stylistic Issues',
			recommended: false
	},
	fixable: 'code',

	schema: [{
			enum: ['always', 'never', 'multiline', 'multiline-multiprop']
	}]
  },

  create: function create(context) {
	var configuration = context.options[0] || 'multiline-multiprop';

	function isMultilineJSX(jsxNode) {
			return jsxNode.loc.start.line < jsxNode.loc.end.line;
	}

	return {
			JSXOpeningElement: function JSXOpeningElement(node) {
		if (configuration === 'multiline' && isMultilineJSX(node) || configuration === 'multiline-multiprop' && isMultilineJSX(node) && node.attributes.length > 1 || configuration === 'always') {
					node.attributes.some(function (decl) {
			if (decl.loc.start.line === node.loc.start.line) {
							context.report({
				node: decl,
				message: 'Property should be placed on a new line',
				fix: function fix(fixer) {
									return fixer.replaceTextRange([node.name.end, decl.start], '\n');
				}
							});
			}
			return true;
					});
		} else if (configuration === 'never' && node.attributes.length > 0) {
					var firstNode = node.attributes[0];
					if (node.loc.start.line < firstNode.loc.start.line) {
			context.report({
							node: firstNode,
							message: 'Property should be placed on the same line as the component declaration',
							fix: function fix(fixer) {
				return fixer.replaceTextRange([node.name.end, firstNode.start], ' ');
							}
			});
			return;
					}
		}
		return;
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = {
  meta: {
	docs: {
			description: 'Enforce event handler naming conventions in JSX',
			category: 'Stylistic Issues',
			recommended: false
	},

	schema: [{
			type: 'object',
			properties: {
		eventHandlerPrefix: {
					type: 'string'
		},
		eventHandlerPropPrefix: {
					type: 'string'
		}
			},
			additionalProperties: false
	}]
  },

  create: function create(context) {
	var sourceCode = context.getSourceCode();
	var configuration = context.options[0] || {};
	var eventHandlerPrefix = configuration.eventHandlerPrefix || 'handle';
	var eventHandlerPropPrefix = configuration.eventHandlerPropPrefix || 'on';

	var EVENT_HANDLER_REGEX = new RegExp('^((props\\.' + eventHandlerPropPrefix + ')|((.*\\.)?' + eventHandlerPrefix + '))[A-Z].*$');
	var PROP_EVENT_HANDLER_REGEX = new RegExp('^(' + eventHandlerPropPrefix + '[A-Z].*|ref)$');

	return {
			JSXAttribute: function JSXAttribute(node) {
		if (!node.value || !node.value.expression || !node.value.expression.object) {
					return;
		}

		var propKey = _typeof(node.name) === 'object' ? node.name.name : node.name;
		var propValue = sourceCode.getText(node.value.expression).replace(/^this\.|.*::/, '');

		if (propKey === 'ref') {
					return;
		}

		var propIsEventHandler = PROP_EVENT_HANDLER_REGEX.test(propKey);
		var propFnIsNamedCorrectly = EVENT_HANDLER_REGEX.test(propValue);

		if (propIsEventHandler && !propFnIsNamedCorrectly) {
					context.report({
			node: node,
			message: 'Handler function for ' + propKey + ' prop key must begin with \'' + eventHandlerPrefix + '\''
					});
		} else if (propFnIsNamedCorrectly && !propIsEventHandler) {
					context.report({
			node: node,
			message: 'Prop key for ' + propValue + ' must begin with \'' + eventHandlerPropPrefix + '\''
					});
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
  meta: {
	docs: {
			description: 'Validate JSX indentation',
			category: 'Stylistic Issues',
			recommended: false
	},
	fixable: 'whitespace',
	schema: [{
			oneOf: [{
		enum: ['tab']
			}, {
		type: 'integer'
			}]
	}]
  },

  create: function create(context) {
	var MESSAGE = 'Expected indentation of {{needed}} {{type}} {{characters}} but found {{gotten}}.';

	var extraColumnStart = 0;
	var indentType = 'space';
	var indentSize = 4;

	var sourceCode = context.getSourceCode();

	if (context.options.length) {
			if (context.options[0] === 'tab') {
		indentSize = 1;
		indentType = 'tab';
			} else if (typeof context.options[0] === 'number') {
		indentSize = context.options[0];
		indentType = 'space';
			}
	}

	var indentChar = indentType === 'space' ? ' ' : '\t';
	function getFixerFunction(node, needed) {
			return function (fixer) {
		var indent = Array(needed + 1).join(indentChar);
		return fixer.replaceTextRange([node.start - node.loc.start.column, node.start], indent);
			};
	}
	function report(node, needed, gotten, loc) {
			var msgContext = {
		needed: needed,
		type: indentType,
		characters: needed === 1 ? 'character' : 'characters',
		gotten: gotten
			};

			if (loc) {
		context.report({
					node: node,
					loc: loc,
					message: MESSAGE,
					data: msgContext,
					fix: getFixerFunction(node, needed)
		});
			} else {
		context.report({
					node: node,
					message: MESSAGE,
					data: msgContext,
					fix: getFixerFunction(node, needed)
		});
			}
	}
	function getNodeIndent(node, byLastLine, excludeCommas) {
			byLastLine = byLastLine || false;
			excludeCommas = excludeCommas || false;

			var src = sourceCode.getText(node, node.loc.start.column + extraColumnStart);
			var lines = src.split('\n');
			if (byLastLine) {
		src = lines[lines.length - 1];
			} else {
		src = lines[0];
			}

			var skip = excludeCommas ? ',' : '';

			var regExp = void 0;
			if (indentType === 'space') {
		regExp = new RegExp('^[ ' + skip + ']+');
			} else {
		regExp = new RegExp('^[\t' + skip + ']+');
			}

			var indent = regExp.exec(src);
			return indent ? indent[0].length : 0;
	}
	function isNodeFirstInLine(node) {
			var token = node;
			do {
		token = sourceCode.getTokenBefore(token);
			} while (token.type === 'JSXText' && /^\s*$/.test(token.value));
			var startLine = node.loc.start.line;
			var endLine = token ? token.loc.end.line : -1;

			return startLine !== endLine;
	}
	function isRightInLogicalExp(node) {
			return node.parent && node.parent.parent && node.parent.parent.type === 'LogicalExpression' && node.parent.parent.right === node.parent;
	}
	function isAlternateInConditionalExp(node) {
			return node.parent && node.parent.parent && node.parent.parent.type === 'ConditionalExpression' && node.parent.parent.alternate === node.parent && sourceCode.getTokenBefore(node).value !== '(';
	}
	function checkNodesIndent(node, indent, excludeCommas) {
			var nodeIndent = getNodeIndent(node, false, excludeCommas);
			var isCorrectRightInLogicalExp = isRightInLogicalExp(node) && nodeIndent - indent === indentSize;
			var isCorrectAlternateInCondExp = isAlternateInConditionalExp(node) && nodeIndent - indent === 0;
			if (nodeIndent !== indent && isNodeFirstInLine(node) && !isCorrectRightInLogicalExp && !isCorrectAlternateInCondExp) {
		report(node, indent, nodeIndent);
			}
	}

	return {
			JSXOpeningElement: function JSXOpeningElement(node) {
		var prevToken = sourceCode.getTokenBefore(node);
		if (!prevToken) {
					return;
		}
		if (prevToken.type === 'JSXText' || prevToken.type === 'Punctuator' && prevToken.value === ',') {
					prevToken = sourceCode.getNodeByRangeIndex(prevToken.start);
					prevToken = prevToken.type === 'Literal' ? prevToken.parent : prevToken;
		} else if (prevToken.type === 'Punctuator' && prevToken.value === ':') {
					do {
			prevToken = sourceCode.getTokenBefore(prevToken);
					} while (prevToken.type === 'Punctuator');
					prevToken = sourceCode.getNodeByRangeIndex(prevToken.range[0]);
					while (prevToken.parent && prevToken.parent.type !== 'ConditionalExpression') {
			prevToken = prevToken.parent;
					}
		}
		prevToken = prevToken.type === 'JSXExpressionContainer' ? prevToken.expression : prevToken;

		var parentElementIndent = getNodeIndent(prevToken);
		var indent = prevToken.loc.start.line === node.loc.start.line || isRightInLogicalExp(node) || isAlternateInConditionalExp(node) ? 0 : indentSize;
		checkNodesIndent(node, parentElementIndent + indent);
			},
			JSXClosingElement: function JSXClosingElement(node) {
		if (!node.parent) {
					return;
		}
		var peerElementIndent = getNodeIndent(node.parent.openingElement);
		checkNodesIndent(node, peerElementIndent);
			},
			JSXExpressionContainer: function JSXExpressionContainer(node) {
		if (!node.parent) {
					return;
		}
		var parentNodeIndent = getNodeIndent(node.parent);
		checkNodesIndent(node, parentNodeIndent + indentSize);
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
  meta: {
	docs: {
			description: 'Validate props indentation in JSX',
			category: 'Stylistic Issues',
			recommended: false
	},
	fixable: 'code',

	schema: [{
			oneOf: [{
		enum: ['tab']
			}, {
		type: 'integer'
			}]
	}]
  },

  create: function create(context) {
	var MESSAGE = 'Expected indentation of {{needed}} {{type}} {{characters}} but found {{gotten}}.';

	var extraColumnStart = 0;
	var indentType = 'space';
	var indentSize = 4;

	var sourceCode = context.getSourceCode();

	if (context.options.length) {
			if (context.options[0] === 'tab') {
		indentSize = 1;
		indentType = 'tab';
			} else if (typeof context.options[0] === 'number') {
		indentSize = context.options[0];
		indentType = 'space';
			}
	}
	function report(node, needed, gotten, loc) {
			var msgContext = {
		needed: needed,
		type: indentType,
		characters: needed === 1 ? 'character' : 'characters',
		gotten: gotten
			};

			if (loc) {
		context.report({
					node: node,
					loc: loc,
					message: MESSAGE,
					data: msgContext
		});
			} else {
		context.report({
					node: node,
					message: MESSAGE,
					data: msgContext,
					fix: function fix(fixer) {
			return fixer.replaceTextRange([node.start - node.loc.start.column, node.start], Array(needed + 1).join(indentType === 'space' ? ' ' : '\t'));
					}
		});
			}
	}
	function getNodeIndent(node, byLastLine, excludeCommas) {
			byLastLine = byLastLine || false;
			excludeCommas = excludeCommas || false;

			var src = sourceCode.getText(node, node.loc.start.column + extraColumnStart);
			var lines = src.split('\n');
			if (byLastLine) {
		src = lines[lines.length - 1];
			} else {
		src = lines[0];
			}

			var skip = excludeCommas ? ',' : '';

			var regExp = void 0;
			if (indentType === 'space') {
		regExp = new RegExp('^[ ' + skip + ']+');
			} else {
		regExp = new RegExp('^[\t' + skip + ']+');
			}

			var indent = regExp.exec(src);
			return indent ? indent[0].length : 0;
	}
	function isNodeFirstInLine(node, byEndLocation) {
			var firstToken = byEndLocation === true ? sourceCode.getLastToken(node, 1) : sourceCode.getTokenBefore(node);
			var startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line;
			var endLine = firstToken ? firstToken.loc.end.line : -1;

			return startLine !== endLine;
	}
	function checkNodesIndent(nodes, indent, excludeCommas) {
			nodes.forEach(function (node) {
		var nodeIndent = getNodeIndent(node, false, excludeCommas);
		if (node.type !== 'ArrayExpression' && node.type !== 'ObjectExpression' && nodeIndent !== indent && isNodeFirstInLine(node)) {
					report(node, indent, nodeIndent);
		}
			});
	}

	return {
			JSXOpeningElement: function JSXOpeningElement(node) {
		var elementIndent = getNodeIndent(node);
		checkNodesIndent(node.attributes, elementIndent + indentSize);
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var hasProp = __webpack_require__(678);
module.exports = {
  meta: {
	docs: {
			description: 'Report missing `key` props in iterators/collection literals',
			category: 'Possible Errors',
			recommended: true
	},
	schema: []
  },

  create: function create(context) {
	function checkIteratorElement(node) {
			if (node.type === 'JSXElement' && !hasProp(node.openingElement.attributes, 'key')) {
		context.report({
					node: node,
					message: 'Missing "key" prop for element in iterator'
		});
			}
	}

	function getReturnStatement(body) {
			return body.filter(function (item) {
		return item.type === 'ReturnStatement';
			})[0];
	}

	return {
			JSXElement: function JSXElement(node) {
		if (hasProp(node.openingElement.attributes, 'key')) {
					return;
		}

		if (node.parent.type === 'ArrayExpression') {
					context.report({
			node: node,
			message: 'Missing "key" prop for element in array'
					});
		}
			},
			CallExpression: function CallExpression(node) {
		if (node.callee && node.callee.type !== 'MemberExpression') {
					return;
		}

		if (node.callee && node.callee.property && node.callee.property.name !== 'map') {
					return;
		}

		var fn = node.arguments[0];
		var isFn = fn && fn.type === 'FunctionExpression';
		var isArrFn = fn && fn.type === 'ArrowFunctionExpression';

		if (isArrFn && fn.body.type === 'JSXElement') {
					checkIteratorElement(fn.body);
		}

		if (isFn || isArrFn) {
					if (fn.body.type === 'BlockStatement') {
			var returnStatement = getReturnStatement(fn.body.body);
			if (returnStatement && returnStatement.argument) {
							checkIteratorElement(returnStatement.argument);
			}
					}
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(109).hasProp; // eslint-disable-line import/no-unresolved
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = hasProp;
exports.hasAnyProp = hasAnyProp;
exports.hasEveryProp = hasEveryProp;

var _propName = __webpack_require__(110);

var _propName2 = _interopRequireDefault(_propName);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var DEFAULT_OPTIONS = {
  spreadStrict: true,
  ignoreCase: true
};
function hasProp() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var prop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_OPTIONS;

  var propToCheck = options.ignoreCase ? prop.toUpperCase() : prop;

  return props.some(function (attribute) {
	if (attribute.type === 'JSXSpreadAttribute') {
			return !options.spreadStrict;
	}

	var currentProp = options.ignoreCase ? (0, _propName2.default)(attribute).toUpperCase() : (0, _propName2.default)(attribute);

	return propToCheck === currentProp;
  });
}
function hasAnyProp() {
  var nodeProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_OPTIONS;

  var propsToCheck = typeof props === 'string' ? props.split(' ') : props;

  return propsToCheck.some(function (prop) {
	return hasProp(nodeProps, prop, options);
  });
}
function hasEveryProp() {
  var nodeProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_OPTIONS;

  var propsToCheck = typeof props === 'string' ? props.split(' ') : props;

  return propsToCheck.every(function (prop) {
	return hasProp(nodeProps, prop, options);
  });
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = elementType;
function resolveMemberExpressions() {
  var object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var property = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (object.type === 'JSXMemberExpression') {
	return resolveMemberExpressions(object.object, object.property) + '.' + property.name;
  }

  return object.name + '.' + property.name;
}
function elementType() {
  var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var name = node.name;

  if (!name) {
	throw new Error('The argument provided is not a JSXElement node.');
  }

  if (name.type === 'JSXMemberExpression') {
	var _name$object = name.object,
		object = _name$object === undefined ? {} : _name$object,
		_name$property = name.property,
		property = _name$property === undefined ? {} : _name$property;

	return resolveMemberExpressions(object, property);
  } else if (name.type === 'JSXNamespacedName') {
	return name.namespace.name + ':' + name.name.name;
  }

  return node.name.name;
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var eventHandlersByType = {
  clipboard: ['onCopy', 'onCut', 'onPaste'],
  composition: ['onCompositionEnd', 'onCompositionStart', 'onCompositionUpdate'],
  keyboard: ['onKeyDown', 'onKeyPress', 'onKeyUp'],
  focus: ['onFocus', 'onBlur'],
  form: ['onChange', 'onInput', 'onSubmit'],
  mouse: ['onClick', 'onContextMenu', 'onDblClick', 'onDoubleClick', 'onDrag', 'onDragEnd', 'onDragEnter', 'onDragExit', 'onDragLeave', 'onDragOver', 'onDragStart', 'onDrop', 'onMouseDown', 'onMouseEnter', 'onMouseLeave', 'onMouseMove', 'onMouseOut', 'onMouseOver', 'onMouseUp'],
  selection: ['onSelect'],
  touch: ['onTouchCancel', 'onTouchEnd', 'onTouchMove', 'onTouchStart'],
  ui: ['onScroll'],
  wheel: ['onWheel'],
  media: ['onAbort', 'onCanPlay', 'onCanPlayThrough', 'onDurationChange', 'onEmptied', 'onEncrypted', 'onEnded', 'onError', 'onLoadedData', 'onLoadedMetadata', 'onLoadStart', 'onPause', 'onPlay', 'onPlaying', 'onProgress', 'onRateChange', 'onSeeked', 'onSeeking', 'onStalled', 'onSuspend', 'onTimeUpdate', 'onVolumeChange', 'onWaiting'],
  image: ['onLoad', 'onError'],
  animation: ['onAnimationStart', 'onAnimationEnd', 'onAnimationIteration'],
  transition: ['onTransitionEnd']
};

var eventHandlers = Object.keys(eventHandlersByType).reduce(function (accumulator, type) {
  return accumulator.concat(eventHandlersByType[type]);
}, []);

exports.default = eventHandlers;
exports.eventHandlersByType = eventHandlersByType;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getProp;

var _propName = __webpack_require__(110);

var _propName2 = _interopRequireDefault(_propName);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var DEFAULT_OPTIONS = {
  ignoreCase: true
};
function getProp() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var prop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_OPTIONS;

  var propToFind = options.ignoreCase ? prop.toUpperCase() : prop;

  return props.find(function (attribute) {
	if (attribute.type === 'JSXSpreadAttribute') {
			return false;
	}

	var currentProp = options.ignoreCase ? (0, _propName2.default)(attribute).toUpperCase() : (0, _propName2.default)(attribute);

	return propToFind === currentProp;
  });
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getPropValue;
exports.getLiteralPropValue = getLiteralPropValue;

var _values = __webpack_require__(684);

var _values2 = _interopRequireDefault(_values);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var extractValue = function extractValue(attribute, extractor) {
  if (attribute && attribute.type === 'JSXAttribute') {
	if (attribute.value === null) {
			return true;
	}

	return extractor(attribute.value);
  }

  return undefined;
};
function getPropValue(attribute) {
  return extractValue(attribute, _values2.default);
}
function getLiteralPropValue(attribute) {
  return extractValue(attribute, _values.getLiteralValue);
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getValue;
exports.getLiteralValue = getLiteralValue;

var _Literal = __webpack_require__(166);

var _Literal2 = _interopRequireDefault(_Literal);

var _JSXElement = __webpack_require__(167);

var _JSXElement2 = _interopRequireDefault(_JSXElement);

var _expressions = __webpack_require__(21);

var _expressions2 = _interopRequireDefault(_expressions);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var TYPES = {
  Literal: _Literal2.default,
  JSXElement: _JSXElement2.default,
  JSXExpressionContainer: _expressions2.default
};
var LITERAL_TYPES = Object.assign({}, TYPES, {
  JSXElement: function JSXElement() {
	return null;
  },
  JSXExpressionContainer: _expressions.extractLiteral
});
function getValue(value) {
  return TYPES[value.type](value);
}
function getLiteralValue(value) {
  return LITERAL_TYPES[value.type](value);
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromIdentifier;
var JS_RESERVED = {
  Array: Array,
  Date: Date,
  Infinity: Infinity,
  Math: Math,
  Number: Number,
  Object: Object,
  String: String,
  undefined: undefined
};
function extractValueFromIdentifier(value) {
  var name = value.name;

  if (Object.hasOwnProperty.call(JS_RESERVED, name)) {
	return JS_RESERVED[name];
  }

  return name;
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromTaggedTemplateExpression;

var _TemplateLiteral = __webpack_require__(168);

var _TemplateLiteral2 = _interopRequireDefault(_TemplateLiteral);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function extractValueFromTaggedTemplateExpression(value) {
  return (0, _TemplateLiteral2.default)(value.quasi);
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromFunctionExpression;
function extractValueFromFunctionExpression(value) {
  return function () {
	return value;
  };
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromLogicalExpression;

var _index = __webpack_require__(21);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function extractValueFromLogicalExpression(value) {
  var operator = value.operator,
			left = value.left,
			right = value.right;

  var leftVal = (0, _index2.default)(left);
  var rightVal = (0, _index2.default)(right);

  return operator === '&&' ? leftVal && rightVal : leftVal || rightVal;
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromMemberExpression;

var _index = __webpack_require__(21);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function extractValueFromMemberExpression(value) {
  return (0, _index2.default)(value.object) + '.' + (0, _index2.default)(value.property);
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromCallExpression;

var _index = __webpack_require__(21);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function extractValueFromCallExpression(value) {
  return (0, _index2.default)(value.callee);
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromUnaryExpression;

var _index = __webpack_require__(21);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function extractValueFromUnaryExpression(value) {
  var operator = value.operator,
			argument = value.argument;

  switch (operator) {
	case '-':
			return -(0, _index2.default)(argument);
	case '+':
			return +(0, _index2.default)(argument); // eslint-disable-line no-implicit-coercion
	case '!':
			return !(0, _index2.default)(argument);
	case '~':
			return ~(0, _index2.default)(argument); // eslint-disable-line no-bitwise
	case 'delete':
			return true;
	case 'typeof':
	case 'void':
	default:
			return undefined;
  }
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromThisExpression;
function extractValueFromThisExpression() {
  return 'this';
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromConditionalExpression;

var _index = __webpack_require__(21);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function extractValueFromConditionalExpression(value) {
  var test = value.test,
			alternate = value.alternate,
			consequent = value.consequent;

  return (0, _index2.default)(test) ? (0, _index2.default)(consequent) : (0, _index2.default)(alternate);
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromBinaryExpression;

var _index = __webpack_require__(21);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function extractValueFromBinaryExpression(value) {
  var operator = value.operator,
			left = value.left,
			right = value.right;

  var leftVal = (0, _index2.default)(left);
  var rightVal = (0, _index2.default)(right);

  switch (operator) {
	case '==':
			return leftVal == rightVal; // eslint-disable-line
	case '!=':
			return leftVal != rightVal; // eslint-disable-line
	case '===':
			return leftVal === rightVal;
	case '!==':
			return leftVal !== rightVal;
	case '<':
			return leftVal < rightVal;
	case '<=':
			return leftVal <= rightVal;
	case '>':
			return leftVal > rightVal;
	case '>=':
			return leftVal >= rightVal;
	case '<<':
			return leftVal << rightVal; // eslint-disable-line no-bitwise
	case '>>':
			return leftVal >> rightVal; // eslint-disable-line no-bitwise
	case '>>>':
			return leftVal >>> rightVal; // eslint-disable-line no-bitwise
	case '+':
			return leftVal + rightVal;
	case '-':
			return leftVal - rightVal;
	case '*':
			return leftVal * rightVal;
	case '/':
			return leftVal / rightVal;
	case '%':
			return leftVal % rightVal;
	case '|':
			return leftVal | rightVal; // eslint-disable-line no-bitwise
	case '^':
			return leftVal ^ rightVal; // eslint-disable-line no-bitwise
	case '&':
			return leftVal & rightVal; // eslint-disable-line no-bitwise
	case 'in':
			try {
		return leftVal in rightVal;
			} catch (err) {
		return false;
			}
	case 'instanceof':
			if (typeof rightVal !== 'function') {
		return false;
			}
			return leftVal instanceof rightVal;
	default:
			return undefined;
  }
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromObjectExpression;

var _index = __webpack_require__(21);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function extractValueFromObjectExpression(value) {
  return value.properties.reduce(function (obj, property) {
	var object = Object.assign({}, obj);
	object[(0, _index2.default)(property.key)] = (0, _index2.default)(property.value);
	return object;
  }, {});
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromNewExpression;
function extractValueFromNewExpression() {
  return new Object(); // eslint-disable-line
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromUpdateExpression;

var _index = __webpack_require__(21);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function extractValueFromUpdateExpression(value) {
  var operator = value.operator,
			argument = value.argument,
			prefix = value.prefix;

  var val = (0, _index2.default)(argument);

  switch (operator) {
	case '++':
			return prefix ? ++val : val++; // eslint-disable-line no-plusplus
	case '--':
			return prefix ? --val : val--; // eslint-disable-line no-plusplus
	default:
			return undefined;
  }
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromArrayExpression;

var _index = __webpack_require__(21);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function extractValueFromArrayExpression(value) {
  return value.elements.map(function (element) {
	return (0, _index2.default)(element);
  });
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractValueFromBindExpression;

var _index = __webpack_require__(21);

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function extractValueFromBindExpression(value) {
  var callee = (0, _index2.default)(value.callee);
  var object = value.object === null ? (0, _index2.default)(value.callee.object) : (0, _index2.default)(value.object);

  if (value.object && value.object.property) {
	return object + '.' + callee + '.bind(' + object + ')';
  }

  return callee + '.bind(' + object + ')';
}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
  meta: {
	docs: {
			description: 'Limit maximum of props on a single line in JSX',
			category: 'Stylistic Issues',
			recommended: false
	},
	fixable: 'code',
	schema: [{
			type: 'object',
			properties: {
		maximum: {
					type: 'integer',
					minimum: 1
		},
		when: {
					type: 'string',
					enum: ['always', 'multiline']
		}
			}
	}]
  },

  create: function create(context) {
	var sourceCode = context.getSourceCode();
	var configuration = context.options[0] || {};
	var maximum = configuration.maximum || 1;
	var when = configuration.when || 'always';

	function getPropName(propNode) {
			if (propNode.type === 'JSXSpreadAttribute') {
		return sourceCode.getText(propNode.argument);
			}
			return propNode.name.name;
	}

	function generateFixFunction(line, max) {
			var output = [];
			var front = line[0].start;
			var back = line[line.length - 1].end;
			for (var i = 0; i < line.length; i += max) {
		var nodes = line.slice(i, i + max);
		output.push(nodes.reduce(function (prev, curr) {
					if (prev === '') {
			return sourceCode.getText(curr);
					}
					return prev + ' ' + sourceCode.getText(curr);
		}, ''));
			}
			var code = output.join('\n');
			return function (fixer) {
		return fixer.replaceTextRange([front, back], code);
			};
	}

	return {
			JSXOpeningElement: function JSXOpeningElement(node) {
		if (!node.attributes.length) {
					return;
		}

		if (when === 'multiline' && node.loc.start.line === node.loc.end.line) {
					return;
		}

		var firstProp = node.attributes[0];
		var linePartitionedProps = [[firstProp]];

		node.attributes.reduce(function (last, decl) {
					if (last.loc.end.line === decl.loc.start.line) {
			linePartitionedProps[linePartitionedProps.length - 1].push(decl);
					} else {
			linePartitionedProps.push([decl]);
					}
					return decl;
		});

		linePartitionedProps.forEach(function (propsInLine) {
					if (propsInLine.length > maximum) {
			var name = getPropName(propsInLine[maximum]);
			context.report({
							node: propsInLine[maximum],
							message: 'Prop `' + name + '` must be placed on a new line',
							fix: generateFixFunction(propsInLine, maximum)
			});
					}
		});
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var Components = __webpack_require__(8);
var propName = __webpack_require__(169);
module.exports = {
  meta: {
	docs: {
			description: 'Prevents usage of Function.prototype.bind and arrow functions in React component definition',
			category: 'Best Practices',
			recommended: false
	},

	schema: [{
			type: 'object',
			properties: {
		allowArrowFunctions: {
					default: false,
					type: 'boolean'
		},
		allowBind: {
					default: false,
					type: 'boolean'
		},
		ignoreRefs: {
					default: false,
					type: 'boolean'
		}
			},
			additionalProperties: false
	}]
  },

  create: Components.detect(function (context, components, utils) {
	var configuration = context.options[0] || {};

	return {
			CallExpression: function CallExpression(node) {
		var callee = node.callee;
		if (!configuration.allowBind && (callee.type !== 'MemberExpression' || callee.property.name !== 'bind')) {
					return;
		}
		var ancestors = context.getAncestors(callee).reverse();
		for (var i = 0, j = ancestors.length; i < j; i++) {
					if (!configuration.allowBind && ancestors[i].type === 'MethodDefinition' && ancestors[i].key.name === 'render' || ancestors[i].type === 'Property' && ancestors[i].key.name === 'render') {
			if (utils.isReturningJSX(ancestors[i])) {
							context.report({
				node: callee,
				message: 'JSX props should not use .bind()'
							});
			}
			break;
					}
		}
			},

			JSXAttribute: function JSXAttribute(node) {
		var isRef = configuration.ignoreRefs && propName(node) === 'ref';
		if (isRef || !node.value || !node.value.expression) {
					return;
		}
		var valueNode = node.value.expression;
		if (!configuration.allowBind && valueNode.type === 'CallExpression' && valueNode.callee.type === 'MemberExpression' && valueNode.callee.property.name === 'bind') {
					context.report({
			node: node,
			message: 'JSX props should not use .bind()'
					});
		} else if (!configuration.allowArrowFunctions && valueNode.type === 'ArrowFunctionExpression') {
					context.report({
			node: node,
			message: 'JSX props should not use arrow functions'
					});
		} else if (!configuration.allowBind && valueNode.type === 'BindExpression') {
					context.report({
			node: node,
			message: 'JSX props should not use ::'
					});
		}
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
  meta: {
	docs: {
			description: 'Comments inside children section of tag should be placed inside braces',
			category: 'Possible Errors',
			recommended: true
	},

	schema: [{
			type: 'object',
			properties: {},
			additionalProperties: false
	}]
  },

  create: function create(context) {
	function reportLiteralNode(node) {
			context.report(node, 'Comments inside children section of tag should be placed inside braces');
	}
	return {
			Literal: function Literal(node) {
		if (/^\s*\/(\/|\*)/m.test(node.value)) {
					if (node.parent.type !== 'JSXAttribute' && node.parent.type !== 'JSXExpressionContainer' && node.parent.type.indexOf('JSX') !== -1) {
			reportLiteralNode(node);
					}
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var has = __webpack_require__(7);
module.exports = {
  meta: {
	docs: {
			description: 'Enforce no duplicate props',
			category: 'Possible Errors',
			recommended: true
	},

	schema: [{
			type: 'object',
			properties: {
		ignoreCase: {
					type: 'boolean'
		}
			},
			additionalProperties: false
	}]
  },

  create: function create(context) {
	var configuration = context.options[0] || {};
	var ignoreCase = configuration.ignoreCase || false;

	return {
			JSXOpeningElement: function JSXOpeningElement(node) {
		var props = {};

		node.attributes.forEach(function (decl) {
					if (decl.type === 'JSXSpreadAttribute') {
			return;
					}

					var name = decl.name.name;

					if (typeof name !== 'string') {
			return;
					}

					if (ignoreCase) {
			name = name.toLowerCase();
					}

					if (has(props, name)) {
			context.report({
							node: decl,
							message: 'No duplicate props allowed'
			});
					} else {
			props[name] = 1;
					}
		});
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
  meta: {
	docs: {
			description: 'Prevent using string literals in React component definition',
			category: 'Stylistic Issues',
			recommended: false
	},

	schema: [{
			type: 'object',
			properties: {
		noStrings: {
					type: 'boolean'
		}
			},
			additionalProperties: false
	}]
  },

  create: function create(context) {
	var isNoStrings = context.options[0] ? context.options[0].noStrings : false;

	var message = isNoStrings ? 'Strings not allowed in JSX files' : 'Missing JSX expression container around literal string';

	function reportLiteralNode(node) {
			context.report({
		node: node,
		message: message
			});
	}

	function getValidation(node) {
			var standard = !/^[\s]+$/.test(node.value) && typeof node.value === 'string' && node.parent && node.parent.type.indexOf('JSX') !== -1 && node.parent.type !== 'JSXAttribute';
			if (isNoStrings) {
		return standard;
			}
			return standard && node.parent.type !== 'JSXExpressionContainer';
	}
	return {

			Literal: function Literal(node) {
		if (getValidation(node)) {
					reportLiteralNode(node);
		}
			},

			TemplateLiteral: function TemplateLiteral(node) {
		if (isNoStrings && node.parent.type === 'JSXExpressionContainer') {
					reportLiteralNode(node);
		}
			}

	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
function isTargetBlank(attr) {
  return attr.name.name === 'target' && attr.value.type === 'Literal' && attr.value.value.toLowerCase() === '_blank';
}

function hasExternalLink(element) {
  return element.attributes.some(function (attr) {
	return attr.name && attr.name.name === 'href' && attr.value.type === 'Literal' && /^(?:\w+:|\/\/)/.test(attr.value.value);
  });
}

function hasSecureRel(element) {
  return element.attributes.find(function (attr) {
	if (attr.type === 'JSXAttribute' && attr.name.name === 'rel') {
			var tags = attr.value && attr.value.type === 'Literal' && attr.value.value.toLowerCase().split(' ');
			return tags && tags.indexOf('noopener') >= 0 && tags.indexOf('noreferrer') >= 0;
	}
	return false;
  });
}

module.exports = {
  meta: {
	docs: {
			description: 'Forbid target="_blank" attribute without rel="noopener noreferrer"',
			category: 'Best Practices',
			recommended: true
	},
	schema: []
  },

  create: function create(context) {
	return {
			JSXAttribute: function JSXAttribute(node) {
		if (node.parent.name.name !== 'a') {
					return;
		}

		if (isTargetBlank(node) && hasExternalLink(node.parent) && !hasSecureRel(node.parent)) {
					context.report(node, 'Using target="_blank" without rel="noopener noreferrer" ' + 'is a security risk: see https://mathiasbynens.github.io/rel-noopener');
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

var tagConvention = /^[a-z]|\-/;
function isTagName(name) {
  return tagConvention.test(name);
}
module.exports = {
  meta: {
	docs: {
			description: 'Disallow undeclared variables in JSX',
			category: 'Possible Errors',
			recommended: true
	},
	schema: [{
			type: 'object',
			properties: {
		allowGlobals: {
					type: 'boolean'
		}
			},
			additionalProperties: false
	}]
  },

  create: function create(context) {
	var config = context.options[0] || {};
	var allowGlobals = config.allowGlobals || false;
	function checkIdentifierInJSX(node) {
			var scope = context.getScope();
			var sourceCode = context.getSourceCode();
			var sourceType = sourceCode.ast.sourceType;
			var variables = scope.variables;
			var scopeType = 'global';
			var i = void 0;
			var len = void 0;
			if (node.name === 'this') {
		return;
			}

			if (!allowGlobals && sourceType === 'module') {
		scopeType = 'module';
			}

			while (scope.type !== scopeType) {
		scope = scope.upper;
		variables = scope.variables.concat(variables);
			}
			if (scope.childScopes.length) {
		variables = scope.childScopes[0].variables.concat(variables);
		if (scope.childScopes[0].childScopes.length) {
					variables = scope.childScopes[0].childScopes[0].variables.concat(variables);
		}
			}

			for (i = 0, len = variables.length; i < len; i++) {
		if (variables[i].name === node.name) {
					return;
		}
			}

			context.report({
		node: node,
		message: '\'' + node.name + '\' is not defined.'
			});
	}

	return {
			JSXOpeningElement: function JSXOpeningElement(node) {
		switch (node.name.type) {
					case 'JSXIdentifier':
			node = node.name;
			if (isTagName(node.name)) {
							return;
			}
			break;
					case 'JSXMemberExpression':
			node = node.name;
			do {
							node = node.object;
			} while (node && node.type !== 'JSXIdentifier');
			break;
					case 'JSXNamespacedName':
			node = node.name.namespace;
			break;
					default:
			break;
		}
		checkIdentifierInJSX(node);
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var OPTION_ALWAYS = 'always';
var OPTION_NEVER = 'never';
var OPTION_IGNORE = 'ignore';

var OPTION_VALUES = [OPTION_ALWAYS, OPTION_NEVER, OPTION_IGNORE];
var DEFAULT_CONFIG = { props: OPTION_NEVER, children: OPTION_NEVER };
module.exports = {
  meta: {
	docs: {
			description: 'Disallow unnecessary JSX expressions when literals alone are sufficient ' + 'or enfore JSX expressions on literals in JSX children or attributes',
			category: 'Stylistic Issues',
			recommended: false
	},
	fixable: 'code',

	schema: [{
			oneOf: [{
		type: 'object',
		properties: {
					props: { enum: OPTION_VALUES, default: OPTION_NEVER },
					children: { enum: OPTION_VALUES, default: OPTION_NEVER }
		},
		additionalProperties: false
			}, {
		enum: OPTION_VALUES
			}]
	}]
  },

  create: function create(context) {
	var ruleOptions = context.options[0];
	var userConfig = typeof ruleOptions === 'string' ? { props: ruleOptions, children: ruleOptions } : Object.assign({}, DEFAULT_CONFIG, ruleOptions);

	function containsBackslashForEscaping(rawStringValue) {
			return rawStringValue.includes('\\');
	}

	function escapeDoubleQuotes(rawStringValue) {
			return rawStringValue.replace(/\\"/g, '"').replace(/"/g, '\\"');
	}
	function reportUnnecessaryCurly(JSXExpressionNode) {
			context.report({
		node: JSXExpressionNode,
		message: 'Curly braces are unnecessary here.',
		fix: function fix(fixer) {
					var expression = JSXExpressionNode.expression;
					var expressionType = expression.type;
					var parentType = JSXExpressionNode.parent.type;

					var textToReplace = void 0;
					if (parentType === 'JSXAttribute') {
			textToReplace = '"' + escapeDoubleQuotes(expressionType === 'TemplateLiteral' ? expression.quasis[0].value.raw : expression.raw.substring(1, expression.raw.length - 1)) + '"';
					} else {
			textToReplace = expressionType === 'TemplateLiteral' ? expression.quasis[0].value.cooked : expression.value;
					}

					return fixer.replaceText(JSXExpressionNode, textToReplace);
		}
			});
	}

	function reportMissingCurly(literalNode) {
			context.report({
		node: literalNode,
		message: 'Need to wrap this literal in a JSX expression.',
		fix: function fix(fixer) {
					var expression = literalNode.parent.type === 'JSXAttribute' ? '{"' + escapeDoubleQuotes(literalNode.raw.substring(1, literalNode.raw.length - 1)) + '"}' : '{' + JSON.stringify(literalNode.value) + '}';

					return fixer.replaceText(literalNode, expression);
		}
			});
	}

	function lintUnnecessaryCurly(JSXExpressionNode) {
			var expression = JSXExpressionNode.expression;
			var expressionType = expression.type;
			var parentType = JSXExpressionNode.parent.type;

			if (expressionType === 'Literal' && typeof expression.value === 'string' && (parentType === 'JSXAttribute' || !containsBackslashForEscaping(expression.raw))) {
		reportUnnecessaryCurly(JSXExpressionNode);
			} else if (expressionType === 'TemplateLiteral' && expression.expressions.length === 0 && (parentType === 'JSXAttribute' || !containsBackslashForEscaping(expression.quasis[0].value.raw))) {
		reportUnnecessaryCurly(JSXExpressionNode);
			}
	}

	function areRuleConditionsSatisfied(parentType, config, ruleCondition) {
			return parentType === 'JSXAttribute' && typeof config.props === 'string' && config.props === ruleCondition || parentType === 'JSXElement' && typeof config.children === 'string' && config.children === ruleCondition;
	}

	function shouldCheckForUnnecessaryCurly(parent, config) {
			var parentType = parent.type;
			if (parentType === 'JSXElement' && parent.children.length !== 1) {
		return false;
			}

			return areRuleConditionsSatisfied(parentType, config, OPTION_NEVER);
	}

	function shouldCheckForMissingCurly(parentType, config) {
			return areRuleConditionsSatisfied(parentType, config, OPTION_ALWAYS);
	}
	return {
			JSXExpressionContainer: function JSXExpressionContainer(node) {
		var parent = node.parent;

		if (shouldCheckForUnnecessaryCurly(parent, userConfig)) {
					lintUnnecessaryCurly(node);
		}
			},

			Literal: function Literal(node) {
		var parentType = node.parent.type;

		if (shouldCheckForMissingCurly(parentType, userConfig)) {
					reportMissingCurly(node);
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var elementType = __webpack_require__(170);
var PASCAL_CASE_REGEX = /^([A-Z0-9]|[A-Z0-9]+[a-z0-9]+(?:[A-Z0-9]+[a-z0-9]*)*)$/;
var COMPAT_TAG_REGEX = /^[a-z]|\-/;
var ALL_CAPS_TAG_REGEX = /^[A-Z0-9]+$/;
module.exports = {
  meta: {
	docs: {
			description: 'Enforce PascalCase for user-defined JSX components',
			category: 'Stylistic Issues',
			recommended: false
	},

	schema: [{
			type: 'object',
			properties: {
		allowAllCaps: {
					type: 'boolean'
		},
		ignore: {
					type: 'array'
		}
			},
			additionalProperties: false
	}]
  },

  create: function create(context) {
	var configuration = context.options[0] || {};
	var allowAllCaps = configuration.allowAllCaps || false;
	var ignore = configuration.ignore || [];

	return {
			JSXOpeningElement: function JSXOpeningElement(node) {
		var name = elementType(node);
		if (name.indexOf(':') > -1) {
					name = name.substring(0, name.indexOf(':'));
		} else if (name.indexOf('.') > -1) {
					name = name.substring(0, name.indexOf('.'));
		}

		var isPascalCase = PASCAL_CASE_REGEX.test(name);
		var isCompatTag = COMPAT_TAG_REGEX.test(name);
		var isAllowedAllCaps = allowAllCaps && ALL_CAPS_TAG_REGEX.test(name);
		var isIgnored = ignore.indexOf(name) !== -1;

		if (!isPascalCase && !isCompatTag && !isAllowedAllCaps && !isIgnored) {
					context.report({
			node: node,
			message: 'Imported JSX component ' + name + ' must be in PascalCase'
					});
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var elementType = __webpack_require__(170);
var propName = __webpack_require__(169);
function isCallbackPropName(name) {
  return (/^on[A-Z]/.test(name)
  );
}

var COMPAT_TAG_REGEX = /^[a-z]|\-/;
function isDOMComponent(node) {
  var name = elementType(node);
  if (name.indexOf(':') > -1) {
	name = name.substring(0, name.indexOf(':'));
  } else if (name.indexOf('.') > -1) {
	name = name.substring(0, name.indexOf('.'));
  }

  return COMPAT_TAG_REGEX.test(name);
}

var RESERVED_PROPS_LIST = ['children', 'dangerouslySetInnerHTML', 'key', 'ref'];

function isReservedPropName(name, list) {
  return list.indexOf(name) >= 0;
}

function alphabeticalCompare(a, b, ignoreCase) {
  if (ignoreCase) {
	a = a.toLowerCase();
	b = b.toLowerCase();
  }
  return a.localeCompare(b);
}
function getGroupsOfSortableAttributes(attributes) {
  var sortableAttributeGroups = [];
  var groupCount = 0;
  for (var i = 0; i < attributes.length; i++) {
	var lastAttr = attributes[i - 1];
	if (!lastAttr || lastAttr.type === 'JSXSpreadAttribute' && attributes[i].type !== 'JSXSpreadAttribute') {
			groupCount++;
			sortableAttributeGroups[groupCount - 1] = [];
	}
	if (attributes[i].type !== 'JSXSpreadAttribute') {
			sortableAttributeGroups[groupCount - 1].push(attributes[i]);
	}
  }
  return sortableAttributeGroups;
}

var generateFixerFunction = function generateFixerFunction(node, context) {
  var sourceCode = context.getSourceCode();
  var attributes = node.attributes.slice(0);
  var configuration = context.options[0] || {};
  var ignoreCase = configuration.ignoreCase || false;
  var sortableAttributeGroups = getGroupsOfSortableAttributes(attributes);
  var sortedAttributeGroups = sortableAttributeGroups.slice(0).map(function (group) {
	return group.slice(0).sort(function (a, b) {
			return alphabeticalCompare(propName(a), propName(b), ignoreCase);
	});
  });

  return function (fixer) {
	var fixers = [];
	sortableAttributeGroups.forEach(function (sortableGroup, ii) {
			sortableGroup.forEach(function (attr, jj) {
		var sortedAttr = sortedAttributeGroups[ii][jj];
		var sortedAttrText = sourceCode.getText(sortedAttr);
		fixers.push(fixer.replaceTextRange([attr.start, attr.end], sortedAttrText));
			});
	});

	return fixers;
  };
};
function validateReservedFirstConfig(context, reservedFirst) {
  if (reservedFirst) {
	if (Array.isArray(reservedFirst)) {
			var nonReservedWords = reservedFirst.filter(function (word) {
		if (!isReservedPropName(word, RESERVED_PROPS_LIST)) {
					return true;
		}
			});

			if (reservedFirst.length === 0) {
		return function (decl) {
					context.report({
			node: decl,
			message: 'A customized reserved first list must not be empty'
					});
		};
			} else if (nonReservedWords.length > 0) {
		return function (decl) {
					context.report({
			node: decl,
			message: 'A customized reserved first list must only contain a subset of React reserved props.' + ' Remove: {{ nonReservedWords }}',
			data: {
							nonReservedWords: nonReservedWords.toString()
			}
					});
		};
			}
	}
  }
}

module.exports = {
  meta: {
	docs: {
			description: 'Enforce props alphabetical sorting',
			category: 'Stylistic Issues',
			recommended: false
	},
	fixable: 'code',
	schema: [{
			type: 'object',
			properties: {
		callbacksLast: {
					type: 'boolean'
		},
		shorthandFirst: {
					type: 'boolean'
		},
		shorthandLast: {
					type: 'boolean'
		},
		ignoreCase: {
					type: 'boolean'
		},
		noSortAlphabetically: {
					type: 'boolean'
		},
		reservedFirst: {
					type: ['array', 'boolean']
		}
			},
			additionalProperties: false
	}]
  },

  create: function create(context) {
	var configuration = context.options[0] || {};
	var ignoreCase = configuration.ignoreCase || false;
	var callbacksLast = configuration.callbacksLast || false;
	var shorthandFirst = configuration.shorthandFirst || false;
	var shorthandLast = configuration.shorthandLast || false;
	var noSortAlphabetically = configuration.noSortAlphabetically || false;
	var reservedFirst = configuration.reservedFirst || false;
	var reservedFirstError = validateReservedFirstConfig(context, reservedFirst);
	var reservedList = Array.isArray(reservedFirst) ? reservedFirst : RESERVED_PROPS_LIST;

	return {
			JSXOpeningElement: function JSXOpeningElement(node) {
		if (reservedFirst && !isDOMComponent(node)) {
					reservedList = reservedList.filter(function (prop) {
			return prop !== 'dangerouslySetInnerHTML';
					});
		}

		node.attributes.reduce(function (memo, decl, idx, attrs) {
					if (decl.type === 'JSXSpreadAttribute') {
			return attrs[idx + 1];
					}

					var previousPropName = propName(memo);
					var currentPropName = propName(decl);
					var previousValue = memo.value;
					var currentValue = decl.value;
					var previousIsCallback = isCallbackPropName(previousPropName);
					var currentIsCallback = isCallbackPropName(currentPropName);

					if (ignoreCase) {
			previousPropName = previousPropName.toLowerCase();
			currentPropName = currentPropName.toLowerCase();
					}

					if (reservedFirst) {
			if (reservedFirstError) {
							reservedFirstError(decl);
							return memo;
			}

			var previousIsReserved = isReservedPropName(previousPropName, reservedList);
			var currentIsReserved = isReservedPropName(currentPropName, reservedList);

			if (previousIsReserved && currentIsReserved) {
							if (!noSortAlphabetically && currentPropName < previousPropName) {
				context.report({
									node: decl,
									message: 'Props should be sorted alphabetically',
									fix: generateFixerFunction(node, context)
				});
				return memo;
							}
							return decl;
			}
			if (!previousIsReserved && currentIsReserved) {
							context.report({
				node: decl,
				message: 'Reserved props must be listed before all other props'
							});
							return memo;
			}
			return decl;
					}

					if (callbacksLast) {
			if (!previousIsCallback && currentIsCallback) {
							return decl;
			}
			if (previousIsCallback && !currentIsCallback) {
							context.report({
				node: memo,
				message: 'Callbacks must be listed after all other props'
							});
							return memo;
			}
					}

					if (shorthandFirst) {
			if (currentValue && !previousValue) {
							return decl;
			}
			if (!currentValue && previousValue) {
							context.report({
				node: memo,
				message: 'Shorthand props must be listed before all other props'
							});
							return memo;
			}
					}

					if (shorthandLast) {
			if (!currentValue && previousValue) {
							return decl;
			}
			if (currentValue && !previousValue) {
							context.report({
				node: memo,
				message: 'Shorthand props must be listed after all other props'
							});
							return memo;
			}
					}

					if (!noSortAlphabetically && currentPropName < previousPropName) {
			context.report({
							node: decl,
							message: 'Props should be sorted alphabetically',
							fix: generateFixerFunction(node, context)
			});
			return memo;
					}

					return decl;
		}, node.attributes[0]);
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function(process) {/**
 * @fileoverview Validate spacing before closing bracket in JSX.
 * @author ryym
 * @deprecated
 */


var getTokenBeforeClosingBracket = __webpack_require__(171);
var isWarnedForDeprecation = false;
module.exports = {
  meta: {
	deprecated: true,
	docs: {
			description: 'Validate spacing before closing bracket in JSX',
			category: 'Stylistic Issues',
			recommended: false
	},
	fixable: 'code',

	schema: [{
			enum: ['always', 'never']
	}]
  },

  create: function create(context) {
	var configuration = context.options[0] || 'always';
	var sourceCode = context.getSourceCode();

	var NEVER_MESSAGE = 'A space is forbidden before closing bracket';
	var ALWAYS_MESSAGE = 'A space is required before closing bracket';
	return {
			JSXOpeningElement: function JSXOpeningElement(node) {
		if (!node.selfClosing) {
					return;
		}

		var leftToken = getTokenBeforeClosingBracket(node);
		var closingSlash = sourceCode.getTokenAfter(leftToken);

		if (leftToken.loc.end.line !== closingSlash.loc.start.line) {
					return;
		}

		if (configuration === 'always' && !sourceCode.isSpaceBetweenTokens(leftToken, closingSlash)) {
					context.report({
			loc: closingSlash.loc.start,
			message: ALWAYS_MESSAGE,
			fix: function fix(fixer) {
							return fixer.insertTextBefore(closingSlash, ' ');
			}
					});
		} else if (configuration === 'never' && sourceCode.isSpaceBetweenTokens(leftToken, closingSlash)) {
					context.report({
			loc: closingSlash.loc.start,
			message: NEVER_MESSAGE,
			fix: function fix(fixer) {
							var previousToken = sourceCode.getTokenBefore(closingSlash);
							return fixer.removeRange([previousToken.range[1], closingSlash.range[0]]);
			}
					});
		}
			},

			Program: function Program() {
		if (isWarnedForDeprecation || /\=-(f|-format)=/.test(process.argv.join('='))) {
					return;
		}
		console.log('The react/jsx-space-before-closing rule is deprecated. ' + 'Please use the react/jsx-tag-spacing rule with the ' + '"beforeSelfClosing" option instead.');
		isWarnedForDeprecation = true;
			}
	};
  }
};
}.call(exports, __webpack_require__(20)))
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
var getTokenBeforeClosingBracket = __webpack_require__(171);
function validateClosingSlash(context, node, option) {
  var sourceCode = context.getSourceCode();

  var SELF_CLOSING_NEVER_MESSAGE = 'Whitespace is forbidden between `/` and `>`; write `/>`';
  var SELF_CLOSING_ALWAYS_MESSAGE = 'Whitespace is required between `/` and `>`; write `/ >`';
  var NEVER_MESSAGE = 'Whitespace is forbidden between `<` and `/`; write `</`';
  var ALWAYS_MESSAGE = 'Whitespace is required between `<` and `/`; write `< /`';

  var adjacent = void 0;

  if (node.selfClosing) {
	var lastTokens = sourceCode.getLastTokens(node, 2);

	adjacent = !sourceCode.isSpaceBetweenTokens(lastTokens[0], lastTokens[1]);

	if (option === 'never') {
			if (!adjacent) {
		context.report({
					node: node,
					loc: {
			start: lastTokens[0].loc.start,
			end: lastTokens[1].loc.end
					},
					message: SELF_CLOSING_NEVER_MESSAGE,
					fix: function fix(fixer) {
			return fixer.removeRange([lastTokens[0].range[1], lastTokens[1].range[0]]);
					}
		});
			}
	} else if (option === 'always' && adjacent) {
			context.report({
		node: node,
		loc: {
					start: lastTokens[0].loc.start,
					end: lastTokens[1].loc.end
		},
		message: SELF_CLOSING_ALWAYS_MESSAGE,
		fix: function fix(fixer) {
					return fixer.insertTextBefore(lastTokens[1], ' ');
		}
			});
	}
  } else {
	var firstTokens = sourceCode.getFirstTokens(node, 2);

	adjacent = !sourceCode.isSpaceBetweenTokens(firstTokens[0], firstTokens[1]);

	if (option === 'never') {
			if (!adjacent) {
		context.report({
					node: node,
					loc: {
			start: firstTokens[0].loc.start,
			end: firstTokens[1].loc.end
					},
					message: NEVER_MESSAGE,
					fix: function fix(fixer) {
			return fixer.removeRange([firstTokens[0].range[1], firstTokens[1].range[0]]);
					}
		});
			}
	} else if (option === 'always' && adjacent) {
			context.report({
		node: node,
		loc: {
					start: firstTokens[0].loc.start,
					end: firstTokens[1].loc.end
		},
		message: ALWAYS_MESSAGE,
		fix: function fix(fixer) {
					return fixer.insertTextBefore(firstTokens[1], ' ');
		}
			});
	}
  }
}

function validateBeforeSelfClosing(context, node, option) {
  var sourceCode = context.getSourceCode();

  var NEVER_MESSAGE = 'A space is forbidden before closing bracket';
  var ALWAYS_MESSAGE = 'A space is required before closing bracket';

  var leftToken = getTokenBeforeClosingBracket(node);
  var closingSlash = sourceCode.getTokenAfter(leftToken);

  if (leftToken.loc.end.line !== closingSlash.loc.start.line) {
	return;
  }

  if (option === 'always' && !sourceCode.isSpaceBetweenTokens(leftToken, closingSlash)) {
	context.report({
			node: node,
			loc: closingSlash.loc.start,
			message: ALWAYS_MESSAGE,
			fix: function fix(fixer) {
		return fixer.insertTextBefore(closingSlash, ' ');
			}
	});
  } else if (option === 'never' && sourceCode.isSpaceBetweenTokens(leftToken, closingSlash)) {
	context.report({
			node: node,
			loc: closingSlash.loc.start,
			message: NEVER_MESSAGE,
			fix: function fix(fixer) {
		var previousToken = sourceCode.getTokenBefore(closingSlash);
		return fixer.removeRange([previousToken.range[1], closingSlash.range[0]]);
			}
	});
  }
}

function validateAfterOpening(context, node, option) {
  var sourceCode = context.getSourceCode();

  var NEVER_MESSAGE = 'A space is forbidden after opening bracket';
  var ALWAYS_MESSAGE = 'A space is required after opening bracket';

  var openingToken = sourceCode.getTokenBefore(node.name);

  if (option === 'allow-multiline') {
	if (openingToken.loc.start.line !== node.name.loc.start.line) {
			return;
	}
  }

  var adjacent = !sourceCode.isSpaceBetweenTokens(openingToken, node.name);

  if (option === 'never' || option === 'allow-multiline') {
	if (!adjacent) {
			context.report({
		node: node,
		loc: {
					start: openingToken.loc.start,
					end: node.name.loc.start
		},
		message: NEVER_MESSAGE,
		fix: function fix(fixer) {
					return fixer.removeRange([openingToken.range[1], node.name.range[0]]);
		}
			});
	}
  } else if (option === 'always' && adjacent) {
	context.report({
			node: node,
			loc: {
		start: openingToken.loc.start,
		end: node.name.loc.start
			},
			message: ALWAYS_MESSAGE,
			fix: function fix(fixer) {
		return fixer.insertTextBefore(node.name, ' ');
			}
	});
  }
}
module.exports = {
  meta: {
	docs: {},
	fixable: 'whitespace',
	schema: [{
			type: 'object',
			properties: {
		closingSlash: {
					enum: ['always', 'never', 'allow']
		},
		beforeSelfClosing: {
					enum: ['always', 'never', 'allow']
		},
		afterOpening: {
					enum: ['always', 'allow-multiline', 'never', 'allow']
		}
			},
			default: {
		closingSlash: 'never',
		beforeSelfClosing: 'always',
		afterOpening: 'never'
			},
			additionalProperties: false
	}]
  },
  create: function create(context) {
	var options = {
			closingSlash: 'never',
			beforeSelfClosing: 'always',
			afterOpening: 'never'
	};
	for (var key in options) {
			if (has(options, key) && has(context.options[0] || {}, key)) {
		options[key] = context.options[0][key];
			}
	}

	return {
			JSXOpeningElement: function JSXOpeningElement(node) {
		if (options.closingSlash !== 'allow' && node.selfClosing) {
					validateClosingSlash(context, node, options.closingSlash);
		}
		if (options.afterOpening !== 'allow') {
					validateAfterOpening(context, node, options.afterOpening);
		}
		if (options.beforeSelfClosing !== 'allow' && node.selfClosing) {
					validateBeforeSelfClosing(context, node, options.beforeSelfClosing);
		}
			},
			JSXClosingElement: function JSXClosingElement(node) {
		if (options.afterOpening !== 'allow') {
					validateAfterOpening(context, node, options.afterOpening);
		}
		if (options.closingSlash !== 'allow') {
					validateClosingSlash(context, node, options.closingSlash);
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var pragmaUtil = __webpack_require__(71);
module.exports = {
  meta: {
	docs: {
			description: 'Prevent React to be marked as unused',
			category: 'Best Practices',
			recommended: true
	},
	schema: []
  },

  create: function create(context) {
	var pragma = pragmaUtil.getFromContext(context);
	return {

			JSXOpeningElement: function JSXOpeningElement() {
		context.markVariableAsUsed(pragma);
			}

	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
  meta: {
	docs: {
			description: 'Prevent variables used in JSX to be marked as unused',
			category: 'Best Practices',
			recommended: true
	},
	schema: []
  },

  create: function create(context) {
	return {
			JSXOpeningElement: function JSXOpeningElement(node) {
		var name = void 0;
		if (node.name.namespace && node.name.namespace.name) {
					name = node.name.namespace.name;
		} else if (node.name.name) {
					name = node.name.name;
		} else if (node.name.object) {
					var parent = node.name.object;
					while (parent.object) {
			parent = parent.object;
					}
					name = parent.name;
		} else {
					return;
		}

		context.markVariableAsUsed(name);
			}

	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
var DEFAULTS = {
  declaration: true,
  assignment: true,
  return: true,
  arrow: true
};
module.exports = {
  meta: {
	docs: {
			description: 'Prevent missing parentheses around multilines JSX',
			category: 'Stylistic Issues',
			recommended: false
	},
	fixable: 'code',

	schema: [{
			type: 'object',
			properties: {
		declaration: {
					type: 'boolean'
		},
		assignment: {
					type: 'boolean'
		},
		return: {
					type: 'boolean'
		},
		arrow: {
					type: 'boolean'
		}
			},
			additionalProperties: false
	}]
  },

  create: function create(context) {
	var sourceCode = context.getSourceCode();

	function isParenthesised(node) {
			var previousToken = sourceCode.getTokenBefore(node);
			var nextToken = sourceCode.getTokenAfter(node);

			return previousToken && nextToken && previousToken.value === '(' && previousToken.range[1] <= node.range[0] && nextToken.value === ')' && nextToken.range[0] >= node.range[1];
	}

	function isMultilines(node) {
			return node.loc.start.line !== node.loc.end.line;
	}

	function check(node) {
			if (!node || node.type !== 'JSXElement') {
		return;
			}

			if (!isParenthesised(node) && isMultilines(node)) {
		context.report({
					node: node,
					message: 'Missing parentheses around multilines JSX',
					fix: function fix(fixer) {
			return fixer.replaceText(node, '(' + sourceCode.getText(node) + ')');
					}
		});
			}
	}

	function isEnabled(type) {
			var userOptions = context.options[0] || {};
			if (has(userOptions, type)) {
		return userOptions[type];
			}
			return DEFAULTS[type];
	}
	return {

			VariableDeclarator: function VariableDeclarator(node) {
		if (!isEnabled('declaration')) {
					return;
		}
		if (node.init && node.init.type === 'ConditionalExpression') {
					check(node.init.consequent);
					check(node.init.alternate);
					return;
		}
		check(node.init);
			},

			AssignmentExpression: function AssignmentExpression(node) {
		if (!isEnabled('assignment')) {
					return;
		}
		if (node.right.type === 'ConditionalExpression') {
					check(node.right.consequent);
					check(node.right.alternate);
					return;
		}
		check(node.right);
			},

			ReturnStatement: function ReturnStatement(node) {
		if (isEnabled('return')) {
					check(node.argument);
		}
			},

			'ArrowFunctionExpression:exit': function ArrowFunctionExpressionExit(node) {
		var arrowBody = node.body;

		if (isEnabled('arrow') && arrowBody.type !== 'BlockStatement') {
					check(arrowBody);
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
module.exports = {
  meta: {
	docs: {
			description: 'Prevent usage of Array index in keys',
			category: 'Best Practices',
			recommended: false
	},

	schema: []
  },

  create: function create(context) {
	var indexParamNames = [];
	var iteratorFunctionsToIndexParamPosition = {
			every: 1,
			filter: 1,
			find: 1,
			findIndex: 1,
			forEach: 1,
			map: 1,
			reduce: 2,
			reduceRight: 2,
			some: 1
	};
	var ERROR_MESSAGE = 'Do not use Array index in keys';

	function isArrayIndex(node) {
			return node.type === 'Identifier' && indexParamNames.indexOf(node.name) !== -1;
	}

	function getMapIndexParamName(node) {
			var callee = node.callee;
			if (callee.type !== 'MemberExpression') {
		return null;
			}
			if (callee.property.type !== 'Identifier') {
		return null;
			}
			if (!has(iteratorFunctionsToIndexParamPosition, callee.property.name)) {
		return null;
			}

			var firstArg = node.arguments[0];
			if (!firstArg) {
		return null;
			}

			var isFunction = ['ArrowFunctionExpression', 'FunctionExpression'].indexOf(firstArg.type) !== -1;
			if (!isFunction) {
		return null;
			}

			var params = firstArg.params;

			var indexParamPosition = iteratorFunctionsToIndexParamPosition[callee.property.name];
			if (params.length < indexParamPosition + 1) {
		return null;
			}

			return params[indexParamPosition].name;
	}

	function getIdentifiersFromBinaryExpression(side) {
			if (side.type === 'Identifier') {
		return side;
			}

			if (side.type === 'BinaryExpression') {
		var left = getIdentifiersFromBinaryExpression(side.left);
		var right = getIdentifiersFromBinaryExpression(side.right);
		return [].concat(left, right).filter(Boolean);
			}

			return null;
	}

	function checkPropValue(node) {
			if (isArrayIndex(node)) {
		context.report({
					node: node,
					message: ERROR_MESSAGE
		});
		return;
			}

			if (node.type === 'TemplateLiteral') {
		node.expressions.filter(isArrayIndex).forEach(function () {
					context.report({ node: node, message: ERROR_MESSAGE });
		});

		return;
			}

			if (node.type === 'BinaryExpression') {
		var identifiers = getIdentifiersFromBinaryExpression(node);

		identifiers.filter(isArrayIndex).forEach(function () {
					context.report({ node: node, message: ERROR_MESSAGE });
		});

		return;
			}
	}

	return {
			CallExpression: function CallExpression(node) {
		if (node.callee && node.callee.type === 'MemberExpression' && ['createElement', 'cloneElement'].indexOf(node.callee.property.name) !== -1 && node.arguments.length > 1) {
					if (!indexParamNames.length) {
			return;
					}

					var props = node.arguments[1];

					if (props.type !== 'ObjectExpression') {
			return;
					}

					props.properties.forEach(function (prop) {
			if (!prop.key || prop.key.name !== 'key') {
							return;
			}

			checkPropValue(prop.value);
					});

					return;
		}

		var mapIndexParamName = getMapIndexParamName(node);
		if (!mapIndexParamName) {
					return;
		}

		indexParamNames.push(mapIndexParamName);
			},

			JSXAttribute: function JSXAttribute(node) {
		if (node.name.name !== 'key') {
					return;
		}

		if (!indexParamNames.length) {
					return;
		}

		var value = node.value;
		if (!value || value.type !== 'JSXExpressionContainer') {
					return;
		}

		checkPropValue(value.expression);
			},

			'CallExpression:exit': function CallExpressionExit(node) {
		var mapIndexParamName = getMapIndexParamName(node);
		if (!mapIndexParamName) {
					return;
		}

		indexParamNames.pop();
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";

function isCreateElementWithProps(node) {
  return node.callee && node.callee.type === 'MemberExpression' && node.callee.property.name === 'createElement' && node.arguments.length > 1 && node.arguments[1].type === 'ObjectExpression';
}
module.exports = {
  meta: {
	docs: {
			description: 'Prevent passing of children as props.',
			category: 'Best Practices',
			recommended: true
	},
	schema: []
  },
  create: function create(context) {
	return {
			JSXAttribute: function JSXAttribute(node) {
		if (node.name.name !== 'children') {
					return;
		}

		context.report({
					node: node,
					message: 'Do not pass children as props. Instead, nest children between the opening and closing tags.'
		});
			},
			CallExpression: function CallExpression(node) {
		if (!isCreateElementWithProps(node)) {
					return;
		}

		var props = node.arguments[1].properties;
		var childrenProp = props.find(function (prop) {
					return prop.key && prop.key.name === 'children';
		});

		if (childrenProp) {
					context.report({
			node: node,
			message: 'Do not pass children as props. Instead, pass them as additional arguments to React.createElement.'
					});
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var DANGEROUS_MESSAGE = 'Dangerous property \'{{name}}\' found';

var DANGEROUS_PROPERTY_NAMES = ['dangerouslySetInnerHTML'];

var DANGEROUS_PROPERTIES = DANGEROUS_PROPERTY_NAMES.reduce(function (props, prop) {
  props[prop] = prop;
  return props;
}, Object.create(null));
var tagConvention = /^[a-z]|\-/;
function isTagName(name) {
  return tagConvention.test(name);
}
function isDangerous(name) {
  return name in DANGEROUS_PROPERTIES;
}
module.exports = {
  meta: {
	docs: {
			description: 'Prevent usage of dangerous JSX props',
			category: 'Best Practices',
			recommended: false
	},
	schema: []
  },

  create: function create(context) {
	return {

			JSXAttribute: function JSXAttribute(node) {
		if (isTagName(node.parent.name.name) && isDangerous(node.name.name)) {
					context.report({
			node: node,
			message: DANGEROUS_MESSAGE,
			data: {
							name: node.name.name
			}
					});
		}
			}

	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var variableUtil = __webpack_require__(27);
module.exports = {
  meta: {
	docs: {
			description: 'Report when a DOM element is using both children and dangerouslySetInnerHTML',
			category: '',
			recommended: true
	},
	schema: [] // no options
  },
  create: function create(context) {
	function findSpreadVariable(name) {
			return variableUtil.variablesInScope(context).find(function (item) {
		return item.name === name;
			});
	}
	function findObjectProp(node, propName) {
			if (!node.properties) {
		return false;
			}
			return node.properties.find(function (prop) {
		if (prop.type === 'Property') {
					return prop.key.name === propName;
		} else if (prop.type === 'ExperimentalSpreadProperty') {
					var variable = findSpreadVariable(prop.argument.name);
					if (variable && variable.defs.length && variable.defs[0].node.init) {
			return findObjectProp(variable.defs[0].node.init, propName);
					}
		}
		return false;
			});
	}
	function findJsxProp(node, propName) {
			var attributes = node.openingElement.attributes;
			return attributes.find(function (attribute) {
		if (attribute.type === 'JSXSpreadAttribute') {
					var variable = findSpreadVariable(attribute.argument.name);
					if (variable && variable.defs.length && variable.defs[0].node.init) {
			return findObjectProp(variable.defs[0].node.init, propName);
					}
		}
		return attribute.name && attribute.name.name === propName;
			});
	}
	function isLineBreak(node) {
			var isLiteral = node.type === 'Literal';
			var isMultiline = node.loc.start.line !== node.loc.end.line;
			var isWhiteSpaces = /^\s*$/.test(node.value);

			return isLiteral && isMultiline && isWhiteSpaces;
	}

	return {
			JSXElement: function JSXElement(node) {
		var hasChildren = false;

		if (node.children.length && !isLineBreak(node.children[0])) {
					hasChildren = true;
		} else if (findJsxProp(node, 'children')) {
					hasChildren = true;
		}

		if (node.openingElement.attributes && hasChildren && findJsxProp(node, 'dangerouslySetInnerHTML')) {
					context.report(node, 'Only set one of `children` or `props.dangerouslySetInnerHTML`');
		}
			},
			CallExpression: function CallExpression(node) {
		if (node.callee && node.callee.type === 'MemberExpression' && node.callee.property.name === 'createElement' && node.arguments.length > 1) {
					var hasChildren = false;

					var props = node.arguments[1];

					if (props.type === 'Identifier') {
			var variable = variableUtil.variablesInScope(context).find(function (item) {
							return item.name === props.name;
			});
			if (variable && variable.defs.length && variable.defs[0].node.init) {
							props = variable.defs[0].node.init;
			}
					}

					var dangerously = findObjectProp(props, 'dangerouslySetInnerHTML');

					if (node.arguments.length === 2) {
			if (findObjectProp(props, 'children')) {
							hasChildren = true;
			}
					} else {
			hasChildren = true;
					}

					if (dangerously && hasChildren) {
			context.report(node, 'Only set one of `children` or `props.dangerouslySetInnerHTML`');
					}
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);

var pragmaUtil = __webpack_require__(71);
var versionUtil = __webpack_require__(57);
var MODULES = {
  react: ['React'],
  'react-addons-perf': ['ReactPerf', 'Perf']
};

var DEPRECATED_MESSAGE = '{{oldMethod}} is deprecated since React {{version}}{{newMethod}}';
module.exports = {
  meta: {
	docs: {
			description: 'Prevent usage of deprecated methods',
			category: 'Best Practices',
			recommended: true
	},
	schema: []
  },

  create: function create(context) {
	var sourceCode = context.getSourceCode();
	var pragma = pragmaUtil.getFromContext(context);

	function getDeprecated() {
			var deprecated = {};
			deprecated[pragma + '.renderComponent'] = ['0.12.0', pragma + '.render'];
			deprecated[pragma + '.renderComponentToString'] = ['0.12.0', pragma + '.renderToString'];
			deprecated[pragma + '.renderComponentToStaticMarkup'] = ['0.12.0', pragma + '.renderToStaticMarkup'];
			deprecated[pragma + '.isValidComponent'] = ['0.12.0', pragma + '.isValidElement'];
			deprecated[pragma + '.PropTypes.component'] = ['0.12.0', pragma + '.PropTypes.element'];
			deprecated[pragma + '.PropTypes.renderable'] = ['0.12.0', pragma + '.PropTypes.node'];
			deprecated[pragma + '.isValidClass'] = ['0.12.0'];
			deprecated['this.transferPropsTo'] = ['0.12.0', 'spread operator ({...})'];
			deprecated[pragma + '.addons.classSet'] = ['0.13.0', 'the npm module classnames'];
			deprecated[pragma + '.addons.cloneWithProps'] = ['0.13.0', pragma + '.cloneElement'];
			deprecated[pragma + '.render'] = ['0.14.0', 'ReactDOM.render'];
			deprecated[pragma + '.unmountComponentAtNode'] = ['0.14.0', 'ReactDOM.unmountComponentAtNode'];
			deprecated[pragma + '.findDOMNode'] = ['0.14.0', 'ReactDOM.findDOMNode'];
			deprecated[pragma + '.renderToString'] = ['0.14.0', 'ReactDOMServer.renderToString'];
			deprecated[pragma + '.renderToStaticMarkup'] = ['0.14.0', 'ReactDOMServer.renderToStaticMarkup'];
			deprecated[pragma + '.addons.LinkedStateMixin'] = ['15.0.0'];
			deprecated['ReactPerf.printDOM'] = ['15.0.0', 'ReactPerf.printOperations'];
			deprecated['Perf.printDOM'] = ['15.0.0', 'Perf.printOperations'];
			deprecated['ReactPerf.getMeasurementsSummaryMap'] = ['15.0.0', 'ReactPerf.getWasted'];
			deprecated['Perf.getMeasurementsSummaryMap'] = ['15.0.0', 'Perf.getWasted'];
			deprecated[pragma + '.createClass'] = ['15.5.0', 'the npm module create-react-class'];
			deprecated[pragma + '.PropTypes'] = ['15.5.0', 'the npm module prop-types'];

			return deprecated;
	}

	function isDeprecated(method) {
			var deprecated = getDeprecated();

			return deprecated && deprecated[method] && versionUtil.testReactVersion(context, deprecated[method][0]);
	}

	function checkDeprecation(node, method) {
			if (!isDeprecated(method)) {
		return;
			}
			var deprecated = getDeprecated();
			context.report({
		node: node,
		message: DEPRECATED_MESSAGE,
		data: {
					oldMethod: method,
					version: deprecated[method][0],
					newMethod: deprecated[method][1] ? ', use ' + deprecated[method][1] + ' instead' : ''
		}
			});
	}

	function getReactModuleName(node) {
			var moduleName = false;
			if (!node.init) {
		return moduleName;
			}
			for (var _module in MODULES) {
		if (!has(MODULES, _module)) {
					continue;
		}
		moduleName = MODULES[_module].find(function (name) {
					return name === node.init.name;
		});
		if (moduleName) {
					break;
		}
			}
			return moduleName;
	}
	return {

			MemberExpression: function MemberExpression(node) {
		checkDeprecation(node, sourceCode.getText(node));
			},

			ImportDeclaration: function ImportDeclaration(node) {
		var isReactImport = typeof MODULES[node.source.value] !== 'undefined';
		if (!isReactImport) {
					return;
		}
		node.specifiers.forEach(function (specifier) {
					if (!specifier.imported) {
			return;
					}
					checkDeprecation(node, MODULES[node.source.value][0] + '.' + specifier.imported.name);
		});
			},

			VariableDeclarator: function VariableDeclarator(node) {
		var reactModuleName = getReactModuleName(node);
		var isRequire = node.init && node.init.callee && node.init.callee.name === 'require';
		var isReactRequire = node.init && node.init.arguments && node.init.arguments.length && typeof MODULES[node.init.arguments[0].value] !== 'undefined';
		var isDestructuring = node.id && node.id.type === 'ObjectPattern';

		if (!(isDestructuring && reactModuleName) && !(isDestructuring && isRequire && isReactRequire)) {
					return;
		}
		node.id.properties.forEach(function (property) {
					checkDeprecation(node, (reactModuleName || pragma) + '.' + property.key.name);
		});
			}

	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var makeNoMethodSetStateRule = __webpack_require__(111);

module.exports = makeNoMethodSetStateRule('componentDidMount');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var makeNoMethodSetStateRule = __webpack_require__(111);

module.exports = makeNoMethodSetStateRule('componentDidUpdate');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var Components = __webpack_require__(8);
module.exports = {
  meta: {
	docs: {
			description: 'Prevent direct mutation of this.state',
			category: 'Possible Errors',
			recommended: true
	}
  },

  create: Components.detect(function (context, components, utils) {
	function isValid(component) {
			return Boolean(component && !component.mutateSetState);
	}
	function reportMutations(component) {
			var mutation = void 0;
			for (var i = 0, j = component.mutations.length; i < j; i++) {
		mutation = component.mutations[i];
		context.report({
					node: mutation,
					message: 'Do not mutate state directly. Use setState().'
		});
			}
	}
	function getOuterMemberExpression(node) {
			while (node.object && node.object.property) {
		node = node.object;
			}
			return node;
	}
	function isStateMemberExpression(node) {
			return node.object.type === 'ThisExpression' && node.property.name === 'state';
	}
	function shouldIgnoreComponent(component) {
			return !component || component.inConstructor && !component.inCallExpression;
	}
	return {
			MethodDefinition: function MethodDefinition(node) {
		if (node.kind === 'constructor') {
					components.set(node, {
			inConstructor: true
					});
		}
			},


			CallExpression: function CallExpression(node) {
		components.set(node, {
					inCallExpression: true
		});
			},

			AssignmentExpression: function AssignmentExpression(node) {
		var component = components.get(utils.getParentComponent());
		if (shouldIgnoreComponent(component) || !node.left || !node.left.object) {
					return;
		}
		var item = getOuterMemberExpression(node.left);
		if (isStateMemberExpression(item)) {
					var mutations = component && component.mutations || [];
					mutations.push(node.left.object);
					components.set(node, {
			mutateSetState: true,
			mutations: mutations
					});
		}
			},
			UpdateExpression: function UpdateExpression(node) {
		var component = components.get(utils.getParentComponent());
		if (shouldIgnoreComponent(component) || node.argument.type !== 'MemberExpression') {
					return;
		}
		var item = getOuterMemberExpression(node.argument);
		if (isStateMemberExpression(item)) {
					var mutations = component && component.mutations || [];
					mutations.push(item);
					components.set(node, {
			mutateSetState: true,
			mutations: mutations
					});
		}
			},


			'CallExpression:exit': function CallExpressionExit(node) {
		components.set(node, {
					inCallExpression: false
		});
			},

			'MethodDefinition:exit': function MethodDefinitionExit(node) {
		if (node.kind === 'constructor') {
					components.set(node, {
			inConstructor: false
					});
		}
			},

			'Program:exit': function ProgramExit() {
		var list = components.list();

		Object.keys(list).forEach(function (key) {
					if (!isValid(list[key])) {
			reportMutations(list[key]);
					}
		});
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
  meta: {
	docs: {
			description: 'Prevent usage of findDOMNode',
			category: 'Best Practices',
			recommended: true
	},
	schema: []
  },

  create: function create(context) {
	return {

			CallExpression: function CallExpression(node) {
		var callee = node.callee;

		var isfindDOMNode = callee.name === 'findDOMNode' || callee.property && callee.property.name === 'findDOMNode';

		if (!isfindDOMNode) {
					return;
		}

		context.report({
					node: callee,
					message: 'Do not use findDOMNode'
		});
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
  meta: {
	docs: {
			description: 'Prevent usage of isMounted',
			category: 'Best Practices',
			recommended: true
	},
	schema: []
  },

  create: function create(context) {
	return {

			CallExpression: function CallExpression(node) {
		var callee = node.callee;
		if (callee.type !== 'MemberExpression') {
					return;
		}
		if (callee.object.type !== 'ThisExpression' || callee.property.name !== 'isMounted') {
					return;
		}
		var ancestors = context.getAncestors(callee);
		for (var i = 0, j = ancestors.length; i < j; i++) {
					if (ancestors[i].type === 'Property' || ancestors[i].type === 'MethodDefinition') {
			context.report({
							node: callee,
							message: 'Do not use isMounted'
			});
			break;
					}
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
var Components = __webpack_require__(8);
module.exports = {
  meta: {
	docs: {
			description: 'Prevent multiple component definition per file',
			category: 'Stylistic Issues',
			recommended: false
	},

	schema: [{
			type: 'object',
			properties: {
		ignoreStateless: {
					default: false,
					type: 'boolean'
		}
			},
			additionalProperties: false
	}]
  },

  create: Components.detect(function (context, components) {
	var configuration = context.options[0] || {};
	var ignoreStateless = configuration.ignoreStateless || false;

	var MULTI_COMP_MESSAGE = 'Declare only one React component per file';
	function isIgnored(component) {
			return ignoreStateless && /Function/.test(component.node.type);
	}
	return {
			'Program:exit': function ProgramExit() {
		if (components.length() <= 1) {
					return;
		}

		var list = components.list();
		var i = 0;

		for (var component in list) {
					if (!has(list, component) || isIgnored(list[component]) || ++i === 1) {
			continue;
					}
					context.report({
			node: list[component].node,
			message: MULTI_COMP_MESSAGE
					});
		}
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
var Components = __webpack_require__(8);
module.exports = {
  meta: {
	docs: {
			description: 'Prevent usage of setState',
			category: 'Stylistic Issues',
			recommended: false
	},
	schema: []
  },

  create: Components.detect(function (context, components, utils) {
	function isValid(component) {
			return Boolean(component && !component.useSetState);
	}
	function reportSetStateUsages(component) {
			var setStateUsage = void 0;
			for (var i = 0, j = component.setStateUsages.length; i < j; i++) {
		setStateUsage = component.setStateUsages[i];
		context.report({
					node: setStateUsage,
					message: 'Do not use setState'
		});
			}
	}
	return {

			CallExpression: function CallExpression(node) {
		var callee = node.callee;
		if (callee.type !== 'MemberExpression' || callee.object.type !== 'ThisExpression' || callee.property.name !== 'setState') {
					return;
		}
		var component = components.get(utils.getParentComponent());
		var setStateUsages = component && component.setStateUsages || [];
		setStateUsages.push(callee);
		components.set(node, {
					useSetState: true,
					setStateUsages: setStateUsages
		});
			},

			'Program:exit': function ProgramExit() {
		var list = components.list();
		for (var component in list) {
					if (!has(list, component) || isValid(list[component])) {
			continue;
					}
					reportSetStateUsages(list[component]);
		}
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var Components = __webpack_require__(8);
module.exports = {
  meta: {
	docs: {
			description: 'Prevent string definitions for references and prevent referencing this.refs',
			category: 'Best Practices',
			recommended: true
	},
	schema: []
  },

  create: Components.detect(function (context, components, utils) {
	function isRefsUsage(node) {
			return Boolean((utils.getParentES6Component() || utils.getParentES5Component()) && node.object.type === 'ThisExpression' && node.property.name === 'refs');
	}
	function isRefAttribute(node) {
			return Boolean(node.type === 'JSXAttribute' && node.name && node.name.name === 'ref');
	}
	function containsStringLiteral(node) {
			return Boolean(node.value && node.value.type === 'Literal' && typeof node.value.value === 'string');
	}
	function containsStringExpressionContainer(node) {
			return Boolean(node.value && node.value.type === 'JSXExpressionContainer' && node.value.expression && node.value.expression.type === 'Literal' && typeof node.value.expression.value === 'string');
	}

	return {
			MemberExpression: function MemberExpression(node) {
		if (isRefsUsage(node)) {
					context.report({
			node: node,
			message: 'Using this.refs is deprecated.'
					});
		}
			},
			JSXAttribute: function JSXAttribute(node) {
		if (isRefAttribute(node) && (containsStringLiteral(node) || containsStringExpressionContainer(node))) {
					context.report({
			node: node,
			message: 'Using string literals in ref attributes is deprecated.'
					});
		}
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var Components = __webpack_require__(8);

function errorMessage(node) {
  return node + ' does not need shouldComponentUpdate when extending React.PureComponent.';
}
module.exports = {
  meta: {
	docs: {
			description: 'Flag shouldComponentUpdate when extending PureComponent',
			category: 'Possible Errors',
			recommended: false
	},
	schema: []
  },

  create: Components.detect(function (context, components, utils) {
	function getPropertyName(node) {
			if (node.key) {
		return node.key.name;
			} else if (node.type === 'ClassProperty') {
		var tokens = context.getFirstTokens(node, 2);
		return tokens[1] && tokens[1].type === 'Identifier' ? tokens[1].value : tokens[0].value;
			}
			return '';
	}
	function getComponentProperties(node) {
			switch (node.type) {
		case 'ClassExpression':
		case 'ClassDeclaration':
					return node.body.body;
		default:
					return [];
			}
	}
	function hasShouldComponentUpdate(node) {
			var properties = getComponentProperties(node);
			return properties.some(function (property) {
		var name = getPropertyName(property);
		return name === 'shouldComponentUpdate';
			});
	}
	function getNodeName(node) {
			if (node.id) {
		return node.id.name;
			} else if (node.parent && node.parent.id) {
		return node.parent.id.name;
			}
			return '';
	}
	function checkForViolation(node) {
			if (utils.isPureComponent(node)) {
		var hasScu = hasShouldComponentUpdate(node);
		if (hasScu) {
					var className = getNodeName(node);
					context.report({
			node: node,
			message: errorMessage(className)
					});
		}
			}
	}

	return {
			ClassDeclaration: checkForViolation,
			ClassExpression: checkForViolation
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var versionUtil = __webpack_require__(57);
module.exports = {
  meta: {
	docs: {
			description: 'Prevent usage of the return value of React.render',
			category: 'Best Practices',
			recommended: true
	},
	schema: []
  },

  create: function create(context) {
	return {

			CallExpression: function CallExpression(node) {
		var callee = node.callee;
		var parent = node.parent;
		if (callee.type !== 'MemberExpression') {
					return;
		}

		var calleeObjectName = /^ReactDOM$/;
		if (versionUtil.testReactVersion(context, '15.0.0')) {
					calleeObjectName = /^ReactDOM$/;
		} else if (versionUtil.testReactVersion(context, '0.14.0')) {
					calleeObjectName = /^React(DOM)?$/;
		} else if (versionUtil.testReactVersion(context, '0.13.0')) {
					calleeObjectName = /^React$/;
		}

		if (callee.object.type !== 'Identifier' || !calleeObjectName.test(callee.object.name) || callee.property.name !== 'render') {
					return;
		}

		if (parent.type === 'VariableDeclarator' || parent.type === 'Property' || parent.type === 'ReturnStatement' || parent.type === 'ArrowFunctionExpression') {
					context.report({
			node: callee,
			message: 'Do not depend on the return value from ' + callee.object.name + '.render'
					});
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var Components = __webpack_require__(8);
var STATIC_CLASS_PROPERTIES = ['propTypes', 'contextTypes', 'childContextTypes', 'defaultProps'];
var LIFECYCLE_METHODS = ['componentWillMount', 'componentDidMount', 'componentWillReceiveProps', 'shouldComponentUpdate', 'componentWillUpdate', 'componentDidUpdate', 'componentWillUnmount', 'render'];

var PROP_TYPES = Object.keys(__webpack_require__(731));

module.exports = {
  meta: {
	docs: {
			description: 'Prevent common typos',
			category: 'Stylistic Issues',
			recommended: false
	},
	schema: []
  },

  create: Components.detect(function (context, components, utils) {
	function checkValidPropTypeQualfier(node) {
			if (node.name !== 'isRequired') {
		context.report({
					node: node,
					message: 'Typo in prop type chain qualifier: ' + node.name
		});
			}
	}

	function checkValidPropType(node) {
			if (node.name && !PROP_TYPES.some(function (propTypeName) {
		return propTypeName === node.name;
			})) {
		context.report({
					node: node,
					message: 'Typo in declared prop type: ' + node.name
		});
			}
	}
	function checkValidProp(node) {
			if (node && node.type === 'MemberExpression' && node.object.type === 'MemberExpression') {
		checkValidPropType(node.object.property);
		checkValidPropTypeQualfier(node.property);
			} else if (node && node.type === 'MemberExpression' && node.object.type === 'Identifier') {
		checkValidPropType(node.property);
			} else if (node && node.type === 'CallExpression') {
		var callee = node.callee;
		if (callee.type === 'MemberExpression' && callee.property.name === 'shape') {
					checkValidPropObject(node.arguments[0]);
		} else if (callee.type === 'MemberExpression' && callee.property.name === 'oneOfType') {
					var args = node.arguments[0];
					if (args && args.type === 'ArrayExpression') {
			args.elements.forEach(function (el) {
							return checkValidProp(el);
			});
					}
		}
			}
	}

	function checkValidPropObject(node) {
			if (node.type === 'ObjectExpression') {
		node.properties.forEach(function (prop) {
					return checkValidProp(prop.value);
		});
			}
	}

	function reportErrorIfClassPropertyCasingTypo(node, propertyName) {
			if (propertyName === 'propTypes' || propertyName === 'contextTypes' || propertyName === 'childContextTypes') {
		var propsNode = node && node.parent && node.parent.type === 'AssignmentExpression' && node.parent.right;
		checkValidPropObject(propsNode);
			}
			STATIC_CLASS_PROPERTIES.forEach(function (CLASS_PROP) {
		if (propertyName && CLASS_PROP.toLowerCase() === propertyName.toLowerCase() && CLASS_PROP !== propertyName) {
					context.report({
			node: node,
			message: 'Typo in static class property declaration'
					});
		}
			});
	}

	function reportErrorIfLifecycleMethodCasingTypo(node) {
			LIFECYCLE_METHODS.forEach(function (method) {
		if (method.toLowerCase() === node.key.name.toLowerCase() && method !== node.key.name) {
					context.report({
			node: node,
			message: 'Typo in component lifecycle method declaration'
					});
		}
			});
	}

	return {
			ClassProperty: function ClassProperty(node) {
		if (!node.static || !utils.isES6Component(node.parent.parent)) {
					return;
		}

		var tokens = context.getFirstTokens(node, 2);
		var propertyName = tokens[1].value;
		reportErrorIfClassPropertyCasingTypo(node, propertyName);
			},

			MemberExpression: function MemberExpression(node) {
		var propertyName = node.property.name;

		if (!propertyName || STATIC_CLASS_PROPERTIES.map(function (prop) {
					return prop.toLocaleLowerCase();
		}).indexOf(propertyName.toLowerCase()) === -1) {
					return;
		}

		var relatedComponent = utils.getRelatedComponent(node);

		if (relatedComponent && (utils.isES6Component(relatedComponent.node) || utils.isReturningJSX(relatedComponent.node))) {
					reportErrorIfClassPropertyCasingTypo(node, propertyName);
		}
			},

			MethodDefinition: function MethodDefinition(node) {
		if (!utils.isES6Component(node.parent.parent)) {
					return;
		}

		reportErrorIfLifecycleMethodCasingTypo(node);
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function(process) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (process.env.NODE_ENV !== 'production') {
  var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element') || 0xeac7;

  var isValidElement = function isValidElement(object) {
	return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  };
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(732)(isValidElement, throwOnDirectAccess);
} else {
  module.exports = __webpack_require__(734)();
}
}.call(exports, __webpack_require__(20)))
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var emptyFunction = __webpack_require__(112);
var invariant = __webpack_require__(113);
var warning = __webpack_require__(172);
var assign = __webpack_require__(154);

var ReactPropTypesSecret = __webpack_require__(114);
var checkPropTypes = __webpack_require__(733);

module.exports = function (isValidElement, throwOnDirectAccess) {
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
  function getIteratorFn(maybeIterable) {
	var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	if (typeof iteratorFn === 'function') {
			return iteratorFn;
	}
  }

  var ANONYMOUS = '<<anonymous>>';
  var ReactPropTypes = {
	array: createPrimitiveTypeChecker('array'),
	bool: createPrimitiveTypeChecker('boolean'),
	func: createPrimitiveTypeChecker('function'),
	number: createPrimitiveTypeChecker('number'),
	object: createPrimitiveTypeChecker('object'),
	string: createPrimitiveTypeChecker('string'),
	symbol: createPrimitiveTypeChecker('symbol'),

	any: createAnyTypeChecker(),
	arrayOf: createArrayOfTypeChecker,
	element: createElementTypeChecker(),
	instanceOf: createInstanceTypeChecker,
	node: createNodeChecker(),
	objectOf: createObjectOfTypeChecker,
	oneOf: createEnumTypeChecker,
	oneOfType: createUnionTypeChecker,
	shape: createShapeTypeChecker,
	exact: createStrictShapeTypeChecker
  };
  function is(x, y) {
	if (x === y) {
			return x !== 0 || 1 / x === 1 / y;
	} else {
			return x !== x && y !== y;
	}
  }
  function PropTypeError(message) {
	this.message = message;
	this.stack = '';
  }
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
	if (process.env.NODE_ENV !== 'production') {
			var manualPropTypeCallCache = {};
			var manualPropTypeWarningCount = 0;
	}
	function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
			componentName = componentName || ANONYMOUS;
			propFullName = propFullName || propName;

			if (secret !== ReactPropTypesSecret) {
		if (throwOnDirectAccess) {
					invariant(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
		} else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
					var cacheKey = componentName + ':' + propName;
					if (!manualPropTypeCallCache[cacheKey] &&
					manualPropTypeWarningCount < 3) {
			warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName);
			manualPropTypeCallCache[cacheKey] = true;
			manualPropTypeWarningCount++;
					}
		}
			}
			if (props[propName] == null) {
		if (isRequired) {
					if (props[propName] === null) {
			return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
					}
					return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
		}
		return null;
			} else {
		return validate(props, propName, componentName, location, propFullName);
			}
	}

	var chainedCheckType = checkType.bind(null, false);
	chainedCheckType.isRequired = checkType.bind(null, true);

	return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
	function validate(props, propName, componentName, location, propFullName, secret) {
			var propValue = props[propName];
			var propType = getPropType(propValue);
			if (propType !== expectedType) {
		var preciseType = getPreciseType(propValue);

		return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
			}
			return null;
	}
	return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
	return createChainableTypeChecker(emptyFunction.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
	function validate(props, propName, componentName, location, propFullName) {
			if (typeof typeChecker !== 'function') {
		return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
			}
			var propValue = props[propName];
			if (!Array.isArray(propValue)) {
		var propType = getPropType(propValue);
		return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
			}
			for (var i = 0; i < propValue.length; i++) {
		var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
		if (error instanceof Error) {
					return error;
		}
			}
			return null;
	}
	return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
	function validate(props, propName, componentName, location, propFullName) {
			var propValue = props[propName];
			if (!isValidElement(propValue)) {
		var propType = getPropType(propValue);
		return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
			}
			return null;
	}
	return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
	function validate(props, propName, componentName, location, propFullName) {
			if (!(props[propName] instanceof expectedClass)) {
		var expectedClassName = expectedClass.name || ANONYMOUS;
		var actualClassName = getClassName(props[propName]);
		return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
			}
			return null;
	}
	return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
	if (!Array.isArray(expectedValues)) {
			process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
			return emptyFunction.thatReturnsNull;
	}

	function validate(props, propName, componentName, location, propFullName) {
			var propValue = props[propName];
			for (var i = 0; i < expectedValues.length; i++) {
		if (is(propValue, expectedValues[i])) {
					return null;
		}
			}

			var valuesString = JSON.stringify(expectedValues);
			return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	}
	return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
	function validate(props, propName, componentName, location, propFullName) {
			if (typeof typeChecker !== 'function') {
		return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
			}
			var propValue = props[propName];
			var propType = getPropType(propValue);
			if (propType !== 'object') {
		return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
			}
			for (var key in propValue) {
		if (propValue.hasOwnProperty(key)) {
					var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
					if (error instanceof Error) {
			return error;
					}
		}
			}
			return null;
	}
	return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
	if (!Array.isArray(arrayOfTypeCheckers)) {
			process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
			return emptyFunction.thatReturnsNull;
	}

	for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
			var checker = arrayOfTypeCheckers[i];
			if (typeof checker !== 'function') {
		warning(false, 'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received %s at index %s.', getPostfixForTypeWarning(checker), i);
		return emptyFunction.thatReturnsNull;
			}
	}

	function validate(props, propName, componentName, location, propFullName) {
			for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
		var checker = arrayOfTypeCheckers[i];
		if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
					return null;
		}
			}

			return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	}
	return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
	function validate(props, propName, componentName, location, propFullName) {
			if (!isNode(props[propName])) {
		return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
			}
			return null;
	}
	return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
	function validate(props, propName, componentName, location, propFullName) {
			var propValue = props[propName];
			var propType = getPropType(propValue);
			if (propType !== 'object') {
		return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
			}
			for (var key in shapeTypes) {
		var checker = shapeTypes[key];
		if (!checker) {
					continue;
		}
		var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
		if (error) {
					return error;
		}
			}
			return null;
	}
	return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
	function validate(props, propName, componentName, location, propFullName) {
			var propValue = props[propName];
			var propType = getPropType(propValue);
			if (propType !== 'object') {
		return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
			}
			var allKeys = assign({}, props[propName], shapeTypes);
			for (var key in allKeys) {
		var checker = shapeTypes[key];
		if (!checker) {
					return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
		}
		var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
		if (error) {
					return error;
		}
			}
			return null;
	}

	return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
	switch (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) {
			case 'number':
			case 'string':
			case 'undefined':
		return true;
			case 'boolean':
		return !propValue;
			case 'object':
		if (Array.isArray(propValue)) {
					return propValue.every(isNode);
		}
		if (propValue === null || isValidElement(propValue)) {
					return true;
		}

		var iteratorFn = getIteratorFn(propValue);
		if (iteratorFn) {
					var iterator = iteratorFn.call(propValue);
					var step;
					if (iteratorFn !== propValue.entries) {
			while (!(step = iterator.next()).done) {
							if (!isNode(step.value)) {
				return false;
							}
			}
					} else {
			while (!(step = iterator.next()).done) {
							var entry = step.value;
							if (entry) {
				if (!isNode(entry[1])) {
									return false;
				}
							}
			}
					}
		} else {
					return false;
		}

		return true;
			default:
		return false;
	}
  }

  function isSymbol(propType, propValue) {
	if (propType === 'symbol') {
			return true;
	}
	if (propValue['@@toStringTag'] === 'Symbol') {
			return true;
	}
	if (typeof Symbol === 'function' && propValue instanceof Symbol) {
			return true;
	}

	return false;
  }
  function getPropType(propValue) {
	var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);
	if (Array.isArray(propValue)) {
			return 'array';
	}
	if (propValue instanceof RegExp) {
			return 'object';
	}
	if (isSymbol(propType, propValue)) {
			return 'symbol';
	}
	return propType;
  }
  function getPreciseType(propValue) {
	if (typeof propValue === 'undefined' || propValue === null) {
			return '' + propValue;
	}
	var propType = getPropType(propValue);
	if (propType === 'object') {
			if (propValue instanceof Date) {
		return 'date';
			} else if (propValue instanceof RegExp) {
		return 'regexp';
			}
	}
	return propType;
  }
  function getPostfixForTypeWarning(value) {
	var type = getPreciseType(value);
	switch (type) {
			case 'array':
			case 'object':
		return 'an ' + type;
			case 'boolean':
			case 'date':
			case 'regexp':
		return 'a ' + type;
			default:
		return type;
	}
  }
  function getClassName(propValue) {
	if (!propValue.constructor || !propValue.constructor.name) {
			return ANONYMOUS;
	}
	return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};
}.call(exports, __webpack_require__(20)))
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (process.env.NODE_ENV !== 'production') {
  var invariant = __webpack_require__(113);
  var warning = __webpack_require__(172);
  var ReactPropTypesSecret = __webpack_require__(114);
  var loggedTypeFailures = {};
}
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
	for (var typeSpecName in typeSpecs) {
			if (typeSpecs.hasOwnProperty(typeSpecName)) {
		var error;
		try {
					invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, _typeof(typeSpecs[typeSpecName]));
					error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
		} catch (ex) {
					error = ex;
		}
		warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error === 'undefined' ? 'undefined' : _typeof(error));
		if (error instanceof Error && !(error.message in loggedTypeFailures)) {
					loggedTypeFailures[error.message] = true;

					var stack = getStack ? getStack() : '';

					warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
		}
			}
	}
  }
}

module.exports = checkPropTypes;
}.call(exports, __webpack_require__(20)))
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var emptyFunction = __webpack_require__(112);
var invariant = __webpack_require__(113);
var ReactPropTypesSecret = __webpack_require__(114);

module.exports = function () {
  function shim(props, propName, componentName, location, propFullName, secret) {
	if (secret === ReactPropTypesSecret) {
			return;
	}
	invariant(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
  };
  shim.isRequired = shim;
  function getShim() {
	return shim;
  };
  var ReactPropTypes = {
	array: shim,
	bool: shim,
	func: shim,
	number: shim,
	object: shim,
	string: shim,
	symbol: shim,

	any: shim,
	arrayOf: getShim,
	element: shim,
	instanceOf: getShim,
	node: shim,
	objectOf: getShim,
	oneOf: getShim,
	oneOfType: getShim,
	shape: getShim,
	exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var DEFAULTS = ['>', '"', '\'', '}'];

module.exports = {
  meta: {
	docs: {
			description: 'Detect unescaped HTML entities, which might represent malformed tags',
			category: 'Possible Errors',
			recommended: true
	},
	schema: [{
			type: 'object',
			properties: {
		forbid: {
					type: 'array',
					items: {
			type: 'string'
					}
		}
			},
			additionalProperties: false
	}]
  },

  create: function create(context) {
	function reportInvalidEntity(node) {
			var configuration = context.options[0] || {};
			var entities = configuration.forbid || DEFAULTS;
			for (var i = node.loc.start.line; i <= node.loc.end.line; i++) {
		var rawLine = context.getSourceCode().lines[i - 1];
		var start = 0;
		var end = rawLine.length;
		if (i === node.loc.start.line) {
					start = node.loc.start.column;
		}
		if (i === node.loc.end.line) {
					end = node.loc.end.column;
		}
		rawLine = rawLine.substring(start, end);
		for (var j = 0; j < entities.length; j++) {
					for (var index = 0; index < rawLine.length; index++) {
			var c = rawLine[index];
			if (c === entities[j]) {
							context.report({
				loc: { line: i, column: start + index },
				message: 'HTML entities must be escaped.',
				node: node
							});
			}
					}
		}
			}
	}

	return {
			Literal: function Literal(node) {
		if (node.type === 'Literal' && node.parent.type === 'JSXElement') {
					reportInvalidEntity(node);
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var DEFAULTS = {
  ignore: []
};

var UNKNOWN_MESSAGE = 'Unknown property \'{{name}}\' found, use \'{{standardName}}\' instead';

var DOM_ATTRIBUTE_NAMES = {
  'accept-charset': 'acceptCharset',
  class: 'className',
  for: 'htmlFor',
  'http-equiv': 'httpEquiv'
};

var SVGDOM_ATTRIBUTE_NAMES = {
  'accent-height': 'accentHeight',
  'alignment-baseline': 'alignmentBaseline',
  'arabic-form': 'arabicForm',
  'baseline-shift': 'baselineShift',
  'cap-height': 'capHeight',
  'clip-path': 'clipPath',
  'clip-rule': 'clipRule',
  'color-interpolation': 'colorInterpolation',
  'color-interpolation-filters': 'colorInterpolationFilters',
  'color-profile': 'colorProfile',
  'color-rendering': 'colorRendering',
  'dominant-baseline': 'dominantBaseline',
  'enable-background': 'enableBackground',
  'fill-opacity': 'fillOpacity',
  'fill-rule': 'fillRule',
  'flood-color': 'floodColor',
  'flood-opacity': 'floodOpacity',
  'font-family': 'fontFamily',
  'font-size': 'fontSize',
  'font-size-adjust': 'fontSizeAdjust',
  'font-stretch': 'fontStretch',
  'font-style': 'fontStyle',
  'font-variant': 'fontVariant',
  'font-weight': 'fontWeight',
  'glyph-name': 'glyphName',
  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
  'glyph-orientation-vertical': 'glyphOrientationVertical',
  'horiz-adv-x': 'horizAdvX',
  'horiz-origin-x': 'horizOriginX',
  'image-rendering': 'imageRendering',
  'letter-spacing': 'letterSpacing',
  'lighting-color': 'lightingColor',
  'marker-end': 'markerEnd',
  'marker-mid': 'markerMid',
  'marker-start': 'markerStart',
  'overline-position': 'overlinePosition',
  'overline-thickness': 'overlineThickness',
  'paint-order': 'paintOrder',
  'panose-1': 'panose1',
  'pointer-events': 'pointerEvents',
  'rendering-intent': 'renderingIntent',
  'shape-rendering': 'shapeRendering',
  'stop-color': 'stopColor',
  'stop-opacity': 'stopOpacity',
  'strikethrough-position': 'strikethroughPosition',
  'strikethrough-thickness': 'strikethroughThickness',
  'stroke-dasharray': 'strokeDasharray',
  'stroke-dashoffset': 'strokeDashoffset',
  'stroke-linecap': 'strokeLinecap',
  'stroke-linejoin': 'strokeLinejoin',
  'stroke-miterlimit': 'strokeMiterlimit',
  'stroke-opacity': 'strokeOpacity',
  'stroke-width': 'strokeWidth',
  'text-anchor': 'textAnchor',
  'text-decoration': 'textDecoration',
  'text-rendering': 'textRendering',
  'underline-position': 'underlinePosition',
  'underline-thickness': 'underlineThickness',
  'unicode-bidi': 'unicodeBidi',
  'unicode-range': 'unicodeRange',
  'units-per-em': 'unitsPerEm',
  'v-alphabetic': 'vAlphabetic',
  'v-hanging': 'vHanging',
  'v-ideographic': 'vIdeographic',
  'v-mathematical': 'vMathematical',
  'vector-effect': 'vectorEffect',
  'vert-adv-y': 'vertAdvY',
  'vert-origin-x': 'vertOriginX',
  'vert-origin-y': 'vertOriginY',
  'word-spacing': 'wordSpacing',
  'writing-mode': 'writingMode',
  'x-height': 'xHeight',
  'xlink:actuate': 'xlinkActuate',
  'xlink:arcrole': 'xlinkArcrole',
  'xlink:href': 'xlinkHref',
  'xlink:role': 'xlinkRole',
  'xlink:show': 'xlinkShow',
  'xlink:title': 'xlinkTitle',
  'xlink:type': 'xlinkType',
  'xml:base': 'xmlBase',
  'xml:lang': 'xmlLang',
  'xml:space': 'xmlSpace'
};

var DOM_PROPERTY_NAMES = [
'acceptCharset', 'accessKey', 'allowFullScreen', 'allowTransparency', 'autoComplete', 'autoFocus', 'autoPlay', 'cellPadding', 'cellSpacing', 'charSet', 'classID', 'className', 'colSpan', 'contentEditable', 'contextMenu', 'crossOrigin', 'dateTime', 'encType', 'formAction', 'formEncType', 'formMethod', 'formNoValidate', 'formTarget', 'frameBorder', 'hrefLang', 'htmlFor', 'httpEquiv', 'inputMode', 'keyParams', 'keyType', 'marginHeight', 'marginWidth', 'maxLength', 'mediaGroup', 'minLength', 'noValidate', 'onAnimationEnd', 'onAnimationIteration', 'onAnimationStart', 'onBlur', 'onChange', 'onClick', 'onContextMenu', 'onCopy', 'onCompositionEnd', 'onCompositionStart', 'onCompositionUpdate', 'onCut', 'onDoubleClick', 'onDrag', 'onDragEnd', 'onDragEnter', 'onDragExit', 'onDragLeave', 'onError', 'onFocus', 'onInput', 'onKeyDown', 'onKeyPress', 'onKeyUp', 'onLoad', 'onWheel', 'onDragOver', 'onDragStart', 'onDrop', 'onMouseDown', 'onMouseEnter', 'onMouseLeave', 'onMouseMove', 'onMouseOut', 'onMouseOver', 'onMouseUp', 'onPaste', 'onScroll', 'onSelect', 'onSubmit', 'onTransitionEnd', 'radioGroup', 'readOnly', 'rowSpan', 'spellCheck', 'srcDoc', 'srcLang', 'srcSet', 'tabIndex', 'useMap',
'autoCapitalize', 'autoCorrect', 'autoSave', 'itemProp', 'itemScope', 'itemType', 'itemRef', 'itemID'];
var tagConvention = /^[a-z][^-]*$/;
function isTagName(node) {
  if (tagConvention.test(node.parent.name.name)) {
	return !node.parent.attributes.some(function (attrNode) {
			return attrNode.type === 'JSXAttribute' && attrNode.name.type === 'JSXIdentifier' && attrNode.name.name === 'is';
	});
  }
  return false;
}
function getStandardName(name) {
  if (DOM_ATTRIBUTE_NAMES[name]) {
	return DOM_ATTRIBUTE_NAMES[name];
  }
  if (SVGDOM_ATTRIBUTE_NAMES[name]) {
	return SVGDOM_ATTRIBUTE_NAMES[name];
  }
  var i = void 0;
  var found = DOM_PROPERTY_NAMES.some(function (element, index) {
	i = index;
	return element.toLowerCase() === name;
  });
  return found ? DOM_PROPERTY_NAMES[i] : null;
}
module.exports = {
  meta: {
	docs: {
			description: 'Prevent usage of unknown DOM property',
			category: 'Possible Errors',
			recommended: true
	},
	fixable: 'code',

	schema: [{
			type: 'object',
			properties: {
		ignore: {
					type: 'array',
					items: {
			type: 'string'
					}
		}
			},
			additionalProperties: false
	}]
  },

  create: function create(context) {
	function getIgnoreConfig() {
			return context.options[0] && context.options[0].ignore || DEFAULTS.ignore;
	}

	var sourceCode = context.getSourceCode();

	return {

			JSXAttribute: function JSXAttribute(node) {
		var ignoreNames = getIgnoreConfig();
		var name = sourceCode.getText(node.name);
		var standardName = getStandardName(name);
		if (!isTagName(node) || !standardName || ignoreNames.indexOf(name) >= 0) {
					return;
		}
		context.report({
					node: node,
					message: UNKNOWN_MESSAGE,
					data: {
			name: name,
			standardName: standardName
					},
					fix: function fix(fixer) {
			return fixer.replaceText(node.name, standardName);
					}
		});
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var has = __webpack_require__(7);
var Components = __webpack_require__(8);
var variable = __webpack_require__(27);
var annotations = __webpack_require__(72);
var versionUtil = __webpack_require__(57);
var DIRECT_PROPS_REGEX = /^props\s*(\.|\[)/;
var DIRECT_NEXT_PROPS_REGEX = /^nextProps\s*(\.|\[)/;
var DIRECT_PREV_PROPS_REGEX = /^prevProps\s*(\.|\[)/;
var LIFE_CYCLE_METHODS = ['componentWillReceiveProps', 'shouldComponentUpdate', 'componentWillUpdate', 'componentDidUpdate'];
module.exports = {
  meta: {
	docs: {
			description: 'Prevent definitions of unused prop types',
			category: 'Best Practices',
			recommended: false
	},

	schema: [{
			type: 'object',
			properties: {
		customValidators: {
					type: 'array',
					items: {
			type: 'string'
					}
		},
		skipShapeProps: {
					type: 'boolean'
		}
			},
			additionalProperties: false
	}]
  },

  create: Components.detect(function (context, components, utils) {
	var defaults = { skipShapeProps: true };
	var sourceCode = context.getSourceCode();
	var configuration = Object.assign({}, defaults, context.options[0] || {});
	var skipShapeProps = configuration.skipShapeProps;
	var customValidators = configuration.customValidators || [];
	var propWrapperFunctions = new Set(context.settings.propWrapperFunctions || []);
	var stack = null;

	var UNUSED_MESSAGE = '\'{{name}}\' PropType is defined but prop is never used';
	function typeScope(key, value) {
			if (arguments.length === 0) {
		return stack[stack.length - 1];
			} else if (arguments.length === 1) {
		return stack[stack.length - 1][key];
			}
			stack[stack.length - 1][key] = value;
			return value;
	}
	function inLifeCycleMethod() {
			var scope = context.getScope();
			while (scope) {
		if (scope.block && scope.block.parent && scope.block.parent.key && LIFE_CYCLE_METHODS.indexOf(scope.block.parent.key.name) >= 0) {
					return true;
		}
		scope = scope.upper;
			}
			return false;
	}
	function isPropTypesUsage(node) {
			var isClassUsage = (utils.getParentES6Component() || utils.getParentES5Component()) && node.object.type === 'ThisExpression' && node.property.name === 'props';
			var isStatelessFunctionUsage = node.object.name === 'props';
			return isClassUsage || isStatelessFunctionUsage || inLifeCycleMethod();
	}
	function isAnnotatedClassPropsDeclaration(node) {
			if (node && node.type === 'ClassProperty') {
		var tokens = context.getFirstTokens(node, 2);
		if (node.typeAnnotation && (tokens[0].value === 'props' || tokens[1] && tokens[1].value === 'props')) {
					return true;
		}
			}
			return false;
	}
	function resolveSuperParameterPropsType(node) {
			var propsParameterPosition = void 0;
			try {
		propsParameterPosition = versionUtil.testFlowVersion(context, '0.53.0') ? 0 : 1;
			} catch (e) {
		propsParameterPosition = node.superTypeParameters.params.length <= 2 ? 0 : 1;
			}

			var annotation = node.superTypeParameters.params[propsParameterPosition];
			while (annotation && (annotation.type === 'TypeAnnotation' || annotation.type === 'NullableTypeAnnotation')) {
		annotation = annotation.typeAnnotation;
			}
			if (annotation.type === 'GenericTypeAnnotation' && typeScope(annotation.id.name)) {
		return typeScope(annotation.id.name);
			}
			return annotation;
	}
	function isSuperTypeParameterPropsDeclaration(node) {
			if (node && node.type === 'ClassDeclaration') {
		if (node.superTypeParameters && node.superTypeParameters.params.length > 0) {
					return true;
		}
			}
			return false;
	}
	function isPropTypesDeclaration(node) {
			if (node && node.type === 'ClassProperty') {
		var tokens = context.getFirstTokens(node, 2);
		if (tokens[0].value === 'propTypes' || tokens[1] && tokens[1].value === 'propTypes') {
					return true;
		}
		return false;
			}

			return Boolean(node && node.name === 'propTypes');
	}
	function hasCustomValidator(validator) {
			return customValidators.indexOf(validator) !== -1;
	}
	function mustBeValidated(component) {
			return Boolean(component && !component.ignorePropsValidation);
	}
	function isNodeALifeCycleMethod(node) {
			var nodeKeyName = (node.key || {}).name;
			return node.kind === 'constructor' || nodeKeyName === 'componentWillReceiveProps' || nodeKeyName === 'shouldComponentUpdate' || nodeKeyName === 'componentWillUpdate' || nodeKeyName === 'componentDidUpdate';
	}
	function isInLifeCycleMethod(node) {
			if (node.type === 'MethodDefinition' && isNodeALifeCycleMethod(node)) {
		return true;
			}

			if (node.parent) {
		return isInLifeCycleMethod(node.parent);
			}

			return false;
	}
	function isPropAttributeName(node) {
			return node.init.name === 'props' || node.init.name === 'nextProps' || node.init.name === 'prevProps';
	}
	function isPropUsed(node, prop) {
			var usedPropTypes = node.usedPropTypes || [];
			for (var i = 0, l = usedPropTypes.length; i < l; i++) {
		var usedProp = usedPropTypes[i];
		if (prop.type === 'shape' || prop.name === '__ANY_KEY__' || usedProp.name === prop.name) {
					return true;
		}
			}

			return false;
	}
	function hasSpreadOperator(node) {
			var tokens = sourceCode.getTokens(node);
			return tokens.length && tokens[0].value === '...';
	}
	function stripQuotes(string) {
			return string.replace(/^\'|\'$/g, '');
	}
	function getKeyValue(node) {
			if (node.type === 'ObjectTypeProperty') {
		var tokens = context.getFirstTokens(node, 2);
		return tokens[0].value === '+' || tokens[0].value === '-' ? tokens[1].value : stripQuotes(tokens[0].value);
			}
			var key = node.key || node.argument;
			return key.type === 'Identifier' ? key.name : key.value;
	}
	function iterateProperties(properties, fn) {
			if (properties.length && typeof fn === 'function') {
		for (var i = 0, j = properties.length; i < j; i++) {
					var node = properties[i];
					var key = getKeyValue(node);

					var value = node.value;
					fn(key, value);
		}
			}
	}
	function buildReactDeclarationTypes(value, parentName) {
			if (value && value.callee && value.callee.object && hasCustomValidator(value.callee.object.name)) {
		return {};
			}

			if (value && value.type === 'MemberExpression' && value.property && value.property.name && value.property.name === 'isRequired') {
		value = value.object;
			}
			if (value && value.type === 'CallExpression' && value.callee && value.callee.property && value.callee.property.name && value.arguments && value.arguments.length > 0) {
		var callName = value.callee.property.name;
		var argument = value.arguments[0];
		switch (callName) {
					case 'shape':
			if (skipShapeProps) {
							return {};
			}

			if (argument.type !== 'ObjectExpression') {
							return {};
			}
			var shapeTypeDefinition = {
							type: 'shape',
							children: []
			};
			iterateProperties(argument.properties, function (childKey, childValue) {
							var fullName = [parentName, childKey].join('.');
							var types = buildReactDeclarationTypes(childValue, fullName);
							types.fullName = fullName;
							types.name = childKey;
							types.node = childValue;
							shapeTypeDefinition.children.push(types);
			});
			return shapeTypeDefinition;
					case 'arrayOf':
					case 'objectOf':
			var fullName = [parentName, '*'].join('.');
			var child = buildReactDeclarationTypes(argument, fullName);
			child.fullName = fullName;
			child.name = '__ANY_KEY__';
			child.node = argument;
			return {
							type: 'object',
							children: [child]
			};
					case 'oneOfType':
			if (!argument.elements || !argument.elements.length) {
							return {};
			}
			var unionTypeDefinition = {
							type: 'union',
							children: []
			};
			for (var i = 0, j = argument.elements.length; i < j; i++) {
							var type = buildReactDeclarationTypes(argument.elements[i], parentName);
							if (Object.keys(type).length > 0) {
				if (type.children === true) {
									unionTypeDefinition.children = true;
									return unionTypeDefinition;
				}
							}

							unionTypeDefinition.children.push(type);
			}
			if (unionTypeDefinition.length === 0) {
							return {};
			}
			return unionTypeDefinition;
					case 'instanceOf':
			return {
							type: 'instance',
							children: true
			};
					case 'oneOf':
					default:
			return {};
		}
			}
			return {};
	}
	function buildTypeAnnotationDeclarationTypes(annotation, parentName) {
			switch (annotation.type) {
		case 'GenericTypeAnnotation':
					if (typeScope(annotation.id.name)) {
			return buildTypeAnnotationDeclarationTypes(typeScope(annotation.id.name), parentName);
					}
					return {};
		case 'ObjectTypeAnnotation':
					if (skipShapeProps) {
			return {};
					}
					var shapeTypeDefinition = {
			type: 'shape',
			children: []
					};
					iterateProperties(annotation.properties, function (childKey, childValue) {
			var fullName = [parentName, childKey].join('.');
			var types = buildTypeAnnotationDeclarationTypes(childValue, fullName);
			types.fullName = fullName;
			types.name = childKey;
			types.node = childValue;
			shapeTypeDefinition.children.push(types);
					});
					return shapeTypeDefinition;
		case 'UnionTypeAnnotation':
					var unionTypeDefinition = {
			type: 'union',
			children: []
					};
					for (var i = 0, j = annotation.types.length; i < j; i++) {
			var type = buildTypeAnnotationDeclarationTypes(annotation.types[i], parentName);
			if (Object.keys(type).length > 0) {
							if (type.children === true) {
				unionTypeDefinition.children = true;
				return unionTypeDefinition;
							}
			}

			unionTypeDefinition.children.push(type);
					}
					if (unionTypeDefinition.children.length === 0) {
			return {};
					}
					return unionTypeDefinition;
		case 'ArrayTypeAnnotation':
					var fullName = [parentName, '*'].join('.');
					var child = buildTypeAnnotationDeclarationTypes(annotation.elementType, fullName);
					child.fullName = fullName;
					child.name = '__ANY_KEY__';
					child.node = annotation;
					return {
			type: 'object',
			children: [child]
					};
		default:
					return {};
			}
	}
	function inConstructor() {
			var scope = context.getScope();
			while (scope) {
		if (scope.block && scope.block.parent && scope.block.parent.kind === 'constructor') {
					return true;
		}
		scope = scope.upper;
			}
			return false;
	}
	function getPropertyName(node) {
			var isDirectProp = DIRECT_PROPS_REGEX.test(sourceCode.getText(node));
			var isDirectNextProp = DIRECT_NEXT_PROPS_REGEX.test(sourceCode.getText(node));
			var isDirectPrevProp = DIRECT_PREV_PROPS_REGEX.test(sourceCode.getText(node));
			var isInClassComponent = utils.getParentES6Component() || utils.getParentES5Component();
			var isNotInConstructor = !inConstructor(node);
			var isNotInLifeCycleMethod = !inLifeCycleMethod();
			if ((isDirectProp || isDirectNextProp || isDirectPrevProp) && isInClassComponent && isNotInConstructor && isNotInLifeCycleMethod) {
		return void 0;
			}
			if (!isDirectProp && !isDirectNextProp && !isDirectPrevProp) {
		node = node.parent;
			}
			var property = node.property;
			if (property) {
		switch (property.type) {
					case 'Identifier':
			if (node.computed) {
							return '__COMPUTED_PROP__';
			}
			return property.name;
					case 'MemberExpression':
			return void 0;
					case 'Literal':
			if (typeof property.value === 'string') {
							return property.value;
			}
					default:
			if (node.computed) {
							return '__COMPUTED_PROP__';
			}
			break;
		}
			}
			return void 0;
	}
	function markPropTypesAsUsed(node, parentNames) {
			parentNames = parentNames || [];
			var type = void 0;
			var name = void 0;
			var allNames = void 0;
			var properties = void 0;
			switch (node.type) {
		case 'MemberExpression':
					name = getPropertyName(node);
					if (name) {
			allNames = parentNames.concat(name);
			if (node.parent.type === 'MemberExpression') {
							markPropTypesAsUsed(node.parent, allNames);
			}
			type = name !== '__COMPUTED_PROP__' ? 'direct' : null;
					} else if (node.parent.id && node.parent.id.properties && node.parent.id.properties.length && getKeyValue(node.parent.id.properties[0])) {
			type = 'destructuring';
			properties = node.parent.id.properties;
					}
					break;
		case 'ArrowFunctionExpression':
		case 'FunctionDeclaration':
		case 'FunctionExpression':
					type = 'destructuring';
					properties = node.params[0].properties;
					break;
		case 'VariableDeclarator':
					for (var i = 0, j = node.id.properties.length; i < j; i++) {
			var thisDestructuring = node.id.properties[i].key && (node.id.properties[i].key.name === 'props' || node.id.properties[i].key.value === 'props') && node.id.properties[i].value.type === 'ObjectPattern';
			var genericDestructuring = isPropAttributeName(node) && (utils.getParentStatelessComponent() || isInLifeCycleMethod(node));

			if (thisDestructuring) {
							properties = node.id.properties[i].value.properties;
			} else if (genericDestructuring) {
							properties = node.id.properties;
			} else {
							continue;
			}
			type = 'destructuring';
			break;
					}
					break;
		default:
					throw new Error(node.type + ' ASTNodes are not handled by markPropTypesAsUsed');
			}

			var component = components.get(utils.getParentComponent());
			var usedPropTypes = component && component.usedPropTypes || [];
			var ignorePropsValidation = component && component.ignorePropsValidation || false;

			switch (type) {
		case 'direct':
					if (Object.prototype[name]) {
			break;
					}

					usedPropTypes.push({
			name: name,
			allNames: allNames
					});
					break;
		case 'destructuring':
					for (var k = 0, l = (properties || []).length; k < l; k++) {
			if (hasSpreadOperator(properties[k]) || properties[k].computed) {
							ignorePropsValidation = true;
							break;
			}
			var propName = getKeyValue(properties[k]);

			var currentNode = node;
			allNames = [];
			while (currentNode.property && currentNode.property.name !== 'props') {
							allNames.unshift(currentNode.property.name);
							currentNode = currentNode.object;
			}
			allNames.push(propName);

			if (propName) {
							usedPropTypes.push({
				allNames: allNames,
				name: propName
							});
			}
					}
					break;
		default:
					break;
			}

			components.set(component ? component.node : node, {
		usedPropTypes: usedPropTypes,
		ignorePropsValidation: ignorePropsValidation
			});
	}
	function declarePropTypesForObjectTypeAnnotation(propTypes, declaredPropTypes) {
			var ignorePropsValidation = false;

			iterateProperties(propTypes.properties, function (key, value) {
		if (!value) {
					ignorePropsValidation = true;
					return;
		}

		var types = buildTypeAnnotationDeclarationTypes(value, key);
		types.fullName = key;
		types.name = key;
		types.node = value;
		declaredPropTypes.push(types);
			});

			return ignorePropsValidation;
	}
	function declarePropTypesForIntersectionTypeAnnotation(propTypes, declaredPropTypes) {
			return propTypes.types.some(function (annotation) {
		if (annotation.type === 'ObjectTypeAnnotation') {
					return declarePropTypesForObjectTypeAnnotation(annotation, declaredPropTypes);
		}

		var typeNode = typeScope(annotation.id.name);

		if (!typeNode) {
					return true;
		} else if (typeNode.type === 'IntersectionTypeAnnotation') {
					return declarePropTypesForIntersectionTypeAnnotation(typeNode, declaredPropTypes);
		}

		return declarePropTypesForObjectTypeAnnotation(typeNode, declaredPropTypes);
			});
	}
	function markPropTypesAsDeclared(node, propTypes) {
			var component = components.get(node);
			var declaredPropTypes = component && component.declaredPropTypes || [];
			var ignorePropsValidation = component && component.ignorePropsValidation || false;

			switch (propTypes && propTypes.type) {
		case 'ObjectTypeAnnotation':
					ignorePropsValidation = declarePropTypesForObjectTypeAnnotation(propTypes, declaredPropTypes);
					break;
		case 'ObjectExpression':
					iterateProperties(propTypes.properties, function (key, value) {
			if (!value) {
							ignorePropsValidation = true;
							return;
			}
			var types = buildReactDeclarationTypes(value, key);
			types.fullName = key;
			types.name = key;
			types.node = value;
			declaredPropTypes.push(types);
					});
					break;
		case 'MemberExpression':
					break;
		case 'Identifier':
					var variablesInScope = variable.variablesInScope(context);
					for (var i = 0, j = variablesInScope.length; i < j; i++) {
			if (variablesInScope[i].name !== propTypes.name) {
							continue;
			}
			var defInScope = variablesInScope[i].defs[variablesInScope[i].defs.length - 1];
			markPropTypesAsDeclared(node, defInScope.node && defInScope.node.init);
			return;
					}
					ignorePropsValidation = true;
					break;
		case 'CallExpression':
					if (propWrapperFunctions.has(propTypes.callee.name) && propTypes.arguments && propTypes.arguments[0]) {
			markPropTypesAsDeclared(node, propTypes.arguments[0]);
			return;
					}
					break;
		case 'IntersectionTypeAnnotation':
					ignorePropsValidation = declarePropTypesForIntersectionTypeAnnotation(propTypes, declaredPropTypes);
					break;
		case null:
					break;
		default:
					ignorePropsValidation = true;
					break;
			}

			components.set(node, {
		declaredPropTypes: declaredPropTypes,
		ignorePropsValidation: ignorePropsValidation
			});
	}
	function reportUnusedPropType(component, props) {
			if (props === true) {
		return;
			}

			(props || []).forEach(function (prop) {
		if (prop === true) {
					return;
		}

		if (prop.node && !isPropUsed(component, prop)) {
					context.report(prop.node, UNUSED_MESSAGE, {
			name: prop.fullName
					});
		}

		if (prop.children) {
					reportUnusedPropType(component, prop.children);
		}
			});
	}
	function reportUnusedPropTypes(component) {
			reportUnusedPropType(component, component.declaredPropTypes);
	}
	function resolveTypeAnnotation(node) {
			var annotation = node.typeAnnotation || node;
			while (annotation && (annotation.type === 'TypeAnnotation' || annotation.type === 'NullableTypeAnnotation')) {
		annotation = annotation.typeAnnotation;
			}
			if (annotation.type === 'GenericTypeAnnotation' && typeScope(annotation.id.name)) {
		return typeScope(annotation.id.name);
			}
			return annotation;
	}
	function markDestructuredFunctionArgumentsAsUsed(node) {
			var destructuring = node.params && node.params[0] && node.params[0].type === 'ObjectPattern';
			if (destructuring && components.get(node)) {
		markPropTypesAsUsed(node);
			}
	}
	function markAnnotatedFunctionArgumentsAsDeclared(node) {
			if (!node.params || !node.params.length || !annotations.isAnnotatedFunctionPropsDeclaration(node, context)) {
		return;
			}
			markPropTypesAsDeclared(node, resolveTypeAnnotation(node.params[0]));
	}
	function handleStatelessComponent(node) {
			markDestructuredFunctionArgumentsAsUsed(node);
			markAnnotatedFunctionArgumentsAsDeclared(node);
	}
	return {
			ClassDeclaration: function ClassDeclaration(node) {
		if (isSuperTypeParameterPropsDeclaration(node)) {
					markPropTypesAsDeclared(node, resolveSuperParameterPropsType(node));
		}
			},

			ClassProperty: function ClassProperty(node) {
		if (isAnnotatedClassPropsDeclaration(node)) {
					markPropTypesAsDeclared(node, resolveTypeAnnotation(node));
		} else if (isPropTypesDeclaration(node)) {
					markPropTypesAsDeclared(node, node.value);
		}
			},

			VariableDeclarator: function VariableDeclarator(node) {
		var destructuring = node.init && node.id && node.id.type === 'ObjectPattern';
		var thisDestructuring = destructuring && node.init.type === 'ThisExpression';
		var statelessDestructuring = destructuring && isPropAttributeName(node) && (utils.getParentStatelessComponent() || isInLifeCycleMethod(node));

		if (!thisDestructuring && !statelessDestructuring) {
					return;
		}
		markPropTypesAsUsed(node);
			},

			FunctionDeclaration: handleStatelessComponent,

			ArrowFunctionExpression: handleStatelessComponent,

			FunctionExpression: handleStatelessComponent,

			MemberExpression: function MemberExpression(node) {
		var type = void 0;
		if (isPropTypesUsage(node)) {
					type = 'usage';
		} else if (isPropTypesDeclaration(node.property)) {
					type = 'declaration';
		}

		switch (type) {
					case 'usage':
			markPropTypesAsUsed(node);
			break;
					case 'declaration':
			var component = utils.getRelatedComponent(node);
			if (!component) {
							return;
			}
			markPropTypesAsDeclared(component.node, node.parent.right || node.parent);
			break;
					default:
			break;
		}
			},

			JSXSpreadAttribute: function JSXSpreadAttribute(node) {
		var component = components.get(utils.getParentComponent());
		components.set(component ? component.node : node, {
					ignorePropsValidation: true
		});
			},

			MethodDefinition: function MethodDefinition(node) {
		if (!isPropTypesDeclaration(node.key)) {
					return;
		}

		var i = node.value.body.body.length - 1;
		for (; i >= 0; i--) {
					if (node.value.body.body[i].type === 'ReturnStatement') {
			break;
					}
		}

		if (i >= 0) {
					markPropTypesAsDeclared(node, node.value.body.body[i].argument);
		}
			},

			ObjectPattern: function ObjectPattern(node) {
		if (isNodeALifeCycleMethod(node.parent.parent)) {
					node.properties.forEach(function (property, i) {
			if (i === 0) {
							markPropTypesAsUsed(node.parent);
			}
					});
		}
			},

			ObjectExpression: function ObjectExpression(node) {
		node.properties.forEach(function (property) {
					if (!isPropTypesDeclaration(property.key)) {
			return;
					}
					markPropTypesAsDeclared(node, property.value);
		});
			},

			TypeAlias: function TypeAlias(node) {
		typeScope(node.id.name, node.right);
			},

			Program: function Program() {
		stack = [{}];
			},

			BlockStatement: function BlockStatement() {
		stack.push(Object.create(typeScope()));
			},

			'BlockStatement:exit': function BlockStatementExit() {
		stack.pop();
			},

			'Program:exit': function ProgramExit() {
		stack = null;
		var list = components.list();
		for (var component in list) {
					if (!has(list, component) || !mustBeValidated(list[component])) {
			continue;
					}
					reportUnusedPropTypes(list[component]);
		}
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";



var Components = __webpack_require__(8);
function uncast(node) {
  while (node.type === 'TypeCastExpression') {
	node = node.expression;
  }
  return node;
}
function getName(node) {
  node = uncast(node);
  var type = node.type;

  if (type === 'Identifier') {
	return node.name;
  } else if (type === 'Literal') {
	return String(node.value);
  } else if (type === 'TemplateLiteral' && node.expressions.length === 0) {
	return node.quasis[0].value.raw;
  }
  return null;
}

function isThisExpression(node) {
  return uncast(node).type === 'ThisExpression';
}

function getInitialClassInfo() {
  return {
	stateFields: new Set(),
	usedStateFields: new Set(),
	aliases: null
  };
}

module.exports = {
  meta: {
	docs: {
			description: 'Prevent definition of unused state fields',
			category: 'Best Practices',
			recommended: false
	},
	schema: []
  },

  create: Components.detect(function (context, components, utils) {
	var classInfo = null;
	function isStateReference(node) {
			node = uncast(node);

			var isDirectStateReference = node.type === 'MemberExpression' && isThisExpression(node.object) && node.property.name === 'state';

			var isAliasedStateReference = node.type === 'Identifier' && classInfo.aliases && classInfo.aliases.has(node.name);

			return isDirectStateReference || isAliasedStateReference;
	}
	function addStateFields(node) {
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
		for (var _iterator = node.properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var prop = _step.value;

					var key = prop.key;

					if (prop.type === 'Property' && (key.type === 'Literal' || key.type === 'TemplateLiteral' && key.expressions.length === 0 || prop.computed === false && key.type === 'Identifier') && getName(prop.key) !== null) {
			classInfo.stateFields.add(prop);
					}
		}
			} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
			} finally {
		try {
					if (!_iteratorNormalCompletion && _iterator.return) {
			_iterator.return();
					}
		} finally {
					if (_didIteratorError) {
			throw _iteratorError;
					}
		}
			}
	}
	function addUsedStateField(node) {
			var name = getName(node);
			if (name) {
		classInfo.usedStateFields.add(name);
			}
	}
	function handleStateDestructuring(node) {
			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
		for (var _iterator2 = node.properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var prop = _step2.value;

					if (prop.type === 'Property') {
			addUsedStateField(prop.key);
					} else if (prop.type === 'ExperimentalRestProperty' && classInfo.aliases) {
			classInfo.aliases.add(getName(prop.argument));
					}
		}
			} catch (err) {
		_didIteratorError2 = true;
		_iteratorError2 = err;
			} finally {
		try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
			_iterator2.return();
					}
		} finally {
					if (_didIteratorError2) {
			throw _iteratorError2;
					}
		}
			}
	}
	function handleAssignment(left, right) {
			switch (left.type) {
		case 'Identifier':
					if (isStateReference(right) && classInfo.aliases) {
			classInfo.aliases.add(left.name);
					}
					break;
		case 'ObjectPattern':
					if (isStateReference(right)) {
			handleStateDestructuring(left);
					} else if (isThisExpression(right) && classInfo.aliases) {
			var _iteratorNormalCompletion3 = true;
			var _didIteratorError3 = false;
			var _iteratorError3 = undefined;

			try {
							for (var _iterator3 = left.properties[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
				var prop = _step3.value;

				if (prop.type === 'Property' && getName(prop.key) === 'state') {
									var name = getName(prop.value);
									if (name) {
					classInfo.aliases.add(name);
									} else if (prop.value.type === 'ObjectPattern') {
					handleStateDestructuring(prop.value);
									}
				}
							}
			} catch (err) {
							_didIteratorError3 = true;
							_iteratorError3 = err;
			} finally {
							try {
				if (!_iteratorNormalCompletion3 && _iterator3.return) {
									_iterator3.return();
				}
							} finally {
				if (_didIteratorError3) {
									throw _iteratorError3;
				}
							}
			}
					}
					break;
		default:
			}
	}

	function reportUnusedFields() {
			var _iteratorNormalCompletion4 = true;
			var _didIteratorError4 = false;
			var _iteratorError4 = undefined;

			try {
		for (var _iterator4 = classInfo.stateFields[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
					var node = _step4.value;

					var name = getName(node.key);
					if (!classInfo.usedStateFields.has(name)) {
			context.report(node, 'Unused state field: \'' + name + '\'');
					}
		}
			} catch (err) {
		_didIteratorError4 = true;
		_iteratorError4 = err;
			} finally {
		try {
					if (!_iteratorNormalCompletion4 && _iterator4.return) {
			_iterator4.return();
					}
		} finally {
					if (_didIteratorError4) {
			throw _iteratorError4;
					}
		}
			}
	}

	return {
			ClassDeclaration: function ClassDeclaration(node) {
		if (utils.isES6Component(node)) {
					classInfo = getInitialClassInfo();
		}
			},
			ObjectExpression: function ObjectExpression(node) {
		if (utils.isES5Component(node)) {
					classInfo = getInitialClassInfo();
		}
			},
			'ObjectExpression:exit': function ObjectExpressionExit(node) {
		if (!classInfo) {
					return;
		}

		if (utils.isES5Component(node)) {
					reportUnusedFields();
					classInfo = null;
		}
			},
			'ClassDeclaration:exit': function ClassDeclarationExit() {
		if (!classInfo) {
					return;
		}
		reportUnusedFields();
		classInfo = null;
			},
			CallExpression: function CallExpression(node) {
		if (!classInfo) {
					return;
		}
		if (node.callee.type === 'MemberExpression' && isThisExpression(node.callee.object) && getName(node.callee.property) === 'setState' && node.arguments.length > 0 && node.arguments[0].type === 'ObjectExpression') {
					addStateFields(node.arguments[0]);
		}
			},
			ClassProperty: function ClassProperty(node) {
		if (!classInfo) {
					return;
		}
		if (getName(node.key) === 'state' && !node.static && node.value && node.value.type === 'ObjectExpression') {
					addStateFields(node.value);
		}
			},
			MethodDefinition: function MethodDefinition() {
		if (!classInfo) {
					return;
		}
		classInfo.aliases = new Set();
			},
			'MethodDefinition:exit': function MethodDefinitionExit() {
		if (!classInfo) {
					return;
		}
		classInfo.aliases = null;
			},
			FunctionExpression: function FunctionExpression(node) {
		if (!classInfo) {
					return;
		}

		var parent = node.parent;
		if (!utils.isES5Component(parent.parent)) {
					return;
		}

		if (parent.key.name === 'getInitialState') {
					var body = node.body.body;
					var lastBodyNode = body[body.length - 1];

					if (lastBodyNode.type === 'ReturnStatement' && lastBodyNode.argument.type === 'ObjectExpression') {
			addStateFields(lastBodyNode.argument);
					}
		} else {
					classInfo.aliases = new Set();
		}
			},
			AssignmentExpression: function AssignmentExpression(node) {
		if (!classInfo) {
					return;
		}
		if (node.left.type === 'MemberExpression' && isThisExpression(node.left.object) && getName(node.left.property) === 'state' && node.right.type === 'ObjectExpression') {
					var fn = node;
					while (fn.type !== 'FunctionExpression' && fn.parent) {
			fn = fn.parent;
					}
					if (fn.parent && fn.parent.type === 'MethodDefinition' && fn.parent.kind === 'constructor') {
			addStateFields(node.right);
					}
		} else {
					handleAssignment(node.left, node.right);
		}
			},
			VariableDeclarator: function VariableDeclarator(node) {
		if (!classInfo || !node.init) {
					return;
		}
		handleAssignment(node.id, node.init);
			},
			MemberExpression: function MemberExpression(node) {
		if (!classInfo) {
					return;
		}
		if (isStateReference(node.object)) {
					if (node.computed && node.property.type !== 'Literal') {
			classInfo = null;
			return;
					}
					addUsedStateField(node.property);
		}
			},
			JSXSpreadAttribute: function JSXSpreadAttribute(node) {
		if (classInfo && isStateReference(node.argument)) {
					classInfo = null;
		}
			},
			ExperimentalSpreadProperty: function ExperimentalSpreadProperty(node) {
		if (classInfo && isStateReference(node.argument)) {
					classInfo = null;
		}
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var makeNoMethodSetStateRule = __webpack_require__(111);

module.exports = makeNoMethodSetStateRule('componentWillUpdate');
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var Components = __webpack_require__(8);
module.exports = {
  meta: {
	docs: {
			description: 'Enforce ES5 or ES6 class for React Components',
			category: 'Stylistic Issues',
			recommended: false
	},

	schema: [{
			enum: ['always', 'never']
	}]
  },

  create: Components.detect(function (context, components, utils) {
	var configuration = context.options[0] || 'always';

	return {
			ObjectExpression: function ObjectExpression(node) {
		if (utils.isES5Component(node) && configuration === 'always') {
					context.report({
			node: node,
			message: 'Component should use es6 class instead of createClass'
					});
		}
			},
			ClassDeclaration: function ClassDeclaration(node) {
		if (utils.isES6Component(node) && configuration === 'never') {
					context.report({
			node: node,
			message: 'Component should use createClass instead of es6 class'
					});
		}
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
var Components = __webpack_require__(8);
var versionUtil = __webpack_require__(57);
module.exports = {
  meta: {
	docs: {
			description: 'Enforce stateless components to be written as a pure function',
			category: 'Stylistic Issues',
			recommended: false
	},
	schema: [{
			type: 'object',
			properties: {
		ignorePureComponents: {
					default: false,
					type: 'boolean'
		}
			},
			additionalProperties: false
	}]
  },

  create: Components.detect(function (context, components, utils) {
	var configuration = context.options[0] || {};
	var ignorePureComponents = configuration.ignorePureComponents || false;

	var sourceCode = context.getSourceCode();
	function getPropertyName(node) {
			if (node.type === 'ClassProperty') {
		var tokens = context.getFirstTokens(node, 2);
		return tokens[1] && tokens[1].type === 'Identifier' ? tokens[1].value : tokens[0].value;
			}

			return node.key.name;
	}
	function getComponentProperties(node) {
			switch (node.type) {
		case 'ClassExpression':
		case 'ClassDeclaration':
					return node.body.body;
		case 'ObjectExpression':
					return node.properties;
		default:
					return [];
			}
	}
	function isSingleSuperCall(body) {
			return body.length === 1 && body[0].type === 'ExpressionStatement' && body[0].expression.type === 'CallExpression' && body[0].expression.callee.type === 'Super';
	}
	function isSimple(node) {
			return node.type === 'Identifier' || node.type === 'RestElement';
	}
	function isSpreadArguments(superArgs) {
			return superArgs.length === 1 && superArgs[0].type === 'SpreadElement' && superArgs[0].argument.type === 'Identifier' && superArgs[0].argument.name === 'arguments';
	}
	function isValidIdentifierPair(ctorParam, superArg) {
			return ctorParam.type === 'Identifier' && superArg.type === 'Identifier' && ctorParam.name === superArg.name;
	}
	function isValidRestSpreadPair(ctorParam, superArg) {
			return ctorParam.type === 'RestElement' && superArg.type === 'SpreadElement' && isValidIdentifierPair(ctorParam.argument, superArg.argument);
	}
	function isValidPair(ctorParam, superArg) {
			return isValidIdentifierPair(ctorParam, superArg) || isValidRestSpreadPair(ctorParam, superArg);
	}
	function isPassingThrough(ctorParams, superArgs) {
			if (ctorParams.length !== superArgs.length) {
		return false;
			}

			for (var i = 0; i < ctorParams.length; ++i) {
		if (!isValidPair(ctorParams[i], superArgs[i])) {
					return false;
		}
			}

			return true;
	}
	function isRedundantSuperCall(body, ctorParams) {
			return isSingleSuperCall(body) && ctorParams.every(isSimple) && (isSpreadArguments(body[0].expression.arguments) || isPassingThrough(ctorParams, body[0].expression.arguments));
	}
	function hasOtherProperties(node) {
			var properties = getComponentProperties(node);
			return properties.some(function (property) {
		var name = getPropertyName(property);
		var isDisplayName = name === 'displayName';
		var isPropTypes = name === 'propTypes' || name === 'props' && property.typeAnnotation;
		var contextTypes = name === 'contextTypes';
		var isUselessConstructor = property.kind === 'constructor' && isRedundantSuperCall(property.value.body.body, property.value.params);
		var isRender = name === 'render';
		return !isDisplayName && !isPropTypes && !contextTypes && !isUselessConstructor && !isRender;
			});
	}
	var markSCUAsDeclared = function markSCUAsDeclared(node) {
			components.set(node, {
		hasSCU: true
			});
	};
	var markChildContextTypesAsDeclared = function markChildContextTypesAsDeclared(node) {
			components.set(node, {
		hasChildContextTypes: true
			});
	};
	function markThisAsUsed(node) {
			components.set(node, {
		useThis: true
			});
	}
	function markPropsOrContextAsUsed(node) {
			components.set(node, {
		usePropsOrContext: true
			});
	}
	function markRefAsUsed(node) {
			components.set(node, {
		useRef: true
			});
	}
	function markReturnAsInvalid(node) {
			components.set(node, {
		invalidReturn: true
			});
	}
	function markDecoratorsAsUsed(node) {
			components.set(node, {
		useDecorators: true
			});
	}

	function visitClass(node) {
			if (ignorePureComponents && utils.isPureComponent(node)) {
		markSCUAsDeclared(node);
			}

			if (node.decorators && node.decorators.length) {
		markDecoratorsAsUsed(node);
			}
	}

	return {
			ClassDeclaration: visitClass,
			ClassExpression: visitClass,
			VariableDeclarator: function VariableDeclarator(node) {
		if (!node.id || node.id.type !== 'ObjectPattern' || !node.init || node.init.type !== 'ThisExpression') {
					return;
		}
		var useThis = node.id.properties.some(function (property) {
					var name = getPropertyName(property);
					return name !== 'props' && name !== 'context';
		});
		if (!useThis) {
					markPropsOrContextAsUsed(node);
					return;
		}
		markThisAsUsed(node);
			},
			MemberExpression: function MemberExpression(node) {
		if (node.object.type !== 'ThisExpression') {
					if (node.property && node.property.name === 'childContextTypes') {
			var component = utils.getRelatedComponent(node);
			if (!component) {
							return;
			}
			markChildContextTypesAsDeclared(component.node);
			return;
					}
					return;
		} else if ((node.property.name || node.property.value) === 'props' || (node.property.name || node.property.value) === 'context') {
					markPropsOrContextAsUsed(node);
					return;
		}
		markThisAsUsed(node);
			},
			JSXAttribute: function JSXAttribute(node) {
		var name = sourceCode.getText(node.name);
		if (name !== 'ref') {
					return;
		}
		markRefAsUsed(node);
			},
			ReturnStatement: function ReturnStatement(node) {
		var blockNode = void 0;
		var scope = context.getScope();
		while (scope) {
					blockNode = scope.block && scope.block.parent;
					if (blockNode && (blockNode.type === 'MethodDefinition' || blockNode.type === 'Property')) {
			break;
					}
					scope = scope.upper;
		}
		var isRender = blockNode && blockNode.key && blockNode.key.name === 'render';
		var allowNull = versionUtil.testReactVersion(context, '15.0.0'); // Stateless components can return null since React 15
		var isReturningJSX = utils.isReturningJSX(node, !allowNull);
		var isReturningNull = node.argument && (node.argument.value === null || node.argument.value === false);
		if (!isRender || allowNull && (isReturningJSX || isReturningNull) || !allowNull && isReturningJSX) {
					return;
		}
		markReturnAsInvalid(node);
			},

			'Program:exit': function ProgramExit() {
		var list = components.list();
		for (var component in list) {
					if (!has(list, component) || hasOtherProperties(list[component].node) || list[component].useThis || list[component].useRef || list[component].invalidReturn || list[component].hasChildContextTypes || list[component].useDecorators || !utils.isES5Component(list[component].node) && !utils.isES6Component(list[component].node)) {
			continue;
					}

					if (list[component].hasSCU && list[component].usePropsOrContext) {
			continue;
					}
					context.report({
			node: list[component].node,
			message: 'Component should be written as a pure function'
					});
		}
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var has = __webpack_require__(7);
var Components = __webpack_require__(8);
var variable = __webpack_require__(27);
var annotations = __webpack_require__(72);
var versionUtil = __webpack_require__(57);
var PROPS_REGEX = /^(props|nextProps)$/;
var DIRECT_PROPS_REGEX = /^(props|nextProps)\s*(\.|\[)/;
module.exports = {
  meta: {
	docs: {
			description: 'Prevent missing props validation in a React component definition',
			category: 'Best Practices',
			recommended: true
	},

	schema: [{
			type: 'object',
			properties: {
		ignore: {
					type: 'array',
					items: {
			type: 'string'
					}
		},
		customValidators: {
					type: 'array',
					items: {
			type: 'string'
					}
		},
		skipUndeclared: {
					type: 'boolean'
		}
			},
			additionalProperties: false
	}]
  },

  create: Components.detect(function (context, components, utils) {
	var sourceCode = context.getSourceCode();
	var configuration = context.options[0] || {};
	var propWrapperFunctions = new Set(context.settings.propWrapperFunctions || []);
	var ignored = configuration.ignore || [];
	var customValidators = configuration.customValidators || [];
	var skipUndeclared = configuration.skipUndeclared || false;
	var stack = null;
	var classExpressions = [];

	var MISSING_MESSAGE = '\'{{name}}\' is missing in props validation';
	function typeScope(key, value) {
			if (arguments.length === 0) {
		return stack[stack.length - 1];
			} else if (arguments.length === 1) {
		return stack[stack.length - 1][key];
			}
			stack[stack.length - 1][key] = value;
			return value;
	}
	function inConstructor() {
			var scope = context.getScope();
			while (scope) {
		if (scope.block && scope.block.parent && scope.block.parent.kind === 'constructor') {
					return true;
		}
		scope = scope.upper;
			}
			return false;
	}
	function inComponentWillReceiveProps() {
			var scope = context.getScope();
			while (scope) {
		if (scope.block && scope.block.parent && scope.block.parent.key && scope.block.parent.key.name === 'componentWillReceiveProps') {
					return true;
		}
		scope = scope.upper;
			}
			return false;
	}

	function isAssignmentToProp(node) {
			return node.parent && node.parent.type === 'AssignmentExpression' && node.parent.left === node;
	}
	function isPropTypesUsage(node) {
			var isClassUsage = (utils.getParentES6Component() || utils.getParentES5Component()) && node.object.type === 'ThisExpression' && node.property.name === 'props';
			var isStatelessFunctionUsage = node.object.name === 'props' && !isAssignmentToProp(node);
			var isNextPropsUsage = node.object.name === 'nextProps' && inComponentWillReceiveProps();
			return isClassUsage || isStatelessFunctionUsage || isNextPropsUsage;
	}
	function isAnnotatedClassPropsDeclaration(node) {
			if (node && node.type === 'ClassProperty') {
		var tokens = context.getFirstTokens(node, 2);
		if (node.typeAnnotation && (tokens[0].value === 'props' || tokens[1] && tokens[1].value === 'props')) {
					return true;
		}
			}
			return false;
	}
	function isSuperTypeParameterPropsDeclaration(node) {
			if (node && (node.type === 'ClassDeclaration' || node.type === 'ClassExpression')) {
		if (node.superTypeParameters && node.superTypeParameters.params.length > 0) {
					return true;
		}
			}
			return false;
	}
	function isPropTypesDeclaration(node) {
			if (node && node.type === 'ClassProperty') {
		var tokens = context.getFirstTokens(node, 2);
		if (tokens[0].value === 'propTypes' || tokens[1] && tokens[1].value === 'propTypes') {
					return true;
		}
		return false;
			}

			return Boolean(node && node.name === 'propTypes');
	}
	function isIgnored(name) {
			return ignored.indexOf(name) !== -1;
	}
	function hasCustomValidator(validator) {
			return customValidators.indexOf(validator) !== -1;
	}
	function mustBeValidated(component) {
			var isSkippedByConfig = skipUndeclared && typeof component.declaredPropTypes === 'undefined';
			return Boolean(component && component.usedPropTypes && !component.ignorePropsValidation && !isSkippedByConfig);
	}
	function _isDeclaredInComponent(declaredPropTypes, keyList) {
			for (var i = 0, j = keyList.length; i < j; i++) {
		var key = keyList[i];

		var propType = declaredPropTypes && (
		declaredPropTypes[key] || // If not, check if this type accepts any key
		declaredPropTypes.__ANY_KEY__);

		if (!propType) {
					return key === '__COMPUTED_PROP__';
		}
		if ((typeof propType === 'undefined' ? 'undefined' : _typeof(propType)) === 'object' && Object.keys(propType).length === 0) {
					return true;
		}
		if (propType.children === true) {
					return true;
		}
		if (propType.acceptedProperties) {
					return key in propType.acceptedProperties;
		}
		if (propType.type === 'union') {
					if (i + 1 >= j) {
			return true;
					}
					var unionTypes = propType.children;
					var unionPropType = {};
					for (var k = 0, z = unionTypes.length; k < z; k++) {
			unionPropType[key] = unionTypes[k];
			var isValid = _isDeclaredInComponent(unionPropType, keyList.slice(i));
			if (isValid) {
							return true;
			}
					}
					return false;
		}
		declaredPropTypes = propType.children;
			}
			return true;
	}
	function isDeclaredInComponent(node, names) {
			while (node) {
		var component = components.get(node);

		var isDeclared = component && component.confidence === 2 && _isDeclaredInComponent(component.declaredPropTypes || {}, names);
		if (isDeclared) {
					return true;
		}
		node = node.parent;
			}
			return false;
	}
	function hasSpreadOperator(node) {
			var tokens = sourceCode.getTokens(node);
			return tokens.length && tokens[0].value === '...';
	}
	function stripQuotes(string) {
			return string.replace(/^\'|\'$/g, '');
	}
	function getKeyValue(node) {
			if (node.type === 'ObjectTypeProperty') {
		var tokens = context.getFirstTokens(node, 2);
		return tokens[0].value === '+' || tokens[0].value === '-' ? tokens[1].value : stripQuotes(tokens[0].value);
			}
			var key = node.key || node.argument;
			return key.type === 'Identifier' ? key.name : key.value;
	}
	function iterateProperties(properties, fn) {
			if (properties.length && typeof fn === 'function') {
		for (var i = 0, j = properties.length; i < j; i++) {
					var node = properties[i];
					var key = getKeyValue(node);

					var value = node.value;
					fn(key, value);
		}
			}
	}
	function buildReactDeclarationTypes(value) {
			if (value && value.callee && value.callee.object && hasCustomValidator(value.callee.object.name)) {
		return {};
			}

			if (value && value.type === 'MemberExpression' && value.property && value.property.name && value.property.name === 'isRequired') {
		value = value.object;
			}
			if (value && value.type === 'CallExpression' && value.callee && value.callee.property && value.callee.property.name && value.arguments && value.arguments.length > 0) {
		var callName = value.callee.property.name;
		var argument = value.arguments[0];
		switch (callName) {
					case 'shape':
			if (argument.type !== 'ObjectExpression') {
							return {};
			}
			var shapeTypeDefinition = {
							type: 'shape',
							children: {}
			};
			iterateProperties(argument.properties, function (childKey, childValue) {
							shapeTypeDefinition.children[childKey] = buildReactDeclarationTypes(childValue);
			});
			return shapeTypeDefinition;
					case 'arrayOf':
					case 'objectOf':
			return {
							type: 'object',
							children: {
				__ANY_KEY__: buildReactDeclarationTypes(argument)
							}
			};
					case 'oneOfType':
			if (!argument.elements || !argument.elements.length) {
							return {};
			}
			var unionTypeDefinition = {
							type: 'union',
							children: []
			};
			for (var i = 0, j = argument.elements.length; i < j; i++) {
							var type = buildReactDeclarationTypes(argument.elements[i]);
							if (Object.keys(type).length > 0) {
				if (type.children === true) {
									unionTypeDefinition.children = true;
									return unionTypeDefinition;
				}
							}

							unionTypeDefinition.children.push(type);
			}
			if (unionTypeDefinition.length === 0) {
							return {};
			}
			return unionTypeDefinition;
					case 'instanceOf':
			return {
							type: 'instance',
							children: true
			};
					case 'oneOf':
					default:
			return {};
		}
			}
			return {};
	}
	function buildTypeAnnotationDeclarationTypes(annotation) {
			switch (annotation.type) {
		case 'GenericTypeAnnotation':
					if (typeScope(annotation.id.name)) {
			return buildTypeAnnotationDeclarationTypes(typeScope(annotation.id.name));
					}
					return {};
		case 'ObjectTypeAnnotation':
					var containsObjectTypeSpread = false;
					var shapeTypeDefinition = {
			type: 'shape',
			children: {}
					};
					iterateProperties(annotation.properties, function (childKey, childValue) {
			if (!childKey && !childValue) {
							containsObjectTypeSpread = true;
			} else {
							shapeTypeDefinition.children[childKey] = buildTypeAnnotationDeclarationTypes(childValue);
			}
					});
					if (containsObjectTypeSpread) {
			return {};
					}
					return shapeTypeDefinition;
		case 'UnionTypeAnnotation':
					var unionTypeDefinition = {
			type: 'union',
			children: []
					};
					for (var i = 0, j = annotation.types.length; i < j; i++) {
			var type = buildTypeAnnotationDeclarationTypes(annotation.types[i]);
			if (Object.keys(type).length > 0) {
							if (type.children === true) {
				unionTypeDefinition.children = true;
				return unionTypeDefinition;
							}
			}

			unionTypeDefinition.children.push(type);
					}
					if (unionTypeDefinition.children.length === 0) {
			return {};
					}
					return unionTypeDefinition;
		case 'ArrayTypeAnnotation':
					return {
			type: 'object',
			children: {
							__ANY_KEY__: buildTypeAnnotationDeclarationTypes(annotation.elementType)
			}
					};
		default:
					return {};
			}
	}
	function getPropertyName(node) {
			var isDirectProp = DIRECT_PROPS_REGEX.test(sourceCode.getText(node));
			var isInClassComponent = utils.getParentES6Component() || utils.getParentES5Component();
			var isNotInConstructor = !inConstructor();
			var isNotInComponentWillReceiveProps = !inComponentWillReceiveProps();
			if (isDirectProp && isInClassComponent && isNotInConstructor && isNotInComponentWillReceiveProps) {
		return void 0;
			}
			if (!isDirectProp) {
		node = node.parent;
			}
			var property = node.property;
			if (property) {
		switch (property.type) {
					case 'Identifier':
			if (node.computed) {
							return '__COMPUTED_PROP__';
			}
			return property.name;
					case 'MemberExpression':
			return void 0;
					case 'Literal':
			if (typeof property.value === 'string') {
							return property.value;
			}
					default:
			if (node.computed) {
							return '__COMPUTED_PROP__';
			}
			break;
		}
			}
			return void 0;
	}
	function markPropTypesAsUsed(node, parentNames) {
			parentNames = parentNames || [];
			var type = void 0;
			var name = void 0;
			var allNames = void 0;
			var properties = void 0;
			switch (node.type) {
		case 'MemberExpression':
					name = getPropertyName(node);
					if (name) {
			allNames = parentNames.concat(name);
			if (node.parent.type === 'MemberExpression') {
							markPropTypesAsUsed(node.parent, allNames);
			}
			type = name !== '__COMPUTED_PROP__' ? 'direct' : null;
					} else if (node.parent.id && node.parent.id.properties && node.parent.id.properties.length && getKeyValue(node.parent.id.properties[0])) {
			type = 'destructuring';
			properties = node.parent.id.properties;
					}
					break;
		case 'ArrowFunctionExpression':
		case 'FunctionDeclaration':
		case 'FunctionExpression':
					type = 'destructuring';
					properties = node.params[0].properties;
					break;
		case 'VariableDeclarator':
					for (var i = 0, j = node.id.properties.length; i < j; i++) {
			var thisDestructuring = !hasSpreadOperator(node.id.properties[i]) && (PROPS_REGEX.test(node.id.properties[i].key.name) || PROPS_REGEX.test(node.id.properties[i].key.value)) && node.id.properties[i].value.type === 'ObjectPattern';
			var directDestructuring = PROPS_REGEX.test(node.init.name) && (utils.getParentStatelessComponent() || inConstructor() || inComponentWillReceiveProps());

			if (thisDestructuring) {
							properties = node.id.properties[i].value.properties;
			} else if (directDestructuring) {
							properties = node.id.properties;
			} else {
							continue;
			}
			type = 'destructuring';
			break;
					}
					break;
		default:
					throw new Error(node.type + ' ASTNodes are not handled by markPropTypesAsUsed');
			}

			var component = components.get(utils.getParentComponent());
			var usedPropTypes = (component && component.usedPropTypes || []).slice();

			switch (type) {
		case 'direct':
					if (Object.prototype[name]) {
			break;
					}

					var isDirectProp = DIRECT_PROPS_REGEX.test(sourceCode.getText(node));

					usedPropTypes.push({
			name: name,
			allNames: allNames,
			node: !isDirectProp && !inConstructor() && !inComponentWillReceiveProps() ? node.parent.property : node.property
					});
					break;
		case 'destructuring':
					for (var k = 0, l = properties.length; k < l; k++) {
			if (hasSpreadOperator(properties[k]) || properties[k].computed) {
							continue;
			}
			var propName = getKeyValue(properties[k]);

			var currentNode = node;
			allNames = [];
			while (currentNode.property && !PROPS_REGEX.test(currentNode.property.name)) {
							allNames.unshift(currentNode.property.name);
							currentNode = currentNode.object;
			}
			allNames.push(propName);

			if (propName) {
							usedPropTypes.push({
				name: propName,
				allNames: allNames,
				node: properties[k]
							});
			}
					}
					break;
		default:
					break;
			}

			components.set(node, {
		usedPropTypes: usedPropTypes
			});
	}
	function declarePropTypesForObjectTypeAnnotation(propTypes, declaredPropTypes) {
			var ignorePropsValidation = false;

			iterateProperties(propTypes.properties, function (key, value) {
		if (!value) {
					ignorePropsValidation = true;
					return;
		}

		declaredPropTypes[key] = buildTypeAnnotationDeclarationTypes(value);
			});

			return ignorePropsValidation;
	}
	function declarePropTypesForIntersectionTypeAnnotation(propTypes, declaredPropTypes) {
			return propTypes.types.some(function (annotation) {
		if (annotation.type === 'ObjectTypeAnnotation') {
					return declarePropTypesForObjectTypeAnnotation(annotation, declaredPropTypes);
		}

		var typeNode = typeScope(annotation.id.name);

		if (!typeNode) {
					return true;
		} else if (typeNode.type === 'IntersectionTypeAnnotation') {
					return declarePropTypesForIntersectionTypeAnnotation(typeNode, declaredPropTypes);
		}

		return declarePropTypesForObjectTypeAnnotation(typeNode, declaredPropTypes);
			});
	}
	function markPropTypesAsDeclared(node, propTypes) {
			var componentNode = node;
			while (componentNode && !components.get(componentNode)) {
		componentNode = componentNode.parent;
			}
			var component = components.get(componentNode);
			var declaredPropTypes = component && component.declaredPropTypes || {};
			var ignorePropsValidation = false;

			switch (propTypes && propTypes.type) {
		case 'ObjectTypeAnnotation':
					ignorePropsValidation = declarePropTypesForObjectTypeAnnotation(propTypes, declaredPropTypes);
					break;
		case 'ObjectExpression':
					iterateProperties(propTypes.properties, function (key, value) {
			if (!value) {
							ignorePropsValidation = true;
							return;
			}
			declaredPropTypes[key] = buildReactDeclarationTypes(value);
					});
					break;
		case 'MemberExpression':
					var curDeclaredPropTypes = declaredPropTypes;
					while (propTypes && propTypes.parent && propTypes.parent.type !== 'AssignmentExpression' && propTypes.property && curDeclaredPropTypes) {
			var propName = propTypes.property.name;
			if (propName in curDeclaredPropTypes) {
							curDeclaredPropTypes = curDeclaredPropTypes[propName].children;
							propTypes = propTypes.parent;
			} else {
							propTypes = null;
			}
					}
					if (propTypes && propTypes.parent && propTypes.property) {
			curDeclaredPropTypes[propTypes.property.name] = buildReactDeclarationTypes(propTypes.parent.right);
					} else {
			ignorePropsValidation = true;
					}
					break;
		case 'Identifier':
					var variablesInScope = variable.variablesInScope(context);
					for (var i = 0, j = variablesInScope.length; i < j; i++) {
			if (variablesInScope[i].name !== propTypes.name) {
							continue;
			}
			var defInScope = variablesInScope[i].defs[variablesInScope[i].defs.length - 1];
			markPropTypesAsDeclared(node, defInScope.node && defInScope.node.init);
			return;
					}
					ignorePropsValidation = true;
					break;
		case 'CallExpression':
					if (propWrapperFunctions.has(sourceCode.getText(propTypes.callee)) && propTypes.arguments && propTypes.arguments[0]) {
			markPropTypesAsDeclared(node, propTypes.arguments[0]);
			return;
					}
					break;
		case 'IntersectionTypeAnnotation':
					ignorePropsValidation = declarePropTypesForIntersectionTypeAnnotation(propTypes, declaredPropTypes);
					break;
		case null:
					break;
		default:
					ignorePropsValidation = true;
					break;
			}

			components.set(node, {
		declaredPropTypes: declaredPropTypes,
		ignorePropsValidation: ignorePropsValidation
			});
	}
	function reportUndeclaredPropTypes(component) {
			var allNames = void 0;
			for (var i = 0, j = component.usedPropTypes.length; i < j; i++) {
		allNames = component.usedPropTypes[i].allNames;
		if (isIgnored(allNames[0]) || isDeclaredInComponent(component.node, allNames)) {
					continue;
		}
		context.report(component.usedPropTypes[i].node, MISSING_MESSAGE, {
					name: allNames.join('.').replace(/\.__COMPUTED_PROP__/g, '[]')
		});
			}
	}
	function resolveTypeAnnotation(node) {
			var annotation = node.typeAnnotation || node;
			while (annotation && (annotation.type === 'TypeAnnotation' || annotation.type === 'NullableTypeAnnotation')) {
		annotation = annotation.typeAnnotation;
			}
			if (annotation.type === 'GenericTypeAnnotation' && typeScope(annotation.id.name)) {
		return typeScope(annotation.id.name);
			}
			return annotation;
	}
	function resolveSuperParameterPropsType(node) {
			var propsParameterPosition = void 0;
			try {
		propsParameterPosition = versionUtil.testFlowVersion(context, '0.53.0') ? 0 : 1;
			} catch (e) {
		propsParameterPosition = node.superTypeParameters.params.length <= 2 ? 0 : 1;
			}

			var annotation = node.superTypeParameters.params[propsParameterPosition];
			while (annotation && (annotation.type === 'TypeAnnotation' || annotation.type === 'NullableTypeAnnotation')) {
		annotation = annotation.typeAnnotation;
			}

			if (annotation.type === 'GenericTypeAnnotation' && typeScope(annotation.id.name)) {
		return typeScope(annotation.id.name);
			}
			return annotation;
	}
	function markDestructuredFunctionArgumentsAsUsed(node) {
			var destructuring = node.params && node.params[0] && node.params[0].type === 'ObjectPattern';
			if (destructuring && components.get(node)) {
		markPropTypesAsUsed(node);
			}
	}
	function markAnnotatedFunctionArgumentsAsDeclared(node) {
			if (!node.params || !node.params.length || !annotations.isAnnotatedFunctionPropsDeclaration(node, context)) {
		return;
			}
			markPropTypesAsDeclared(node, resolveTypeAnnotation(node.params[0]));
	}
	function handleStatelessComponent(node) {
			markDestructuredFunctionArgumentsAsUsed(node);
			markAnnotatedFunctionArgumentsAsDeclared(node);
	}
	return {
			ClassDeclaration: function ClassDeclaration(node) {
		if (isSuperTypeParameterPropsDeclaration(node)) {
					markPropTypesAsDeclared(node, resolveSuperParameterPropsType(node));
		}
			},

			ClassExpression: function ClassExpression(node) {
		classExpressions.push(node);
			},

			ClassProperty: function ClassProperty(node) {
		if (isAnnotatedClassPropsDeclaration(node)) {
					markPropTypesAsDeclared(node, resolveTypeAnnotation(node));
		} else if (isPropTypesDeclaration(node)) {
					markPropTypesAsDeclared(node, node.value);
		}
			},

			VariableDeclarator: function VariableDeclarator(node) {
		var destructuring = node.init && node.id && node.id.type === 'ObjectPattern';
		var thisDestructuring = destructuring && node.init.type === 'ThisExpression';
		var directDestructuring = destructuring && PROPS_REGEX.test(node.init.name) && (utils.getParentStatelessComponent() || inConstructor() || inComponentWillReceiveProps());

		if (!thisDestructuring && !directDestructuring) {
					return;
		}
		markPropTypesAsUsed(node);
			},

			FunctionDeclaration: handleStatelessComponent,

			ArrowFunctionExpression: handleStatelessComponent,

			FunctionExpression: function FunctionExpression(node) {
		if (node.parent.type === 'MethodDefinition') {
					return;
		}
		handleStatelessComponent(node);
			},

			MemberExpression: function MemberExpression(node) {
		var type = void 0;
		if (isPropTypesUsage(node)) {
					type = 'usage';
		} else if (isPropTypesDeclaration(node.property)) {
					type = 'declaration';
		}

		switch (type) {
					case 'usage':
			markPropTypesAsUsed(node);
			break;
					case 'declaration':
			var component = utils.getRelatedComponent(node);
			if (!component) {
							return;
			}
			markPropTypesAsDeclared(component.node, node.parent.right || node.parent);
			break;
					default:
			break;
		}
			},

			MethodDefinition: function MethodDefinition(node) {
		if (!node.static || node.kind !== 'get' || !isPropTypesDeclaration(node.key)) {
					return;
		}

		var i = node.value.body.body.length - 1;
		for (; i >= 0; i--) {
					if (node.value.body.body[i].type === 'ReturnStatement') {
			break;
					}
		}

		if (i >= 0) {
					markPropTypesAsDeclared(node, node.value.body.body[i].argument);
		}
			},

			ObjectExpression: function ObjectExpression(node) {
		node.properties.forEach(function (property) {
					if (!isPropTypesDeclaration(property.key)) {
			return;
					}
					markPropTypesAsDeclared(node, property.value);
		});
			},

			TypeAlias: function TypeAlias(node) {
		typeScope(node.id.name, node.right);
			},

			TypeParameterDeclaration: function TypeParameterDeclaration(node) {
		var identifier = node.params[0];

		if (identifier.typeAnnotation) {
					typeScope(identifier.name, identifier.typeAnnotation.typeAnnotation);
		}
			},

			Program: function Program() {
		stack = [{}];
			},

			BlockStatement: function BlockStatement() {
		stack.push(Object.create(typeScope()));
			},

			'BlockStatement:exit': function BlockStatementExit() {
		stack.pop();
			},

			'Program:exit': function ProgramExit() {
		classExpressions.forEach(function (node) {
					if (isSuperTypeParameterPropsDeclaration(node)) {
			markPropTypesAsDeclared(node, resolveSuperParameterPropsType(node));
					}
		});

		stack = null;
		var list = components.list();
		for (var component in list) {
					if (!has(list, component) || !mustBeValidated(list[component])) {
			continue;
					}
					reportUndeclaredPropTypes(list[component]);
		}
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var variableUtil = __webpack_require__(27);
var pragmaUtil = __webpack_require__(71);
module.exports = {
  meta: {
	docs: {
			description: 'Prevent missing React when using JSX',
			category: 'Possible Errors',
			recommended: true
	},
	schema: []
  },

  create: function create(context) {
	var pragma = pragmaUtil.getFromContext(context);
	var NOT_DEFINED_MESSAGE = '\'{{name}}\' must be in scope when using JSX';

	return {

			JSXOpeningElement: function JSXOpeningElement(node) {
		var variables = variableUtil.variablesInScope(context);
		if (variableUtil.findVariable(variables, pragma)) {
					return;
		}
		context.report({
					node: node,
					message: NOT_DEFINED_MESSAGE,
					data: {
			name: pragma
					}
		});
			}

	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
var Components = __webpack_require__(8);
var variableUtil = __webpack_require__(27);
var annotations = __webpack_require__(72);

var QUOTES_REGEX = /^["']|["']$/g;
module.exports = {
  meta: {
	docs: {
			description: 'Enforce a defaultProps definition for every prop that is not a required prop.',
			category: 'Best Practices'
	},

	schema: []
  },

  create: Components.detect(function (context, components, utils) {
	var sourceCode = context.getSourceCode();
	var propWrapperFunctions = new Set(context.settings.propWrapperFunctions || []);
	function getPropertyName(node) {
			if (node.key || ['MethodDefinition', 'Property'].indexOf(node.type) !== -1) {
		return node.key.name;
			} else if (node.type === 'MemberExpression') {
		return node.property.name;
			} else if (node.type === 'ClassProperty') {
		var tokens = context.getFirstTokens(node, 2);
		return tokens[1] && tokens[1].type === 'Identifier' ? tokens[1].value : tokens[0].value;
			}
			return '';
	}
	function isPropTypesDeclaration(node) {
			return getPropertyName(node) === 'propTypes';
	}
	function isDefaultPropsDeclaration(node) {
			return getPropertyName(node) === 'defaultProps' || getPropertyName(node) === 'getDefaultProps';
	}
	function isRequiredPropType(propTypeExpression) {
			return propTypeExpression.type === 'MemberExpression' && propTypeExpression.property.name === 'isRequired';
	}
	function findVariableByName(name) {
			var variable = variableUtil.variablesInScope(context).find(function (item) {
		return item.name === name;
			});

			if (!variable || !variable.defs[0] || !variable.defs[0].node) {
		return null;
			}

			if (variable.defs[0].node.type === 'TypeAlias') {
		return variable.defs[0].node.right;
			}

			return variable.defs[0].node.init;
	}
	function resolveNodeValue(node) {
			if (node.type === 'Identifier') {
		return findVariableByName(node.name);
			}
			if (node.type === 'CallExpression' && propWrapperFunctions.has(node.callee.name) && node.arguments && node.arguments[0]) {
		return resolveNodeValue(node.arguments[0]);
			}

			return node;
	}
	function resolveGenericTypeAnnotation(node) {
			if (node.type !== 'GenericTypeAnnotation' || node.id.type !== 'Identifier') {
		return null;
			}

			return findVariableByName(node.id.name);
	}

	function resolveUnionTypeAnnotation(node) {
			return node.types.map(function (annotation) {
		if (annotation.type === 'GenericTypeAnnotation') {
					return resolveGenericTypeAnnotation(annotation);
		}

		return annotation;
			});
	}
	function getPropTypesFromObjectExpression(objectExpression) {
			var props = objectExpression.properties.filter(function (property) {
		return property.type !== 'ExperimentalSpreadProperty';
			});

			return props.map(function (property) {
		return {
					name: sourceCode.getText(property.key).replace(QUOTES_REGEX, ''),
					isRequired: isRequiredPropType(property.value),
					node: property
		};
			});
	}
	function getPropTypesFromTypeAnnotation(node) {
			var properties = void 0;

			switch (node.typeAnnotation.type) {
		case 'GenericTypeAnnotation':
					var annotation = resolveGenericTypeAnnotation(node.typeAnnotation);

					if (annotation && annotation.id) {
			annotation = findVariableByName(annotation.id.name);
					}

					properties = annotation ? annotation.properties || [] : [];
					break;

		case 'UnionTypeAnnotation':
					var union = resolveUnionTypeAnnotation(node.typeAnnotation);
					properties = union.reduce(function (acc, curr) {
			if (!curr) {
							return acc;
			}

			return acc.concat(curr.properties);
					}, []);
					break;

		case 'ObjectTypeAnnotation':
					properties = node.typeAnnotation.properties;
					break;

		default:
					properties = [];
					break;
			}

			var props = properties.filter(function (property) {
		return property.type === 'ObjectTypeProperty';
			});

			return props.map(function (property) {
		var tokens = context.getFirstTokens(property, 1);
		var name = tokens[0].value;

		return {
					name: name,
					isRequired: !property.optional,
					node: property
		};
			});
	}
	function getDefaultPropsFromObjectExpression(objectExpression) {
			var hasSpread = objectExpression.properties.find(function (property) {
		return property.type === 'ExperimentalSpreadProperty';
			});

			if (hasSpread) {
		return 'unresolved';
			}

			return objectExpression.properties.map(function (property) {
		return sourceCode.getText(property.key).replace(QUOTES_REGEX, '');
			});
	}
	function markDefaultPropsAsUnresolved(component) {
			components.set(component.node, {
		defaultProps: 'unresolved'
			});
	}
	function addPropTypesToComponent(component, propTypes) {
			var props = component.propTypes || [];

			components.set(component.node, {
		propTypes: props.concat(propTypes)
			});
	}
	function addDefaultPropsToComponent(component, defaultProps) {
			if (component.defaultProps === 'unresolved') {
		return;
			}

			if (defaultProps === 'unresolved') {
		markDefaultPropsAsUnresolved(component);
		return;
			}

			var defaults = component.defaultProps || {};

			defaultProps.forEach(function (defaultProp) {
		defaults[defaultProp] = true;
			});

			components.set(component.node, {
		defaultProps: defaults
			});
	}
	function handleStatelessComponent(node) {
			if (!node.params || !node.params.length || !annotations.isAnnotatedFunctionPropsDeclaration(node, context)) {
		return;
			}
			var component = components.get(utils.getParentStatelessComponent());
			if (!component) {
		return;
			}

			addPropTypesToComponent(component, getPropTypesFromTypeAnnotation(node.params[0].typeAnnotation, context));
	}

	function handlePropTypeAnnotationClassProperty(node) {
			var component = components.get(utils.getParentES6Component());
			if (!component) {
		return;
			}

			addPropTypesToComponent(component, getPropTypesFromTypeAnnotation(node.typeAnnotation, context));
	}

	function isPropTypeAnnotation(node) {
			return getPropertyName(node) === 'props' && !!node.typeAnnotation;
	}
	function reportPropTypesWithoutDefault(propTypes, defaultProps) {
			if (defaultProps === 'unresolved') {
		return;
			}

			propTypes.forEach(function (prop) {
		if (prop.isRequired) {
					return;
		}

		if (defaultProps[prop.name]) {
					return;
		}

		context.report(prop.node, 'propType "{{name}}" is not required, but has no corresponding defaultProp declaration.', { name: prop.name });
			});
	}
	return {
			MemberExpression: function MemberExpression(node) {
		var isPropType = isPropTypesDeclaration(node);
		var isDefaultProp = isDefaultPropsDeclaration(node);

		if (!isPropType && !isDefaultProp) {
					return;
		}
		var component = utils.getRelatedComponent(node);
		if (!component) {
					return;
		}
		//
		//
		if (node.parent.type === 'AssignmentExpression') {
					var expression = resolveNodeValue(node.parent.right);
					if (!expression || expression.type !== 'ObjectExpression') {
			if (isDefaultProp) {
							markDefaultPropsAsUnresolved(component);
			}

			return;
					}

					if (isPropType) {
			addPropTypesToComponent(component, getPropTypesFromObjectExpression(expression));
					} else {
			addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(expression));
					}

					return;
		}
		if (node.parent.type === 'MemberExpression' && node.parent.parent.type === 'AssignmentExpression') {
					if (isPropType) {
			addPropTypesToComponent(component, [{
							name: node.parent.property.name,
							isRequired: isRequiredPropType(node.parent.parent.right),
							node: node.parent.parent
			}]);
					} else {
			addDefaultPropsToComponent(component, [node.parent.property.name]);
					}

					return;
		}
			},
			MethodDefinition: function MethodDefinition(node) {
		if (!node.static || node.kind !== 'get') {
					return;
		}

		var isPropType = isPropTypesDeclaration(node);
		var isDefaultProp = isDefaultPropsDeclaration(node);

		if (!isPropType && !isDefaultProp) {
					return;
		}
		var component = components.get(utils.getParentES6Component());
		if (!component) {
					return;
		}

		var returnStatement = utils.findReturnStatement(node);
		if (!returnStatement) {
					return;
		}

		var expression = resolveNodeValue(returnStatement.argument);
		if (!expression || expression.type !== 'ObjectExpression') {
					return;
		}

		if (isPropType) {
					addPropTypesToComponent(component, getPropTypesFromObjectExpression(expression));
		} else {
					addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(expression));
		}
			},
			ClassProperty: function ClassProperty(node) {
		if (isPropTypeAnnotation(node)) {
					handlePropTypeAnnotationClassProperty(node);
					return;
		}

		if (!node.static) {
					return;
		}

		if (!node.value) {
					return;
		}

		var isPropType = getPropertyName(node) === 'propTypes';
		var isDefaultProp = getPropertyName(node) === 'defaultProps' || getPropertyName(node) === 'getDefaultProps';

		if (!isPropType && !isDefaultProp) {
					return;
		}
		var component = components.get(utils.getParentES6Component());
		if (!component) {
					return;
		}

		var expression = resolveNodeValue(node.value);
		if (!expression || expression.type !== 'ObjectExpression') {
					return;
		}

		if (isPropType) {
					addPropTypesToComponent(component, getPropTypesFromObjectExpression(expression));
		} else {
					addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(expression));
		}
			},
			ObjectExpression: function ObjectExpression(node) {
		var component = utils.isES5Component(node) && components.get(node);
		if (!component) {
					return;
		}
		node.properties.forEach(function (property) {
					if (property.type === 'ExperimentalSpreadProperty') {
			return;
					}

					var isPropType = isPropTypesDeclaration(property);
					var isDefaultProp = isDefaultPropsDeclaration(property);

					if (!isPropType && !isDefaultProp) {
			return;
					}

					if (isPropType && property.value.type === 'ObjectExpression') {
			addPropTypesToComponent(component, getPropTypesFromObjectExpression(property.value));
			return;
					}

					if (isDefaultProp && property.value.type === 'FunctionExpression') {
			var returnStatement = utils.findReturnStatement(property);
			if (!returnStatement || returnStatement.argument.type !== 'ObjectExpression') {
							return;
			}

			addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(returnStatement.argument));
					}
		});
			},
			FunctionDeclaration: handleStatelessComponent,
			ArrowFunctionExpression: handleStatelessComponent,
			FunctionExpression: handleStatelessComponent,

			'Program:exit': function ProgramExit() {
		var list = components.list();

		for (var component in list) {
					if (!has(list, component)) {
			continue;
					}
					if (!list[component].propTypes) {
			continue;
					}

					reportPropTypesWithoutDefault(list[component].propTypes, list[component].defaultProps || {});
		}
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
var Components = __webpack_require__(8);

module.exports = {
  meta: {
	docs: {
			description: 'Enforce React components to have a shouldComponentUpdate method',
			category: 'Best Practices',
			recommended: false
	},

	schema: [{
			type: 'object',
			properties: {
		allowDecorators: {
					type: 'array',
					items: {
			type: 'string'
					}
		}
			},
			additionalProperties: false
	}]
  },

  create: Components.detect(function (context, components, utils) {
	var MISSING_MESSAGE = 'Component is not optimized. Please add a shouldComponentUpdate method.';
	var configuration = context.options[0] || {};
	var allowDecorators = configuration.allowDecorators || [];
	var hasPureRenderDecorator = function hasPureRenderDecorator(node) {
			if (node.decorators && node.decorators.length) {
		for (var i = 0, l = node.decorators.length; i < l; i++) {
					if (node.decorators[i].expression && node.decorators[i].expression.callee && node.decorators[i].expression.callee.object && node.decorators[i].expression.callee.object.name === 'reactMixin' && node.decorators[i].expression.callee.property && node.decorators[i].expression.callee.property.name === 'decorate' && node.decorators[i].expression.arguments && node.decorators[i].expression.arguments.length && node.decorators[i].expression.arguments[0].name === 'PureRenderMixin') {
			return true;
					}
		}
			}

			return false;
	};
	var hasCustomDecorator = function hasCustomDecorator(node) {
			var allowLength = allowDecorators.length;

			if (allowLength && node.decorators && node.decorators.length) {
		for (var i = 0; i < allowLength; i++) {
					for (var j = 0, l = node.decorators.length; j < l; j++) {
			if (node.decorators[j].expression && node.decorators[j].expression.name === allowDecorators[i]) {
							return true;
			}
					}
		}
			}

			return false;
	};
	var isSCUDeclard = function isSCUDeclard(node) {
			return Boolean(node && node.name === 'shouldComponentUpdate');
	};
	var isPureRenderDeclared = function isPureRenderDeclared(node) {
			var hasPR = false;
			if (node.value && node.value.elements) {
		for (var i = 0, l = node.value.elements.length; i < l; i++) {
					if (node.value.elements[i].name === 'PureRenderMixin') {
			hasPR = true;
			break;
					}
		}
			}

			return Boolean(node && node.key.name === 'mixins' && hasPR);
	};
	var markSCUAsDeclared = function markSCUAsDeclared(node) {
			components.set(node, {
		hasSCU: true
			});
	};
	var reportMissingOptimization = function reportMissingOptimization(component) {
			context.report({
		node: component.node,
		message: MISSING_MESSAGE,
		data: {
					component: component.name
		}
			});
	};
	var isFunctionInClass = function isFunctionInClass() {
			var blockNode = void 0;
			var scope = context.getScope();
			while (scope) {
		blockNode = scope.block;
		if (blockNode && blockNode.type === 'ClassDeclaration') {
					return true;
		}
		scope = scope.upper;
			}

			return false;
	};

	return {
			ArrowFunctionExpression: function ArrowFunctionExpression(node) {
		markSCUAsDeclared(node);
			},

			ClassDeclaration: function ClassDeclaration(node) {
		if (!(hasPureRenderDecorator(node) || hasCustomDecorator(node) || utils.isPureComponent(node))) {
					return;
		}
		markSCUAsDeclared(node);
			},

			FunctionDeclaration: function FunctionDeclaration(node) {
		if (isFunctionInClass()) {
					return;
		}
		markSCUAsDeclared(node);
			},

			FunctionExpression: function FunctionExpression(node) {
		if (isFunctionInClass()) {
					return;
		}
		markSCUAsDeclared(node);
			},

			MethodDefinition: function MethodDefinition(node) {
		if (!isSCUDeclard(node.key)) {
					return;
		}
		markSCUAsDeclared(node);
			},

			ObjectExpression: function ObjectExpression(node) {
		for (var i = 0, l = node.properties.length; i < l; i++) {
					if (!node.properties[i].key || !isSCUDeclard(node.properties[i].key) && !isPureRenderDeclared(node.properties[i])) {
			continue;
					}
					markSCUAsDeclared(node);
		}
			},

			'Program:exit': function ProgramExit() {
		var list = components.list();
		for (var component in list) {
					if (!has(list, component) || list[component].hasSCU) {
			continue;
					}
					reportMissingOptimization(list[component]);
		}
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
var Components = __webpack_require__(8);
module.exports = {
  meta: {
	docs: {
			description: 'Enforce ES5 or ES6 class for returning value in render function',
			category: 'Possible Errors',
			recommended: true
	},
	schema: [{}]
  },

  create: Components.detect(function (context, components, utils) {
	function markReturnStatementPresent(node) {
			components.set(node, {
		hasReturnStatement: true
			});
	}
	function getComponentProperties(node) {
			switch (node.type) {
		case 'ClassDeclaration':
					return node.body.body;
		case 'ObjectExpression':
					return node.properties;
		default:
					return [];
			}
	}
	function getPropertyName(node) {
			if (node.type === 'ClassProperty') {
		var tokens = context.getFirstTokens(node, 2);
		return tokens[1] && tokens[1].type === 'Identifier' ? tokens[1].value : tokens[0].value;
			} else if (['MethodDefinition', 'Property'].indexOf(node.type) !== -1) {
		return node.key.name;
			}
			return '';
	}
	function hasRenderMethod(node) {
			var properties = getComponentProperties(node);
			for (var i = 0, j = properties.length; i < j; i++) {
		if (getPropertyName(properties[i]) !== 'render' || !properties[i].value) {
					continue;
		}
		return (/FunctionExpression$/.test(properties[i].value.type)
		);
			}
			return false;
	}

	return {
			ReturnStatement: function ReturnStatement(node) {
		var ancestors = context.getAncestors(node).reverse();
		var depth = 0;
		for (var i = 0, j = ancestors.length; i < j; i++) {
					if (/Function(Expression|Declaration)$/.test(ancestors[i].type)) {
			depth++;
					}
					if (!/(MethodDefinition|(Class)?Property)$/.test(ancestors[i].type) || getPropertyName(ancestors[i]) !== 'render' || depth > 1) {
			continue;
					}
					markReturnStatementPresent(node);
		}
			},

			ArrowFunctionExpression: function ArrowFunctionExpression(node) {
		if (node.expression === false || getPropertyName(node.parent) !== 'render') {
					return;
		}
		markReturnStatementPresent(node);
			},

			'Program:exit': function ProgramExit() {
		var list = components.list();
		for (var component in list) {
					if (!has(list, component) || !hasRenderMethod(list[component].node) || list[component].hasReturnStatement || !utils.isES5Component(list[component].node) && !utils.isES6Component(list[component].node)) {
			continue;
					}
					context.report({
			node: list[component].node,
			message: 'Your render method should have return statement'
					});
		}
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
module.exports = {
  meta: {
	docs: {
			description: 'Prevent extra closing tags for components without children',
			category: 'Stylistic Issues',
			recommended: false
	},
	fixable: 'code',

	schema: [{
			type: 'object',
			properties: {
		component: {
					default: true,
					type: 'boolean'
		},
		html: {
					default: true,
					type: 'boolean'
		}
			},
			additionalProperties: false
	}]
  },

  create: function create(context) {
	var tagConvention = /^[a-z]|\-/;
	function isTagName(name) {
			return tagConvention.test(name);
	}

	function isComponent(node) {
			return node.name && node.name.type === 'JSXIdentifier' && !isTagName(node.name.name);
	}

	function hasChildren(node) {
			var childrens = node.parent.children;
			if (!childrens.length || childrens.length === 1 && childrens[0].type === 'Literal' && !childrens[0].value.replace(/(?!\xA0)\s/g, '')) {
		return false;
			}
			return true;
	}

	function isShouldBeSelfClosed(node) {
			var configuration = context.options[0] || { component: true, html: true };
			return (configuration.component && isComponent(node) || configuration.html && isTagName(node.name.name)) && !node.selfClosing && !hasChildren(node);
	}
	return {

			JSXOpeningElement: function JSXOpeningElement(node) {
		if (!isShouldBeSelfClosed(node)) {
					return;
		}
		context.report({
					node: node,
					message: 'Empty components are self-closing',
					fix: function fix(fixer) {
			var openingElementEnding = node.end - 1;
			var closingElementEnding = node.parent.closingElement.end;
			var range = [openingElementEnding, closingElementEnding];
			return fixer.replaceTextRange(range, ' />');
					}
		});
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);
var util = __webpack_require__(108);

var Components = __webpack_require__(8);
function getMethodsOrder(defaultConfig, userConfig) {
  userConfig = userConfig || {};

  var groups = util._extend(defaultConfig.groups, userConfig.groups);
  var order = userConfig.order || defaultConfig.order;

  var config = [];
  var entry = void 0;
  for (var i = 0, j = order.length; i < j; i++) {
	entry = order[i];
	if (has(groups, entry)) {
			config = config.concat(groups[entry]);
	} else {
			config.push(entry);
	}
  }

  return config;
}
module.exports = {
  meta: {
	docs: {
			description: 'Enforce component methods order',
			category: 'Stylistic Issues',
			recommended: false
	},

	schema: [{
			type: 'object',
			properties: {
		order: {
					type: 'array',
					items: {
			type: 'string'
					}
		},
		groups: {
					type: 'object',
					patternProperties: {
			'^.*$': {
							type: 'array',
							items: {
				type: 'string'
							}
			}
					}
		}
			},
			additionalProperties: false
	}]
  },

  create: Components.detect(function (context, components) {
	var errors = {};

	var MISPOSITION_MESSAGE = '{{propA}} should be placed {{position}} {{propB}}';

	var methodsOrder = getMethodsOrder({
			order: ['static-methods', 'lifecycle', 'everything-else', 'render'],
			groups: {
		lifecycle: ['displayName', 'propTypes', 'contextTypes', 'childContextTypes', 'mixins', 'statics', 'defaultProps', 'constructor', 'getDefaultProps', 'state', 'getInitialState', 'getChildContext', 'componentWillMount', 'componentDidMount', 'componentWillReceiveProps', 'shouldComponentUpdate', 'componentWillUpdate', 'componentDidUpdate', 'componentWillUnmount']
			}
	}, context.options[0]);
	var regExpRegExp = /\/(.*)\/([g|y|i|m]*)/;
	function getRefPropIndexes(method) {
			var isRegExp = void 0;
			var matching = void 0;
			var i = void 0;
			var j = void 0;
			var indexes = [];

			if (method.static) {
		var staticIndex = methodsOrder.indexOf('static-methods');
		if (staticIndex >= 0) {
					indexes.push(staticIndex);
		}
			}

			if (method.getter) {
		var getterIndex = methodsOrder.indexOf('getters');
		if (getterIndex >= 0) {
					indexes.push(getterIndex);
		}
			}

			if (method.setter) {
		var setterIndex = methodsOrder.indexOf('setters');
		if (setterIndex >= 0) {
					indexes.push(setterIndex);
		}
			}

			if (method.typeAnnotation) {
		var annotationIndex = methodsOrder.indexOf('type-annotations');
		if (annotationIndex >= 0) {
					indexes.push(annotationIndex);
		}
			}
			if (indexes.length === 0) {
		for (i = 0, j = methodsOrder.length; i < j; i++) {
					isRegExp = methodsOrder[i].match(regExpRegExp);
					if (isRegExp) {
			matching = new RegExp(isRegExp[1], isRegExp[2]).test(method.name);
					} else {
			matching = methodsOrder[i] === method.name;
					}
					if (matching) {
			indexes.push(i);
					}
		}
			}
			if (indexes.length === 0) {
		for (i = 0, j = methodsOrder.length; i < j; i++) {
					if (methodsOrder[i] === 'everything-else') {
			indexes.push(i);
			break;
					}
		}
			}
			if (indexes.length === 0) {
		indexes.push(Infinity);
			}

			return indexes;
	}
	function getPropertyName(node) {
			if (node.type === 'ClassProperty') {
		var tokens = context.getFirstTokens(node, 2);
		return tokens[1] && tokens[1].type === 'Identifier' ? tokens[1].value : tokens[0].value;
			}

			if (node.kind === 'get') {
		return 'getter functions';
			}

			if (node.kind === 'set') {
		return 'setter functions';
			}

			return node.key.name;
	}
	function storeError(propA, propB) {
			if (!errors[propA.index]) {
		errors[propA.index] = {
					node: propA.node,
					score: 0,
					closest: {
			distance: Infinity,
			ref: {
							node: null,
							index: 0
			}
					}
		};
			}
			errors[propA.index].score++;
			if (getPropertyName(errors[propA.index].node) !== getPropertyName(propA.node)) {
		return;
			}
			if (Math.abs(propA.index - propB.index) > errors[propA.index].closest.distance) {
		return;
			}
			errors[propA.index].closest.distance = Math.abs(propA.index - propB.index);
			errors[propA.index].closest.ref.node = propB.node;
			errors[propA.index].closest.ref.index = propB.index;
	}
	function dedupeErrors() {
			for (var i in errors) {
		if (!has(errors, i)) {
					continue;
		}
		var index = errors[i].closest.ref.index;
		if (!errors[index]) {
					continue;
		}
		if (errors[i].score > errors[index].score) {
					delete errors[index];
		} else {
					delete errors[i];
		}
			}
	}
	function reportErrors() {
			dedupeErrors();

			var nodeA = void 0;
			var nodeB = void 0;
			var indexA = void 0;
			var indexB = void 0;
			for (var i in errors) {
		if (!has(errors, i)) {
					continue;
		}

		nodeA = errors[i].node;
		nodeB = errors[i].closest.ref.node;
		indexA = i;
		indexB = errors[i].closest.ref.index;

		context.report({
					node: nodeA,
					message: MISPOSITION_MESSAGE,
					data: {
			propA: getPropertyName(nodeA),
			propB: getPropertyName(nodeB),
			position: indexA < indexB ? 'before' : 'after'
					}
		});
			}
	}
	function getComponentProperties(node) {
			switch (node.type) {
		case 'ClassExpression':
		case 'ClassDeclaration':
					return node.body.body;
		case 'ObjectExpression':
					return node.properties.filter(function (property) {
			return property.type === 'Property';
					});
		default:
					return [];
			}
	}
	function comparePropsOrder(propertiesInfos, propA, propB) {
			var i = void 0;
			var j = void 0;
			var k = void 0;
			var l = void 0;
			var refIndexA = void 0;
			var refIndexB = void 0;
			var refIndexesA = getRefPropIndexes(propA);
			var refIndexesB = getRefPropIndexes(propB);
			var classIndexA = propertiesInfos.indexOf(propA);
			var classIndexB = propertiesInfos.indexOf(propB);
			for (i = 0, j = refIndexesA.length; i < j; i++) {
		refIndexA = refIndexesA[i];
		for (k = 0, l = refIndexesB.length; k < l; k++) {
					refIndexB = refIndexesB[k];

					if (
					refIndexA === refIndexB ||
					refIndexA < refIndexB && classIndexA < classIndexB ||
					refIndexA > refIndexB && classIndexA > classIndexB) {
			return {
							correct: true,
							indexA: classIndexA,
							indexB: classIndexB
			};
					}
		}
			}
			return {
		correct: false,
		indexA: refIndexA,
		indexB: refIndexB
			};
	}
	function checkPropsOrder(properties) {
			var propertiesInfos = properties.map(function (node) {
		return {
					name: getPropertyName(node),
					getter: node.kind === 'get',
					setter: node.kind === 'set',
					static: node.static,
					typeAnnotation: !!node.typeAnnotation && node.value === null
		};
			});

			var i = void 0;
			var j = void 0;
			var k = void 0;
			var l = void 0;
			var propA = void 0;
			var propB = void 0;
			var order = void 0;
			for (i = 0, j = propertiesInfos.length; i < j; i++) {
		propA = propertiesInfos[i];
		for (k = 0, l = propertiesInfos.length; k < l; k++) {
					propB = propertiesInfos[k];
					order = comparePropsOrder(propertiesInfos, propA, propB);
					if (order.correct === true) {
			continue;
					}
					storeError({
			node: properties[i],
			index: order.indexA
					}, {
			node: properties[k],
			index: order.indexB
					});
		}
			}
	}

	return {
			'Program:exit': function ProgramExit() {
		var list = components.list();
		for (var component in list) {
					if (!has(list, component)) {
			continue;
					}
					var properties = getComponentProperties(list[component].node);
					checkPropsOrder(properties);
		}

		reportErrors();
			}
	};
  })
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var variableUtil = __webpack_require__(27);
module.exports = {
  meta: {
	docs: {
			description: 'Enforce propTypes declarations alphabetical sorting',
			category: 'Stylistic Issues',
			recommended: false
	},

	schema: [{
			type: 'object',
			properties: {
		requiredFirst: {
					type: 'boolean'
		},
		callbacksLast: {
					type: 'boolean'
		},
		ignoreCase: {
					type: 'boolean'
		}
			},
			additionalProperties: false
	}]
  },

  create: function create(context) {
	var sourceCode = context.getSourceCode();
	var configuration = context.options[0] || {};
	var requiredFirst = configuration.requiredFirst || false;
	var callbacksLast = configuration.callbacksLast || false;
	var ignoreCase = configuration.ignoreCase || false;
	var propWrapperFunctions = new Set(context.settings.propWrapperFunctions || []);
	function isPropTypesDeclaration(node) {
			if (node.type === 'ClassProperty') {
		var tokens = context.getFirstTokens(node, 2);
		return tokens[0] && tokens[0].value === 'propTypes' || tokens[1] && tokens[1].value === 'propTypes';
			}

			return Boolean(node && node.name === 'propTypes');
	}

	function getKey(node) {
			return sourceCode.getText(node.key || node.argument);
	}

	function getValueName(node) {
			return node.type === 'Property' && node.value.property && node.value.property.name;
	}

	function isCallbackPropName(propName) {
			return (/^on[A-Z]/.test(propName)
			);
	}

	function isRequiredProp(node) {
			return getValueName(node) === 'isRequired';
	}
	function findVariableByName(name) {
			var variable = variableUtil.variablesInScope(context).find(function (item) {
		return item.name === name;
			});

			if (!variable || !variable.defs[0] || !variable.defs[0].node) {
		return null;
			}

			if (variable.defs[0].node.type === 'TypeAlias') {
		return variable.defs[0].node.right;
			}

			return variable.defs[0].node.init;
	}
	function checkSorted(declarations) {
			declarations.reduce(function (prev, curr, idx, decls) {
		if (/SpreadProperty$/.test(curr.type)) {
					return decls[idx + 1];
		}

		var prevPropName = getKey(prev);
		var currentPropName = getKey(curr);
		var previousIsRequired = isRequiredProp(prev);
		var currentIsRequired = isRequiredProp(curr);
		var previousIsCallback = isCallbackPropName(prevPropName);
		var currentIsCallback = isCallbackPropName(currentPropName);

		if (ignoreCase) {
					prevPropName = prevPropName.toLowerCase();
					currentPropName = currentPropName.toLowerCase();
		}

		if (requiredFirst) {
					if (previousIsRequired && !currentIsRequired) {
			return curr;
					}
					if (!previousIsRequired && currentIsRequired) {
			context.report({
							node: curr,
							message: 'Required prop types must be listed before all other prop types'
			});
			return curr;
					}
		}

		if (callbacksLast) {
					if (!previousIsCallback && currentIsCallback) {
			return curr;
					}
					if (previousIsCallback && !currentIsCallback) {
			context.report({
							node: prev,
							message: 'Callback prop types must be listed after all other prop types'
			});
			return prev;
					}
		}

		if (currentPropName < prevPropName) {
					context.report({
			node: curr,
			message: 'Prop types declarations should be sorted alphabetically'
					});
					return prev;
		}

		return curr;
			}, declarations[0]);
	}

	function checkNode(node) {
			switch (node && node.type) {
		case 'ObjectExpression':
					checkSorted(node.properties);
					break;
		case 'Identifier':
					var propTypesObject = findVariableByName(node.name);
					if (propTypesObject && propTypesObject.properties) {
			checkSorted(propTypesObject.properties);
					}
					break;
		case 'CallExpression':
					var innerNode = node.arguments && node.arguments[0];
					if (propWrapperFunctions.has(node.callee.name) && innerNode) {
			checkNode(innerNode);
					}
					break;
		default:
					break;
			}
	}

	return {
			ClassProperty: function ClassProperty(node) {
		if (!isPropTypesDeclaration(node)) {
					return;
		}
		checkNode(node.value);
			},

			MemberExpression: function MemberExpression(node) {
		if (!isPropTypesDeclaration(node.property)) {
					return;
		}

		checkNode(node.parent.right);
			},

			ObjectExpression: function ObjectExpression(node) {
		node.properties.forEach(function (property) {
					if (!property.key) {
			return;
					}

					if (!isPropTypesDeclaration(property.key)) {
			return;
					}
					if (property.value.type === 'ObjectExpression') {
			checkSorted(property.value.properties);
					}
		});
			}

	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var variableUtil = __webpack_require__(27);
module.exports = {
  meta: {
	docs: {
			description: 'Enforce style prop value is an object',
			category: '',
			recommended: false
	},
	schema: []
  },

  create: function create(context) {
	function isNonNullaryLiteral(expression) {
			return expression.type === 'Literal' && expression.value !== null;
	}
	function checkIdentifiers(node) {
			var variable = variableUtil.variablesInScope(context).find(function (item) {
		return item.name === node.name;
			});

			if (!variable || !variable.defs[0] || !variable.defs[0].node.init) {
		return;
			}

			if (isNonNullaryLiteral(variable.defs[0].node.init)) {
		context.report(node, 'Style prop value must be an object');
			}
	}

	return {
			CallExpression: function CallExpression(node) {
		if (node.callee && node.callee.type === 'MemberExpression' && node.callee.property.name === 'createElement' && node.arguments.length > 1) {
					if (node.arguments[1].type === 'ObjectExpression') {
			var style = node.arguments[1].properties.find(function (property) {
							return property.key && property.key.name === 'style' && !property.computed;
			});
			if (style) {
							if (style.value.type === 'Identifier') {
				checkIdentifiers(style.value);
							} else if (isNonNullaryLiteral(style.value)) {
				context.report(style.value, 'Style prop value must be an object');
							}
			}
					}
		}
			},

			JSXAttribute: function JSXAttribute(node) {
		if (!node.value || node.name.name !== 'style') {
					return;
		}

		if (node.value.type !== 'JSXExpressionContainer' || isNonNullaryLiteral(node.value.expression)) {
					context.report(node, 'Style prop value must be an object');
		} else if (node.value.expression.type === 'Identifier') {
					checkIdentifiers(node.value.expression);
		}
			}
	};
  }
};
 }),
 (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(7);

var Components = __webpack_require__(8);
var VOID_DOM_ELEMENTS = {
  area: true,
  base: true,
  br: true,
  col: true,
  embed: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  menuitem: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
};

function isVoidDOMElement(elementName) {
  return has(VOID_DOM_ELEMENTS, elementName);
}

function errorMessage(elementName) {
  return 'Void DOM element <' + elementName + ' /> cannot receive children.';
}
module.exports = {
  meta: {
	docs: {
			description: 'Prevent passing of children to void DOM elements (e.g. <br />).',
			category: 'Best Practices',
			recommended: false
	},
	schema: []
  },

  create: Components.detect(function (context, components, utils) {
	return {
			JSXElement: function JSXElement(node) {
		var elementName = node.openingElement.name.name;

		if (!isVoidDOMElement(elementName)) {
					return;
		}

		if (node.children.length > 0) {
					context.report({
			node: node,
			message: errorMessage(elementName)
					});
		}

		var attributes = node.openingElement.attributes;

		var hasChildrenAttributeOrDanger = attributes.some(function (attribute) {
					if (!attribute.name) {
			return false;
					}

					return attribute.name.name === 'children' || attribute.name.name === 'dangerouslySetInnerHTML';
		});

		if (hasChildrenAttributeOrDanger) {
					context.report({
			node: node,
			message: errorMessage(elementName)
					});
		}
			},

			CallExpression: function CallExpression(node) {
		if (node.callee.type !== 'MemberExpression' && node.callee.type !== 'Identifier') {
					return;
		}

		if (!utils.isReactCreateElement(node)) {
					return;
		}

		var args = node.arguments;

		if (args.length < 1) {
					return;
		}

		var elementName = args[0].value;

		if (!isVoidDOMElement(elementName)) {
					return;
		}

		if (args.length < 2 || args[1].type !== 'ObjectExpression') {
					return;
		}

		var firstChild = args[2];
		if (firstChild) {
					context.report({
			node: node,
			message: errorMessage(elementName)
					});
		}

		var props = args[1].properties;

		var hasChildrenPropOrDanger = props.some(function (prop) {
					if (!prop.key) {
			return false;
					}

					return prop.key.name === 'children' || prop.key.name === 'dangerouslySetInnerHTML';
		});

		if (hasChildrenPropOrDanger) {
					context.report({
			node: node,
			message: errorMessage(elementName)
					});
		}
			}
	};
  })
};
 }),
 (function(module, exports) {

module.exports = {"rules":{"generator-star":["generator-star-spacing"],"global-strict":["strict"],"no-arrow-condition":["no-confusing-arrow","no-constant-condition"],"no-comma-dangle":["comma-dangle"],"no-empty-class":["no-empty-character-class"],"no-empty-label":["no-labels"],"no-extra-strict":["strict"],"no-reserved-keys":["quote-props"],"no-space-before-semi":["semi-spacing"],"no-wrap-func":["no-extra-parens"],"space-after-function-name":["space-before-function-paren"],"space-after-keywords":["keyword-spacing"],"space-before-function-parentheses":["space-before-function-paren"],"space-before-keywords":["keyword-spacing"],"space-in-brackets":["object-curly-spacing","array-bracket-spacing","computed-property-spacing"],"space-return-throw-case":["keyword-spacing"],"space-unary-word-ops":["space-unary-ops"],"spaced-line-comment":["spaced-comment"]}}
 }),
 (function(module, exports) {

function webpackEmptyContext(req) {
	throw new Error("Cannot find module '" + req + "'.");
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = 753;
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
(function(process) {/**
 * @fileoverview Tracks performance of individual rules.
 * @author Brandon Mills
 */

function alignLeft(str, len, ch) {
	return str + new Array(len - str.length + 1).join(ch || " ");
}
function alignRight(str, len, ch) {
	return new Array(len - str.length + 1).join(ch || " ") + str;
}
var enabled = !!process.env.TIMING;

var HEADERS = ["Rule", "Time (ms)", "Relative"];
var ALIGN = [alignLeft, alignRight, alignRight];
function display(data) {
	var total = 0;
	var rows = Object.keys(data).map(function (key) {
		var time = data[key];

		total += time;
		return [key, time];
	}).sort(function (a, b) {
		return b[1] - a[1];
	}).slice(0, 10);

	rows.forEach(function (row) {
		row.push((row[1] * 100 / total).toFixed(1) + "%");
		row[1] = row[1].toFixed(3);
	});

	rows.unshift(HEADERS);

	var widths = [];

	rows.forEach(function (row) {
		var len = row.length;

		for (var i = 0; i < len; i++) {
			var n = row[i].length;

			if (!widths[i] || n > widths[i]) {
				widths[i] = n;
			}
		}
	});

	var table = rows.map(function (row) {
		return row.map(function (cell, index) {
			return ALIGN[index](cell, widths[index]);
		}).join(" | ");
	});

	table.splice(1, 0, widths.map(function (w, index) {
		if (index !== 0 && index !== widths.length - 1) {
			w++;
		}

		return ALIGN[index](":", w + 1, "-");
	}).join("|"));

	console.log(table.join("\n")); // eslint-disable-line no-console
}
module.exports = function () {

	var data = Object.create(null);
	function time(key, fn) {
		if (typeof data[key] === "undefined") {
			data[key] = 0;
		}

		return function () {
			var t = process.hrtime();

			fn.apply(null, Array.prototype.slice.call(arguments));
			t = process.hrtime(t);
			data[key] += t[0] * 1e3 + t[1] / 1e6;
		};
	}

	if (enabled) {
		process.on("exit", function () {
			display(data);
		});
	}

	return {
		time: time,
		enabled: enabled
	};
}();
}.call(exports, __webpack_require__(20)))
 }),
 (function(module, exports) {

module.exports = {"_from":"eslint@^4.12.0","_id":"eslint@4.13.1","_inBundle":false,"_integrity":"sha512-UCJVV50RtLHYzBp1DZ8CMPtRSg4iVZvjgO9IJHIKyWU/AnJVjtdRikoUPLB29n5pzMB7TnsLQWf0V6VUJfoPfw==","_location":"/eslint","_phantomChildren":{"color-convert":"1.9.1","escape-string-regexp":"1.0.5","has-flag":"2.0.0","ms":"2.0.0"},"_requested":{"type":"range","registry":true,"raw":"eslint@^4.12.0","name":"eslint","escapedName":"eslint","rawSpec":"^4.12.0","saveSpec":null,"fetchSpec":"^4.12.0"},"_requiredBy":["/"],"_resolved":"https://registry.npmjs.org/eslint/-/eslint-4.13.1.tgz","_shasum":"0055e0014464c7eb7878caf549ef2941992b444f","_spec":"eslint@^4.12.0","_where":"J:\\Chromium\\newclient\\plugins\\c9.ide.language.javascript.eslint\\packager","author":{"name":"Nicholas C. Zakas","email":"nicholas+npm@nczconsulting.com"},"bin":{"eslint":"./bin/eslint.js"},"bugs":{"url":"https://github.com/eslint/eslint/issues/"},"bundleDependencies":false,"dependencies":{"ajv":"^5.3.0","babel-code-frame":"^6.22.0","chalk":"^2.1.0","concat-stream":"^1.6.0","cross-spawn":"^5.1.0","debug":"^3.0.1","doctrine":"^2.0.2","eslint-scope":"^3.7.1","espree":"^3.5.2","esquery":"^1.0.0","estraverse":"^4.2.0","esutils":"^2.0.2","file-entry-cache":"^2.0.0","functional-red-black-tree":"^1.0.1","glob":"^7.1.2","globals":"^11.0.1","ignore":"^3.3.3","imurmurhash":"^0.1.4","inquirer":"^3.0.6","is-resolvable":"^1.0.0","js-yaml":"^3.9.1","json-stable-stringify-without-jsonify":"^1.0.1","levn":"^0.3.0","lodash":"^4.17.4","minimatch":"^3.0.2","mkdirp":"^0.5.1","natural-compare":"^1.4.0","optionator":"^0.8.2","path-is-inside":"^1.0.2","pluralize":"^7.0.0","progress":"^2.0.0","require-uncached":"^1.0.3","semver":"^5.3.0","strip-ansi":"^4.0.0","strip-json-comments":"~2.0.1","table":"^4.0.1","text-table":"~0.2.0"},"deprecated":false,"description":"An AST-based pattern checker for JavaScript.","devDependencies":{"babel-polyfill":"^6.23.0","babel-preset-es2015":"^6.24.1","babelify":"^7.3.0","beefy":"^2.1.8","brfs":"1.4.3","browserify":"^14.4.0","chai":"^4.0.1","cheerio":"^0.22.0","coveralls":"^2.13.1","dateformat":"^2.0.0","ejs":"^2.5.6","eslint-plugin-eslint-plugin":"^1.2.0","eslint-plugin-node":"^5.1.0","eslint-plugin-rulesdir":"^0.1.0","eslint-release":"^0.10.1","eslint-rule-composer":"^0.1.0","eslump":"1.6.0","esprima":"^4.0.0","esprima-fb":"^15001.1001.0-dev-harmony-fb","istanbul":"^0.4.5","jsdoc":"^3.4.3","karma":"^1.7.0","karma-babel-preprocessor":"^6.0.1","karma-mocha":"^1.3.0","karma-mocha-reporter":"^2.2.3","karma-phantomjs-launcher":"^1.0.4","leche":"^2.1.2","load-perf":"^0.2.0","markdownlint":"^0.6.1","mocha":"^3.4.2","mock-fs":"^4.3.0","npm-license":"^0.3.3","phantomjs-prebuilt":"^2.1.14","proxyquire":"^1.8.0","shelljs":"^0.7.7","sinon":"^3.2.1","temp":"^0.8.3","through":"^2.3.8"},"engines":{"node":">=4"},"files":["LICENSE","README.md","bin","conf","lib","messages"],"homepage":"https://eslint.org","keywords":["ast","lint","javascript","ecmascript","espree"],"license":"MIT","main":"./lib/api.js","name":"eslint","repository":{"type":"git","url":"git+https://github.com/eslint/eslint.git"},"scripts":{"alpharelease":"node Makefile.js prerelease -- alpha","betarelease":"node Makefile.js prerelease -- beta","browserify":"node Makefile.js browserify","ci-release":"node Makefile.js ciRelease","coveralls":"cat ./coverage/lcov.info | coveralls","docs":"node Makefile.js docs","fuzz":"node Makefile.js fuzz","gensite":"node Makefile.js gensite","lint":"node Makefile.js lint","perf":"node Makefile.js perf","profile":"beefy tests/bench/bench.js --open -- -t brfs -t ./tests/bench/xform-rules.js -r espree","release":"node Makefile.js release","test":"node Makefile.js test"},"version":"4.13.1"}
 }),
 (function(module, exports, __webpack_require__) {

"use strict";
var debug = __webpack_require__(67)("eslint:text-fixer");
var BOM = "\uFEFF";
function compareMessagesByFixRange(a, b) {
	return a.fix.range[0] - b.fix.range[0] || a.fix.range[1] - b.fix.range[1];
}
function compareMessagesByLocation(a, b) {
	return a.line - b.line || a.column - b.column;
}
function SourceCodeFixer() {
	Object.freeze(this);
}
SourceCodeFixer.applyFixes = function (sourceText, messages, shouldFix) {
	debug("Applying fixes");

	if (shouldFix === false) {
		debug("shouldFix parameter was false, not attempting fixes");
		return {
			fixed: false,
			messages: messages,
			output: sourceText
		};
	}
	var remainingMessages = [],
		fixes = [],
		bom = sourceText.startsWith(BOM) ? BOM : "",
		text = bom ? sourceText.slice(1) : sourceText;
	var lastPos = Number.NEGATIVE_INFINITY,
		output = bom;
	function attemptFix(problem) {
		var fix = problem.fix;
		var start = fix.range[0];
		var end = fix.range[1];
		if (lastPos >= start || start > end) {
			remainingMessages.push(problem);
			return false;
		}
		if (start < 0 && end >= 0 || start === 0 && fix.text.startsWith(BOM)) {
			output = "";
		}
		output += text.slice(Math.max(0, lastPos), Math.max(0, start));
		output += fix.text;
		lastPos = end;
		return true;
	}

	messages.forEach(function (problem) {
		if (problem.hasOwnProperty("fix")) {
			fixes.push(problem);
		} else {
			remainingMessages.push(problem);
		}
	});

	if (fixes.length) {
		debug("Found fixes to apply");
		var fixesWereApplied = false;

		var _iteratorNormalCompletion = true;
		var _didIteratorError = false;
		var _iteratorError = undefined;

		try {
			for (var _iterator = fixes.sort(compareMessagesByFixRange)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
				var problem = _step.value;

				if (typeof shouldFix !== "function" || shouldFix(problem)) {
					attemptFix(problem);
					fixesWereApplied = true;
				} else {
					remainingMessages.push(problem);
				}
			}
		} catch (err) {
			_didIteratorError = true;
			_iteratorError = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion && _iterator.return) {
					_iterator.return();
				}
			} finally {
				if (_didIteratorError) {
					throw _iteratorError;
				}
			}
		}

		output += text.slice(Math.max(0, lastPos));

		return {
			fixed: fixesWereApplied,
			messages: remainingMessages.sort(compareMessagesByLocation),
			output: output
		};
	}

	debug("No fixes to apply");
	return {
		fixed: false,
		messages: messages,
		output: bom + text
	};
};

module.exports = SourceCodeFixer;
 })
 ])});;