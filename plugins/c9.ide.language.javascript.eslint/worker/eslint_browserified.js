/*
 * generated from cloud9ide/eslint using `node Makefile.js browserify`
 * and applying our patches since last update commit
 */
(function() {
var require=(function outer (modules, cache, entry) {
    var previousRequire = typeof require == "function" && require;

    function newRequire(name, jumped){
        if(!cache[name]) {
            if(!modules[name]) {
                var currentRequire = typeof require == "function" && require;
                if (!jumped && currentRequire) return currentRequire(name, true);

                if (previousRequire) return previousRequire(name, true);
                var err = new Error('Cannot find module \'' + name + '\'');
                err.code = 'MODULE_NOT_FOUND';
                throw err;
            }
            var m = cache[name] = {exports:{}};
            modules[name][0].call(m.exports, function(x){
                var id = modules[name][1][x];
                return newRequire(id ? id : x);
            },m,m.exports,outer,modules,cache,entry);
        }
        return cache[name].exports;
    }
    for(var i=0;i<entry.length;i++) newRequire(entry[i]);

    return newRequire;
})({
"/../acorn/dist/acorn.js": [function(require,module,exports){
(function (global){
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.acorn = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/src\\expression.js":[function(_dereq_,module,exports){
"use strict";

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var pp = _state.Parser.prototype;

pp.checkPropClash = function (prop, propHash) {
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) return;
  var key = prop.key;var name = undefined;
  switch (key.type) {
    case "Identifier":
      name = key.name;break;
    case "Literal":
      name = String(key.value);break;
    default:
      return;
  }
  var kind = prop.kind;

  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
      propHash.proto = true;
    }
    return;
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var isGetSet = kind !== "init";
    if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init)) this.raiseRecoverable(key.start, "Redefinition of property");
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};

pp.parseExpression = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
  if (this.type === _tokentype.types.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(_tokentype.types.comma)) node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors));
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};

pp.parseMaybeAssign = function (noIn, refDestructuringErrors, afterLeftParse) {
  if (this.inGenerator && this.isContextual("yield")) return this.parseYield();

  var validateDestructuring = false;
  if (!refDestructuringErrors) {
    refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 };
    validateDestructuring = true;
  }
  var startPos = this.start,
      startLoc = this.startLoc;
  if (this.type == _tokentype.types.parenL || this.type == _tokentype.types.name) this.potentialArrowAt = this.start;
  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
  if (this.type.isAssign) {
    if (validateDestructuring) this.checkPatternErrors(refDestructuringErrors, true);
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    node.left = this.type === _tokentype.types.eq ? this.toAssignable(left) : left;
    refDestructuringErrors.shorthandAssign = 0; // reset because shorthand default was used correctly
    this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression");
  } else {
    if (validateDestructuring) this.checkExpressionErrors(refDestructuringErrors, true);
  }
  return left;
};

pp.parseMaybeConditional = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseExprOps(noIn, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
  if (this.eat(_tokentype.types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(_tokentype.types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};

pp.parseExprOps = function (noIn, refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false);
  if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
  return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
};

pp.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.type.binop;
  if (prec != null && (!noIn || this.type !== _tokentype.types._in)) {
    if (prec > minPrec) {
      var logical = this.type === _tokentype.types.logicalOR || this.type === _tokentype.types.logicalAND;
      var op = this.value;
      this.next();
      var startPos = this.start,
          startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
    }
  }
  return left;
};

pp.buildBinary = function (startPos, startLoc, left, right, op, logical) {
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
};

pp.parseMaybeUnary = function (refDestructuringErrors, sawUnary) {
  var startPos = this.start,
      startLoc = this.startLoc,
      expr = undefined;
  if (this.type.prefix) {
    var node = this.startNode(),
        update = this.type === _tokentype.types.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) this.checkLVal(node.argument);else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") this.raiseRecoverable(node.start, "Deleting local variable in strict mode");else sawUnary = true;
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node = this.startNodeAt(startPos, startLoc);
      node.operator = this.value;
      node.prefix = false;
      node.argument = expr;
      this.checkLVal(expr);
      this.next();
      expr = this.finishNode(node, "UpdateExpression");
    }
  }

  if (!sawUnary && this.eat(_tokentype.types.starstar)) return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false);else return expr;
};

pp.parseExprSubscripts = function (refDestructuringErrors) {
  var startPos = this.start,
      startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);
  var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr;
  return this.parseSubscripts(expr, startPos, startLoc);
};

pp.parseSubscripts = function (base, startPos, startLoc, noCalls) {
  for (;;) {
    if (this.eat(_tokentype.types.dot)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = this.parseIdent(true);
      node.computed = false;
      base = this.finishNode(node, "MemberExpression");
    } else if (this.eat(_tokentype.types.bracketL)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = this.parseExpression();
      node.computed = true;
      this.expect(_tokentype.types.bracketR);
      base = this.finishNode(node, "MemberExpression");
    } else if (!noCalls && this.eat(_tokentype.types.parenL)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.callee = base;
      node.arguments = this.parseExprList(_tokentype.types.parenR, false);
      base = this.finishNode(node, "CallExpression");
    } else if (this.type === _tokentype.types.backQuote) {
      var node = this.startNodeAt(startPos, startLoc);
      node.tag = base;
      node.quasi = this.parseTemplate();
      base = this.finishNode(node, "TaggedTemplateExpression");
    } else if (this.type == _tokentype.types.colon && this.input[this.end] == ":") {
      this.next();
      this.next();
      var node = this.startNodeAt(startPos, startLoc);
      node.expressions = [base];
      var e2 = this.parseExpression();
      node.expressions.push(e2);
      base = this.finishNode(node, "SequenceExpression");
    } else {
      return base;
    }
  }
};

pp.parseExprAtom = function (refDestructuringErrors) {
  var node = undefined,
      canBeArrow = this.potentialArrowAt == this.start;
  switch (this.type) {
    case _tokentype.types._super:
      if (!this.inFunction) this.raise(this.start, "'super' outside of function or class");

    case _tokentype.types._this:
      var type = this.type === _tokentype.types._this ? "ThisExpression" : "Super";
      node = this.startNode();
      this.next();
      return this.finishNode(node, type);

    case _tokentype.types.name:
      if (this.value == "async" && /^[ \t]*(function\b|\(|\w+[ \t]*=>)/.test(this.input.slice(this.end))) {
        node = this.startNode();
        this.next();
        this.potentialArrowAt = this.start;
        return this.parseExprAtom(refDestructuringErrors);
      }
      if (this.value == "await" && /^[ \t]+[\w\x1f-\uffff]/.test(this.input.slice(this.end))) {
        node = this.startNode();
        this.next();
        return this.parseExprAtom(refDestructuringErrors);
      }

      var startPos = this.start,
          startLoc = this.startLoc;
      var id = this.parseIdent(this.type !== _tokentype.types.name);
      if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id]);
      return id;

    case _tokentype.types.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = { pattern: value.pattern, flags: value.flags };
      return node;

    case _tokentype.types.num:case _tokentype.types.string:
      return this.parseLiteral(this.value);

    case _tokentype.types._null:case _tokentype.types._true:case _tokentype.types._false:
      node = this.startNode();
      node.value = this.type === _tokentype.types._null ? null : this.type === _tokentype.types._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal");

    case _tokentype.types.parenL:
      return this.parseParenAndDistinguishExpression(canBeArrow);

    case _tokentype.types.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(_tokentype.types.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression");

    case _tokentype.types.braceL:
      return this.parseObj(false, refDestructuringErrors);

    case _tokentype.types._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, false);

    case _tokentype.types._class:
      return this.parseClass(this.startNode(), false);

    case _tokentype.types._new:
      return this.parseNew();

    case _tokentype.types.backQuote:
      return this.parseTemplate();

    case _tokentype.types._do:
      this.next();
      return this.parseStatement();
    case _tokentype.types.at:
      this.next();
      return this.parseExprAtom();
    case _tokentype.types.colon:
      if (this.input[this.end] == ":") {
         this.next();
         this.next();
         return this.parseExprSubscripts(refDestructuringErrors);
      }

    default:
      this.unexpected();
  }
};

pp.parseLiteral = function (value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  this.next();
  return this.finishNode(node, "Literal");
};

pp.parseParenExpression = function () {
  this.expect(_tokentype.types.parenL);
  var val = this.parseExpression();
  this.expect(_tokentype.types.parenR);
  return val;
};

pp.parseParenAndDistinguishExpression = function (canBeArrow) {
  var startPos = this.start,
      startLoc = this.startLoc,
      val = undefined;
  if (this.options.ecmaVersion >= 6) {
    this.next();

    var innerStartPos = this.start,
        innerStartLoc = this.startLoc;
    var exprList = [],
        first = true;
    var refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 },
        spreadStart = undefined,
        innerParenStart = undefined;
    while (this.type !== _tokentype.types.parenR) {
      first ? first = false : this.expect(_tokentype.types.comma);
      if (this.type === _tokentype.types.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRest()));
        break;
      } else {
        if (this.type === _tokentype.types.parenL && !innerParenStart) {
          innerParenStart = this.start;
        }
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.start,
        innerEndLoc = this.startLoc;
    this.expect(_tokentype.types.parenR);

    if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, true);
      if (innerParenStart) this.unexpected(innerParenStart);
      return this.parseParenArrowList(startPos, startLoc, exprList);
    }

    if (!exprList.length) this.unexpected(this.lastTokStart);
    if (spreadStart) this.unexpected(spreadStart);
    this.checkExpressionErrors(refDestructuringErrors, true);

    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val;
  }
};

pp.parseParenItem = function (item) {
  return item;
};

pp.parseParenArrowList = function (startPos, startLoc, exprList) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
};

var empty = [];

pp.parseNew = function () {
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(_tokentype.types.dot)) {
    node.meta = meta;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target") this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target");
    if (!this.inFunction) this.raiseRecoverable(node.start, "new.target can only be used in functions");
    return this.finishNode(node, "MetaProperty");
  }
  var startPos = this.start,
      startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  if (this.eat(_tokentype.types.parenL)) node.arguments = this.parseExprList(_tokentype.types.parenR, false);else node.arguments = empty;
  return this.finishNode(node, "NewExpression");
};

pp.parseTemplateElement = function () {
  var elem = this.startNode();
  elem.value = {
    raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
    cooked: this.value
  };
  this.next();
  elem.tail = this.type === _tokentype.types.backQuote;
  return this.finishNode(elem, "TemplateElement");
};

pp.parseTemplate = function () {
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement();
  node.quasis = [curElt];
  while (!curElt.tail) {
    this.expect(_tokentype.types.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(_tokentype.types.braceR);
    node.quasis.push(curElt = this.parseTemplateElement());
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral");
};

pp.parseObj = function (isPattern, refDestructuringErrors) {
  var node = this.startNode(),
      first = true,
      propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(_tokentype.types.braceR)) {
    if (!first) {
      this.expect(_tokentype.types.comma);
      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
    } else first = false;
    if (this.value == "async" && /^[ \t]*\w+/.test(this.input.slice(this.end))) this.next();

    var prop = this.startNode(),
        isGenerator = undefined,
        startPos = undefined,
        startLoc = undefined;
    if (this.options.ecmaVersion >= 6) {
      prop.method = false;
      prop.shorthand = false;
      if (isPattern || refDestructuringErrors) {
        startPos = this.start;
        startLoc = this.startLoc;
      }
      if (!isPattern) isGenerator = this.eat(_tokentype.types.star);
    }

    this.parsePropertyName(prop);
    this.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors);
    this.checkPropClash(prop, propHash);
    node.properties.push(this.finishNode(prop, "Property"));
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};

pp.parsePropertyValue = function (prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors) {
  if (this.eat(_tokentype.types.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === _tokentype.types.parenL) {
    if (isPattern) this.unexpected();
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator);
  } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type != _tokentype.types.comma && this.type != _tokentype.types.braceR)) {
    if (isGenerator || isPattern) this.unexpected();
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === "get" ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;
      if (prop.kind === "get") this.raiseRecoverable(start, "getter should have no params");else this.raiseRecoverable(start, "setter should have exactly one param");
    }
    if (prop.kind === "set" && prop.value.params[0].type === "RestElement") this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    prop.kind = "init";
    if (isPattern) {
      if (this.keywords.test(prop.key.name) || (this.strict ? this.reservedWordsStrictBind : this.reservedWords).test(prop.key.name) || this.inGenerator && prop.key.name == "yield") this.raiseRecoverable(prop.key.start, "Binding " + prop.key.name);
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else if (this.type === _tokentype.types.eq && refDestructuringErrors) {
      if (!refDestructuringErrors.shorthandAssign) refDestructuringErrors.shorthandAssign = this.start;
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else {
      prop.value = prop.key;
    }
    prop.shorthand = true;
  } else this.unexpected();
};

pp.parsePropertyName = function (prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(_tokentype.types.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(_tokentype.types.bracketR);
      return prop.key;
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === _tokentype.types.num || this.type === _tokentype.types.string ? this.parseExprAtom() : this.parseIdent(true);
};

pp.initFunction = function (node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) {
    node.generator = false;
    node.expression = false;
  }
};

pp.parseMethod = function (isGenerator) {
  var node = this.startNode(),
      oldInGen = this.inGenerator;
  this.inGenerator = isGenerator;
  this.initFunction(node);
  this.expect(_tokentype.types.parenL);
  node.params = this.parseBindingList(_tokentype.types.parenR, false, false);
  if (this.options.ecmaVersion >= 6) node.generator = isGenerator;
  this.parseFunctionBody(node, false);
  this.inGenerator = oldInGen;
  return this.finishNode(node, "FunctionExpression");
};

pp.parseArrowExpression = function (node, params) {
  var oldInGen = this.inGenerator;
  this.inGenerator = false;
  this.initFunction(node);
  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true);
  this.inGenerator = oldInGen;
  return this.finishNode(node, "ArrowFunctionExpression");
};

pp.parseFunctionBody = function (node, isArrowFunction) {
  var isExpression = isArrowFunction && this.type !== _tokentype.types.braceL;

  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
  } else {
    var oldInFunc = this.inFunction,
        oldLabels = this.labels;
    this.inFunction = true;this.labels = [];
    node.body = this.parseBlock(true);
    node.expression = false;
    this.inFunction = oldInFunc;this.labels = oldLabels;
  }

  if (this.strict || !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) {
    var oldStrict = this.strict;
    this.strict = true;
    if (node.id) this.checkLVal(node.id, true);
    this.checkParams(node);
    this.strict = oldStrict;
  } else if (isArrowFunction) {
    this.checkParams(node);
  }
};

pp.checkParams = function (node) {
  var nameHash = {};
  for (var i = 0; i < node.params.length; i++) {
    this.checkLVal(node.params[i], true, nameHash);
  }
};

pp.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [],
      first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(_tokentype.types.comma);
      if (this.type === close && refDestructuringErrors && !refDestructuringErrors.trailingComma) {
        refDestructuringErrors.trailingComma = this.lastTokStart;
      }
      if (allowTrailingComma && this.afterTrailingComma(close)) break;
    } else first = false;

    var elt = undefined;
    if (allowEmpty && this.type === _tokentype.types.comma) elt = null;else if (this.type === _tokentype.types.ellipsis) elt = this.parseSpread(refDestructuringErrors);else elt = this.parseMaybeAssign(false, refDestructuringErrors);
    elts.push(elt);
  }
  return elts;
};

pp.parseIdent = function (liberal) {
  var node = this.startNode();
  if (liberal && this.options.allowReserved == "never") liberal = false;
  if (this.type === _tokentype.types.name) {
    if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) && (this.options.ecmaVersion >= 6 || this.input.slice(this.start, this.end).indexOf("\\") == -1)) this.raiseRecoverable(this.start, "The keyword '" + this.value + "' is reserved");
    if (!liberal && this.inGenerator && this.value === "yield") this.raiseRecoverable(this.start, "Can not use 'yield' as identifier inside a generator");
    node.name = this.value;
  } else if (liberal && this.type.keyword) {
    node.name = this.type.keyword;
  } else {
    this.unexpected();
  }
  this.next();
  return this.finishNode(node, "Identifier");
};

pp.parseYield = function () {
  var node = this.startNode();
  this.next();
  if (this.type == _tokentype.types.semi || this.canInsertSemicolon() || this.type != _tokentype.types.star && !this.type.startsExpr) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(_tokentype.types.star);
    node.argument = this.parseMaybeAssign();
  }
  return this.finishNode(node, "YieldExpression");
};

},{"./state":"/src\\state.js","./tokentype":"/src\\tokentype.js"}],"/src\\identifier.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.isIdentifierStart = isIdentifierStart;
exports.isIdentifierChar = isIdentifierChar;
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  7: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};

exports.reservedWords = reservedWords;
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

var keywords = {
  5: ecma5AndLessKeywords,
  6: ecma5AndLessKeywords + " const class extends export import super"
};

exports.keywords = keywords;
function isIdentifierStart(code, astral) {
  if (code < 65) return code === 36;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  return code >= 0xaa;
}

function isIdentifierChar(code, astral) {
  if (code < 48) return code === 36;
  if (code < 58) return true;
  if (code < 65) return false;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  return code >= 0xaa;
}

},{}],"/src\\index.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.parse = parse;
exports.parseExpressionAt = parseExpressionAt;
exports.tokenizer = tokenizer;

var _state = _dereq_("./state");

_dereq_("./parseutil");

_dereq_("./statement");

_dereq_("./lval");

_dereq_("./expression");

_dereq_("./location");

exports.Parser = _state.Parser;
exports.plugins = _state.plugins;

var _options = _dereq_("./options");

exports.defaultOptions = _options.defaultOptions;

var _locutil = _dereq_("./locutil");

exports.Position = _locutil.Position;
exports.SourceLocation = _locutil.SourceLocation;
exports.getLineInfo = _locutil.getLineInfo;

var _node = _dereq_("./node");

exports.Node = _node.Node;

var _tokentype = _dereq_("./tokentype");

exports.TokenType = _tokentype.TokenType;
exports.tokTypes = _tokentype.types;

var _tokencontext = _dereq_("./tokencontext");

exports.TokContext = _tokencontext.TokContext;
exports.tokContexts = _tokencontext.types;

var _identifier = _dereq_("./identifier");

exports.isIdentifierChar = _identifier.isIdentifierChar;
exports.isIdentifierStart = _identifier.isIdentifierStart;

var _tokenize = _dereq_("./tokenize");

exports.Token = _tokenize.Token;

var _whitespace = _dereq_("./whitespace");

exports.isNewLine = _whitespace.isNewLine;
exports.lineBreak = _whitespace.lineBreak;
exports.lineBreakG = _whitespace.lineBreakG;
var version = "3.0.2";

exports.version = version;
function parse(input, options) {
  return new _state.Parser(options, input).parse();
}

function parseExpressionAt(input, pos, options) {
  var p = new _state.Parser(options, input, pos);
  p.nextToken();
  return p.parseExpression();
}

function tokenizer(input, options) {
  return new _state.Parser(options, input);
}

},{"./expression":"/src\\expression.js","./identifier":"/src\\identifier.js","./location":"/src\\location.js","./locutil":"/src\\locutil.js","./lval":"/src\\lval.js","./node":"/src\\node.js","./options":"/src\\options.js","./parseutil":"/src\\parseutil.js","./state":"/src\\state.js","./statement":"/src\\statement.js","./tokencontext":"/src\\tokencontext.js","./tokenize":"/src\\tokenize.js","./tokentype":"/src\\tokentype.js","./whitespace":"/src\\whitespace.js"}],"/src\\location.js":[function(_dereq_,module,exports){
"use strict";

var _state = _dereq_("./state");

var _locutil = _dereq_("./locutil");

var pp = _state.Parser.prototype;

pp.raise = function (pos, message) {
  var loc = _locutil.getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos;err.loc = loc;err.raisedAt = this.pos;
  throw err;
};

pp.raiseRecoverable = pp.raise;

pp.curPosition = function () {
  if (this.options.locations) {
    return new _locutil.Position(this.curLine, this.pos - this.lineStart);
  }
};

},{"./locutil":"/src\\locutil.js","./state":"/src\\state.js"}],"/src\\locutil.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.getLineInfo = getLineInfo;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _whitespace = _dereq_("./whitespace");

var Position = (function () {
  function Position(line, col) {


    this.line = line;
    this.column = col;
  }

  Position.prototype.offset = function offset(n) {
    return new Position(this.line, this.column + n);
  };

  return Position;
})();

exports.Position = Position;

var SourceLocation = function SourceLocation(p, start, end) {


  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) this.source = p.sourceFile;
};

exports.SourceLocation = SourceLocation;

function getLineInfo(input, offset) {
  for (var line = 0, cur = 0;;) {
    _whitespace.lineBreakG.lastIndex = cur;
    var match = _whitespace.lineBreakG.exec(input);
    if (match && match.index < offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset - cur);
    }
  }
}

},{"./whitespace":"/src\\whitespace.js"}],"/src\\lval.js":[function(_dereq_,module,exports){
"use strict";

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var _util = _dereq_("./util");

var pp = _state.Parser.prototype;

pp.toAssignable = function (node, isBinding) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
        break;

      case "ObjectExpression":
        node.type = "ObjectPattern";
        for (var i = 0; i < node.properties.length; i++) {
          var prop = node.properties[i];
          if (prop.kind !== "init") this.raise(prop.key.start, "Object pattern can't contain getter or setter");
          this.toAssignable(prop.value, isBinding);
        }
        break;

      case "ArrayExpression":
        node.type = "ArrayPattern";
        this.toAssignableList(node.elements, isBinding);
        break;

      case "AssignmentExpression":
        if (node.operator === "=") {
          node.type = "AssignmentPattern";
          delete node.operator
          ;
        } else {
          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
          break;
        }

      case "AssignmentPattern":
        if (node.right.type === "YieldExpression") this.raise(node.right.start, "Yield expression cannot be a default value");
        break;

      case "ParenthesizedExpression":
        node.expression = this.toAssignable(node.expression, isBinding);
        break;

      case "MemberExpression":
        if (!isBinding) break;

      default:
        this.raise(node.start, "Assigning to rvalue");
    }
  }
  return node;
};

pp.toAssignableList = function (exprList, isBinding) {
  var end = exprList.length;
  if (end) {
    var last = exprList[end - 1];
    if (last && last.type == "RestElement") {
      --end;
    } else if (last && last.type == "SpreadElement") {
      last.type = "RestElement";
      var arg = last.argument;
      this.toAssignable(arg, isBinding);
      if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern") this.unexpected(arg.start);
      --end;
    }

    if (isBinding && last.type === "RestElement" && last.argument.type !== "Identifier") this.unexpected(last.argument.start);
  }
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) this.toAssignable(elt, isBinding);
  }
  return exprList;
};

pp.parseSpread = function (refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(refDestructuringErrors);
  return this.finishNode(node, "SpreadElement");
};

pp.parseRest = function (allowNonIdent) {
  var node = this.startNode();
  this.next();

  if (allowNonIdent) node.argument = this.type === _tokentype.types.name ? this.parseIdent() : this.unexpected();else node.argument = this.type === _tokentype.types.name || this.type === _tokentype.types.bracketL ? this.parseBindingAtom() : this.unexpected();

  return this.finishNode(node, "RestElement");
};

pp.parseBindingAtom = function () {
  if (this.options.ecmaVersion < 6) return this.parseIdent();
  switch (this.type) {
    case _tokentype.types.name:
      return this.parseIdent();

    case _tokentype.types.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(_tokentype.types.bracketR, true, true);
      return this.finishNode(node, "ArrayPattern");

    case _tokentype.types.braceL:
      return this.parseObj(true);

    default:
      this.unexpected();
  }
};

pp.parseBindingList = function (close, allowEmpty, allowTrailingComma, allowNonIdent) {
  var elts = [],
      first = true;
  while (!this.eat(close)) {
    if (first) first = false;else this.expect(_tokentype.types.comma);
    if (allowEmpty && this.type === _tokentype.types.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break;
    } else if (this.type === _tokentype.types.ellipsis) {
      var rest = this.parseRest(allowNonIdent);
      this.parseBindingListItem(rest);
      elts.push(rest);
      this.expect(close);
      break;
    } else {
      var elem = this.parseMaybeDefault(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts;
};

pp.parseBindingListItem = function (param) {
  return param;
};

pp.parseMaybeDefault = function (startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(_tokentype.types.eq)) return left;
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
};

pp.checkLVal = function (expr, isBinding, checkClashes) {
  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) this.raiseRecoverable(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      if (checkClashes) {
        if (_util.has(checkClashes, expr.name)) this.raiseRecoverable(expr.start, "Argument name clash");
        checkClashes[expr.name] = true;
      }
      break;

    case "MemberExpression":
      if (isBinding) this.raiseRecoverable(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression");
      break;

    case "ObjectPattern":
      for (var i = 0; i < expr.properties.length; i++) {
        this.checkLVal(expr.properties[i].value, isBinding, checkClashes);
      }break;

    case "ArrayPattern":
      for (var i = 0; i < expr.elements.length; i++) {
        var elem = expr.elements[i];
        if (elem) this.checkLVal(elem, isBinding, checkClashes);
      }
      break;

    case "AssignmentPattern":
      this.checkLVal(expr.left, isBinding, checkClashes);
      break;

    case "RestElement":
      this.checkLVal(expr.argument, isBinding, checkClashes);
      break;

    case "ParenthesizedExpression":
      this.checkLVal(expr.expression, isBinding, checkClashes);
      break;

    default:
      this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " rvalue");
  }
};

},{"./state":"/src\\state.js","./tokentype":"/src\\tokentype.js","./util":"/src\\util.js"}],"/src\\node.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _state = _dereq_("./state");

var _locutil = _dereq_("./locutil");

var Node = function Node(parser, pos, loc) {


  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations) this.loc = new _locutil.SourceLocation(parser, loc);
  if (parser.options.directSourceFile) this.sourceFile = parser.options.directSourceFile;
  if (parser.options.ranges) this.range = [pos, 0];
};

exports.Node = Node;

var pp = _state.Parser.prototype;

pp.startNode = function () {
  return new Node(this, this.start, this.startLoc);
};

pp.startNodeAt = function (pos, loc) {
  return new Node(this, pos, loc);
};

function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations) node.loc.end = loc;
  if (this.options.ranges) node.range[1] = pos;
  return node;
}

pp.finishNode = function (node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
};

pp.finishNodeAt = function (node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc);
};

},{"./locutil":"/src\\locutil.js","./state":"/src\\state.js"}],"/src\\options.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.getOptions = getOptions;

var _util = _dereq_("./util");

var _locutil = _dereq_("./locutil");

var defaultOptions = {
  ecmaVersion: 6,
  sourceType: "script",
  onInsertedSemicolon: null,
  onTrailingComma: null,
  allowReserved: null,
  allowReturnOutsideFunction: false,
  allowImportExportEverywhere: false,
  allowHashBang: false,
  locations: true,
  onToken: null,
  onComment: null,
  ranges: false,
  program: null,
  sourceFile: null,
  directSourceFile: null,
  preserveParens: false,
  plugins: {}
};

exports.defaultOptions = defaultOptions;
function getOptions(opts) {
  var options = {};
  for (var opt in defaultOptions) {
    options[opt] = opts && _util.has(opts, opt) ? opts[opt] : defaultOptions[opt];
  }if (options.allowReserved == null) options.allowReserved = options.ecmaVersion < 5;

  if (_util.isArray(options.onToken)) {
    (function () {
      var tokens = options.onToken;
      options.onToken = function (token) {
        return tokens.push(token);
      };
    })();
  }
  if (_util.isArray(options.onComment)) options.onComment = pushComment(options, options.onComment);

  return options;
}

function pushComment(options, array) {
  return function (block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start: start,
      end: end
    };
    if (options.locations) comment.loc = new _locutil.SourceLocation(this, startLoc, endLoc);
    if (options.ranges) comment.range = [start, end];
    array.push(comment);
  };
}

},{"./locutil":"/src\\locutil.js","./util":"/src\\util.js"}],"/src\\parseutil.js":[function(_dereq_,module,exports){
"use strict";

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var _whitespace = _dereq_("./whitespace");

var pp = _state.Parser.prototype;

pp.isUseStrict = function (stmt) {
  return this.options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && stmt.expression.raw.slice(1, -1) === "use strict";
};

pp.eat = function (type) {
  if (this.type === type) {
    this.next();
    return true;
  } else {
    return false;
  }
};

pp.isContextual = function (name) {
  return this.type === _tokentype.types.name && this.value === name;
};

pp.eatContextual = function (name) {
  return this.value === name && this.eat(_tokentype.types.name);
};

pp.expectContextual = function (name) {
  if (!this.eatContextual(name)) this.unexpected();
};

pp.canInsertSemicolon = function () {
  return this.type === _tokentype.types.eof || this.type === _tokentype.types.braceR || _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};

pp.insertSemicolon = function () {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    return true;
  }
};

pp.semicolon = function () {
  if (!this.eat(_tokentype.types.semi) && !this.insertSemicolon()) this.unexpected();
};

pp.afterTrailingComma = function (tokType) {
  if (this.type == tokType) {
    if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    this.next();
    return true;
  }
};

pp.expect = function (type) {
  this.eat(type) || this.unexpected();
};

pp.unexpected = function (pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

pp.checkPatternErrors = function (refDestructuringErrors, andThrow) {
  var pos = refDestructuringErrors && refDestructuringErrors.trailingComma;
  if (!andThrow) return !!pos;
  if (pos) this.raise(pos, "Trailing comma is not permitted in destructuring patterns");
};

pp.checkExpressionErrors = function (refDestructuringErrors, andThrow) {
  var pos = refDestructuringErrors && refDestructuringErrors.shorthandAssign;
  if (!andThrow) return !!pos;
  if (pos) this.raise(pos, "Shorthand property assignments are valid only in destructuring patterns");
};

},{"./state":"/src\\state.js","./tokentype":"/src\\tokentype.js","./whitespace":"/src\\whitespace.js"}],"/src\\state.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _identifier = _dereq_("./identifier");

var _tokentype = _dereq_("./tokentype");

var _whitespace = _dereq_("./whitespace");

var _options = _dereq_("./options");

var plugins = {};

exports.plugins = plugins;
function keywordRegexp(words) {
  return new RegExp("^(" + words.replace(/ /g, "|") + ")$");
}

var Parser = (function () {
  function Parser(options, input, startPos) {


    this.options = options = _options.getOptions(options);
    this.sourceFile = options.sourceFile;
    this.keywords = keywordRegexp(_identifier.keywords[options.ecmaVersion >= 6 ? 6 : 5]);
    var reserved = options.allowReserved ? "" : _identifier.reservedWords[options.ecmaVersion] + (options.sourceType == "module" ? " await" : "");
    this.reservedWords = keywordRegexp(reserved);
    var reservedStrict = (reserved ? reserved + " " : "") + _identifier.reservedWords.strict;
    this.reservedWordsStrict = keywordRegexp(reservedStrict);
    this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + _identifier.reservedWords.strictBind);
    this.input = String(input);

    this.containsEsc = false;

    this.loadPlugins(options.plugins);

    if (startPos) {
      this.pos = startPos;
      this.lineStart = Math.max(0, this.input.lastIndexOf("\n", startPos));
      this.curLine = this.input.slice(0, this.lineStart).split(_whitespace.lineBreak).length;
    } else {
      this.pos = this.lineStart = 0;
      this.curLine = 0;
    }

    this.type = _tokentype.types.eof;
    this.value = null;
    this.start = this.end = this.pos;
    this.startLoc = this.endLoc = this.curPosition();

    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;

    this.context = this.initialContext();
    this.exprAllowed = true;

    this.strict = this.inModule = options.sourceType === "module";

    this.potentialArrowAt = -1;

    this.inFunction = this.inGenerator = false;
    this.labels = [];

    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") this.skipLineComment(2);
  }

  Parser.prototype.isKeyword = function isKeyword(word) {
    return this.keywords.test(word);
  };

  Parser.prototype.isReservedWord = function isReservedWord(word) {
    return this.reservedWords.test(word);
  };

  Parser.prototype.extend = function extend(name, f) {
    this[name] = f(this[name]);
  };

  Parser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {
    for (var _name in pluginConfigs) {
      var plugin = plugins[_name];
      if (!plugin) throw new Error("Plugin '" + _name + "' not found");
      plugin(this, pluginConfigs[_name]);
    }
  };

  Parser.prototype.parse = function parse() {
    var node = this.options.program || this.startNode();
    this.nextToken();
    return this.parseTopLevel(node);
  };

  return Parser;
})();

exports.Parser = Parser;

},{"./identifier":"/src\\identifier.js","./options":"/src\\options.js","./tokentype":"/src\\tokentype.js","./whitespace":"/src\\whitespace.js"}],"/src\\statement.js":[function(_dereq_,module,exports){
"use strict";

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var _whitespace = _dereq_("./whitespace");

var _identifier = _dereq_("./identifier");

var pp = _state.Parser.prototype;

pp.parseTopLevel = function (node) {
  var first = true;
  if (!node.body) node.body = [];
  while (this.type !== _tokentype.types.eof) {
    var stmt = this.parseStatement(true, true);
    node.body.push(stmt);
    if (first) {
      if (this.isUseStrict(stmt)) this.setStrict(true);
      first = false;
    }
  }
  this.next();
  if (this.options.ecmaVersion >= 6) {
    node.sourceType = this.options.sourceType;
  }
  return this.finishNode(node, "Program");
};

var loopLabel = { kind: "loop" },
    switchLabel = { kind: "switch" };

pp.isLet = function () {
  if (this.type !== _tokentype.types.name || this.options.ecmaVersion < 6 || this.value != "let") return false;
  _whitespace.skipWhiteSpace.lastIndex = this.pos;
  var skip = _whitespace.skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length,
      nextCh = this.input.charCodeAt(next);
  if (nextCh === 91 || nextCh == 123) return true; // '{' and '['
  if (_identifier.isIdentifierStart(nextCh, true)) {
    for (var pos = next + 1; _identifier.isIdentifierChar(this.input.charCodeAt(pos, true)); ++pos) {}
    var ident = this.input.slice(next, pos);
    if (!this.isKeyword(ident)) return true;
  }
  return false;
};

pp.parseStatement = function (declaration, topLevel) {
  var starttype = this.type,
      node = this.startNode(),
      kind = undefined;

  if (this.isLet()) {
    starttype = _tokentype.types._var;
    kind = "let";
  }

  switch (starttype) {
    case _tokentype.types._break:case _tokentype.types._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);
    case _tokentype.types._debugger:
      return this.parseDebuggerStatement(node);
    case _tokentype.types._do:
      return this.parseDoStatement(node);
    case _tokentype.types._for:
      return this.parseForStatement(node);
    case _tokentype.types._function:
      if (!declaration && this.options.ecmaVersion >= 6) this.unexpected();
      return this.parseFunctionStatement(node);
    case _tokentype.types._class:
      if (!declaration) this.unexpected();
      return this.parseClass(node, true);
    case _tokentype.types._if:
      return this.parseIfStatement(node);
    case _tokentype.types._return:
      return this.parseReturnStatement(node);
    case _tokentype.types._switch:
      return this.parseSwitchStatement(node);
    case _tokentype.types._throw:
      return this.parseThrowStatement(node);
    case _tokentype.types._try:
      return this.parseTryStatement(node);
    case _tokentype.types._const:case _tokentype.types._var:
      kind = kind || this.value;
      if (!declaration && kind != "var") this.unexpected();
      return this.parseVarStatement(node, kind);
    case _tokentype.types._while:
      return this.parseWhileStatement(node);
    case _tokentype.types._with:
      return this.parseWithStatement(node);
    case _tokentype.types.braceL:
      return this.parseBlock();
    case _tokentype.types.semi:
      return this.parseEmptyStatement(node);
    case _tokentype.types._export:
    case _tokentype.types._import:
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) this.raise(this.start, "'import' and 'export' may only appear at the top level");
        // if (!this.inModule) this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
      }
      return starttype === _tokentype.types._import ? this.parseImport(node) : this.parseExport(node);

    case _tokentype.types.at:
      this.next();
      return this.parseExpression();
    default:
      var maybeName = this.value,
          expr = this.parseExpression();
      if (starttype === _tokentype.types.name && expr.type === "Identifier" && this.eat(_tokentype.types.colon)) {
        return this.parseLabeledStatement(node, maybeName, expr);
      }
      else {
        return this.parseExpressionStatement(node, expr);
      }
  }
};

pp.parseBreakContinueStatement = function (node, keyword) {
  var isBreak = keyword == "break";
  this.next();
  if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.label = null;else if (this.type !== _tokentype.types.name) this.unexpected();else {
    node.label = this.parseIdent();
    this.semicolon();
  }

  for (var i = 0; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
      if (node.label && isBreak) break;
    }
  }
  if (i === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};

pp.parseDebuggerStatement = function (node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};

pp.parseDoStatement = function (node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  this.expect(_tokentype.types._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) this.eat(_tokentype.types.semi);else this.semicolon();
  return this.finishNode(node, "DoWhileStatement");
};

pp.parseForStatement = function (node) {
  this.next();
  this.labels.push(loopLabel);
  this.expect(_tokentype.types.parenL);
  if (this.type === _tokentype.types.semi) return this.parseFor(node, null);
  var isLet = this.isLet();
  if (this.type === _tokentype.types._var || this.type === _tokentype.types._const || isLet) {
    var _init = this.startNode(),
        kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(_init, true, kind);
    this.finishNode(_init, "VariableDeclaration");
    if ((this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && _init.declarations.length === 1 && !(kind !== "var" && _init.declarations[0].init)) return this.parseForIn(node, _init);
    return this.parseFor(node, _init);
  }
  var refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 };
  var init = this.parseExpression(true, refDestructuringErrors);
  if (this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
    this.checkPatternErrors(refDestructuringErrors, true);
    this.toAssignable(init);
    this.checkLVal(init);
    return this.parseForIn(node, init);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  return this.parseFor(node, init);
};

pp.parseFunctionStatement = function (node) {
  this.next();
  return this.parseFunction(node, true);
};

pp.parseIfStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  node.consequent = this.parseStatement(false);
  node.alternate = this.eat(_tokentype.types._else) ? this.parseStatement(false) : null;
  return this.finishNode(node, "IfStatement");
};

pp.parseReturnStatement = function (node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, "'return' outside of function");
  this.next();

  if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.argument = null;else {
    node.argument = this.parseExpression();this.semicolon();
  }
  return this.finishNode(node, "ReturnStatement");
};

pp.parseSwitchStatement = function (node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(_tokentype.types.braceL);
  this.labels.push(switchLabel);

  for (var cur, sawDefault = false; this.type != _tokentype.types.braceR;) {
    if (this.type === _tokentype.types._case || this.type === _tokentype.types._default) {
      var isCase = this.type === _tokentype.types._case;
      if (cur) this.finishNode(cur, "SwitchCase");
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
        sawDefault = true;
        cur.test = null;
      }
      this.expect(_tokentype.types.colon);
    } else {
      if (!cur) this.unexpected();
      cur.consequent.push(this.parseStatement(true));
    }
  }
  if (cur) this.finishNode(cur, "SwitchCase");
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};

pp.parseThrowStatement = function (node) {
  this.next();
  if (_whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, "Illegal newline after throw");
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
};

var empty = [];

pp.parseTryStatement = function (node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === _tokentype.types._catch) {
    var clause = this.startNode();
    this.next();
    this.expect(_tokentype.types.parenL);
    clause.param = this.parseBindingAtom();
    this.checkLVal(clause.param, true);
    this.expect(_tokentype.types.parenR);
    clause.body = this.parseBlock();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(_tokentype.types._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer) this.raise(node.start, "Missing catch or finally clause");
  return this.finishNode(node, "TryStatement");
};

pp.parseVarStatement = function (node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};

pp.parseWhileStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "WhileStatement");
};

pp.parseWithStatement = function (node) {
  if (this.strict) this.raise(this.start, "'with' in strict mode");
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement(false);
  return this.finishNode(node, "WithStatement");
};

pp.parseEmptyStatement = function (node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};

pp.parseLabeledStatement = function (node, maybeName, expr) {
  for (var i = 0; i < this.labels.length; ++i) {
    if (this.labels[i].name === maybeName) this.raise(expr.start, "Label '" + maybeName + "' is already declared");
  }var kind = this.type.isLoop ? "loop" : this.type === _tokentype.types._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label = this.labels[i];
    if (label.statementStart == node.start) {
      label.statementStart = this.start;
      label.kind = kind;
    } else break;
  }
  this.labels.push({ name: maybeName, kind: kind, statementStart: this.start });
  node.body = this.parseStatement(true);
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};

pp.parseExpressionStatement = function (node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
};

pp.parseBlock = function (allowStrict) {
  var node = this.startNode(),
      first = true,
      oldStrict = undefined;
  node.body = [];
  this.expect(_tokentype.types.braceL);
  while (!this.eat(_tokentype.types.braceR)) {
    var stmt = this.parseStatement(true);
    node.body.push(stmt);
    if (first && allowStrict && this.isUseStrict(stmt)) {
      oldStrict = this.strict;
      this.setStrict(this.strict = true);
    }
    first = false;
  }
  if (oldStrict === false) this.setStrict(false);
  return this.finishNode(node, "BlockStatement");
};

pp.parseFor = function (node, init) {
  node.init = init;
  this.expect(_tokentype.types.semi);
  node.test = this.type === _tokentype.types.semi ? null : this.parseExpression();
  this.expect(_tokentype.types.semi);
  node.update = this.type === _tokentype.types.parenR ? null : this.parseExpression();
  this.expect(_tokentype.types.parenR);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "ForStatement");
};

pp.parseForIn = function (node, init) {
  var type = this.type === _tokentype.types._in ? "ForInStatement" : "ForOfStatement";
  this.next();
  node.left = init;
  node.right = this.parseExpression();
  this.expect(_tokentype.types.parenR);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, type);
};

pp.parseVar = function (node, isFor, kind) {
  node.declarations = [];
  node.kind = kind;
  for (;;) {
    var decl = this.startNode();
    this.parseVarId(decl);
    if (this.eat(_tokentype.types.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === "const" && !(this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (decl.id.type != "Identifier" && !(isFor && (this.type === _tokentype.types._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(_tokentype.types.comma)) break;
  }
  return node;
};

pp.parseVarId = function (decl) {
  decl.id = this.parseBindingAtom();
  this.checkLVal(decl.id, true);
};

pp.parseFunction = function (node, isStatement, allowExpressionBody) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 6) node.generator = this.eat(_tokentype.types.star);
  var oldInGen = this.inGenerator;
  this.inGenerator = node.generator;
  if (isStatement || this.type === _tokentype.types.name) node.id = this.parseIdent();
  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody);
  this.inGenerator = oldInGen;
  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
};

pp.parseFunctionParams = function (node) {
  this.expect(_tokentype.types.parenL);
  node.params = this.parseBindingList(_tokentype.types.parenR, false, false, true);
};

pp.parseClass = function (node, isStatement) {
  this.next();
  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(_tokentype.types.braceL);
  var decorators = [];
  while (!this.eat(_tokentype.types.braceR)) {
    if (this.eat(_tokentype.types.semi)) continue;
    if (this.type == _tokentype.types.at) {
      this.next();
      var expr = this.parseMaybeAssign(true);
      decorators.push(expr);
      continue;
    }
    if (this.value == "async" && /^[ \t]*\w+/.test(this.input.slice(this.end))) this.next();
    var method = this.startNode();
    var isGenerator = this.eat(_tokentype.types.star);
    var isMaybeStatic = this.type === _tokentype.types.name && this.value === "static";
    this.parsePropertyName(method);
    method["static"] = isMaybeStatic && this.type !== _tokentype.types.parenL;
    if (method["static"]) {
      if (isGenerator) this.unexpected();
      isGenerator = this.eat(_tokentype.types.star);
      this.parsePropertyName(method);
    }
    method.kind = "method";
    var isGetSet = false;
    if (!method.computed) {
      var key = method.key;

      if (!isGenerator && key.type === "Identifier" && this.type !== _tokentype.types.parenL && (key.name === "get" || key.name === "set")) {
        isGetSet = true;
        method.kind = key.name;
        key = this.parsePropertyName(method);
      }
      if (!method["static"] && (key.type === "Identifier" && key.name === "constructor" || key.type === "Literal" && key.value === "constructor")) {
        if (hadConstructor) this.raise(key.start, "Duplicate constructor in the same class");
        if (isGetSet) this.raise(key.start, "Constructor can't have get/set modifier");
        if (isGenerator) this.raise(key.start, "Constructor can't be a generator");
        method.kind = "constructor";
        hadConstructor = true;
      }
    }

    if (this.type == _tokentype.types.eq) {
      this.next();
      method.value = this.parseExpression();
    } else if (this.type == _tokentype.types.semi || this.canInsertSemicolon()) {
      if (this.type == _tokentype.types.semi) this.next();
      var _node = this.startNode();
      _node.body = [];
      method.value = this.finishNode(_node, "BlockStatement");
    }
    if (method.value) {
      method.kind = 'class'
      classBody.body.push(this.finishNode(method, "Property"));
      continue;
    }

    this.parseClassMethod(classBody, method, isGenerator);

    if (decorators.length) {
      var body = method.value.body.body;
      if (body) body.unshift.apply(body, decorators);
      decorators = [];
    }
    if (isGetSet) {
      var paramCount = method.kind === "get" ? 0 : 1;
      if (method.value.params.length !== paramCount) {
        var start = method.value.start;
        if (method.kind === "get") this.raiseRecoverable(start, "getter should have no params");else this.raiseRecoverable(start, "setter should have exactly one param");
      }
      if (method.kind === "set" && method.value.params[0].type === "RestElement") this.raise(method.value.params[0].start, "Setter cannot use rest params");
    }
  }
  node.body = this.finishNode(classBody, "ClassBody");
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};

pp.parseClassMethod = function (classBody, method, isGenerator) {
  method.value = this.parseMethod(isGenerator);
  classBody.body.push(this.finishNode(method, "MethodDefinition"));
};

pp.parseClassId = function (node, isStatement) {
  node.id = this.type === _tokentype.types.name ? this.parseIdent() : isStatement ? this.unexpected() : null;
};

pp.parseClassSuper = function (node) {
  node.superClass = this.eat(_tokentype.types._extends) ? this.parseExprSubscripts() : null;
};

pp.parseExport = function (node) {
  this.next();
  if (this.eat(_tokentype.types.star)) {
    this.expectContextual("from");
    node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
    this.semicolon();
    return this.finishNode(node, "ExportAllDeclaration");
  }
  if (this.eat(_tokentype.types._default)) {
    var parens = this.type == _tokentype.types.parenL;
    var expr = this.parseMaybeAssign();
    var needsSemi = true;
    if (!parens && (expr.type == "FunctionExpression" || expr.type == "ClassExpression")) {
      needsSemi = false;
      if (expr.id) {
        expr.type = expr.type == "FunctionExpression" ? "FunctionDeclaration" : "ClassDeclaration";
      }
    }
    node.declaration = expr;
    if (needsSemi) this.semicolon();
    return this.finishNode(node, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(true);
    node.specifiers = [];
    node.source = null;
  } else {
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers();
    if (this.eatContextual("from")) {
      node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
    } else {
      for (var i = 0; i < node.specifiers.length; i++) {
        if (this.keywords.test(node.specifiers[i].local.name) || this.reservedWords.test(node.specifiers[i].local.name)) {
          this.unexpected(node.specifiers[i].local.start);
        }
      }

      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration");
};

pp.shouldParseExportStatement = function () {
  return this.type.keyword || this.isLet();
};

pp.parseExportSpecifiers = function () {
  var nodes = [],
      first = true;
  this.expect(_tokentype.types.braceL);
  while (!this.eat(_tokentype.types.braceR)) {
    if (!first) {
      this.expect(_tokentype.types.comma);
      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
    } else first = false;

    var node = this.startNode();
    node.local = this.parseIdent(this.type === _tokentype.types._default);
    node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
    nodes.push(this.finishNode(node, "ExportSpecifier"));
  }
  return nodes;
};

pp.parseImport = function (node) {
  this.next();
  if (this.type === _tokentype.types.string) {
    node.specifiers = empty;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};

pp.parseImportSpecifiers = function () {
  var nodes = [],
      first = true;
  if (this.type === _tokentype.types.name) {
    var node = this.startNode();
    node.local = this.parseIdent();
    this.checkLVal(node.local, true);
    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
    if (!this.eat(_tokentype.types.comma)) return nodes;
  }
  if (this.type === _tokentype.types.star) {
    var node = this.startNode();
    this.next();
    this.expectContextual("as");
    node.local = this.parseIdent();
    this.checkLVal(node.local, true);
    nodes.push(this.finishNode(node, "ImportNamespaceSpecifier"));
    return nodes;
  }
  this.expect(_tokentype.types.braceL);
  while (!this.eat(_tokentype.types.braceR)) {
    if (!first) {
      this.expect(_tokentype.types.comma);
      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
    } else first = false;

    var node = this.startNode();
    node.imported = this.parseIdent(true);
    if (this.eatContextual("as")) {
      node.local = this.parseIdent();
    } else {
      node.local = node.imported;
      if (this.isKeyword(node.local.name)) this.unexpected(node.local.start);
      if (this.reservedWordsStrict.test(node.local.name)) this.raise(node.local.start, "The keyword '" + node.local.name + "' is reserved");
    }
    this.checkLVal(node.local, true);
    nodes.push(this.finishNode(node, "ImportSpecifier"));
  }
  return nodes;
};

},{"./identifier":"/src\\identifier.js","./state":"/src\\state.js","./tokentype":"/src\\tokentype.js","./whitespace":"/src\\whitespace.js"}],"/src\\tokencontext.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _state = _dereq_("./state");

var _tokentype = _dereq_("./tokentype");

var _whitespace = _dereq_("./whitespace");

var TokContext = function TokContext(token, isExpr, preserveSpace, override) {


  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
};

exports.TokContext = TokContext;
var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", true),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) {
    return p.readTmplToken();
  }),
  f_expr: new TokContext("function", true)
};

exports.types = types;
var pp = _state.Parser.prototype;

pp.initialContext = function () {
  return [types.b_stat];
};

pp.braceIsBlock = function (prevType) {
  if (prevType === _tokentype.types.colon) {
    var _parent = this.curContext();
    if (_parent === types.b_stat || _parent === types.b_expr) return !_parent.isExpr;
  }
  if (prevType === _tokentype.types._return) return _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  if (prevType === _tokentype.types._else || prevType === _tokentype.types.semi || prevType === _tokentype.types.eof || prevType === _tokentype.types.parenR) return true;
  if (prevType == _tokentype.types.braceL) return this.curContext() === types.b_stat;
  return !this.exprAllowed;
};

pp.updateContext = function (prevType) {
  var update = undefined,
      type = this.type;
  if (type.keyword && prevType == _tokentype.types.dot) this.exprAllowed = false;else if (update = type.updateContext) update.call(this, prevType);else this.exprAllowed = type.beforeExpr;
};

_tokentype.types.parenR.updateContext = _tokentype.types.braceR.updateContext = function () {
  if (this.context.length == 1) {
    this.exprAllowed = true;
    return;
  }
  var out = this.context.pop();
  if (out === types.b_stat && this.curContext() === types.f_expr) {
    this.context.pop();
    this.exprAllowed = false;
  } else if (out === types.b_tmpl) {
    this.exprAllowed = true;
  } else {
    this.exprAllowed = !out.isExpr;
  }
};

_tokentype.types.braceL.updateContext = function (prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};

_tokentype.types.dollarBraceL.updateContext = function () {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};

_tokentype.types.parenL.updateContext = function (prevType) {
  var statementParens = prevType === _tokentype.types._if || prevType === _tokentype.types._for || prevType === _tokentype.types._with || prevType === _tokentype.types._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};

_tokentype.types.incDec.updateContext = function () {};

_tokentype.types._function.updateContext = function () {
  if (this.curContext() !== types.b_stat) this.context.push(types.f_expr);
  this.exprAllowed = false;
};

_tokentype.types.backQuote.updateContext = function () {
  if (this.curContext() === types.q_tmpl) this.context.pop();else this.context.push(types.q_tmpl);
  this.exprAllowed = false;
};

},{"./state":"/src\\state.js","./tokentype":"/src\\tokentype.js","./whitespace":"/src\\whitespace.js"}],"/src\\tokenize.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _identifier = _dereq_("./identifier");

var _tokentype = _dereq_("./tokentype");

var _state = _dereq_("./state");

var _locutil = _dereq_("./locutil");

var _whitespace = _dereq_("./whitespace");

var Token = function Token(p) {


  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations) this.loc = new _locutil.SourceLocation(p, p.startLoc, p.endLoc);
  if (p.options.ranges) this.range = [p.start, p.end];
};

exports.Token = Token;

var pp = _state.Parser.prototype;

var isRhino = typeof Packages == "object" && Object.prototype.toString.call(Packages) == "[object JavaPackage]";

pp.next = function () {
  if (this.options.onToken) this.options.onToken(new Token(this));

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};

pp.getToken = function () {
  this.next();
  return new Token(this);
};

if (typeof Symbol !== "undefined") pp[Symbol.iterator] = function () {
  var self = this;
  return { next: function next() {
      var token = self.getToken();
      return {
        done: token.type === _tokentype.types.eof,
        value: token
      };
    } };
};

pp.setStrict = function (strict) {
  this.strict = strict;
  if (this.type !== _tokentype.types.num && this.type !== _tokentype.types.string) return;
  this.pos = this.start;
  if (this.options.locations) {
    while (this.pos < this.lineStart) {
      this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
      --this.curLine;
    }
  }
  this.nextToken();
};

pp.curContext = function () {
  return this.context[this.context.length - 1];
};

pp.nextToken = function () {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) this.skipSpace();

  this.start = this.pos;
  if (this.options.locations) this.startLoc = this.curPosition();
  if (this.pos >= this.input.length) return this.finishToken(_tokentype.types.eof);

  if (curContext.override) return curContext.override(this);else this.readToken(this.fullCharCodeAtPos());
};

pp.readToken = function (code) {
  if (_identifier.isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */) return this.readWord();

  return this.getTokenFromCode(code);
};

pp.fullCharCodeAtPos = function () {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 0xd7ff || code >= 0xe000) return code;
  var next = this.input.charCodeAt(this.pos + 1);
  return (code << 10) + next - 0x35fdc00;
};

pp.skipBlockComment = function () {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos,
      end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
  this.pos = end + 2;
  if (this.options.locations) {
    _whitespace.lineBreakG.lastIndex = start;
    var match = undefined;
    while ((match = _whitespace.lineBreakG.exec(this.input)) && match.index < this.pos) {
      ++this.curLine;
      this.lineStart = match.index + match[0].length;
    }
  }
  if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
};

pp.skipLineComment = function (startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
    ++this.pos;
    ch = this.input.charCodeAt(this.pos);
  }
  if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
};

pp.skipSpace = function () {
  loop: while (this.pos < this.input.length) {
    var ch = this.input.charCodeAt(this.pos);
    switch (ch) {
      case 32:case 160:
        ++this.pos;
        break;
      case 13:
        if (this.input.charCodeAt(this.pos + 1) === 10) {
          ++this.pos;
        }
      case 10:case 8232:case 8233:
        ++this.pos;
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        break;
      case 47:
        switch (this.input.charCodeAt(this.pos + 1)) {
          case 42:
            this.skipBlockComment();
            break;
          case 47:
            this.skipLineComment(2);
            break;
          default:
            break loop;
        }
        break;
      default:
        if (ch > 8 && ch < 14 || ch >= 5760 && _whitespace.nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this.pos;
        } else {
          break loop;
        }
    }
  }
};

pp.finishToken = function (type, val) {
  this.end = this.pos;
  if (this.options.locations) this.endLoc = this.curPosition();
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.updateContext(prevType);
};

pp.readToken_dot = function () {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) return this.readNumber(true);
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
    this.pos += 3;
    return this.finishToken(_tokentype.types.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(_tokentype.types.dot);
  }
};

pp.readToken_slash = function () {
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;return this.readRegexp();
  }
  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
  return this.finishOp(_tokentype.types.slash, 1);
};

pp.readToken_mult_modulo_exp = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? _tokentype.types.star : _tokentype.types.modulo;

  if (this.options.ecmaVersion >= 7 && next === 42) {
    ++size;
    tokentype = _tokentype.types.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }

  if (next === 61) return this.finishOp(_tokentype.types.assign, size + 1);
  return this.finishOp(tokentype, size);
};

pp.readToken_pipe_amp = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) return this.finishOp(code === 124 ? _tokentype.types.logicalOR : _tokentype.types.logicalAND, 2);
  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
  return this.finishOp(code === 124 ? _tokentype.types.bitwiseOR : _tokentype.types.bitwiseAND, 1);
};

pp.readToken_caret = function () {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
  return this.finishOp(_tokentype.types.bitwiseXOR, 1);
};

pp.readToken_plus_min = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 && _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(_tokentype.types.incDec, 2);
  }
  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
  return this.finishOp(_tokentype.types.plusMin, 1);
};

pp.readToken_lt_gt = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(_tokentype.types.assign, size + 1);
    return this.finishOp(_tokentype.types.bitShift, size);
  }
  if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 && this.input.charCodeAt(this.pos + 3) == 45) {
    if (this.inModule) this.unexpected();
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next === 61) size = 2;
  return this.finishOp(_tokentype.types.relational, size);
};

pp.readToken_eq_excl = function (code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) return this.finishOp(_tokentype.types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
    this.pos += 2;
    return this.finishToken(_tokentype.types.arrow);
  }
  return this.finishOp(code === 61 ? _tokentype.types.eq : _tokentype.types.prefix, 1);
};

pp.getTokenFromCode = function (code) {
  switch (code) {
    case 46:
      return this.readToken_dot();

    case 40:
      ++this.pos;return this.finishToken(_tokentype.types.parenL);
    case 41:
      ++this.pos;return this.finishToken(_tokentype.types.parenR);
    case 59:
      ++this.pos;return this.finishToken(_tokentype.types.semi);
    case 44:
      ++this.pos;return this.finishToken(_tokentype.types.comma);
    case 91:
      ++this.pos;return this.finishToken(_tokentype.types.bracketL);
    case 93:
      ++this.pos;return this.finishToken(_tokentype.types.bracketR);
    case 123:
      ++this.pos;return this.finishToken(_tokentype.types.braceL);
    case 125:
      ++this.pos;return this.finishToken(_tokentype.types.braceR);
    case 58:
      ++this.pos;return this.finishToken(_tokentype.types.colon);
    case 63:
      ++this.pos;return this.finishToken(_tokentype.types.question);

    case 96:
      if (this.options.ecmaVersion < 6) break;
      ++this.pos;
      return this.finishToken(_tokentype.types.backQuote);

    case 48:
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) return this.readRadixNumber(16); // '0x', '0X' - hex number
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) return this.readRadixNumber(8); // '0o', '0O' - octal number
        if (next === 98 || next === 66) return this.readRadixNumber(2) // '0b', '0B' - binary number
        ;
      }
    case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
      return this.readNumber(false);

    case 34:case 39:
      return this.readString(code);

    case 47:
      return this.readToken_slash();

    case 37:case 42:
      return this.readToken_mult_modulo_exp(code);

    case 124:case 38:
      return this.readToken_pipe_amp(code);

    case 94:
      return this.readToken_caret();

    case 43:case 45:
      return this.readToken_plus_min(code);

    case 60:case 62:
      return this.readToken_lt_gt(code);

    case 61:case 33:
      return this.readToken_eq_excl(code);

    case 126:
      return this.finishOp(_tokentype.types.prefix, 1);
    case 64:
      ++this.pos;return this.finishToken(_tokentype.types.at);
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};

pp.finishOp = function (type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str);
};

function tryCreateRegexp(src, flags, throwErrorAt, parser) {
  try {
    return new RegExp(src, flags);
  } catch (e) {
    if (throwErrorAt !== undefined) {
      if (e instanceof SyntaxError) parser.raise(throwErrorAt, "Error parsing regular expression: " + e.message);
      throw e;
    }
  }
}

var regexpUnicodeSupport = false; // !!tryCreateRegexp("\uffff", "u");

pp.readRegexp = function () {
  var _this = this;

  var escaped = undefined,
      inClass = undefined,
      start = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
    var ch = this.input.charAt(this.pos);
    if (_whitespace.lineBreak.test(ch)) this.raise(start, "Unterminated regular expression");
    if (!escaped) {
      if (ch === "[") inClass = true;else if (ch === "]" && inClass) inClass = false;else if (ch === "/" && !inClass) break;
      escaped = ch === "\\";
    } else escaped = false;
    ++this.pos;
  }
  var content = this.input.slice(start, this.pos);
  ++this.pos;
  var mods = this.readWord1();
  var tmp = content;
  if (mods) {
    var validFlags = /^[gim]*$/;
    if (this.options.ecmaVersion >= 6) validFlags = /^[gimuy]*$/;
    if (!validFlags.test(mods)) this.raise(start, "Invalid regular expression flag");
    if (mods.indexOf("u") >= 0 && !regexpUnicodeSupport) {
      tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, function (_match, code, offset) {
        code = Number("0x" + code);
        if (code > 0x10FFFF) _this.raise(start + offset + 3, "Code point out of bounds");
        return "x";
      });
      tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
    }
  }
  var value = null;
  if (!isRhino) {
    tryCreateRegexp(tmp, undefined, start, this);
    value = tryCreateRegexp(content, mods);
  }
  return this.finishToken(_tokentype.types.regexp, { pattern: content, flags: mods, value: value });
};

pp.readInt = function (radix, len) {
  var start = this.pos,
      total = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
    var code = this.input.charCodeAt(this.pos),
        val = undefined;
    if (code >= 97) val = code - 97 + 10 // a
    ;else if (code >= 65) val = code - 65 + 10 // A
    ;else if (code >= 48 && code <= 57) val = code - 48 // 0-9
    ;else val = Infinity;
    if (val >= radix) break;
    ++this.pos;
    total = total * radix + val;
  }
  if (this.pos === start || len != null && this.pos - start !== len) return null;

  return total;
};

pp.readRadixNumber = function (radix) {
  this.pos += 2; // 0x
  var val = this.readInt(radix);
  if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix);
  if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
  return this.finishToken(_tokentype.types.num, val);
};

pp.readNumber = function (startsWithDot) {
  var start = this.pos,
      isFloat = false,
      octal = this.input.charCodeAt(this.pos) === 48;
  if (!startsWithDot && this.readInt(10) === null) this.raise(start, "Invalid number");
  var next = this.input.charCodeAt(this.pos);
  if (next === 46) {
    ++this.pos;
    this.readInt(10);
    isFloat = true;
    next = this.input.charCodeAt(this.pos);
  }
  if (next === 69 || next === 101) {
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) ++this.pos; // '+-'
    if (this.readInt(10) === null) this.raise(start, "Invalid number");
    isFloat = true;
  }
  if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");

  var str = this.input.slice(start, this.pos),
      val = undefined;
  if (isFloat) val = parseFloat(str);else if (!octal || str.length === 1) val = parseInt(str, 10);else if (/[89]/.test(str) || this.strict) this.raise(start, "Invalid number");else val = parseInt(str, 8);
  return this.finishToken(_tokentype.types.num, val);
};

pp.readCodePoint = function () {
  var ch = this.input.charCodeAt(this.pos),
      code = undefined;

  if (ch === 123) {
    if (this.options.ecmaVersion < 6) this.unexpected();
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 0x10FFFF) this.raise(codePos, "Code point out of bounds");
  } else {
    code = this.readHexChar(4);
  }
  return code;
};

function codePointToString(code) {
  if (code <= 0xFFFF) return String.fromCharCode(code);
  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);
}

pp.readString = function (quote) {
  var out = "",
      chunkStart = ++this.pos;
  for (;;) {
    if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) break;
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else {
      if (_whitespace.isNewLine(ch)) this.raise(this.start, "Unterminated string constant");
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(_tokentype.types.string, out);
};

pp.readTmplToken = function () {
  var out = "",
      chunkStart = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) this.raise(this.start, "Unterminated template");
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      if (this.pos === this.start && this.type === _tokentype.types.template) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(_tokentype.types.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(_tokentype.types.backQuote);
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(_tokentype.types.template, out);
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (_whitespace.isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
        case 10:
          out += "\n";
          break;
        default:
          out += String.fromCharCode(ch);
          break;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};

pp.readEscapedChar = function (inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
    case 110:
      return "\n"; // 'n' -> '\n'
    case 114:
      return "\r"; // 'r' -> '\r'
    case 120:
      return String.fromCharCode(this.readHexChar(2)); // 'x'
    case 117:
      return codePointToString(this.readCodePoint()); // 'u'
    case 116:
      return "\t"; // 't' -> '\t'
    case 98:
      return "\b"; // 'b' -> '\b'
    case 118:
      return "\u000b"; // 'v' -> '\u000b'
    case 102:
      return "\f"; // 'f' -> '\f'
    case 13:
      if (this.input.charCodeAt(this.pos) === 10) ++this.pos; // '\r\n'
    case 10:
      if (this.options.locations) {
        this.lineStart = this.pos;++this.curLine;
      }
      return "";
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        if (octalStr !== "0" && (this.strict || inTemplate)) {
          this.raise(this.pos - 2, "Octal literal in strict mode");
        }
        this.pos += octalStr.length - 1;
        return String.fromCharCode(octal);
      }
      return String.fromCharCode(ch);
  }
};

pp.readHexChar = function (len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) this.raise(codePos, "Bad character escape sequence");
  return n;
};

pp.readWord1 = function () {
  this.containsEsc = false;
  var word = "",
      first = true,
      chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (_identifier.isIdentifierChar(ch, astral)) {
      this.pos += ch <= 0xffff ? 1 : 2;
    } else if (ch === 92) {
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) != 117) // "u"
        this.raise(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? _identifier.isIdentifierStart : _identifier.isIdentifierChar)(esc, astral)) this.raise(escStart, "Invalid Unicode escape");
      word += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break;
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos);
};

pp.readWord = function () {
  var word = this.readWord1();
  var type = _tokentype.types.name;
  if ((this.options.ecmaVersion >= 6 || !this.containsEsc) && this.keywords.test(word)) type = _tokentype.keywords[word];
  return this.finishToken(type, word);
};

},{"./identifier":"/src\\identifier.js","./locutil":"/src\\locutil.js","./state":"/src\\state.js","./tokentype":"/src\\tokentype.js","./whitespace":"/src\\whitespace.js"}],"/src\\tokentype.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TokenType = function TokenType(label) {
  var conf = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];


  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

exports.TokenType = TokenType;

function binop(name, prec) {
  return new TokenType(name, { beforeExpr: true, binop: prec });
}
var beforeExpr = { beforeExpr: true },
    startsExpr = { startsExpr: true };

var types = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  eof: new TokenType("eof"),

  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),

  at: new TokenType("@", { beforeExpr: true, startsExpr: true }),

  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("prefix", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=", 6),
  relational: binop("</>", 7),
  bitShift: binop("<</>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: true })
};

exports.types = types;
var keywords = {};

exports.keywords = keywords;
function kw(name) {
  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  options.keyword = name;
  keywords[name] = types["_" + name] = new TokenType(name, options);
}

kw("break");
kw("case", beforeExpr);
kw("catch");
kw("continue");
kw("debugger");
kw("default", beforeExpr);
kw("do", { isLoop: true, beforeExpr: true });
kw("else", beforeExpr);
kw("finally");
kw("for", { isLoop: true });
kw("function", startsExpr);
kw("if");
kw("return", beforeExpr);
kw("switch");
kw("throw", beforeExpr);
kw("try");
kw("var");
kw("const");
kw("while", { isLoop: true });
kw("with");
kw("new", { beforeExpr: true, startsExpr: true });
kw("this", startsExpr);
kw("super", startsExpr);
kw("class");
kw("extends", beforeExpr);
kw("export");
kw("import");
kw("null", startsExpr);
kw("true", startsExpr);
kw("false", startsExpr);
kw("in", { beforeExpr: true, binop: 7 });
kw("instanceof", { beforeExpr: true, binop: 7 });
kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true });
kw("void", { beforeExpr: true, prefix: true, startsExpr: true });
kw("delete", { beforeExpr: true, prefix: true, startsExpr: true });

},{}],"/src\\util.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.isArray = isArray;
exports.has = has;

function isArray(obj) {
  return Object.prototype.toString.call(obj) === "[object Array]";
}

function has(obj, propName) {
  return Object.prototype.hasOwnProperty.call(obj, propName);
}

},{}],"/src\\whitespace.js":[function(_dereq_,module,exports){
"use strict";

exports.__esModule = true;
exports.isNewLine = isNewLine;
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
exports.lineBreak = lineBreak;
var lineBreakG = new RegExp(lineBreak.source, "g");

exports.lineBreakG = lineBreakG;

function isNewLine(code) {
  return code === 10 || code === 13 || code === 0x2028 || code == 0x2029;
}

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

exports.nonASCIIwhitespace = nonASCIIwhitespace;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
exports.skipWhiteSpace = skipWhiteSpace;

},{}]},{},["/src\\index.js"])("/src\\index.js")
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},
   {}],

"/node_modules/espree/lib/ast-node-types.js": [function(require,module,exports){
"use strict";

module.exports = {
    AssignmentExpression: "AssignmentExpression",
    AssignmentPattern: "AssignmentPattern",
    ArrayExpression: "ArrayExpression",
    ArrayPattern: "ArrayPattern",
    ArrowFunctionExpression: "ArrowFunctionExpression",
    BlockStatement: "BlockStatement",
    BinaryExpression: "BinaryExpression",
    BreakStatement: "BreakStatement",
    CallExpression: "CallExpression",
    CatchClause: "CatchClause",
    ClassBody: "ClassBody",
    ClassDeclaration: "ClassDeclaration",
    ClassExpression: "ClassExpression",
    ConditionalExpression: "ConditionalExpression",
    ContinueStatement: "ContinueStatement",
    DoWhileStatement: "DoWhileStatement",
    DebuggerStatement: "DebuggerStatement",
    EmptyStatement: "EmptyStatement",
    ExperimentalRestProperty: "ExperimentalRestProperty",
    ExperimentalSpreadProperty: "ExperimentalSpreadProperty",
    ExpressionStatement: "ExpressionStatement",
    ForStatement: "ForStatement",
    ForInStatement: "ForInStatement",
    ForOfStatement: "ForOfStatement",
    FunctionDeclaration: "FunctionDeclaration",
    FunctionExpression: "FunctionExpression",
    Identifier: "Identifier",
    IfStatement: "IfStatement",
    Literal: "Literal",
    LabeledStatement: "LabeledStatement",
    LogicalExpression: "LogicalExpression",
    MemberExpression: "MemberExpression",
    MetaProperty: "MetaProperty",
    MethodDefinition: "MethodDefinition",
    NewExpression: "NewExpression",
    ObjectExpression: "ObjectExpression",
    ObjectPattern: "ObjectPattern",
    Program: "Program",
    Property: "Property",
    RestElement: "RestElement",
    ReturnStatement: "ReturnStatement",
    SequenceExpression: "SequenceExpression",
    SpreadElement: "SpreadElement",
    Super: "Super",
    SwitchCase: "SwitchCase",
    SwitchStatement: "SwitchStatement",
    TaggedTemplateExpression: "TaggedTemplateExpression",
    TemplateElement: "TemplateElement",
    TemplateLiteral: "TemplateLiteral",
    ThisExpression: "ThisExpression",
    ThrowStatement: "ThrowStatement",
    TryStatement: "TryStatement",
    UnaryExpression: "UnaryExpression",
    UpdateExpression: "UpdateExpression",
    VariableDeclaration: "VariableDeclaration",
    VariableDeclarator: "VariableDeclarator",
    WhileStatement: "WhileStatement",
    WithStatement: "WithStatement",
    YieldExpression: "YieldExpression",
    JSXIdentifier: "JSXIdentifier",
    JSXNamespacedName: "JSXNamespacedName",
    JSXMemberExpression: "JSXMemberExpression",
    JSXEmptyExpression: "JSXEmptyExpression",
    JSXExpressionContainer: "JSXExpressionContainer",
    JSXElement: "JSXElement",
    JSXClosingElement: "JSXClosingElement",
    JSXOpeningElement: "JSXOpeningElement",
    JSXAttribute: "JSXAttribute",
    JSXSpreadAttribute: "JSXSpreadAttribute",
    JSXText: "JSXText",
    ExportDefaultDeclaration: "ExportDefaultDeclaration",
    ExportNamedDeclaration: "ExportNamedDeclaration",
    ExportAllDeclaration: "ExportAllDeclaration",
    ExportSpecifier: "ExportSpecifier",
    ImportDeclaration: "ImportDeclaration",
    ImportSpecifier: "ImportSpecifier",
    ImportDefaultSpecifier: "ImportDefaultSpecifier",
    ImportNamespaceSpecifier: "ImportNamespaceSpecifier"
};

},
   {}],

"/node_modules/espree/lib/comment-attachment.js": [function(require,module,exports){
"use strict";

var astNodeTypes = require("./ast-node-types");

var extra = {
    trailingComments: [],
    leadingComments: [],
    bottomRightStack: []
};

module.exports = {

    reset: function() {
        extra.trailingComments = [];
        extra.leadingComments = [];
        extra.bottomRightStack = [];
    },

    addComment: function(comment) {
        extra.trailingComments.push(comment);
        extra.leadingComments.push(comment);
    },

    processComment: function(node) {
        var lastChild,
            trailingComments,
            i;

        if (node.type === astNodeTypes.Program) {
            if (node.body.length > 0) {
                return;
            }
        }

        if (extra.trailingComments.length > 0) {

            if (extra.trailingComments[0].range[0] >= node.range[1]) {
                trailingComments = extra.trailingComments;
                extra.trailingComments = [];
            } else {

                extra.trailingComments.length = 0;
            }
        } else {
            if (extra.bottomRightStack.length > 0 &&
                    extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments &&
                    extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments[0].range[0] >= node.range[1]) {
                trailingComments = extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
                delete extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
            }
        }

        while (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].range[0] >= node.range[0]) {
            lastChild = extra.bottomRightStack.pop();
        }

        if (lastChild) {
            if (lastChild.leadingComments) {
                if (lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= node.range[0]) {
                    node.leadingComments = lastChild.leadingComments;
                    delete lastChild.leadingComments;
                } else {
                    for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {
                        if (lastChild.leadingComments[i].range[1] <= node.range[0]) {
                            node.leadingComments = lastChild.leadingComments.splice(0, i + 1);
                            break;
                        }
                    }
                }
            }
        } else if (extra.leadingComments.length > 0) {

            if (extra.leadingComments[extra.leadingComments.length - 1].range[1] <= node.range[0]) {
                node.leadingComments = extra.leadingComments;
                extra.leadingComments = [];
            } else {

                for (i = 0; i < extra.leadingComments.length; i++) {
                    if (extra.leadingComments[i].range[1] > node.range[0]) {
                        break;
                    }
                }

                node.leadingComments = extra.leadingComments.slice(0, i);
                if (node.leadingComments.length === 0) {
                    delete node.leadingComments;
                }

                trailingComments = extra.leadingComments.slice(i);
                if (trailingComments.length === 0) {
                    trailingComments = null;
                }
            }
        }

        if (trailingComments) {
            node.trailingComments = trailingComments;
        }

        extra.bottomRightStack.push(node);
    }

};

},
   {"./ast-node-types":"/node_modules/espree/lib/ast-node-types.js"}],

"/node_modules/espree/lib/token-translator.js": [function(require,module,exports){
"use strict";


var Token = {
    Boolean: "Boolean",
    EOF: "<end>",
    Identifier: "Identifier",
    Keyword: "Keyword",
    Null: "Null",
    Numeric: "Numeric",
    Punctuator: "Punctuator",
    String: "String",
    RegularExpression: "RegularExpression",
    Template: "Template",
    JSXIdentifier: "JSXIdentifier",
    JSXText: "JSXText"
};

function convertTemplatePart(tokens, code) {
    var firstToken = tokens[0],
        lastTemplateToken = tokens[tokens.length - 1];

    var token = {
        type: Token.Template,
        value: code.slice(firstToken.start, lastTemplateToken.end)
    };

    if (firstToken.loc) {
        token.loc = {
            start: firstToken.loc.start,
            end: lastTemplateToken.loc.end
        };
    }

    if (firstToken.range) {
        token.range = [firstToken.range[0], lastTemplateToken.range[1]];
    }

    return token;
}

function TokenTranslator(acornTokTypes, code) {

    this._acornTokTypes = acornTokTypes;

    this._tokens = [];

    this._curlyBrace = null;

    this._code = code;

}

TokenTranslator.prototype = {
    constructor: TokenTranslator,

    translate: function(token, extra) {

        var type = token.type,
            tt = this._acornTokTypes;

        if (type === tt.name) {
            token.type = Token.Identifier;

            if (token.value === "static") {
                token.type = Token.Keyword;
            }

            if (extra.ecmaVersion > 5 && (token.value === "yield" || token.value === "let")) {
                token.type = Token.Keyword;
            }

        } else if (type === tt.semi || type === tt.comma ||
                 type === tt.parenL || type === tt.parenR ||
                 type === tt.braceL || type === tt.braceR ||
                 type === tt.dot || type === tt.bracketL ||
                 type === tt.colon || type === tt.question ||
                 type === tt.bracketR || type === tt.ellipsis ||
                 type === tt.arrow || type === tt.jsxTagStart ||
                 type === tt.incDec || type === tt.starstar ||
                 type === tt.jsxTagEnd || (type.binop && !type.keyword) ||
                 type.isAssign) {

            token.type = Token.Punctuator;
            token.value = this._code.slice(token.start, token.end);
        } else if (type === tt.jsxName) {
            token.type = Token.JSXIdentifier;
        } else if (type.label === "jsxText" || type === tt.jsxAttrValueToken) {
            token.type = Token.JSXText;
        } else if (type.keyword) {
            if (type.keyword === "true" || type.keyword === "false") {
                token.type = Token.Boolean;
            } else if (type.keyword === "null") {
                token.type = Token.Null;
            } else {
                token.type = Token.Keyword;
            }
        } else if (type === tt.num) {
            token.type = Token.Numeric;
            token.value = this._code.slice(token.start, token.end);
        } else if (type === tt.string) {

            if (extra.jsxAttrValueToken) {
                extra.jsxAttrValueToken = false;
                token.type = Token.JSXText;
            } else {
                token.type = Token.String;
            }

            token.value = this._code.slice(token.start, token.end);
        } else if (type === tt.regexp) {
            token.type = Token.RegularExpression;
            var value = token.value;
            token.regex = {
                flags: value.flags,
                pattern: value.pattern
            };
            token.value = "/" + value.pattern + "/" + value.flags;
        }

        return token;
    },

    onToken: function(token, extra) {

        var that = this,
            tt = this._acornTokTypes,
            tokens = extra.tokens,
            templateTokens = this._tokens;

        function translateTemplateTokens() {
            tokens.push(convertTemplatePart(that._tokens, that._code));
            that._tokens = [];
        }

        if (token.type === tt.eof) {

            if (this._curlyBrace) {
                tokens.push(this.translate(this._curlyBrace, extra));
            }

            return;
        }

        if (token.type === tt.backQuote) {
            templateTokens.push(token);

            if (templateTokens.length > 1) {
                translateTemplateTokens();
            }

            return;
        } else if (token.type === tt.dollarBraceL) {
            templateTokens.push(token);
            translateTemplateTokens();
            return;
        } else if (token.type === tt.braceR) {

            if (this._curlyBrace) {

                tokens.push(this.translate(this._curlyBrace, extra));
            }

            this._curlyBrace = token;
            return;
        } else if (token.type === tt.template) {
            if (this._curlyBrace) {
                templateTokens.push(this._curlyBrace);
                this._curlyBrace = null;
            }

            templateTokens.push(token);
            return;
        }

        if (this._curlyBrace) {
            tokens.push(this.translate(this._curlyBrace, extra));
            this._curlyBrace = null;
        }

        tokens.push(this.translate(token, extra));
    }
};

module.exports = TokenTranslator;

},
   {}],

"/node_modules/espree/lib/visitor-keys.js": [function(require,module,exports){
"use strict";

module.exports = {

    AssignmentExpression: ["left", "right"],
    AssignmentPattern: ["left", "right"],
    ArrayExpression: ["elements"],
    ArrayPattern: ["elements"],
    ArrowFunctionExpression: ["params", "body"],
    BlockStatement: ["body"],
    BinaryExpression: ["left", "right"],
    BreakStatement: ["label"],
    CallExpression: ["callee", "arguments"],
    CatchClause: ["param", "body"],
    ClassBody: ["body"],
    ClassDeclaration: ["id", "superClass", "body"],
    ClassExpression: ["id", "superClass", "body"],
    ConditionalExpression: ["test", "consequent", "alternate"],
    ContinueStatement: ["label"],
    DebuggerStatement: [],
    DirectiveStatement: [],
    DoWhileStatement: ["body", "test"],
    EmptyStatement: [],
    ExportAllDeclaration: ["source"],
    ExportDefaultDeclaration: ["declaration"],
    ExportNamedDeclaration: ["declaration", "specifiers", "source"],
    ExportSpecifier: ["exported", "local"],
    ExpressionStatement: ["expression"],
    ForStatement: ["init", "test", "update", "body"],
    ForInStatement: ["left", "right", "body"],
    ForOfStatement: ["left", "right", "body"],
    FunctionDeclaration: ["id", "params", "body"],
    FunctionExpression: ["id", "params", "body"],
    Identifier: [],
    IfStatement: ["test", "consequent", "alternate"],
    ImportDeclaration: ["specifiers", "source"],
    ImportDefaultSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportSpecifier: ["imported", "local"],
    Literal: [],
    LabeledStatement: ["label", "body"],
    LogicalExpression: ["left", "right"],
    MemberExpression: ["object", "property"],
    MetaProperty: ["meta", "property"],
    MethodDefinition: ["key", "value"],
    ModuleSpecifier: [],
    NewExpression: ["callee", "arguments"],
    ObjectExpression: ["properties"],
    ObjectPattern: ["properties"],
    Program: ["body"],
    Property: ["key", "value"],
    RestElement: [ "argument" ],
    ReturnStatement: ["argument"],
    SequenceExpression: ["expressions"],
    SpreadElement: ["argument"],
    Super: [],
    SwitchStatement: ["discriminant", "cases"],
    SwitchCase: ["test", "consequent"],
    TaggedTemplateExpression: ["tag", "quasi"],
    TemplateElement: [],
    TemplateLiteral: ["quasis", "expressions"],
    ThisExpression: [],
    ThrowStatement: ["argument"],
    TryStatement: ["block", "handler", "finalizer"],
    UnaryExpression: ["argument"],
    UpdateExpression: ["argument"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id", "init"],
    WhileStatement: ["test", "body"],
    WithStatement: ["object", "body"],
    YieldExpression: ["argument"],

    JSXIdentifier: [],
    JSXNamespacedName: ["namespace", "name"],
    JSXMemberExpression: ["object", "property"],
    JSXEmptyExpression: [],
    JSXExpressionContainer: ["expression"],
    JSXElement: ["openingElement", "closingElement", "children"],
    JSXClosingElement: ["name"],
    JSXOpeningElement: ["name", "attributes"],
    JSXAttribute: ["name", "value"],
    JSXText: null,
    JSXSpreadAttribute: ["argument"],

    ExperimentalRestProperty: ["argument"],
    ExperimentalSpreadProperty: ["argument"]
};

},
   {}],

"/node_modules/espree/node_modules/acorn-jsx/inject.js": [function(require,module,exports){
'use strict';

var XHTMLEntities = require('./xhtml');

var hexNumber = /^[\da-fA-F]+$/;
var decimalNumber = /^\d+$/;

module.exports = function(acorn) {
  var tt = acorn.tokTypes;
  var tc = acorn.tokContexts;

  tc.j_oTag = new acorn.TokContext('<tag', false);
  tc.j_cTag = new acorn.TokContext('</tag', false);
  tc.j_expr = new acorn.TokContext('<tag>...</tag>', true, true);

  tt.jsxName = new acorn.TokenType('jsxName');
  tt.jsxText = new acorn.TokenType('jsxText', {beforeExpr: true});
  tt.jsxTagStart = new acorn.TokenType('jsxTagStart');
  tt.jsxTagEnd = new acorn.TokenType('jsxTagEnd');

  tt.jsxTagStart.updateContext = function() {
    this.context.push(tc.j_expr); // treat as beginning of JSX expression
    this.context.push(tc.j_oTag); // start opening tag context
    this.exprAllowed = false;
  };
  tt.jsxTagEnd.updateContext = function(prevType) {
    var out = this.context.pop();
    if (out === tc.j_oTag && prevType === tt.slash || out === tc.j_cTag) {
      this.context.pop();
      this.exprAllowed = this.curContext() === tc.j_expr;
    } else {
      this.exprAllowed = true;
    }
  };

  var pp = acorn.Parser.prototype;

  pp.jsx_readToken = function() {
    var out = '', chunkStart = this.pos;
    for (;;) {
      if (this.pos >= this.input.length)
        this.raise(this.start, 'Unterminated JSX contents');
      var ch = this.input.charCodeAt(this.pos);

      switch (ch) {
      case 60: // '<'
      case 123: // '{'
        if (this.pos === this.start) {
          if (ch === 60 && this.exprAllowed) {
            ++this.pos;
            return this.finishToken(tt.jsxTagStart);
          }
          return this.getTokenFromCode(ch);
        }
        out += this.input.slice(chunkStart, this.pos);
        return this.finishToken(tt.jsxText, out);

      case 38: // '&'
        out += this.input.slice(chunkStart, this.pos);
        out += this.jsx_readEntity();
        chunkStart = this.pos;
        break;

      default:
        if (acorn.isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.pos);
          out += this.jsx_readNewLine(true);
          chunkStart = this.pos;
        } else {
          ++this.pos;
        }
      }
    }
  };

  pp.jsx_readNewLine = function(normalizeCRLF) {
    var ch = this.input.charCodeAt(this.pos);
    var out;
    ++this.pos;
    if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {
      ++this.pos;
      out = normalizeCRLF ? '\n' : '\r\n';
    } else {
      out = String.fromCharCode(ch);
    }
    if (this.options.locations) {
      ++this.curLine;
      this.lineStart = this.pos;
    }

    return out;
  };

  pp.jsx_readString = function(quote) {
    var out = '', chunkStart = ++this.pos;
    for (;;) {
      if (this.pos >= this.input.length)
        this.raise(this.start, 'Unterminated string constant');
      var ch = this.input.charCodeAt(this.pos);
      if (ch === quote) break;
      if (ch === 38) { // '&'
        out += this.input.slice(chunkStart, this.pos);
        out += this.jsx_readEntity();
        chunkStart = this.pos;
      } else if (acorn.isNewLine(ch)) {
        out += this.input.slice(chunkStart, this.pos);
        out += this.jsx_readNewLine(false);
        chunkStart = this.pos;
      } else {
        ++this.pos;
      }
    }
    out += this.input.slice(chunkStart, this.pos++);
    return this.finishToken(tt.string, out);
  };

  pp.jsx_readEntity = function() {
    var str = '', count = 0, entity;
    var ch = this.input[this.pos];
    if (ch !== '&')
      this.raise(this.pos, 'Entity must start with an ampersand');
    var startPos = ++this.pos;
    while (this.pos < this.input.length && count++ < 10) {
      ch = this.input[this.pos++];
      if (ch === ';') {
        if (str[0] === '#') {
          if (str[1] === 'x') {
            str = str.substr(2);
            if (hexNumber.test(str))
              entity = String.fromCharCode(parseInt(str, 16));
          } else {
            str = str.substr(1);
            if (decimalNumber.test(str))
              entity = String.fromCharCode(parseInt(str, 10));
          }
        } else {
          entity = XHTMLEntities[str];
        }
        break;
      }
      str += ch;
    }
    if (!entity) {
      this.pos = startPos;
      return '&';
    }
    return entity;
  };


  pp.jsx_readWord = function() {
    var ch, start = this.pos;
    do {
      ch = this.input.charCodeAt(++this.pos);
    } while (acorn.isIdentifierChar(ch) || ch === 45); // '-'
    return this.finishToken(tt.jsxName, this.input.slice(start, this.pos));
  };

  function getQualifiedJSXName(object) {
    if (object.type === 'JSXIdentifier')
      return object.name;

    if (object.type === 'JSXNamespacedName')
      return object.namespace.name + ':' + object.name.name;

    if (object.type === 'JSXMemberExpression')
      return getQualifiedJSXName(object.object) + '.' +
      getQualifiedJSXName(object.property);
  }

  pp.jsx_parseIdentifier = function() {
    var node = this.startNode();
    if (this.type === tt.jsxName)
      node.name = this.value;
    else if (this.type.keyword)
      node.name = this.type.keyword;
    else
      this.unexpected();
    this.next();
    return this.finishNode(node, 'JSXIdentifier');
  };

  pp.jsx_parseNamespacedName = function() {
    var startPos = this.start, startLoc = this.startLoc;
    var name = this.jsx_parseIdentifier();
    if (!this.eat(tt.colon)) return name;
    var node = this.startNodeAt(startPos, startLoc);
    node.namespace = name;
    node.name = this.jsx_parseIdentifier();
    return this.finishNode(node, 'JSXNamespacedName');
  };

  pp.jsx_parseElementName = function() {
    var startPos = this.start, startLoc = this.startLoc;
    var node = this.jsx_parseNamespacedName();
    while (this.eat(tt.dot)) {
      var newNode = this.startNodeAt(startPos, startLoc);
      newNode.object = node;
      newNode.property = this.jsx_parseIdentifier();
      node = this.finishNode(newNode, 'JSXMemberExpression');
    }
    return node;
  };

  pp.jsx_parseAttributeValue = function() {
    switch (this.type) {
    case tt.braceL:
      var node = this.jsx_parseExpressionContainer();
      if (node.expression.type === 'JSXEmptyExpression')
        this.raise(node.start, 'JSX attributes must only be assigned a non-empty expression');
      return node;

    case tt.jsxTagStart:
    case tt.string:
      return this.parseExprAtom();

    default:
      this.raise(this.start, 'JSX value should be either an expression or a quoted JSX text');
    }
  };

  pp.jsx_parseEmptyExpression = function() {
    var node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
    return this.finishNodeAt(node, 'JSXEmptyExpression', this.start, this.startLoc);
  };


  pp.jsx_parseExpressionContainer = function() {
    var node = this.startNode();
    this.next();
    node.expression = this.type === tt.braceR
      ? this.jsx_parseEmptyExpression()
      : this.parseExpression();
    this.expect(tt.braceR);
    return this.finishNode(node, 'JSXExpressionContainer');
  };

  pp.jsx_parseAttribute = function() {
    var node = this.startNode();
    if (this.eat(tt.braceL)) {
      this.expect(tt.ellipsis);
      node.argument = this.parseMaybeAssign();
      this.expect(tt.braceR);
      return this.finishNode(node, 'JSXSpreadAttribute');
    }
    node.name = this.jsx_parseNamespacedName();
    node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;
    return this.finishNode(node, 'JSXAttribute');
  };

  pp.jsx_parseOpeningElementAt = function(startPos, startLoc) {
    var node = this.startNodeAt(startPos, startLoc);
    node.attributes = [];
    node.name = this.jsx_parseElementName();
    while (this.type !== tt.slash && this.type !== tt.jsxTagEnd)
      node.attributes.push(this.jsx_parseAttribute());
    node.selfClosing = this.eat(tt.slash);
    this.expect(tt.jsxTagEnd);
    return this.finishNode(node, 'JSXOpeningElement');
  };

  pp.jsx_parseClosingElementAt = function(startPos, startLoc) {
    var node = this.startNodeAt(startPos, startLoc);
    node.name = this.jsx_parseElementName();
    this.expect(tt.jsxTagEnd);
    return this.finishNode(node, 'JSXClosingElement');
  };

  pp.jsx_parseElementAt = function(startPos, startLoc) {
    var node = this.startNodeAt(startPos, startLoc);
    var children = [];
    var openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);
    var closingElement = null;

    if (!openingElement.selfClosing) {
      contents: for (;;) {
        switch (this.type) {
        case tt.jsxTagStart:
          startPos = this.start; startLoc = this.startLoc;
          this.next();
          if (this.eat(tt.slash)) {
            closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
            break contents;
          }
          children.push(this.jsx_parseElementAt(startPos, startLoc));
          break;

        case tt.jsxText:
          children.push(this.parseExprAtom());
          break;

        case tt.braceL:
          children.push(this.jsx_parseExpressionContainer());
          break;

        default:
          this.unexpected();
        }
      }
      if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
        this.raise(
          closingElement.start,
          'Expected corresponding JSX closing tag for <' + getQualifiedJSXName(openingElement.name) + '>');
      }
    }

    node.openingElement = openingElement;
    node.closingElement = closingElement;
    node.children = children;
    if (this.type === tt.relational && this.value === "<") {
      this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
    }
    return this.finishNode(node, 'JSXElement');
  };

  pp.jsx_parseElement = function() {
    var startPos = this.start, startLoc = this.startLoc;
    this.next();
    return this.jsx_parseElementAt(startPos, startLoc);
  };

  acorn.plugins.jsx = function(instance) {
    instance.extend('parseExprAtom', function(inner) {
      return function(refShortHandDefaultPos) {
        if (this.type === tt.jsxText)
          return this.parseLiteral(this.value);
        else if (this.type === tt.jsxTagStart)
          return this.jsx_parseElement();
        else
          return inner.call(this, refShortHandDefaultPos);
      };
    });

    instance.extend('readToken', function(inner) {
      return function(code) {
        var context = this.curContext();

        if (context === tc.j_expr) return this.jsx_readToken();

        if (context === tc.j_oTag || context === tc.j_cTag) {
          if (acorn.isIdentifierStart(code)) return this.jsx_readWord();

          if (code == 62) {
            ++this.pos;
            return this.finishToken(tt.jsxTagEnd);
          }

          if ((code === 34 || code === 39) && context == tc.j_oTag)
            return this.jsx_readString(code);
        }

        if (code === 60 && this.exprAllowed) {
          ++this.pos;
          return this.finishToken(tt.jsxTagStart);
        }
        return inner.call(this, code);
      };
    });

    instance.extend('updateContext', function(inner) {
      return function(prevType) {
        if (this.type == tt.braceL) {
          var curContext = this.curContext();
          if (curContext == tc.j_oTag) this.context.push(tc.b_expr);
          else if (curContext == tc.j_expr) this.context.push(tc.b_tmpl);
          else inner.call(this, prevType);
          this.exprAllowed = true;
        } else if (this.type === tt.slash && prevType === tt.jsxTagStart) {
          this.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore
          this.context.push(tc.j_cTag); // reconsider as closing tag context
          this.exprAllowed = false;
        } else {
          return inner.call(this, prevType);
        }
      };
    });
  };

  return acorn;
};

},
   {"./xhtml":"/node_modules/espree/node_modules/acorn-jsx/xhtml.js"}],

"/node_modules/espree/node_modules/acorn-jsx/xhtml.js": [function(require,module,exports){
module.exports = {
  quot: '\u0022',
  amp: '&',
  apos: '\u0027',
  lt: '<',
  gt: '>',
  nbsp: '\u00A0',
  iexcl: '\u00A1',
  cent: '\u00A2',
  pound: '\u00A3',
  curren: '\u00A4',
  yen: '\u00A5',
  brvbar: '\u00A6',
  sect: '\u00A7',
  uml: '\u00A8',
  copy: '\u00A9',
  ordf: '\u00AA',
  laquo: '\u00AB',
  not: '\u00AC',
  shy: '\u00AD',
  reg: '\u00AE',
  macr: '\u00AF',
  deg: '\u00B0',
  plusmn: '\u00B1',
  sup2: '\u00B2',
  sup3: '\u00B3',
  acute: '\u00B4',
  micro: '\u00B5',
  para: '\u00B6',
  middot: '\u00B7',
  cedil: '\u00B8',
  sup1: '\u00B9',
  ordm: '\u00BA',
  raquo: '\u00BB',
  frac14: '\u00BC',
  frac12: '\u00BD',
  frac34: '\u00BE',
  iquest: '\u00BF',
  Agrave: '\u00C0',
  Aacute: '\u00C1',
  Acirc: '\u00C2',
  Atilde: '\u00C3',
  Auml: '\u00C4',
  Aring: '\u00C5',
  AElig: '\u00C6',
  Ccedil: '\u00C7',
  Egrave: '\u00C8',
  Eacute: '\u00C9',
  Ecirc: '\u00CA',
  Euml: '\u00CB',
  Igrave: '\u00CC',
  Iacute: '\u00CD',
  Icirc: '\u00CE',
  Iuml: '\u00CF',
  ETH: '\u00D0',
  Ntilde: '\u00D1',
  Ograve: '\u00D2',
  Oacute: '\u00D3',
  Ocirc: '\u00D4',
  Otilde: '\u00D5',
  Ouml: '\u00D6',
  times: '\u00D7',
  Oslash: '\u00D8',
  Ugrave: '\u00D9',
  Uacute: '\u00DA',
  Ucirc: '\u00DB',
  Uuml: '\u00DC',
  Yacute: '\u00DD',
  THORN: '\u00DE',
  szlig: '\u00DF',
  agrave: '\u00E0',
  aacute: '\u00E1',
  acirc: '\u00E2',
  atilde: '\u00E3',
  auml: '\u00E4',
  aring: '\u00E5',
  aelig: '\u00E6',
  ccedil: '\u00E7',
  egrave: '\u00E8',
  eacute: '\u00E9',
  ecirc: '\u00EA',
  euml: '\u00EB',
  igrave: '\u00EC',
  iacute: '\u00ED',
  icirc: '\u00EE',
  iuml: '\u00EF',
  eth: '\u00F0',
  ntilde: '\u00F1',
  ograve: '\u00F2',
  oacute: '\u00F3',
  ocirc: '\u00F4',
  otilde: '\u00F5',
  ouml: '\u00F6',
  divide: '\u00F7',
  oslash: '\u00F8',
  ugrave: '\u00F9',
  uacute: '\u00FA',
  ucirc: '\u00FB',
  uuml: '\u00FC',
  yacute: '\u00FD',
  thorn: '\u00FE',
  yuml: '\u00FF',
  OElig: '\u0152',
  oelig: '\u0153',
  Scaron: '\u0160',
  scaron: '\u0161',
  Yuml: '\u0178',
  fnof: '\u0192',
  circ: '\u02C6',
  tilde: '\u02DC',
  Alpha: '\u0391',
  Beta: '\u0392',
  Gamma: '\u0393',
  Delta: '\u0394',
  Epsilon: '\u0395',
  Zeta: '\u0396',
  Eta: '\u0397',
  Theta: '\u0398',
  Iota: '\u0399',
  Kappa: '\u039A',
  Lambda: '\u039B',
  Mu: '\u039C',
  Nu: '\u039D',
  Xi: '\u039E',
  Omicron: '\u039F',
  Pi: '\u03A0',
  Rho: '\u03A1',
  Sigma: '\u03A3',
  Tau: '\u03A4',
  Upsilon: '\u03A5',
  Phi: '\u03A6',
  Chi: '\u03A7',
  Psi: '\u03A8',
  Omega: '\u03A9',
  alpha: '\u03B1',
  beta: '\u03B2',
  gamma: '\u03B3',
  delta: '\u03B4',
  epsilon: '\u03B5',
  zeta: '\u03B6',
  eta: '\u03B7',
  theta: '\u03B8',
  iota: '\u03B9',
  kappa: '\u03BA',
  lambda: '\u03BB',
  mu: '\u03BC',
  nu: '\u03BD',
  xi: '\u03BE',
  omicron: '\u03BF',
  pi: '\u03C0',
  rho: '\u03C1',
  sigmaf: '\u03C2',
  sigma: '\u03C3',
  tau: '\u03C4',
  upsilon: '\u03C5',
  phi: '\u03C6',
  chi: '\u03C7',
  psi: '\u03C8',
  omega: '\u03C9',
  thetasym: '\u03D1',
  upsih: '\u03D2',
  piv: '\u03D6',
  ensp: '\u2002',
  emsp: '\u2003',
  thinsp: '\u2009',
  zwnj: '\u200C',
  zwj: '\u200D',
  lrm: '\u200E',
  rlm: '\u200F',
  ndash: '\u2013',
  mdash: '\u2014',
  lsquo: '\u2018',
  rsquo: '\u2019',
  sbquo: '\u201A',
  ldquo: '\u201C',
  rdquo: '\u201D',
  bdquo: '\u201E',
  dagger: '\u2020',
  Dagger: '\u2021',
  bull: '\u2022',
  hellip: '\u2026',
  permil: '\u2030',
  prime: '\u2032',
  Prime: '\u2033',
  lsaquo: '\u2039',
  rsaquo: '\u203A',
  oline: '\u203E',
  frasl: '\u2044',
  euro: '\u20AC',
  image: '\u2111',
  weierp: '\u2118',
  real: '\u211C',
  trade: '\u2122',
  alefsym: '\u2135',
  larr: '\u2190',
  uarr: '\u2191',
  rarr: '\u2192',
  darr: '\u2193',
  harr: '\u2194',
  crarr: '\u21B5',
  lArr: '\u21D0',
  uArr: '\u21D1',
  rArr: '\u21D2',
  dArr: '\u21D3',
  hArr: '\u21D4',
  forall: '\u2200',
  part: '\u2202',
  exist: '\u2203',
  empty: '\u2205',
  nabla: '\u2207',
  isin: '\u2208',
  notin: '\u2209',
  ni: '\u220B',
  prod: '\u220F',
  sum: '\u2211',
  minus: '\u2212',
  lowast: '\u2217',
  radic: '\u221A',
  prop: '\u221D',
  infin: '\u221E',
  ang: '\u2220',
  and: '\u2227',
  or: '\u2228',
  cap: '\u2229',
  cup: '\u222A',
  'int': '\u222B',
  there4: '\u2234',
  sim: '\u223C',
  cong: '\u2245',
  asymp: '\u2248',
  ne: '\u2260',
  equiv: '\u2261',
  le: '\u2264',
  ge: '\u2265',
  sub: '\u2282',
  sup: '\u2283',
  nsub: '\u2284',
  sube: '\u2286',
  supe: '\u2287',
  oplus: '\u2295',
  otimes: '\u2297',
  perp: '\u22A5',
  sdot: '\u22C5',
  lceil: '\u2308',
  rceil: '\u2309',
  lfloor: '\u230A',
  rfloor: '\u230B',
  lang: '\u2329',
  rang: '\u232A',
  loz: '\u25CA',
  spades: '\u2660',
  clubs: '\u2663',
  hearts: '\u2665',
  diams: '\u2666'
};

},
   {}],

"/node_modules/espree/package.json": [function(require,module,exports){
module.exports={
  "name": "espree",
  "description": "An Esprima-compatible JavaScript parser built on Acorn",
  "author": {
    "name": "Nicholas C. Zakas",
    "email": "nicholas+npm@nczconsulting.com"
  },
  "homepage": "https://github.com/eslint/espree",
  "main": "espree.js",
  "version": "3.1.1",
  "files": [
    "lib",
    "espree.js"
  ],
  "engines": {
    "node": ">=0.10.0"
  },
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/eslint/espree.git"
  },
  "bugs": {
    "url": "http://github.com/eslint/espree.git"
  },
  "license": "BSD-2-Clause",
  "dependencies": {
    "acorn": "^3.0.4",
    "acorn-jsx": "^2.0.1"
  },
  "devDependencies": {
    "browserify": "^7.0.0",
    "chai": "^1.10.0",
    "eslint": "^2.0.0-beta.1",
    "eslint-config-eslint": "^3.0.0",
    "eslint-release": "^0.3.0",
    "esprima": "latest",
    "esprima-fb": "^8001.2001.0-dev-harmony-fb",
    "istanbul": "~0.2.6",
    "json-diff": "~0.3.1",
    "leche": "^1.0.1",
    "mocha": "^2.0.1",
    "optimist": "~0.6.0",
    "regenerate": "~0.5.4",
    "shelljs": "^0.3.0",
    "shelljs-nodecli": "^0.1.1",
    "unicode-6.3.0": "~0.1.0"
  },
  "keywords": [
    "ast",
    "ecmascript",
    "javascript",
    "parser",
    "syntax",
    "acorn"
  ],
  "scripts": {
    "generate-regex": "node tools/generate-identifier-regex.js",
    "test": "npm run-script lint && node Makefile.js test",
    "lint": "node Makefile.js lint",
    "release": "eslint-release",
    "alpharelease": "eslint-prelease alpha",
    "betarelease": "eslint-prelease beta",
    "browserify": "node Makefile.js browserify"
  },
  "_id": "espree@3.1.1",
  "_shasum": "54d560a12bcf414a970d6527adaedd9f6d7ba95b",
  "_from": "espree@>=3.1.1 <4.0.0",
  "_npmVersion": "1.4.10",
  "_npmUser": {
    "name": "nzakas",
    "email": "nicholas@nczconsulting.com"
  },
  "maintainers": [
    {
      "name": "nzakas",
      "email": "nicholas@nczconsulting.com"
    }
  ],
  "dist": {
    "shasum": "54d560a12bcf414a970d6527adaedd9f6d7ba95b",
    "tarball": "http://registry.npmjs.org/espree/-/espree-3.1.1.tgz"
  },
  "_npmOperationalInternal": {
    "host": "packages-6-west.internal.npmjs.com",
    "tmp": "tmp/espree-3.1.1.tgz_1456510901064_0.6160593316890299"
  },
  "directories": {},
  "_resolved": "https://registry.npmjs.org/espree/-/espree-3.1.1.tgz",
  "readme": "ERROR: No README data found!"
}

},
   {}],

"espree": [function(require,module,exports){
"use strict";

var astNodeTypes = require("./lib/ast-node-types"),
    commentAttachment = require("./lib/comment-attachment"),
    TokenTranslator = require("./lib/token-translator"),
    acornJSX = require("acorn-jsx/inject"),
    rawAcorn = require("acorn");


var acorn = acornJSX(rawAcorn);

var lookahead,
    extra,
    lastToken;

function resetExtra() {
    extra = {
        tokens: null,
        range: false,
        loc: false,
        comment: false,
        comments: [],
        tolerant: true,
        errors: [],
        strict: false,
        ecmaFeatures: {},
        ecmaVersion: 5,
        isModule: false
    };
}



var tt = acorn.tokTypes,
    getLineInfo = acorn.getLineInfo;

tt.jsxAttrValueToken = {};

function isValidNode(node) {
    return true;
}

function esprimaFinishNode(result) {
    if (!isValidNode(result)) {
        this.unexpected(result.start);
    }

    if (result.type === "TryStatement") {
        delete result.guardedHandlers;
    } else if (result.type === "CatchClause") {
        delete result.guard;
    }

    if (result.type === "TemplateElement") {

        var terminalDollarBraceL = this.input.slice(result.end, result.end + 2) === "${";

        if (result.range) {
            result.range[0]--;
            result.range[1] += (terminalDollarBraceL ? 2 : 1);
        }

        if (result.loc) {
            result.loc.start.column--;
            result.loc.end.column += (terminalDollarBraceL ? 2 : 1);
        }
    }

    if (result.type === "ExportDefaultDeclaration") {
        if (/^(Class|Function)Expression$/.test(result.declaration.type)) {
            result.declaration.type = result.declaration.type.replace("Expression", "Declaration");
        }
    }

    if (result.type === "Literal" && result.value === undefined) {
        result.value = null;
    }

    if (extra.attachComment) {
        commentAttachment.processComment(result);
    }

    if (result.type.indexOf("Function") > -1 && !result.generator) {
        result.generator = false;
    }

    return result;
}

function isValidToken(parser) {
    return true;
}

function wrapFinishNode(finishNode) {
    return /** @this acorn.Parser */ function(node, type, pos, loc) {
        var result = finishNode.call(this, node, type, pos, loc);
        return esprimaFinishNode.call(this, result);
    };
}

acorn.plugins.espree = function(instance) {

    instance.extend("finishNode", wrapFinishNode);

    instance.extend("finishNodeAt", wrapFinishNode);

    instance.extend("next", function(next) {
        return /** @this acorn.Parser */ function() {
            if (!isValidToken(this)) {
                this.unexpected();
            }
            return next.call(this);
        };
    });

    instance.extend("checkLVal", function(checkLVal) {

        return /** @this acorn.Parser */ function(expr, isBinding, checkClashes) {

            if (extra.ecmaFeatures.experimentalObjectRestSpread && expr.type === "ObjectPattern") {
                for (var i = 0; i < expr.properties.length; i++) {
                    if (expr.properties[i].type.indexOf("Experimental") === -1) {
                        this.checkLVal(expr.properties[i].value, isBinding, checkClashes);
                    }
                }
                return undefined;
            }

            return checkLVal.call(this, expr, isBinding, checkClashes);
        };
    });

    instance.extend("parseTopLevel", function(parseTopLevel) {
        return /** @this acorn.Parser */ function(node) {
            if (extra.ecmaFeatures.impliedStrict && this.options.ecmaVersion >= 5) {
                this.strict = true;
            }
            return parseTopLevel.call(this, node);
        };
    });

    instance.extend("toAssignable", function(toAssignable) {

        return /** @this acorn.Parser */ function(node, isBinding) {

            if (extra.ecmaFeatures.experimentalObjectRestSpread &&
                    node.type === "ObjectExpression"
            ) {
                node.type = "ObjectPattern";

                for (var i = 0; i < node.properties.length; i++) {
                    var prop = node.properties[i];

                    if (prop.type === "ExperimentalSpreadProperty") {
                        prop.type = "ExperimentalRestProperty";
                    } else if (prop.kind !== "init") {
                        this.raise(prop.key.start, "Object pattern can't contain getter or setter");
                    } else {
                        this.toAssignable(prop.value, isBinding);
                    }
                }

                return node;
            } else {
                return toAssignable.call(this, node, isBinding);
            }
        };

    });

    instance.parseObjectRest = function() {
        var node = this.startNode();
        this.next();
        node.argument = this.parseIdent();
        return this.finishNode(node, "ExperimentalRestProperty");
    };

    instance.parseObj = function(isPattern, refShorthandDefaultPos) {
        var node = this.startNode(),
            first = true,
            propHash = {};
        node.properties = [];
        this.next();
        while (!this.eat(tt.braceR)) {

            if (!first) {
                this.expect(tt.comma);

                if (this.afterTrailingComma(tt.braceR)) {
                    break;
                }

            } else {
                first = false;
            }

            if (this.value == "async" && /^[ \t]*\w+/.test(this.input.slice(this.end)))
                this.next();
            
            var prop = this.startNode(),
                isGenerator,
                startPos,
                startLoc;

            if (extra.ecmaFeatures.experimentalObjectRestSpread && this.type === tt.ellipsis) {
                if (isPattern) {
                    prop = this.parseObjectRest();
                } else {
                    prop = this.parseSpread();
                    prop.type = "ExperimentalSpreadProperty";
                }

                node.properties.push(prop);
                continue;
            }

            if (this.options.ecmaVersion >= 6) {
                prop.method = false;
                prop.shorthand = false;

                if (isPattern || refShorthandDefaultPos) {
                    startPos = this.start;
                    startLoc = this.startLoc;
                }

                if (!isPattern) {
                    isGenerator = this.eat(tt.star);
                }
            }

            this.parsePropertyName(prop);
            this.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refShorthandDefaultPos);
            this.checkPropClash(prop, propHash);
            node.properties.push(this.finishNode(prop, "Property"));
        }

        return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
    };

    instance.raise = instance.raiseRecoverable = function(pos, message) {
        var loc = getLineInfo(this.input, pos);
        var err = new SyntaxError(message);
        err.index = pos;
        err.lineNumber = loc.line;
        err.column = loc.column; // acorn uses 0-based columns
        throw err;
    };

    instance.unexpected = function(pos) {
        var message = "Unexpected token";

        if (pos !== null && pos !== undefined) {
            this.pos = pos;

            if (this.options.locations) {
                while (this.pos < this.lineStart) {
                    this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
                    --this.curLine;
                }
            }

            this.nextToken();
        }

        if (this.end > this.start) {
            message += " " + this.input.slice(this.start, this.end);
        }

        this.raise(this.start, message);
    };

    instance.extend("jsx_readString", function(jsxReadString) {
        return /** @this acorn.Parser */ function(quote) {
            var result = jsxReadString.call(this, quote);
            if (this.type === tt.string) {
                extra.jsxAttrValueToken = true;
            }

            return result;
        };
    });
};

function tokenize(code, options) {
    var toString,
        tokens,
        impliedStrict,
        translator = new TokenTranslator(tt, code);

    toString = String;
    if (typeof code !== "string" && !(code instanceof String)) {
        code = toString(code);
    }

    lookahead = null;

    options = options || {};

    var acornOptions = {
        ecmaVersion: 5,
        plugins: {
            espree: true
        }
    };

    resetExtra();

    options.tokens = true;
    extra.tokens = [];

    extra.range = (typeof options.range === "boolean") && options.range;
    acornOptions.ranges = extra.range;

    extra.loc = (typeof options.loc === "boolean") && options.loc;
    acornOptions.locations = extra.loc;

    extra.comment = typeof options.comment === "boolean" && options.comment;

    if (extra.comment) {
        acornOptions.onComment = function() {
            var comment = convertAcornCommentToEsprimaComment.apply(this, arguments);
            extra.comments.push(comment);
        };
    }

    extra.tolerant = typeof options.tolerant === "boolean" && options.tolerant;

    if (typeof options.ecmaVersion === "number") {
        switch (options.ecmaVersion) {
            case 3:
            case 5:
            case 6:
            case 7:
                acornOptions.ecmaVersion = options.ecmaVersion;
                extra.ecmaVersion = options.ecmaVersion;
                break;

            default:
                throw new Error("ecmaVersion must be 3, 5, 6, or 7.");
        }
    }

    if (options.ecmaFeatures && typeof options.ecmaFeatures === "object") {
        extra.ecmaFeatures = options.ecmaFeatures;
        impliedStrict = extra.ecmaFeatures.impliedStrict;
        extra.ecmaFeatures.impliedStrict = typeof impliedStrict === "boolean" && impliedStrict;
    }

    try {
        var tokenizer = acorn.tokenizer(code, acornOptions);
        while ((lookahead = tokenizer.getToken()).type !== tt.eof) {
            translator.onToken(lookahead, extra);
        }

        tokens = extra.tokens;

        if (extra.comment) {
            tokens.comments = extra.comments;
        }
        if (extra.tolerant) {
            tokens.errors = extra.errors;
        }
    } catch (e) {
        throw e;
    }
    return tokens;
}



function convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc) {
    var comment = {
        type: block ? "Block" : "Line",
        value: text
    };

    if (typeof start === "number") {
        comment.start = start;
        comment.end = end;
        comment.range = [start, end];
    }

    if (typeof startLoc === "object") {
        comment.loc = {
            start: startLoc,
            end: endLoc
        };
    }

    return comment;
}

function parse(code, options) {
    var program,
        toString = String,
        translator,
        impliedStrict,
        acornOptions = {
            ecmaVersion: 5,
            plugins: {
                espree: true
            }
        };

    lastToken = null;

    if (typeof code !== "string" && !(code instanceof String)) {
        code = toString(code);
    }

    resetExtra();
    commentAttachment.reset();

    if (typeof options !== "undefined") {
        extra.range = (typeof options.range === "boolean") && options.range;
        extra.loc = (typeof options.loc === "boolean") && options.loc;
        extra.attachComment = (typeof options.attachComment === "boolean") && options.attachComment;

        if (extra.loc && options.source !== null && options.source !== undefined) {
            extra.source = toString(options.source);
        }

        if (typeof options.tokens === "boolean" && options.tokens) {
            extra.tokens = [];
            translator = new TokenTranslator(tt, code);
        }
        if (typeof options.comment === "boolean" && options.comment) {
            extra.comment = true;
            extra.comments = [];
        }
        if (typeof options.tolerant === "boolean" && options.tolerant) {
            extra.errors = [];
        }
        if (extra.attachComment) {
            extra.range = true;
            extra.comments = [];
            commentAttachment.reset();
        }

        if (typeof options.ecmaVersion === "number") {
            switch (options.ecmaVersion) {
                case 3:
                case 5:
                case 6:
                case 7:
                    acornOptions.ecmaVersion = options.ecmaVersion;
                    extra.ecmaVersion = options.ecmaVersion;
                    break;

                default:
                    throw new Error("ecmaVersion must be 3, 5, 6, or 7.");
            }
        }

        if (options.sourceType === "module") {
            extra.isModule = true;

            if (acornOptions.ecmaVersion < 6) {
                acornOptions.ecmaVersion = 6;
                extra.ecmaVersion = 6;
            }

            acornOptions.sourceType = "module";
        }

        if (options.ecmaFeatures && typeof options.ecmaFeatures === "object") {
            extra.ecmaFeatures = options.ecmaFeatures;
            impliedStrict = extra.ecmaFeatures.impliedStrict;
            extra.ecmaFeatures.impliedStrict = typeof impliedStrict === "boolean" && impliedStrict;
            if (options.ecmaFeatures.globalReturn) {
                acornOptions.allowReturnOutsideFunction = true;
            }
        }


        acornOptions.onToken = function(token) {
            if (extra.tokens) {
                translator.onToken(token, extra);
            }
            if (token.type !== tt.eof) {
                lastToken = token;
            }
        };

        if (extra.attachComment || extra.comment) {
            acornOptions.onComment = function() {
                var comment = convertAcornCommentToEsprimaComment.apply(this, arguments);
                extra.comments.push(comment);

                if (extra.attachComment) {
                    commentAttachment.addComment(comment);
                }
            };
        }

        if (extra.range) {
            acornOptions.ranges = true;
        }

        if (extra.loc) {
            acornOptions.locations = true;
        }

        if (extra.ecmaFeatures.jsx) {
            acornOptions.plugins = {
                jsx: true,
                espree: true
            };
        }
    }

    program = acorn.parse(code, acornOptions);
    program.sourceType = extra.isModule ? "module" : "script";

    if (extra.comment || extra.attachComment) {
        program.comments = extra.comments;
    }

    if (extra.tokens) {
        program.tokens = extra.tokens;
    }

    if (program.range) {
        program.range[0] = program.body.length ? program.body[0].range[0] : program.range[0];
        program.range[1] = lastToken ? lastToken.range[1] : program.range[1];
    }

    if (program.loc) {
        program.loc.start = program.body.length ? program.body[0].loc.start : program.loc.start;
        program.loc.end = lastToken ? lastToken.loc.end : program.loc.end;
    }

    return program;
}

exports.version = require("./package.json").version;

exports.tokenize = tokenize;

exports.parse = parse;

exports.Syntax = (function() {
    var name, types = {};

    if (typeof Object.create === "function") {
        types = Object.create(null);
    }

    for (name in astNodeTypes) {
        if (astNodeTypes.hasOwnProperty(name)) {
            types[name] = astNodeTypes[name];
        }
    }

    if (typeof Object.freeze === "function") {
        Object.freeze(types);
    }

    return types;
}());

exports.VisitorKeys = (function() {
    var visitorKeys = require("./lib/visitor-keys");
    var name,
        keys = {};

    if (typeof Object.create === "function") {
        keys = Object.create(null);
    }

    for (name in visitorKeys) {
        if (visitorKeys.hasOwnProperty(name)) {
            keys[name] = visitorKeys[name];
        }
    }

    if (typeof Object.freeze === "function") {
        Object.freeze(keys);
    }

    return keys;
}());

},
   {"./lib/ast-node-types":"/node_modules/espree/lib/ast-node-types.js","./lib/comment-attachment":"/node_modules/espree/lib/comment-attachment.js","./lib/token-translator":"/node_modules/espree/lib/token-translator.js","./lib/visitor-keys":"/node_modules/espree/lib/visitor-keys.js","./package.json":"/node_modules/espree/package.json","acorn":"/../acorn/dist/acorn.js","acorn-jsx/inject":"/node_modules/espree/node_modules/acorn-jsx/inject.js"}]},{},[]);

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.eslint = f()}})(function(){var define,module,exports;return (function outer (modules, cache, entry) {
    var previousRequire = typeof require == "function" && require;

    function newRequire(name, jumped){
        if(!cache[name]) {
            if(!modules[name]) {
                var currentRequire = typeof require == "function" && require;
                if (!jumped && currentRequire) return currentRequire(name, true);

                if (previousRequire) return previousRequire(name, true);
                var err = new Error('Cannot find module \'' + name + '\'');
                err.code = 'MODULE_NOT_FOUND';
                throw err;
            }
            var m = cache[name] = {exports:{}};
            modules[name][0].call(m.exports, function(x){
                var id = modules[name][1][x];
                return newRequire(id ? id : x);
            },m,m.exports,outer,modules,cache,entry);
        }
        return cache[name].exports;
    }
    for(var i=0;i<entry.length;i++) newRequire(entry[i]);

    return newRequire;
})({
"/conf/blank-script.json": [function(require,module,exports){
module.exports={
  "type": "Program",
  "body": [],
  "sourceType": "script",
  "range": [
    0,
    0
  ],
  "loc": {
    "start": {
      "line": 0,
      "column": 0
    },
    "end": {
      "line": 0,
      "column": 0
    }
  },
  "comments": [],
  "tokens": []
}

},
   {}],

"/conf/environments.js": [function(require,module,exports){
"use strict";

var globals = require("globals");

module.exports = {
    builtin: globals.es6,
    browser: {
        globals: globals.browser
    },
    node: {
        globals: globals.node,
        parserOptions: {
            ecmaFeatures: {
                globalReturn: true
            }
        }
    },
    commonjs: {
        globals: globals.commonjs,
        parserOptions: {
            ecmaFeatures: {
                globalReturn: true
            }
        }
    },
    "shared-node-browser": {
        globals: globals["shared-node-browser"]
    },
    worker: {
        globals: globals.worker
    },
    amd: {
        globals: globals.amd
    },
    mocha: {
        globals: globals.mocha
    },
    jasmine: {
        globals: globals.jasmine
    },
    jest: {
        globals: globals.jest
    },
    phantomjs: {
        globals: globals.phantomjs
    },
    jquery: {
        globals: globals.jquery
    },
    qunit: {
        globals: globals.qunit
    },
    prototypejs: {
        globals: globals.prototypejs
    },
    shelljs: {
        globals: globals.shelljs
    },
    meteor: {
        globals: globals.meteor
    },
    mongo: {
        globals: globals.mongo
    },
    protractor: {
        globals: globals.protractor
    },
    applescript: {
        globals: globals.applescript
    },
    nashorn: {
        globals: globals.nashorn
    },
    serviceworker: {
        globals: globals.serviceworker
    },
    atomtest: {
        globals: globals.atomtest
    },
    embertest: {
        globals: globals.embertest
    },
    webextensions: {
        globals: globals.webextensions
    },
    es6: {
        globals: globals.es6,
        parserOptions: {
            ecmaVersion: 6
        }
    },
    greasemonkey: {
        globals: globals.greasemonkey
    }
};

},
   {"globals":"/node_modules/globals/index.js"}],

"/conf/eslint.json": [function(require,module,exports){
module.exports={
    "parser": "espree",
    "ecmaFeatures": {},
    "rules": {
        "no-alert": "off",
        "no-array-constructor": "off",
        "no-bitwise": "off",
        "no-caller": "off",
        "no-case-declarations": "error",
        "no-catch-shadow": "off",
        "no-class-assign": "error",
        "no-cond-assign": "error",
        "no-confusing-arrow": "off",
        "no-console": "error",
        "no-const-assign": "error",
        "no-constant-condition": "error",
        "no-continue": "off",
        "no-control-regex": "error",
        "no-debugger": "error",
        "no-delete-var": "error",
        "no-div-regex": "off",
        "no-dupe-class-members": "error",
        "no-dupe-keys": "error",
        "no-dupe-args": "error",
        "no-duplicate-case": "error",
        "no-else-return": "off",
        "no-empty": "error",
        "no-empty-character-class": "error",
        "no-empty-function": "off",
        "no-empty-pattern": "error",
        "no-eq-null": "off",
        "no-eval": "off",
        "no-ex-assign": "error",
        "no-extend-native": "off",
        "no-extra-bind": "off",
        "no-extra-boolean-cast": "error",
        "no-extra-label": "off",
        "no-extra-parens": "off",
        "no-extra-semi": "error",
        "no-fallthrough": "error",
        "no-floating-decimal": "off",
        "no-func-assign": "error",
        "no-implicit-coercion": "off",
        "no-implicit-globals": "off",
        "no-implied-eval": "off",
        "no-inline-comments": "off",
        "no-inner-declarations": "error",
        "no-invalid-regexp": "error",
        "no-invalid-this": "off",
        "no-irregular-whitespace": "error",
        "no-iterator": "off",
        "no-label-var": "off",
        "no-labels": "off",
        "no-lone-blocks": "off",
        "no-lonely-if": "off",
        "no-loop-func": "off",
        "no-mixed-requires": "off",
        "no-mixed-spaces-and-tabs": "error",
        "linebreak-style": "off",
        "no-multi-spaces": "off",
        "no-multi-str": "off",
        "no-multiple-empty-lines": "off",
        "no-native-reassign": "off",
        "no-negated-condition": "off",
        "no-negated-in-lhs": "error",
        "no-nested-ternary": "off",
        "no-new": "off",
        "no-new-func": "off",
        "no-new-object": "off",
        "no-new-require": "off",
        "no-new-symbol": "error",
        "no-new-wrappers": "off",
        "no-obj-calls": "error",
        "no-octal": "error",
        "no-octal-escape": "off",
        "no-param-reassign": "off",
        "no-path-concat": "off",
        "no-plusplus": "off",
        "no-process-env": "off",
        "no-process-exit": "off",
        "no-proto": "off",
        "no-redeclare": "error",
        "no-regex-spaces": "error",
        "no-restricted-globals": "off",
        "no-restricted-imports": "off",
        "no-restricted-modules": "off",
        "no-restricted-syntax": "off",
        "no-return-assign": "off",
        "no-script-url": "off",
        "no-self-assign": "error",
        "no-self-compare": "off",
        "no-sequences": "off",
        "no-shadow": "off",
        "no-shadow-restricted-names": "off",
        "no-whitespace-before-property": "off",
        "no-spaced-func": "off",
        "no-sparse-arrays": "error",
        "no-sync": "off",
        "no-ternary": "off",
        "no-trailing-spaces": "off",
        "no-this-before-super": "error",
        "no-throw-literal": "off",
        "no-undef": "error",
        "no-undef-init": "off",
        "no-undefined": "off",
        "no-unexpected-multiline": "error",
        "no-underscore-dangle": "off",
        "no-unmodified-loop-condition": "off",
        "no-unneeded-ternary": "off",
        "no-unreachable": "error",
        "no-unused-expressions": "off",
        "no-unused-labels": "error",
        "no-unused-vars": "error",
        "no-use-before-define": "off",
        "no-useless-call": "off",
        "no-useless-concat": "off",
        "no-useless-constructor": "off",
        "no-void": "off",
        "no-var": "off",
        "no-warning-comments": "off",
        "no-with": "off",
        "no-magic-numbers": "off",
        "array-bracket-spacing": "off",
        "array-callback-return": "off",
        "arrow-body-style": "off",
        "arrow-parens": "off",
        "arrow-spacing": "off",
        "accessor-pairs": "off",
        "block-scoped-var": "off",
        "block-spacing": "off",
        "brace-style": "off",
        "callback-return": "off",
        "camelcase": "off",
        "comma-dangle": "error",
        "comma-spacing": "off",
        "comma-style": "off",
        "complexity": ["off", 11],
        "computed-property-spacing": "off",
        "consistent-return": "off",
        "consistent-this": "off",
        "constructor-super": "error",
        "curly": "off",
        "default-case": "off",
        "dot-location": "off",
        "dot-notation": "off",
        "eol-last": "off",
        "eqeqeq": "off",
        "func-names": "off",
        "func-style": "off",
        "generator-star-spacing": "off",
        "global-require": "off",
        "guard-for-in": "off",
        "handle-callback-err": "off",
        "id-length": "off",
        "indent": "off",
        "init-declarations": "off",
        "jsx-quotes": "off",
        "key-spacing": "off",
        "keyword-spacing": "off",
        "lines-around-comment": "off",
        "max-depth": "off",
        "max-len": "off",
        "max-nested-callbacks": "off",
        "max-params": "off",
        "max-statements": "off",
        "new-cap": "off",
        "new-parens": "off",
        "newline-after-var": "off",
        "newline-before-return": "off",
        "newline-per-chained-call": "off",
        "object-curly-spacing": ["off", "never"],
        "object-shorthand": "off",
        "one-var": "off",
        "one-var-declaration-per-line": "off",
        "operator-assignment": "off",
        "operator-linebreak": "off",
        "padded-blocks": "off",
        "prefer-arrow-callback": "off",
        "prefer-const": "off",
        "prefer-reflect": "off",
        "prefer-rest-params": "off",
        "prefer-spread": "off",
        "prefer-template": "off",
        "quote-props": "off",
        "quotes": "off",
        "radix": "off",
        "id-match": "off",
        "id-blacklist": "off",
        "require-jsdoc": "off",
        "require-yield": "off",
        "semi": "off",
        "semi-spacing": "off",
        "sort-vars": "off",
        "sort-imports": "off",
        "space-before-blocks": "off",
        "space-before-function-paren": "off",
        "space-in-parens": "off",
        "space-infix-ops": "off",
        "space-unary-ops": "off",
        "spaced-comment": "off",
        "strict": "off",
        "template-curly-spacing": "off",
        "use-isnan": "error",
        "valid-jsdoc": "off",
        "valid-typeof": "error",
        "vars-on-top": "off",
        "wrap-iife": "off",
        "wrap-regex": "off",
        "yield-star-spacing": "off",
        "yoda": "off"
    }
}

},
   {}],

"/conf/replacements.json": [function(require,module,exports){
module.exports={
    "rules": {
        "generator-star": ["generator-star-spacing"],
        "global-strict": ["strict"],
        "no-arrow-condition": ["no-confusing-arrow", "no-constant-condition"],
        "no-comma-dangle": ["comma-dangle"],
        "no-empty-class": ["no-empty-character-class"],
        "no-empty-label": ["no-labels"],
        "no-extra-strict": ["strict"],
        "no-reserved-keys": ["quote-props"],
        "no-space-before-semi": ["semi-spacing"],
        "no-wrap-func": ["no-extra-parens"],
        "space-after-function-name": ["space-before-function-paren"],
        "space-after-keywords": ["keyword-spacing"],
        "space-before-function-parentheses": ["space-before-function-paren"],
        "space-before-keywords": ["keyword-spacing"],
        "space-in-brackets": ["object-curly-spacing", "array-bracket-spacing", "computed-property-spacing"],
        "space-return-throw-case": ["keyword-spacing"],
        "space-unary-word-ops": ["space-unary-ops"],
        "spaced-line-comment": ["spaced-comment"]
    }
}

},
   {}],

"/node_modules/browserify/node_modules/assert/assert.js": [function(require,module,exports){
var util = require('util/');

var pSlice = Array.prototype.slice;
var hasOwn = Object.prototype.hasOwnProperty;

var assert = module.exports = ok;

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
  else {
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      var fn_name = stackStartFunction.name;
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && !isFinite(value)) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

assert.fail = fail;

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  if (a.prototype !== b.prototype) return false;
  if (util.isPrimitive(a) || util.isPrimitive(b)) {
    return a === b;
  }
  var aIsArgs = isArguments(a),
      bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  var ka = objectKeys(a),
      kb = objectKeys(b),
      key, i;
  if (ka.length != kb.length)
    return false;
  ka.sort();
  kb.sort();
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

},
   {"util/":"/node_modules/browserify/node_modules/util/util.js"}],

"/node_modules/browserify/node_modules/events/events.js": [function(require,module,exports){
function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

EventEmitter.defaultMaxListeners = 10;

EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    this._events[type].push(listener);
  else
    this._events[type] = [this._events[type], listener];

  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},
   {}],

"/node_modules/browserify/node_modules/inherits/inherits_browser.js": [function(require,module,exports){
if (typeof Object.create === 'function') {
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},
   {}],

"/node_modules/browserify/node_modules/path-browserify/index.js": [function(require,module,exports){
(function (process){
function normalizeArray(parts, allowAboveRoot) {
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    return '.';
  }

  if (dir) {
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))
},
   {"_process":"/node_modules/browserify/node_modules/process/browser.js"}],

"/node_modules/browserify/node_modules/process/browser.js": [function(require,module,exports){
var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},
   {}],

"/node_modules/browserify/node_modules/util/support/isBufferBrowser.js": [function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},
   {}],

"/node_modules/browserify/node_modules/util/util.js": [function(require,module,exports){
(function (process,global){
var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


exports.deprecate = function(fn, msg) {
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


function inspect(obj, opts) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    ctx.showHidden = opts;
  } else if (opts) {
    exports._extend(ctx, opts);
  }
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      value.inspect !== exports.inspect &&
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},
   {"./support/isBuffer":"/node_modules/browserify/node_modules/util/support/isBufferBrowser.js","_process":"/node_modules/browserify/node_modules/process/browser.js","inherits":"/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],

"/node_modules/debug/browser.js": [function(require,module,exports){

exports = module.exports = require('./debug');

},
   {"./debug":"/node_modules/debug/debug.js"}],

"/node_modules/debug/debug.js": [function(require,module,exports){

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

exports.names = [];
exports.skips = [];

exports.formatters = {};

var prevColor = 0;

var prevTime;

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

function debug(namespace) {

  function disabled() {
  }
  disabled.enabled = false;

  function enabled() {

    var self = enabled;

    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      args = ['%o'].concat(args);
    }

    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

function disable() {
  exports.enable('');
}

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},
   {"ms":"/node_modules/debug/node_modules/ms/index.js"}],

"/node_modules/debug/node_modules/ms/index.js": [function(require,module,exports){
var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

function parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},
   {}],

"/node_modules/doctrine/lib/doctrine.js": [function(require,module,exports){
(function () {
    'use strict';

    var typed,
        utility,
        isArray,
        jsdoc,
        esutils,
        hasOwnProperty;

    esutils = require('esutils');
    isArray = require('isarray');
    typed = require('./typed');
    utility = require('./utility');

    function sliceSource(source, index, last) {
        return source.slice(index, last);
    }

    hasOwnProperty = (function () {
        var func = Object.prototype.hasOwnProperty;
        return function hasOwnProperty(obj, name) {
            return func.call(obj, name);
        };
    }());

    function shallowCopy(obj) {
        var ret = {}, key;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }

    function isASCIIAlphanumeric(ch) {
        return (ch >= 0x61  /* 'a' */ && ch <= 0x7A  /* 'z' */) ||
            (ch >= 0x41  /* 'A' */ && ch <= 0x5A  /* 'Z' */) ||
            (ch >= 0x30  /* '0' */ && ch <= 0x39  /* '9' */);
    }

    function isParamTitle(title) {
        return title === 'param' || title === 'argument' || title === 'arg';
    }

    function isReturnTitle(title) {
        return title === 'return' || title === 'returns';
    }

    function isProperty(title) {
        return title === 'property' || title === 'prop';
    }

    function isNameParameterRequired(title) {
        return isParamTitle(title) || isProperty(title) ||
            title === 'alias' || title === 'this' || title === 'mixes' || title === 'requires';
    }

    function isAllowedName(title) {
        return isNameParameterRequired(title) || title === 'const' || title === 'constant';
    }

    function isAllowedNested(title) {
        return isProperty(title) || isParamTitle(title);
    }

    function isTypeParameterRequired(title) {
        return isParamTitle(title) || isReturnTitle(title) ||
            title === 'define' || title === 'enum' ||
            title === 'implements' || title === 'this' ||
            title === 'type' || title === 'typedef' || isProperty(title);
    }

    function isAllowedType(title) {
        return isTypeParameterRequired(title) || title === 'throws' || title === 'const' || title === 'constant' ||
            title === 'namespace' || title === 'member' || title === 'var' || title === 'module' ||
            title === 'constructor' || title === 'class' || title === 'extends' || title === 'augments' ||
            title === 'public' || title === 'private' || title === 'protected';
    }

    function trim(str) {
        return str.replace(/^\s+/, '').replace(/\s+$/, '');
    }

    function unwrapComment(doc) {
        var BEFORE_STAR = 0,
            STAR = 1,
            AFTER_STAR = 2,
            index,
            len,
            mode,
            result,
            ch;

        doc = doc.replace(/^\/\*\*?/, '').replace(/\*\/$/, '');
        index = 0;
        len = doc.length;
        mode = BEFORE_STAR;
        result = '';

        while (index < len) {
            ch = doc.charCodeAt(index);
            switch (mode) {
            case BEFORE_STAR:
                if (esutils.code.isLineTerminator(ch)) {
                    result += String.fromCharCode(ch);
                } else if (ch === 0x2A  /* '*' */) {
                    mode = STAR;
                } else if (!esutils.code.isWhiteSpace(ch)) {
                    result += String.fromCharCode(ch);
                    mode = AFTER_STAR;
                }
                break;

            case STAR:
                if (!esutils.code.isWhiteSpace(ch)) {
                    result += String.fromCharCode(ch);
                }
                mode = esutils.code.isLineTerminator(ch) ? BEFORE_STAR : AFTER_STAR;
                break;

            case AFTER_STAR:
                result += String.fromCharCode(ch);
                if (esutils.code.isLineTerminator(ch)) {
                    mode = BEFORE_STAR;
                }
                break;
            }
            index += 1;
        }

        return result.replace(/\s+$/, '');
    }

    (function (exports) {
        var Rules,
            index,
            lineNumber,
            length,
            source,
            recoverable,
            sloppy,
            strict;

        function advance() {
            var ch = source.charCodeAt(index);
            index += 1;
            if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D  /* '\r' */ && source.charCodeAt(index) === 0x0A  /* '\n' */)) {
                lineNumber += 1;
            }
            return String.fromCharCode(ch);
        }

        function scanTitle() {
            var title = '';
            advance();

            while (index < length && isASCIIAlphanumeric(source.charCodeAt(index))) {
                title += advance();
            }

            return title;
        }

        function seekContent() {
            var ch, waiting, last = index;

            waiting = false;
            while (last < length) {
                ch = source.charCodeAt(last);
                if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D  /* '\r' */ && source.charCodeAt(last + 1) === 0x0A  /* '\n' */)) {
                    waiting = true;
                } else if (waiting) {
                    if (ch === 0x40  /* '@' */) {
                        break;
                    }
                    if (!esutils.code.isWhiteSpace(ch)) {
                        waiting = false;
                    }
                }
                last += 1;
            }
            return last;
        }

        function parseType(title, last) {
            var ch, brace, type, direct = false;


            while (index < last) {
                ch = source.charCodeAt(index);
                if (esutils.code.isWhiteSpace(ch)) {
                    advance();
                } else if (ch === 0x7B  /* '{' */) {
                    advance();
                    break;
                } else {
                    direct = true;
                    break;
                }
            }


            if (direct) {
                return null;
            }

            brace = 1;
            type = '';
            while (index < last) {
                ch = source.charCodeAt(index);
                if (esutils.code.isLineTerminator(ch)) {
                    advance();
                } else {
                    if (ch === 0x7D  /* '}' */) {
                        brace -= 1;
                        if (brace === 0) {
                            advance();
                            break;
                        }
                    } else if (ch === 0x7B  /* '{' */) {
                        brace += 1;
                    }
                    type += advance();
                }
            }

            if (brace !== 0) {
                return utility.throwError('Braces are not balanced');
            }

            if (isParamTitle(title)) {
                return typed.parseParamType(type);
            }
            return typed.parseType(type);
        }

        function scanIdentifier(last) {
            var identifier;
            if (!esutils.code.isIdentifierStart(source.charCodeAt(index))) {
                return null;
            }
            identifier = advance();
            while (index < last && esutils.code.isIdentifierPart(source.charCodeAt(index))) {
                identifier += advance();
            }
            return identifier;
        }

        function skipWhiteSpace(last) {
            while (index < last && (esutils.code.isWhiteSpace(source.charCodeAt(index)) || esutils.code.isLineTerminator(source.charCodeAt(index)))) {
                advance();
            }
        }

        function parseName(last, allowBrackets, allowNestedParams) {
            var name = '', useBrackets;

            skipWhiteSpace(last);

            if (index >= last) {
                return null;
            }

            if (allowBrackets && source.charCodeAt(index) === 0x5B  /* '[' */) {
                useBrackets = true;
                name = advance();
            }

            if (!esutils.code.isIdentifierStart(source.charCodeAt(index))) {
                return null;
            }

            name += scanIdentifier(last);

            if (allowNestedParams) {
                if (source.charCodeAt(index) === 0x3A /* ':' */ && (
                        name === 'module' ||
                        name === 'external' ||
                        name === 'event')) {
                    name += advance();
                    name += scanIdentifier(last);

                }
                if(source.charCodeAt(index) === 0x5B  /* '[' */ && source.charCodeAt(index + 1) === 0x5D  /* ']' */){
                    name += advance();
                    name += advance();
                }
                while (source.charCodeAt(index) === 0x2E  /* '.' */ ||
                        source.charCodeAt(index) === 0x2F  /* '/' */ ||
                        source.charCodeAt(index) === 0x23  /* '#' */ ||
                        source.charCodeAt(index) === 0x7E  /* '~' */) {
                    name += advance();
                    name += scanIdentifier(last);
                }
            }

            if (useBrackets) {
                skipWhiteSpace(last);
                if (source.charCodeAt(index) === 0x3D  /* '=' */) {
                    name += advance();
                    skipWhiteSpace(last);

                    var ch;
                    var bracketDepth = 1;
                    while (index < last) {
                        ch = source.charCodeAt(index);

                        if (esutils.code.isWhiteSpace(ch)) {
                            skipWhiteSpace(last);
                            ch = source.charCodeAt(index);
                        }

                        if (ch === 0x5B /* '[' */) {
                            bracketDepth++;
                        } else if (ch === 0x5D  /* ']' */ &&
                            --bracketDepth === 0) {
                            break;
                        }

                        name += advance();
                    }
                }

                skipWhiteSpace(last);

                if (index >= last  || source.charCodeAt(index) !== 0x5D  /* ']' */) {
                    return null;
                }

                name += advance();
            }

            return name;
        }

        function skipToTag() {
            while (index < length && source.charCodeAt(index) !== 0x40  /* '@' */) {
                advance();
            }
            if (index >= length) {
                return false;
            }
            utility.assert(source.charCodeAt(index) === 0x40  /* '@' */);
            return true;
        }

        function TagParser(options, title) {
            this._options = options;
            this._title = title;
            this._tag = {
                title: title,
                description: null
            };
            if (this._options.lineNumbers) {
                this._tag.lineNumber = lineNumber;
            }
            this._last = 0;
            this._extra = { };
        }

        TagParser.prototype.addError = function addError(errorText) {
            var args = Array.prototype.slice.call(arguments, 1),
                msg = errorText.replace(
                    /%(\d)/g,
                    function (whole, index) {
                        utility.assert(index < args.length, 'Message reference must be in range');
                        return args[index];
                    }
                );

            if (!this._tag.errors) {
                this._tag.errors = [];
            }
            if (strict) {
                utility.throwError(msg);
            }
            this._tag.errors.push(msg);
            return recoverable;
        };

        TagParser.prototype.parseType = function () {
            if (isTypeParameterRequired(this._title)) {
                try {
                    this._tag.type = parseType(this._title, this._last);
                    if (!this._tag.type) {
                        if (!isParamTitle(this._title) && !isReturnTitle(this._title)) {
                            if (!this.addError('Missing or invalid tag type')) {
                                return false;
                            }
                        }
                    }
                } catch (error) {
                    this._tag.type = null;
                    if (!this.addError(error.message)) {
                        return false;
                    }
                }
            } else if (isAllowedType(this._title)) {
                try {
                    this._tag.type = parseType(this._title, this._last);
                } catch (e) {
                }
            }
            return true;
        };

        TagParser.prototype._parseNamePath = function (optional) {
            var name;
            name = parseName(this._last, sloppy && isParamTitle(this._title), true);
            if (!name) {
                if (!optional) {
                    if (!this.addError('Missing or invalid tag name')) {
                        return false;
                    }
                }
            }
            this._tag.name = name;
            return true;
        };

        TagParser.prototype.parseNamePath = function () {
            return this._parseNamePath(false);
        };

        TagParser.prototype.parseNamePathOptional = function () {
            return this._parseNamePath(true);
        };


        TagParser.prototype.parseName = function () {
            var assign, name;

            if (isAllowedName(this._title)) {
                this._tag.name = parseName(this._last, sloppy && isParamTitle(this._title), isAllowedNested(this._title));
                if (!this._tag.name) {
                    if (!isNameParameterRequired(this._title)) {
                        return true;
                    }

                    if (isParamTitle(this._title) && this._tag.type && this._tag.type.name) {
                        this._extra.name = this._tag.type;
                        this._tag.name = this._tag.type.name;
                        this._tag.type = null;
                    } else {
                        if (!this.addError('Missing or invalid tag name')) {
                            return false;
                        }
                    }
                } else {
                    name = this._tag.name;
                    if (name.charAt(0) === '[' && name.charAt(name.length - 1) === ']') {
                        assign = name.substring(1, name.length - 1).split('=');
                        if (assign[1]) {
                            this._tag['default'] = assign[1];
                        }
                        this._tag.name = assign[0];

                        if (this._tag.type && this._tag.type.type !== 'OptionalType') {
                            this._tag.type = {
                                type: 'OptionalType',
                                expression: this._tag.type
                            };
                        }
                    }
                }
            }

            return true;
        };

        TagParser.prototype.parseDescription = function parseDescription() {
            var description = trim(sliceSource(source, index, this._last));
            if (description) {
                if ((/^-\s+/).test(description)) {
                    description = description.substring(2);
                }
                this._tag.description = description;
            }
            return true;
        };

        TagParser.prototype.parseCaption = function parseDescription() {
            var description = trim(sliceSource(source, index, this._last));
            var captionStartTag = '<caption>';
            var captionEndTag = '</caption>';
            var captionStart = description.indexOf(captionStartTag);
            var captionEnd = description.indexOf(captionEndTag);
            if (captionStart >= 0 && captionEnd >= 0) {
                this._tag.caption = trim(description.substring(
                    captionStart + captionStartTag.length, captionEnd));
                this._tag.description = trim(description.substring(captionEnd + captionEndTag.length));
            } else {
                this._tag.description = description;
            }
            return true;
        };

        TagParser.prototype.parseKind = function parseKind() {
            var kind, kinds;
            kinds = {
                'class': true,
                'constant': true,
                'event': true,
                'external': true,
                'file': true,
                'function': true,
                'member': true,
                'mixin': true,
                'module': true,
                'namespace': true,
                'typedef': true
            };
            kind = trim(sliceSource(source, index, this._last));
            this._tag.kind = kind;
            if (!hasOwnProperty(kinds, kind)) {
                if (!this.addError('Invalid kind name \'%0\'', kind)) {
                    return false;
                }
            }
            return true;
        };

        TagParser.prototype.parseAccess = function parseAccess() {
            var access;
            access = trim(sliceSource(source, index, this._last));
            this._tag.access = access;
            if (access !== 'private' && access !== 'protected' && access !== 'public') {
                if (!this.addError('Invalid access name \'%0\'', access)) {
                    return false;
                }
            }
            return true;
        };

        TagParser.prototype.parseThis = function parseAccess() {
            var value = trim(sliceSource(source, index, this._last));
            if (value && value.charAt(0) === '{') {
                var gotType = this.parseType();
                if (gotType && this._tag.type.type === 'NameExpression') {
                    this._tag.name = this._tag.type.name;
                    return true;
                } else {
                    return this.addError('Invalid name for this');
                }
            } else {
                return this.parseNamePath();
            }
        };

        TagParser.prototype.parseVariation = function parseVariation() {
            var variation, text;
            text = trim(sliceSource(source, index, this._last));
            variation = parseFloat(text, 10);
            this._tag.variation = variation;
            if (isNaN(variation)) {
                if (!this.addError('Invalid variation \'%0\'', text)) {
                    return false;
                }
            }
            return true;
        };

        TagParser.prototype.ensureEnd = function () {
            var shouldBeEmpty = trim(sliceSource(source, index, this._last));
            if (shouldBeEmpty) {
                if (!this.addError('Unknown content \'%0\'', shouldBeEmpty)) {
                    return false;
                }
            }
            return true;
        };

        TagParser.prototype.epilogue = function epilogue() {
            var description;

            description = this._tag.description;
            if (isParamTitle(this._title) && !this._tag.type && description && description.charAt(0) === '[') {
                this._tag.type = this._extra.name;
                if (!this._tag.name) {
                    this._tag.name = undefined;
                }

                if (!sloppy) {
                    if (!this.addError('Missing or invalid tag name')) {
                        return false;
                    }
                }
            }

            return true;
        };

        Rules = {
            'access': ['parseAccess'],
            'alias': ['parseNamePath', 'ensureEnd'],
            'augments': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
            'constructor': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
            'class': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
            'extends': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
            'example': ['parseCaption'],
            'deprecated': ['parseDescription'],
            'global': ['ensureEnd'],
            'inner': ['ensureEnd'],
            'instance': ['ensureEnd'],
            'kind': ['parseKind'],
            'mixes': ['parseNamePath', 'ensureEnd'],
            'mixin': ['parseNamePathOptional', 'ensureEnd'],
            'member': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
            'method': ['parseNamePathOptional', 'ensureEnd'],
            'module': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
            'func': ['parseNamePathOptional', 'ensureEnd'],
            'function': ['parseNamePathOptional', 'ensureEnd'],
            'var': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
            'name': ['parseNamePath', 'ensureEnd'],
            'namespace': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
            'private': ['parseType', 'parseDescription'],
            'protected': ['parseType', 'parseDescription'],
            'public': ['parseType', 'parseDescription'],
            'readonly': ['ensureEnd'],
            'requires': ['parseNamePath', 'ensureEnd'],
            'since': ['parseDescription'],
            'static': ['ensureEnd'],
            'summary': ['parseDescription'],
            'this': ['parseThis', 'ensureEnd'],
            'todo': ['parseDescription'],
            'typedef': ['parseType', 'parseNamePathOptional'],
            'variation': ['parseVariation'],
            'version': ['parseDescription']
        };

        TagParser.prototype.parse = function parse() {
            var i, iz, sequences, method;

            if (!this._title) {
                if (!this.addError('Missing or invalid title')) {
                    return null;
                }
            }

            this._last = seekContent(this._title);

            if (hasOwnProperty(Rules, this._title)) {
                sequences = Rules[this._title];
            } else {
                sequences = ['parseType', 'parseName', 'parseDescription', 'epilogue'];
            }

            for (i = 0, iz = sequences.length; i < iz; ++i) {
                method = sequences[i];
                if (!this[method]()) {
                    return null;
                }
            }

            return this._tag;
        };

        function parseTag(options) {
            var title, parser, tag;

            if (!skipToTag()) {
                return null;
            }

            title = scanTitle();

            parser = new TagParser(options, title);
            tag = parser.parse();

            while (index < parser._last) {
                advance();
            }
            return tag;
        }

        function scanJSDocDescription(preserveWhitespace) {
            var description = '', ch, atAllowed;

            atAllowed = true;
            while (index < length) {
                ch = source.charCodeAt(index);

                if (atAllowed && ch === 0x40  /* '@' */) {
                    break;
                }

                if (esutils.code.isLineTerminator(ch)) {
                    atAllowed = true;
                } else if (atAllowed && !esutils.code.isWhiteSpace(ch)) {
                    atAllowed = false;
                }

                description += advance();
            }

            return preserveWhitespace ? description : trim(description);
        }

        function parse(comment, options) {
            var tags = [], tag, description, interestingTags, i, iz;

            if (options === undefined) {
                options = {};
            }

            if (typeof options.unwrap === 'boolean' && options.unwrap) {
                source = unwrapComment(comment);
            } else {
                source = comment;
            }

            if (options.tags) {
                if (isArray(options.tags)) {
                    interestingTags = { };
                    for (i = 0, iz = options.tags.length; i < iz; i++) {
                        if (typeof options.tags[i] === 'string') {
                            interestingTags[options.tags[i]] = true;
                        } else {
                            utility.throwError('Invalid "tags" parameter: ' + options.tags);
                        }
                    }
                } else {
                    utility.throwError('Invalid "tags" parameter: ' + options.tags);
                }
            }

            length = source.length;
            index = 0;
            lineNumber = 0;
            recoverable = options.recoverable;
            sloppy = options.sloppy;
            strict = options.strict;

            description = scanJSDocDescription(options.preserveWhitespace);

            while (true) {
                tag = parseTag(options);
                if (!tag) {
                    break;
                }
                if (!interestingTags || interestingTags.hasOwnProperty(tag.title)) {
                    tags.push(tag);
                }
            }

            return {
                description: description,
                tags: tags
            };
        }
        exports.parse = parse;
    }(jsdoc = {}));

    exports.version = utility.VERSION;
    exports.parse = jsdoc.parse;
    exports.parseType = typed.parseType;
    exports.parseParamType = typed.parseParamType;
    exports.unwrapComment = unwrapComment;
    exports.Syntax = shallowCopy(typed.Syntax);
    exports.Error = utility.DoctrineError;
    exports.type = {
        Syntax: exports.Syntax,
        parseType: typed.parseType,
        parseParamType: typed.parseParamType,
        stringify: typed.stringify
    };
}());

},
   {"./typed":"/node_modules/doctrine/lib/typed.js","./utility":"/node_modules/doctrine/lib/utility.js","esutils":"/node_modules/doctrine/node_modules/esutils/lib/utils.js","isarray":"/node_modules/doctrine/node_modules/isarray/index.js"}],

"/node_modules/doctrine/lib/typed.js": [function(require,module,exports){
(function () {
    'use strict';

    var Syntax,
        Token,
        source,
        length,
        index,
        previous,
        token,
        value,
        esutils,
        utility;

    esutils = require('esutils');
    utility = require('./utility');

    Syntax = {
        NullableLiteral: 'NullableLiteral',
        AllLiteral: 'AllLiteral',
        NullLiteral: 'NullLiteral',
        UndefinedLiteral: 'UndefinedLiteral',
        VoidLiteral: 'VoidLiteral',
        UnionType: 'UnionType',
        ArrayType: 'ArrayType',
        RecordType: 'RecordType',
        FieldType: 'FieldType',
        FunctionType: 'FunctionType',
        ParameterType: 'ParameterType',
        RestType: 'RestType',
        NonNullableType: 'NonNullableType',
        OptionalType: 'OptionalType',
        NullableType: 'NullableType',
        NameExpression: 'NameExpression',
        TypeApplication: 'TypeApplication'
    };

    Token = {
        ILLEGAL: 0,    // ILLEGAL
        DOT_LT: 1,     // .<
        REST: 2,       // ...
        LT: 3,         // <
        GT: 4,         // >
        LPAREN: 5,     // (
        RPAREN: 6,     // )
        LBRACE: 7,     // {
        RBRACE: 8,     // }
        LBRACK: 9,    // [
        RBRACK: 10,    // ]
        COMMA: 11,     // ,
        COLON: 12,     // :
        STAR: 13,      // *
        PIPE: 14,      // |
        QUESTION: 15,  // ?
        BANG: 16,      // !
        EQUAL: 17,     // =
        NAME: 18,      // name token
        STRING: 19,    // string
        NUMBER: 20,    // number
        EOF: 21
    };

    function isTypeName(ch) {
        return '><(){}[],:*|?!='.indexOf(String.fromCharCode(ch)) === -1 && !esutils.code.isWhiteSpace(ch) && !esutils.code.isLineTerminator(ch);
    }

    function Context(previous, index, token, value) {
        this._previous = previous;
        this._index = index;
        this._token = token;
        this._value = value;
    }

    Context.prototype.restore = function () {
        previous = this._previous;
        index = this._index;
        token = this._token;
        value = this._value;
    };

    Context.save = function () {
        return new Context(previous, index, token, value);
    };

    function advance() {
        var ch = source.charAt(index);
        index += 1;
        return ch;
    }

    function scanHexEscape(prefix) {
        var i, len, ch, code = 0;

        len = (prefix === 'u') ? 4 : 2;
        for (i = 0; i < len; ++i) {
            if (index < length && esutils.code.isHexDigit(source.charCodeAt(index))) {
                ch = advance();
                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
            } else {
                return '';
            }
        }
        return String.fromCharCode(code);
    }

    function scanString() {
        var str = '', quote, ch, code, unescaped, restore; //TODO review removal octal = false
        quote = source.charAt(index);
        ++index;

        while (index < length) {
            ch = advance();

            if (ch === quote) {
                quote = '';
                break;
            } else if (ch === '\\') {
                ch = advance();
                if (!esutils.code.isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case 'n':
                        str += '\n';
                        break;
                    case 'r':
                        str += '\r';
                        break;
                    case 't':
                        str += '\t';
                        break;
                    case 'u':
                    case 'x':
                        restore = index;
                        unescaped = scanHexEscape(ch);
                        if (unescaped) {
                            str += unescaped;
                        } else {
                            index = restore;
                            str += ch;
                        }
                        break;
                    case 'b':
                        str += '\b';
                        break;
                    case 'f':
                        str += '\f';
                        break;
                    case 'v':
                        str += '\v';
                        break;

                    default:
                        if (esutils.code.isOctalDigit(ch.charCodeAt(0))) {
                            code = '01234567'.indexOf(ch);

                            if (index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {
                                code = code * 8 + '01234567'.indexOf(advance());

                                if ('0123'.indexOf(ch) >= 0 &&
                                        index < length &&
                                        esutils.code.isOctalDigit(source.charCodeAt(index))) {
                                    code = code * 8 + '01234567'.indexOf(advance());
                                }
                            }
                            str += String.fromCharCode(code);
                        } else {
                            str += ch;
                        }
                        break;
                    }
                } else {
                    if (ch ===  '\r' && source.charCodeAt(index) === 0x0A  /* '\n' */) {
                        ++index;
                    }
                }
            } else if (esutils.code.isLineTerminator(ch.charCodeAt(0))) {
                break;
            } else {
                str += ch;
            }
        }

        if (quote !== '') {
            utility.throwError('unexpected quote');
        }

        value = str;
        return Token.STRING;
    }

    function scanNumber() {
        var number, ch;

        number = '';
        ch = source.charCodeAt(index);

        if (ch !== 0x2E  /* '.' */) {
            number = advance();
            ch = source.charCodeAt(index);

            if (number === '0') {
                if (ch === 0x78  /* 'x' */ || ch === 0x58  /* 'X' */) {
                    number += advance();
                    while (index < length) {
                        ch = source.charCodeAt(index);
                        if (!esutils.code.isHexDigit(ch)) {
                            break;
                        }
                        number += advance();
                    }

                    if (number.length <= 2) {
                        utility.throwError('unexpected token');
                    }

                    if (index < length) {
                        ch = source.charCodeAt(index);
                        if (esutils.code.isIdentifierStart(ch)) {
                            utility.throwError('unexpected token');
                        }
                    }
                    value = parseInt(number, 16);
                    return Token.NUMBER;
                }

                if (esutils.code.isOctalDigit(ch)) {
                    number += advance();
                    while (index < length) {
                        ch = source.charCodeAt(index);
                        if (!esutils.code.isOctalDigit(ch)) {
                            break;
                        }
                        number += advance();
                    }

                    if (index < length) {
                        ch = source.charCodeAt(index);
                        if (esutils.code.isIdentifierStart(ch) || esutils.code.isDecimalDigit(ch)) {
                            utility.throwError('unexpected token');
                        }
                    }
                    value = parseInt(number, 8);
                    return Token.NUMBER;
                }

                if (esutils.code.isDecimalDigit(ch)) {
                    utility.throwError('unexpected token');
                }
            }

            while (index < length) {
                ch = source.charCodeAt(index);
                if (!esutils.code.isDecimalDigit(ch)) {
                    break;
                }
                number += advance();
            }
        }

        if (ch === 0x2E  /* '.' */) {
            number += advance();
            while (index < length) {
                ch = source.charCodeAt(index);
                if (!esutils.code.isDecimalDigit(ch)) {
                    break;
                }
                number += advance();
            }
        }

        if (ch === 0x65  /* 'e' */ || ch === 0x45  /* 'E' */) {
            number += advance();

            ch = source.charCodeAt(index);
            if (ch === 0x2B  /* '+' */ || ch === 0x2D  /* '-' */) {
                number += advance();
            }

            ch = source.charCodeAt(index);
            if (esutils.code.isDecimalDigit(ch)) {
                number += advance();
                while (index < length) {
                    ch = source.charCodeAt(index);
                    if (!esutils.code.isDecimalDigit(ch)) {
                        break;
                    }
                    number += advance();
                }
            } else {
                utility.throwError('unexpected token');
            }
        }

        if (index < length) {
            ch = source.charCodeAt(index);
            if (esutils.code.isIdentifierStart(ch)) {
                utility.throwError('unexpected token');
            }
        }

        value = parseFloat(number);
        return Token.NUMBER;
    }


    function scanTypeName() {
        var ch, ch2;

        value = advance();
        while (index < length && isTypeName(source.charCodeAt(index))) {
            ch = source.charCodeAt(index);
            if (ch === 0x2E  /* '.' */) {
                if ((index + 1) >= length) {
                    return Token.ILLEGAL;
                }
                ch2 = source.charCodeAt(index + 1);
                if (ch2 === 0x3C  /* '<' */) {
                    break;
                }
            }
            value += advance();
        }
        return Token.NAME;
    }

    function next() {
        var ch;

        previous = index;

        while (index < length && esutils.code.isWhiteSpace(source.charCodeAt(index))) {
            advance();
        }
        if (index >= length) {
            token = Token.EOF;
            return token;
        }

        ch = source.charCodeAt(index);
        switch (ch) {
        case 0x27:  /* ''' */
        case 0x22:  /* '"' */
            token = scanString();
            return token;

        case 0x3A:  /* ':' */
            advance();
            token = Token.COLON;
            return token;

        case 0x2C:  /* ',' */
            advance();
            token = Token.COMMA;
            return token;

        case 0x28:  /* '(' */
            advance();
            token = Token.LPAREN;
            return token;

        case 0x29:  /* ')' */
            advance();
            token = Token.RPAREN;
            return token;

        case 0x5B:  /* '[' */
            advance();
            token = Token.LBRACK;
            return token;

        case 0x5D:  /* ']' */
            advance();
            token = Token.RBRACK;
            return token;

        case 0x7B:  /* '{' */
            advance();
            token = Token.LBRACE;
            return token;

        case 0x7D:  /* '}' */
            advance();
            token = Token.RBRACE;
            return token;

        case 0x2E:  /* '.' */
            if (index + 1 < length) {
                ch = source.charCodeAt(index + 1);
                if (ch === 0x3C  /* '<' */) {
                    advance();  // '.'
                    advance();  // '<'
                    token = Token.DOT_LT;
                    return token;
                }

                if (ch === 0x2E  /* '.' */ && index + 2 < length && source.charCodeAt(index + 2) === 0x2E  /* '.' */) {
                    advance();  // '.'
                    advance();  // '.'
                    advance();  // '.'
                    token = Token.REST;
                    return token;
                }

                if (esutils.code.isDecimalDigit(ch)) {
                    token = scanNumber();
                    return token;
                }
            }
            token = Token.ILLEGAL;
            return token;

        case 0x3C:  /* '<' */
            advance();
            token = Token.LT;
            return token;

        case 0x3E:  /* '>' */
            advance();
            token = Token.GT;
            return token;

        case 0x2A:  /* '*' */
            advance();
            token = Token.STAR;
            return token;

        case 0x7C:  /* '|' */
            advance();
            token = Token.PIPE;
            return token;

        case 0x3F:  /* '?' */
            advance();
            token = Token.QUESTION;
            return token;

        case 0x21:  /* '!' */
            advance();
            token = Token.BANG;
            return token;

        case 0x3D:  /* '=' */
            advance();
            token = Token.EQUAL;
            return token;

        default:
            if (esutils.code.isDecimalDigit(ch)) {
                token = scanNumber();
                return token;
            }

            utility.assert(isTypeName(ch));
            token = scanTypeName();
            return token;
        }
    }

    function consume(target, text) {
        utility.assert(token === target, text || 'consumed token not matched');
        next();
    }

    function expect(target, message) {
        if (token !== target) {
            utility.throwError(message || 'unexpected token');
        }
        next();
    }

    function parseUnionType() {
        var elements;
        consume(Token.LPAREN, 'UnionType should start with (');
        elements = [];
        if (token !== Token.RPAREN) {
            while (true) {
                elements.push(parseTypeExpression());
                if (token === Token.RPAREN) {
                    break;
                }
                expect(Token.PIPE);
            }
        }
        consume(Token.RPAREN, 'UnionType should end with )');
        return {
            type: Syntax.UnionType,
            elements: elements
        };
    }

    function parseArrayType() {
        var elements;
        consume(Token.LBRACK, 'ArrayType should start with [');
        elements = [];
        while (token !== Token.RBRACK) {
            if (token === Token.REST) {
                consume(Token.REST);
                elements.push({
                    type: Syntax.RestType,
                    expression: parseTypeExpression()
                });
                break;
            } else {
                elements.push(parseTypeExpression());
            }
            if (token !== Token.RBRACK) {
                expect(Token.COMMA);
            }
        }
        expect(Token.RBRACK);
        return {
            type: Syntax.ArrayType,
            elements: elements
        };
    }

    function parseFieldName() {
        var v = value;
        if (token === Token.NAME || token === Token.STRING) {
            next();
            return v;
        }

        if (token === Token.NUMBER) {
            consume(Token.NUMBER);
            return String(v);
        }

        utility.throwError('unexpected token');
    }

    function parseFieldType() {
        var key;

        key = parseFieldName();
        if (token === Token.COLON) {
            consume(Token.COLON);
            return {
                type: Syntax.FieldType,
                key: key,
                value: parseTypeExpression()
            };
        }
        return {
            type: Syntax.FieldType,
            key: key,
            value: null
        };
    }

    function parseRecordType() {
        var fields;

        consume(Token.LBRACE, 'RecordType should start with {');
        fields = [];
        if (token === Token.COMMA) {
            consume(Token.COMMA);
        } else {
            while (token !== Token.RBRACE) {
                fields.push(parseFieldType());
                if (token !== Token.RBRACE) {
                    expect(Token.COMMA);
                }
            }
        }
        expect(Token.RBRACE);
        return {
            type: Syntax.RecordType,
            fields: fields
        };
    }

    function parseNameExpression() {
        var name = value;
        expect(Token.NAME);

        if (token === Token.COLON && (
                name === 'module' ||
                name === 'external' ||
                name === 'event')) {
            consume(Token.COLON);
            name += ':' + value;
            expect(Token.NAME);
        }

        return {
            type: Syntax.NameExpression,
            name: name
        };
    }

    function parseTypeExpressionList() {
        var elements = [];

        elements.push(parseTop());
        while (token === Token.COMMA) {
            consume(Token.COMMA);
            elements.push(parseTop());
        }
        return elements;
    }

    function parseTypeName() {
        var expr, applications;

        expr = parseNameExpression();
        if (token === Token.DOT_LT || token === Token.LT) {
            next();
            applications = parseTypeExpressionList();
            expect(Token.GT);
            return {
                type: Syntax.TypeApplication,
                expression: expr,
                applications: applications
            };
        }
        return expr;
    }

    function parseResultType() {
        consume(Token.COLON, 'ResultType should start with :');
        if (token === Token.NAME && value === 'void') {
            consume(Token.NAME);
            return {
                type: Syntax.VoidLiteral
            };
        }
        return parseTypeExpression();
    }

    function parseParametersType() {
        var params = [], optionalSequence = false, expr, rest = false;

        while (token !== Token.RPAREN) {
            if (token === Token.REST) {
                consume(Token.REST);
                rest = true;
            }

            expr = parseTypeExpression();
            if (expr.type === Syntax.NameExpression && token === Token.COLON) {
                consume(Token.COLON);
                expr = {
                    type: Syntax.ParameterType,
                    name: expr.name,
                    expression: parseTypeExpression()
                };
            }
            if (token === Token.EQUAL) {
                consume(Token.EQUAL);
                expr = {
                    type: Syntax.OptionalType,
                    expression: expr
                };
                optionalSequence = true;
            } else {
                if (optionalSequence) {
                    utility.throwError('unexpected token');
                }
            }
            if (rest) {
                expr = {
                    type: Syntax.RestType,
                    expression: expr
                };
            }
            params.push(expr);
            if (token !== Token.RPAREN) {
                expect(Token.COMMA);
            }
        }
        return params;
    }

    function parseFunctionType() {
        var isNew, thisBinding, params, result, fnType;
        utility.assert(token === Token.NAME && value === 'function', 'FunctionType should start with \'function\'');
        consume(Token.NAME);

        expect(Token.LPAREN);

        isNew = false;
        params = [];
        thisBinding = null;
        if (token !== Token.RPAREN) {
            if (token === Token.NAME &&
                    (value === 'this' || value === 'new')) {
                isNew = value === 'new';
                consume(Token.NAME);
                expect(Token.COLON);
                thisBinding = parseTypeName();
                if (token === Token.COMMA) {
                    consume(Token.COMMA);
                    params = parseParametersType();
                }
            } else {
                params = parseParametersType();
            }
        }

        expect(Token.RPAREN);

        result = null;
        if (token === Token.COLON) {
            result = parseResultType();
        }

        fnType = {
            type: Syntax.FunctionType,
            params: params,
            result: result
        };
        if (thisBinding) {
            fnType['this'] = thisBinding;
            if (isNew) {
                fnType['new'] = true;
            }
        }
        return fnType;
    }

    function parseBasicTypeExpression() {
        var context;
        switch (token) {
        case Token.STAR:
            consume(Token.STAR);
            return {
                type: Syntax.AllLiteral
            };

        case Token.LPAREN:
            return parseUnionType();

        case Token.LBRACK:
            return parseArrayType();

        case Token.LBRACE:
            return parseRecordType();

        case Token.NAME:
            if (value === 'null') {
                consume(Token.NAME);
                return {
                    type: Syntax.NullLiteral
                };
            }

            if (value === 'undefined') {
                consume(Token.NAME);
                return {
                    type: Syntax.UndefinedLiteral
                };
            }

            context = Context.save();
            if (value === 'function') {
                try {
                    return parseFunctionType();
                } catch (e) {
                    context.restore();
                }
            }

            return parseTypeName();

        default:
            utility.throwError('unexpected token');
        }
    }

    function parseTypeExpression() {
        var expr;

        if (token === Token.QUESTION) {
            consume(Token.QUESTION);
            if (token === Token.COMMA || token === Token.EQUAL || token === Token.RBRACE ||
                    token === Token.RPAREN || token === Token.PIPE || token === Token.EOF ||
                    token === Token.RBRACK || token === Token.GT) {
                return {
                    type: Syntax.NullableLiteral
                };
            }
            return {
                type: Syntax.NullableType,
                expression: parseBasicTypeExpression(),
                prefix: true
            };
        }

        if (token === Token.BANG) {
            consume(Token.BANG);
            return {
                type: Syntax.NonNullableType,
                expression: parseBasicTypeExpression(),
                prefix: true
            };
        }

        expr = parseBasicTypeExpression();
        if (token === Token.BANG) {
            consume(Token.BANG);
            return {
                type: Syntax.NonNullableType,
                expression: expr,
                prefix: false
            };
        }

        if (token === Token.QUESTION) {
            consume(Token.QUESTION);
            return {
                type: Syntax.NullableType,
                expression: expr,
                prefix: false
            };
        }

        if (token === Token.LBRACK) {
            consume(Token.LBRACK);
            expect(Token.RBRACK, 'expected an array-style type declaration (' + value + '[])');
            return {
                type: Syntax.TypeApplication,
                expression: {
                    type: Syntax.NameExpression,
                    name: 'Array'
                },
                applications: [expr]
            };
        }

        return expr;
    }

    function parseTop() {
        var expr, elements;

        expr = parseTypeExpression();
        if (token !== Token.PIPE) {
            return expr;
        }

        elements = [expr];
        consume(Token.PIPE);
        while (true) {
            elements.push(parseTypeExpression());
            if (token !== Token.PIPE) {
                break;
            }
            consume(Token.PIPE);
        }

        return {
            type: Syntax.UnionType,
            elements: elements
        };
    }

    function parseTopParamType() {
        var expr;

        if (token === Token.REST) {
            consume(Token.REST);
            return {
                type: Syntax.RestType,
                expression: parseTop()
            };
        }

        expr = parseTop();
        if (token === Token.EQUAL) {
            consume(Token.EQUAL);
            return {
                type: Syntax.OptionalType,
                expression: expr
            };
        }

        return expr;
    }

    function parseType(src, opt) {
        var expr;

        source = src;
        length = source.length;
        index = 0;
        previous = 0;

        next();
        expr = parseTop();

        if (opt && opt.midstream) {
            return {
                expression: expr,
                index: previous
            };
        }

        if (token !== Token.EOF) {
            utility.throwError('not reach to EOF');
        }

        return expr;
    }

    function parseParamType(src, opt) {
        var expr;

        source = src;
        length = source.length;
        index = 0;
        previous = 0;

        next();
        expr = parseTopParamType();

        if (opt && opt.midstream) {
            return {
                expression: expr,
                index: previous
            };
        }

        if (token !== Token.EOF) {
            utility.throwError('not reach to EOF');
        }

        return expr;
    }

    function stringifyImpl(node, compact, topLevel) {
        var result, i, iz;

        switch (node.type) {
        case Syntax.NullableLiteral:
            result = '?';
            break;

        case Syntax.AllLiteral:
            result = '*';
            break;

        case Syntax.NullLiteral:
            result = 'null';
            break;

        case Syntax.UndefinedLiteral:
            result = 'undefined';
            break;

        case Syntax.VoidLiteral:
            result = 'void';
            break;

        case Syntax.UnionType:
            if (!topLevel) {
                result = '(';
            } else {
                result = '';
            }

            for (i = 0, iz = node.elements.length; i < iz; ++i) {
                result += stringifyImpl(node.elements[i], compact);
                if ((i + 1) !== iz) {
                    result += '|';
                }
            }

            if (!topLevel) {
                result += ')';
            }
            break;

        case Syntax.ArrayType:
            result = '[';
            for (i = 0, iz = node.elements.length; i < iz; ++i) {
                result += stringifyImpl(node.elements[i], compact);
                if ((i + 1) !== iz) {
                    result += compact ? ',' : ', ';
                }
            }
            result += ']';
            break;

        case Syntax.RecordType:
            result = '{';
            for (i = 0, iz = node.fields.length; i < iz; ++i) {
                result += stringifyImpl(node.fields[i], compact);
                if ((i + 1) !== iz) {
                    result += compact ? ',' : ', ';
                }
            }
            result += '}';
            break;

        case Syntax.FieldType:
            if (node.value) {
                result = node.key + (compact ? ':' : ': ') + stringifyImpl(node.value, compact);
            } else {
                result = node.key;
            }
            break;

        case Syntax.FunctionType:
            result = compact ? 'function(' : 'function (';

            if (node['this']) {
                if (node['new']) {
                    result += (compact ? 'new:' : 'new: ');
                } else {
                    result += (compact ? 'this:' : 'this: ');
                }

                result += stringifyImpl(node['this'], compact);

                if (node.params.length !== 0) {
                    result += compact ? ',' : ', ';
                }
            }

            for (i = 0, iz = node.params.length; i < iz; ++i) {
                result += stringifyImpl(node.params[i], compact);
                if ((i + 1) !== iz) {
                    result += compact ? ',' : ', ';
                }
            }

            result += ')';

            if (node.result) {
                result += (compact ? ':' : ': ') + stringifyImpl(node.result, compact);
            }
            break;

        case Syntax.ParameterType:
            result = node.name + (compact ? ':' : ': ') + stringifyImpl(node.expression, compact);
            break;

        case Syntax.RestType:
            result = '...';
            if (node.expression) {
                result += stringifyImpl(node.expression, compact);
            }
            break;

        case Syntax.NonNullableType:
            if (node.prefix) {
                result = '!' + stringifyImpl(node.expression, compact);
            } else {
                result = stringifyImpl(node.expression, compact) + '!';
            }
            break;

        case Syntax.OptionalType:
            result = stringifyImpl(node.expression, compact) + '=';
            break;

        case Syntax.NullableType:
            if (node.prefix) {
                result = '?' + stringifyImpl(node.expression, compact);
            } else {
                result = stringifyImpl(node.expression, compact) + '?';
            }
            break;

        case Syntax.NameExpression:
            result = node.name;
            break;

        case Syntax.TypeApplication:
            result = stringifyImpl(node.expression, compact) + '.<';
            for (i = 0, iz = node.applications.length; i < iz; ++i) {
                result += stringifyImpl(node.applications[i], compact);
                if ((i + 1) !== iz) {
                    result += compact ? ',' : ', ';
                }
            }
            result += '>';
            break;

        default:
            utility.throwError('Unknown type ' + node.type);
        }

        return result;
    }

    function stringify(node, options) {
        if (options == null) {
            options = {};
        }
        return stringifyImpl(node, options.compact, options.topLevel);
    }

    exports.parseType = parseType;
    exports.parseParamType = parseParamType;
    exports.stringify = stringify;
    exports.Syntax = Syntax;
}());

},
   {"./utility":"/node_modules/doctrine/lib/utility.js","esutils":"/node_modules/doctrine/node_modules/esutils/lib/utils.js"}],

"/node_modules/doctrine/lib/utility.js": [function(require,module,exports){

(function () {
    'use strict';

    var VERSION;

    VERSION = require('../package.json').version;
    exports.VERSION = VERSION;

    function DoctrineError(message) {
        this.name = 'DoctrineError';
        this.message = message;
    }
    DoctrineError.prototype = (function () {
        var Middle = function () { };
        Middle.prototype = Error.prototype;
        return new Middle();
    }());
    DoctrineError.prototype.constructor = DoctrineError;
    exports.DoctrineError = DoctrineError;

    function throwError(message) {
        throw new DoctrineError(message);
    }
    exports.throwError = throwError;

    exports.assert = require('assert');
}());


},
   {"../package.json":"/node_modules/doctrine/package.json","assert":"/node_modules/browserify/node_modules/assert/assert.js"}],

"/node_modules/doctrine/node_modules/esutils/lib/ast.js": [function(require,module,exports){
(function () {
    'use strict';

    function isExpression(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'ArrayExpression':
            case 'AssignmentExpression':
            case 'BinaryExpression':
            case 'CallExpression':
            case 'ConditionalExpression':
            case 'FunctionExpression':
            case 'Identifier':
            case 'Literal':
            case 'LogicalExpression':
            case 'MemberExpression':
            case 'NewExpression':
            case 'ObjectExpression':
            case 'SequenceExpression':
            case 'ThisExpression':
            case 'UnaryExpression':
            case 'UpdateExpression':
                return true;
        }
        return false;
    }

    function isIterationStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'DoWhileStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'WhileStatement':
                return true;
        }
        return false;
    }

    function isStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'BlockStatement':
            case 'BreakStatement':
            case 'ContinueStatement':
            case 'DebuggerStatement':
            case 'DoWhileStatement':
            case 'EmptyStatement':
            case 'ExpressionStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'IfStatement':
            case 'LabeledStatement':
            case 'ReturnStatement':
            case 'SwitchStatement':
            case 'ThrowStatement':
            case 'TryStatement':
            case 'VariableDeclaration':
            case 'WhileStatement':
            case 'WithStatement':
                return true;
        }
        return false;
    }

    function isSourceElement(node) {
      return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
    }

    function trailingStatement(node) {
        switch (node.type) {
        case 'IfStatement':
            if (node.alternate != null) {
                return node.alternate;
            }
            return node.consequent;

        case 'LabeledStatement':
        case 'ForStatement':
        case 'ForInStatement':
        case 'WhileStatement':
        case 'WithStatement':
            return node.body;
        }
        return null;
    }

    function isProblematicIfStatement(node) {
        var current;

        if (node.type !== 'IfStatement') {
            return false;
        }
        if (node.alternate == null) {
            return false;
        }
        current = node.consequent;
        do {
            if (current.type === 'IfStatement') {
                if (current.alternate == null)  {
                    return true;
                }
            }
            current = trailingStatement(current);
        } while (current);

        return false;
    }

    module.exports = {
        isExpression: isExpression,
        isStatement: isStatement,
        isIterationStatement: isIterationStatement,
        isSourceElement: isSourceElement,
        isProblematicIfStatement: isProblematicIfStatement,

        trailingStatement: trailingStatement
    };
}());

},
   {}],

"/node_modules/doctrine/node_modules/esutils/lib/code.js": [function(require,module,exports){
(function () {
    'use strict';

    var Regex, NON_ASCII_WHITESPACES;

    Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
        NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
    };

    function isDecimalDigit(ch) {
        return (ch >= 48 && ch <= 57);   // 0..9
    }

    function isHexDigit(ch) {
        return isDecimalDigit(ch) ||    // 0..9
            (97 <= ch && ch <= 102) ||  // a..f
            (65 <= ch && ch <= 70);     // A..F
    }

    function isOctalDigit(ch) {
        return (ch >= 48 && ch <= 55);   // 0..7
    }

    NON_ASCII_WHITESPACES = [
        0x1680, 0x180E,
        0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,
        0x202F, 0x205F,
        0x3000,
        0xFEFF
    ];

    function isWhiteSpace(ch) {
        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
            (ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0);
    }

    function isLineTerminator(ch) {
        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
    }

    function isIdentifierStart(ch) {
        return (ch >= 97 && ch <= 122) ||     // a..z
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch === 36) || (ch === 95) ||     // $ (dollar) and _ (underscore)
            (ch === 92) ||                    // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
    }

    function isIdentifierPart(ch) {
        return (ch >= 97 && ch <= 122) ||     // a..z
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 48 && ch <= 57) ||         // 0..9
            (ch === 36) || (ch === 95) ||     // $ (dollar) and _ (underscore)
            (ch === 92) ||                    // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
    }

    module.exports = {
        isDecimalDigit: isDecimalDigit,
        isHexDigit: isHexDigit,
        isOctalDigit: isOctalDigit,
        isWhiteSpace: isWhiteSpace,
        isLineTerminator: isLineTerminator,
        isIdentifierStart: isIdentifierStart,
        isIdentifierPart: isIdentifierPart
    };
}());

},
   {}],

"/node_modules/doctrine/node_modules/esutils/lib/keyword.js": [function(require,module,exports){
(function () {
    'use strict';

    var code = require('./code');

    function isStrictModeReservedWordES6(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isKeywordES5(id, strict) {
        if (!strict && id === 'yield') {
            return false;
        }
        return isKeywordES6(id, strict);
    }

    function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
            return true;
        }

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    function isReservedWordES5(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
    }

    function isReservedWordES6(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    function isIdentifierName(id) {
        var i, iz, ch;

        if (id.length === 0) {
            return false;
        }

        ch = id.charCodeAt(0);
        if (!code.isIdentifierStart(ch) || ch === 92) {  // \ (backslash)
            return false;
        }

        for (i = 1, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (!code.isIdentifierPart(ch) || ch === 92) {  // \ (backslash)
                return false;
            }
        }
        return true;
    }

    function isIdentifierES5(id, strict) {
        return isIdentifierName(id) && !isReservedWordES5(id, strict);
    }

    function isIdentifierES6(id, strict) {
        return isIdentifierName(id) && !isReservedWordES6(id, strict);
    }

    module.exports = {
        isKeywordES5: isKeywordES5,
        isKeywordES6: isKeywordES6,
        isReservedWordES5: isReservedWordES5,
        isReservedWordES6: isReservedWordES6,
        isRestrictedWord: isRestrictedWord,
        isIdentifierName: isIdentifierName,
        isIdentifierES5: isIdentifierES5,
        isIdentifierES6: isIdentifierES6
    };
}());

},
   {"./code":"/node_modules/doctrine/node_modules/esutils/lib/code.js"}],

"/node_modules/doctrine/node_modules/esutils/lib/utils.js": [function(require,module,exports){

(function () {
    'use strict';

    exports.ast = require('./ast');
    exports.code = require('./code');
    exports.keyword = require('./keyword');
}());

},
   {"./ast":"/node_modules/doctrine/node_modules/esutils/lib/ast.js","./code":"/node_modules/doctrine/node_modules/esutils/lib/code.js","./keyword":"/node_modules/doctrine/node_modules/esutils/lib/keyword.js"}],

"/node_modules/doctrine/node_modules/isarray/index.js": [function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},
   {}],

"/node_modules/doctrine/package.json": [function(require,module,exports){
module.exports={
  "name": "doctrine",
  "description": "JSDoc parser",
  "homepage": "https://github.com/eslint/doctrine",
  "main": "lib/doctrine.js",
  "version": "1.2.0",
  "engines": {
    "node": ">=0.10.0"
  },
  "directories": {
    "lib": "./lib"
  },
  "files": [
    "lib",
    "LICENSE.BSD",
    "LICENSE.closure-compiler",
    "LICENSE.esprima",
    "README.md"
  ],
  "maintainers": [
    {
      "name": "constellation",
      "email": "utatane.tea@gmail.com"
    },
    {
      "name": "nzakas",
      "email": "nicholas@nczconsulting.com"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/eslint/doctrine.git"
  },
  "devDependencies": {
    "coveralls": "^2.11.2",
    "dateformat": "^1.0.11",
    "eslint": "^1.10.3",
    "eslint-release": "^0.3.0",
    "istanbul": "^0.4.1",
    "linefix": "^0.1.1",
    "mocha": "^2.3.3",
    "npm-license": "^0.3.1",
    "semver": "^5.0.3",
    "shelljs": "^0.5.3",
    "shelljs-nodecli": "^0.1.1",
    "should": "^5.0.1"
  },
  "licenses": [
    {
      "type": "BSD",
      "url": "http://github.com/eslint/doctrine/raw/master/LICENSE.BSD"
    }
  ],
  "scripts": {
    "test": "npm run lint && node Makefile.js test",
    "lint": "eslint lib/",
    "release": "eslint-release",
    "alpharelease": "eslint-prerelease alpha",
    "betarelease": "eslint-prerelease beta"
  },
  "dependencies": {
    "esutils": "^1.1.6",
    "isarray": "^1.0.0"
  },
  "bugs": {
    "url": "https://github.com/eslint/doctrine/issues"
  },
  "_id": "doctrine@1.2.0",
  "_shasum": "ff0adabd686b4faeb1e2b5c775c34a74539e784f",
  "_from": "doctrine@>=1.2.0 <2.0.0",
  "_npmVersion": "1.4.10",
  "_npmUser": {
    "name": "nzakas",
    "email": "nicholas@nczconsulting.com"
  },
  "dist": {
    "shasum": "ff0adabd686b4faeb1e2b5c775c34a74539e784f",
    "tarball": "http://registry.npmjs.org/doctrine/-/doctrine-1.2.0.tgz"
  },
  "_npmOperationalInternal": {
    "host": "packages-5-east.internal.npmjs.com",
    "tmp": "tmp/doctrine-1.2.0.tgz_1455906515924_0.953179617645219"
  },
  "_resolved": "https://registry.npmjs.org/doctrine/-/doctrine-1.2.0.tgz"
}

},
   {}],

"/node_modules/es6-map/index.js": [function(require,module,exports){
'use strict';

module.exports = require('./is-implemented')() ? Map : require('./polyfill');

},
   {"./is-implemented":"/node_modules/es6-map/is-implemented.js","./polyfill":"/node_modules/es6-map/polyfill.js"}],

"/node_modules/es6-map/is-implemented.js": [function(require,module,exports){
'use strict';

module.exports = function () {
	var map, iterator, result;
	if (typeof Map !== 'function') return false;
	try {
		map = new Map([['raz', 'one'], ['dwa', 'two'], ['trzy', 'three']]);
	} catch (e) {
		return false;
	}
	if (String(map) !== '[object Map]') return false;
	if (map.size !== 3) return false;
	if (typeof map.clear !== 'function') return false;
	if (typeof map.delete !== 'function') return false;
	if (typeof map.entries !== 'function') return false;
	if (typeof map.forEach !== 'function') return false;
	if (typeof map.get !== 'function') return false;
	if (typeof map.has !== 'function') return false;
	if (typeof map.keys !== 'function') return false;
	if (typeof map.set !== 'function') return false;
	if (typeof map.values !== 'function') return false;

	iterator = map.entries();
	result = iterator.next();
	if (result.done !== false) return false;
	if (!result.value) return false;
	if (result.value[0] !== 'raz') return false;
	if (result.value[1] !== 'one') return false;

	return true;
};

},
   {}],

"/node_modules/es6-map/is-native-implemented.js": [function(require,module,exports){
'use strict';

module.exports = (function () {
	if (typeof Map === 'undefined') return false;
	return (Object.prototype.toString.call(new Map()) === '[object Map]');
}());

},
   {}],

"/node_modules/es6-map/lib/iterator-kinds.js": [function(require,module,exports){
'use strict';

module.exports = require('es5-ext/object/primitive-set')('key',
	'value', 'key+value');

},
   {"es5-ext/object/primitive-set":"/node_modules/es6-map/node_modules/es5-ext/object/primitive-set.js"}],

"/node_modules/es6-map/lib/iterator.js": [function(require,module,exports){
'use strict';

var setPrototypeOf    = require('es5-ext/object/set-prototype-of')
  , d                 = require('d')
  , Iterator          = require('es6-iterator')
  , toStringTagSymbol = require('es6-symbol').toStringTag
  , kinds             = require('./iterator-kinds')

  , defineProperties = Object.defineProperties
  , unBind = Iterator.prototype._unBind
  , MapIterator;

MapIterator = module.exports = function (map, kind) {
	if (!(this instanceof MapIterator)) return new MapIterator(map, kind);
	Iterator.call(this, map.__mapKeysData__, map);
	if (!kind || !kinds[kind]) kind = 'key+value';
	defineProperties(this, {
		__kind__: d('', kind),
		__values__: d('w', map.__mapValuesData__)
	});
};
if (setPrototypeOf) setPrototypeOf(MapIterator, Iterator);

MapIterator.prototype = Object.create(Iterator.prototype, {
	constructor: d(MapIterator),
	_resolve: d(function (i) {
		if (this.__kind__ === 'value') return this.__values__[i];
		if (this.__kind__ === 'key') return this.__list__[i];
		return [this.__list__[i], this.__values__[i]];
	}),
	_unBind: d(function () {
		this.__values__ = null;
		unBind.call(this);
	}),
	toString: d(function () { return '[object Map Iterator]'; })
});
Object.defineProperty(MapIterator.prototype, toStringTagSymbol,
	d('c', 'Map Iterator'));

},
   {"./iterator-kinds":"/node_modules/es6-map/lib/iterator-kinds.js","d":"/node_modules/es6-map/node_modules/d/index.js","es5-ext/object/set-prototype-of":"/node_modules/es6-map/node_modules/es5-ext/object/set-prototype-of/index.js","es6-iterator":"/node_modules/es6-map/node_modules/es6-iterator/index.js","es6-symbol":"/node_modules/es6-map/node_modules/es6-symbol/index.js"}],

"/node_modules/es6-map/node_modules/d/auto-bind.js": [function(require,module,exports){
'use strict';

var copy       = require('es5-ext/object/copy')
  , map        = require('es5-ext/object/map')
  , callable   = require('es5-ext/object/valid-callable')
  , validValue = require('es5-ext/object/valid-value')

  , bind = Function.prototype.bind, defineProperty = Object.defineProperty
  , hasOwnProperty = Object.prototype.hasOwnProperty
  , define;

define = function (name, desc, bindTo) {
	var value = validValue(desc) && callable(desc.value), dgs;
	dgs = copy(desc);
	delete dgs.writable;
	delete dgs.value;
	dgs.get = function () {
		if (hasOwnProperty.call(this, name)) return value;
		desc.value = bind.call(value, (bindTo == null) ? this : this[bindTo]);
		defineProperty(this, name, desc);
		return this[name];
	};
	return dgs;
};

module.exports = function (props/*, bindTo*/) {
	var bindTo = arguments[1];
	return map(props, function (desc, name) {
		return define(name, desc, bindTo);
	});
};

},
   {"es5-ext/object/copy":"/node_modules/es6-map/node_modules/es5-ext/object/copy.js","es5-ext/object/map":"/node_modules/es6-map/node_modules/es5-ext/object/map.js","es5-ext/object/valid-callable":"/node_modules/es6-map/node_modules/es5-ext/object/valid-callable.js","es5-ext/object/valid-value":"/node_modules/es6-map/node_modules/es5-ext/object/valid-value.js"}],

"/node_modules/es6-map/node_modules/d/index.js": [function(require,module,exports){
'use strict';

var assign        = require('es5-ext/object/assign')
  , normalizeOpts = require('es5-ext/object/normalize-options')
  , isCallable    = require('es5-ext/object/is-callable')
  , contains      = require('es5-ext/string/#/contains')

  , d;

d = module.exports = function (dscr, value/*, options*/) {
	var c, e, w, options, desc;
	if ((arguments.length < 2) || (typeof dscr !== 'string')) {
		options = value;
		value = dscr;
		dscr = null;
	} else {
		options = arguments[2];
	}
	if (dscr == null) {
		c = w = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
		w = contains.call(dscr, 'w');
	}

	desc = { value: value, configurable: c, enumerable: e, writable: w };
	return !options ? desc : assign(normalizeOpts(options), desc);
};

d.gs = function (dscr, get, set/*, options*/) {
	var c, e, options, desc;
	if (typeof dscr !== 'string') {
		options = set;
		set = get;
		get = dscr;
		dscr = null;
	} else {
		options = arguments[3];
	}
	if (get == null) {
		get = undefined;
	} else if (!isCallable(get)) {
		options = get;
		get = set = undefined;
	} else if (set == null) {
		set = undefined;
	} else if (!isCallable(set)) {
		options = set;
		set = undefined;
	}
	if (dscr == null) {
		c = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
	}

	desc = { get: get, set: set, configurable: c, enumerable: e };
	return !options ? desc : assign(normalizeOpts(options), desc);
};

},
   {"es5-ext/object/assign":"/node_modules/es6-map/node_modules/es5-ext/object/assign/index.js","es5-ext/object/is-callable":"/node_modules/es6-map/node_modules/es5-ext/object/is-callable.js","es5-ext/object/normalize-options":"/node_modules/es6-map/node_modules/es5-ext/object/normalize-options.js","es5-ext/string/#/contains":"/node_modules/es6-map/node_modules/es5-ext/string/#/contains/index.js"}],

"/node_modules/es6-map/node_modules/es5-ext/array/#/clear.js": [function(require,module,exports){
'use strict';

var value = require('../../object/valid-value');

module.exports = function () {
	value(this).length = 0;
	return this;
};

},
   {"../../object/valid-value":"/node_modules/es6-map/node_modules/es5-ext/object/valid-value.js"}],

"/node_modules/es6-map/node_modules/es5-ext/array/#/e-index-of.js": [function(require,module,exports){
'use strict';

var toPosInt = require('../../number/to-pos-integer')
  , value    = require('../../object/valid-value')

  , indexOf = Array.prototype.indexOf
  , hasOwnProperty = Object.prototype.hasOwnProperty
  , abs = Math.abs, floor = Math.floor;

module.exports = function (searchElement/*, fromIndex*/) {
	var i, l, fromIndex, val;
	if (searchElement === searchElement) { //jslint: ignore
		return indexOf.apply(this, arguments);
	}

	l = toPosInt(value(this).length);
	fromIndex = arguments[1];
	if (isNaN(fromIndex)) fromIndex = 0;
	else if (fromIndex >= 0) fromIndex = floor(fromIndex);
	else fromIndex = toPosInt(this.length) - floor(abs(fromIndex));

	for (i = fromIndex; i < l; ++i) {
		if (hasOwnProperty.call(this, i)) {
			val = this[i];
			if (val !== val) return i; //jslint: ignore
		}
	}
	return -1;
};

},
   {"../../number/to-pos-integer":"/node_modules/es6-map/node_modules/es5-ext/number/to-pos-integer.js","../../object/valid-value":"/node_modules/es6-map/node_modules/es5-ext/object/valid-value.js"}],

"/node_modules/es6-map/node_modules/es5-ext/function/is-arguments.js": [function(require,module,exports){
'use strict';

var toString = Object.prototype.toString

  , id = toString.call((function () { return arguments; }()));

module.exports = function (x) { return (toString.call(x) === id); };

},
   {}],

"/node_modules/es6-map/node_modules/es5-ext/math/sign/index.js": [function(require,module,exports){
'use strict';

module.exports = require('./is-implemented')()
	? Math.sign
	: require('./shim');

},
   {"./is-implemented":"/node_modules/es6-map/node_modules/es5-ext/math/sign/is-implemented.js","./shim":"/node_modules/es6-map/node_modules/es5-ext/math/sign/shim.js"}],

"/node_modules/es6-map/node_modules/es5-ext/math/sign/is-implemented.js": [function(require,module,exports){
'use strict';

module.exports = function () {
	var sign = Math.sign;
	if (typeof sign !== 'function') return false;
	return ((sign(10) === 1) && (sign(-20) === -1));
};

},
   {}],

"/node_modules/es6-map/node_modules/es5-ext/math/sign/shim.js": [function(require,module,exports){
'use strict';

module.exports = function (value) {
	value = Number(value);
	if (isNaN(value) || (value === 0)) return value;
	return (value > 0) ? 1 : -1;
};

},
   {}],

"/node_modules/es6-map/node_modules/es5-ext/number/to-integer.js": [function(require,module,exports){
'use strict';

var sign = require('../math/sign')

  , abs = Math.abs, floor = Math.floor;

module.exports = function (value) {
	if (isNaN(value)) return 0;
	value = Number(value);
	if ((value === 0) || !isFinite(value)) return value;
	return sign(value) * floor(abs(value));
};

},
   {"../math/sign":"/node_modules/es6-map/node_modules/es5-ext/math/sign/index.js"}],

"/node_modules/es6-map/node_modules/es5-ext/number/to-pos-integer.js": [function(require,module,exports){
'use strict';

var toInteger = require('./to-integer')

  , max = Math.max;

module.exports = function (value) { return max(0, toInteger(value)); };

},
   {"./to-integer":"/node_modules/es6-map/node_modules/es5-ext/number/to-integer.js"}],

"/node_modules/es6-map/node_modules/es5-ext/object/_iterate.js": [function(require,module,exports){
'use strict';

var callable = require('./valid-callable')
  , value    = require('./valid-value')

  , bind = Function.prototype.bind, call = Function.prototype.call, keys = Object.keys
  , propertyIsEnumerable = Object.prototype.propertyIsEnumerable;

module.exports = function (method, defVal) {
	return function (obj, cb/*, thisArg, compareFn*/) {
		var list, thisArg = arguments[2], compareFn = arguments[3];
		obj = Object(value(obj));
		callable(cb);

		list = keys(obj);
		if (compareFn) {
			list.sort((typeof compareFn === 'function') ? bind.call(compareFn, obj) : undefined);
		}
		if (typeof method !== 'function') method = list[method];
		return call.call(method, list, function (key, index) {
			if (!propertyIsEnumerable.call(obj, key)) return defVal;
			return call.call(cb, thisArg, obj[key], key, obj, index);
		});
	};
};

},
   {"./valid-callable":"/node_modules/es6-map/node_modules/es5-ext/object/valid-callable.js","./valid-value":"/node_modules/es6-map/node_modules/es5-ext/object/valid-value.js"}],

"/node_modules/es6-map/node_modules/es5-ext/object/assign/index.js": [function(require,module,exports){
'use strict';

module.exports = require('./is-implemented')()
	? Object.assign
	: require('./shim');

},
   {"./is-implemented":"/node_modules/es6-map/node_modules/es5-ext/object/assign/is-implemented.js","./shim":"/node_modules/es6-map/node_modules/es5-ext/object/assign/shim.js"}],

"/node_modules/es6-map/node_modules/es5-ext/object/assign/is-implemented.js": [function(require,module,exports){
'use strict';

module.exports = function () {
	var assign = Object.assign, obj;
	if (typeof assign !== 'function') return false;
	obj = { foo: 'raz' };
	assign(obj, { bar: 'dwa' }, { trzy: 'trzy' });
	return (obj.foo + obj.bar + obj.trzy) === 'razdwatrzy';
};

},
   {}],

"/node_modules/es6-map/node_modules/es5-ext/object/assign/shim.js": [function(require,module,exports){
'use strict';

var keys  = require('../keys')
  , value = require('../valid-value')

  , max = Math.max;

module.exports = function (dest, src/*, srcn*/) {
	var error, i, l = max(arguments.length, 2), assign;
	dest = Object(value(dest));
	assign = function (key) {
		try { dest[key] = src[key]; } catch (e) {
			if (!error) error = e;
		}
	};
	for (i = 1; i < l; ++i) {
		src = arguments[i];
		keys(src).forEach(assign);
	}
	if (error !== undefined) throw error;
	return dest;
};

},
   {"../keys":"/node_modules/es6-map/node_modules/es5-ext/object/keys/index.js","../valid-value":"/node_modules/es6-map/node_modules/es5-ext/object/valid-value.js"}],

"/node_modules/es6-map/node_modules/es5-ext/object/copy.js": [function(require,module,exports){
'use strict';

var assign = require('./assign')
  , value  = require('./valid-value');

module.exports = function (obj) {
	var copy = Object(value(obj));
	if (copy !== obj) return copy;
	return assign({}, obj);
};

},
   {"./assign":"/node_modules/es6-map/node_modules/es5-ext/object/assign/index.js","./valid-value":"/node_modules/es6-map/node_modules/es5-ext/object/valid-value.js"}],

"/node_modules/es6-map/node_modules/es5-ext/object/create.js": [function(require,module,exports){
'use strict';

var create = Object.create, shim;

if (!require('./set-prototype-of/is-implemented')()) {
	shim = require('./set-prototype-of/shim');
}

module.exports = (function () {
	var nullObject, props, desc;
	if (!shim) return create;
	if (shim.level !== 1) return create;

	nullObject = {};
	props = {};
	desc = { configurable: false, enumerable: false, writable: true,
		value: undefined };
	Object.getOwnPropertyNames(Object.prototype).forEach(function (name) {
		if (name === '__proto__') {
			props[name] = { configurable: true, enumerable: false, writable: true,
				value: undefined };
			return;
		}
		props[name] = desc;
	});
	Object.defineProperties(nullObject, props);

	Object.defineProperty(shim, 'nullPolyfill', { configurable: false,
		enumerable: false, writable: false, value: nullObject });

	return function (prototype, props) {
		return create((prototype === null) ? nullObject : prototype, props);
	};
}());

},
   {"./set-prototype-of/is-implemented":"/node_modules/es6-map/node_modules/es5-ext/object/set-prototype-of/is-implemented.js","./set-prototype-of/shim":"/node_modules/es6-map/node_modules/es5-ext/object/set-prototype-of/shim.js"}],

"/node_modules/es6-map/node_modules/es5-ext/object/for-each.js": [function(require,module,exports){
'use strict';

module.exports = require('./_iterate')('forEach');

},
   {"./_iterate":"/node_modules/es6-map/node_modules/es5-ext/object/_iterate.js"}],

"/node_modules/es6-map/node_modules/es5-ext/object/is-callable.js": [function(require,module,exports){
'use strict';

module.exports = function (obj) { return typeof obj === 'function'; };

},
   {}],

"/node_modules/es6-map/node_modules/es5-ext/object/is-object.js": [function(require,module,exports){
'use strict';

var map = { function: true, object: true };

module.exports = function (x) {
	return ((x != null) && map[typeof x]) || false;
};

},
   {}],

"/node_modules/es6-map/node_modules/es5-ext/object/keys/index.js": [function(require,module,exports){
'use strict';

module.exports = require('./is-implemented')()
	? Object.keys
	: require('./shim');

},
   {"./is-implemented":"/node_modules/es6-map/node_modules/es5-ext/object/keys/is-implemented.js","./shim":"/node_modules/es6-map/node_modules/es5-ext/object/keys/shim.js"}],

"/node_modules/es6-map/node_modules/es5-ext/object/keys/is-implemented.js": [function(require,module,exports){
'use strict';

module.exports = function () {
	try {
		Object.keys('primitive');
		return true;
	} catch (e) { return false; }
};

},
   {}],

"/node_modules/es6-map/node_modules/es5-ext/object/keys/shim.js": [function(require,module,exports){
'use strict';

var keys = Object.keys;

module.exports = function (object) {
	return keys(object == null ? object : Object(object));
};

},
   {}],

"/node_modules/es6-map/node_modules/es5-ext/object/map.js": [function(require,module,exports){
'use strict';

var callable = require('./valid-callable')
  , forEach  = require('./for-each')

  , call = Function.prototype.call;

module.exports = function (obj, cb/*, thisArg*/) {
	var o = {}, thisArg = arguments[2];
	callable(cb);
	forEach(obj, function (value, key, obj, index) {
		o[key] = call.call(cb, thisArg, value, key, obj, index);
	});
	return o;
};

},
   {"./for-each":"/node_modules/es6-map/node_modules/es5-ext/object/for-each.js","./valid-callable":"/node_modules/es6-map/node_modules/es5-ext/object/valid-callable.js"}],

"/node_modules/es6-map/node_modules/es5-ext/object/normalize-options.js": [function(require,module,exports){
'use strict';

var forEach = Array.prototype.forEach, create = Object.create;

var process = function (src, obj) {
	var key;
	for (key in src) obj[key] = src[key];
};

module.exports = function (options/*, options*/) {
	var result = create(null);
	forEach.call(arguments, function (options) {
		if (options == null) return;
		process(Object(options), result);
	});
	return result;
};

},
   {}],

"/node_modules/es6-map/node_modules/es5-ext/object/primitive-set.js": [function(require,module,exports){
'use strict';

var forEach = Array.prototype.forEach, create = Object.create;

module.exports = function (arg/*, args*/) {
	var set = create(null);
	forEach.call(arguments, function (name) { set[name] = true; });
	return set;
};

},
   {}],

"/node_modules/es6-map/node_modules/es5-ext/object/set-prototype-of/index.js": [function(require,module,exports){
'use strict';

module.exports = require('./is-implemented')()
	? Object.setPrototypeOf
	: require('./shim');

},
   {"./is-implemented":"/node_modules/es6-map/node_modules/es5-ext/object/set-prototype-of/is-implemented.js","./shim":"/node_modules/es6-map/node_modules/es5-ext/object/set-prototype-of/shim.js"}],

"/node_modules/es6-map/node_modules/es5-ext/object/set-prototype-of/is-implemented.js": [function(require,module,exports){
'use strict';

var create = Object.create, getPrototypeOf = Object.getPrototypeOf
  , x = {};

module.exports = function (/*customCreate*/) {
	var setPrototypeOf = Object.setPrototypeOf
	  , customCreate = arguments[0] || create;
	if (typeof setPrototypeOf !== 'function') return false;
	return getPrototypeOf(setPrototypeOf(customCreate(null), x)) === x;
};

},
   {}],

"/node_modules/es6-map/node_modules/es5-ext/object/set-prototype-of/shim.js": [function(require,module,exports){
'use strict';

var isObject      = require('../is-object')
  , value         = require('../valid-value')

  , isPrototypeOf = Object.prototype.isPrototypeOf
  , defineProperty = Object.defineProperty
  , nullDesc = { configurable: true, enumerable: false, writable: true,
		value: undefined }
  , validate;

validate = function (obj, prototype) {
	value(obj);
	if ((prototype === null) || isObject(prototype)) return obj;
	throw new TypeError('Prototype must be null or an object');
};

module.exports = (function (status) {
	var fn, set;
	if (!status) return null;
	if (status.level === 2) {
		if (status.set) {
			set = status.set;
			fn = function (obj, prototype) {
				set.call(validate(obj, prototype), prototype);
				return obj;
			};
		} else {
			fn = function (obj, prototype) {
				validate(obj, prototype).__proto__ = prototype;
				return obj;
			};
		}
	} else {
		fn = function self(obj, prototype) {
			var isNullBase;
			validate(obj, prototype);
			isNullBase = isPrototypeOf.call(self.nullPolyfill, obj);
			if (isNullBase) delete self.nullPolyfill.__proto__;
			if (prototype === null) prototype = self.nullPolyfill;
			obj.__proto__ = prototype;
			if (isNullBase) defineProperty(self.nullPolyfill, '__proto__', nullDesc);
			return obj;
		};
	}
	return Object.defineProperty(fn, 'level', { configurable: false,
		enumerable: false, writable: false, value: status.level });
}((function () {
	var x = Object.create(null), y = {}, set
	  , desc = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__');

	if (desc) {
		try {
			set = desc.set; // Opera crashes at this point
			set.call(x, y);
		} catch (ignore) { }
		if (Object.getPrototypeOf(x) === y) return { set: set, level: 2 };
	}

	x.__proto__ = y;
	if (Object.getPrototypeOf(x) === y) return { level: 2 };

	x = {};
	x.__proto__ = y;
	if (Object.getPrototypeOf(x) === y) return { level: 1 };

	return false;
}())));

require('../create');

},
   {"../create":"/node_modules/es6-map/node_modules/es5-ext/object/create.js","../is-object":"/node_modules/es6-map/node_modules/es5-ext/object/is-object.js","../valid-value":"/node_modules/es6-map/node_modules/es5-ext/object/valid-value.js"}],

"/node_modules/es6-map/node_modules/es5-ext/object/valid-callable.js": [function(require,module,exports){
'use strict';

module.exports = function (fn) {
	if (typeof fn !== 'function') throw new TypeError(fn + " is not a function");
	return fn;
};

},
   {}],

"/node_modules/es6-map/node_modules/es5-ext/object/valid-value.js": [function(require,module,exports){
'use strict';

module.exports = function (value) {
	if (value == null) throw new TypeError("Cannot use null or undefined");
	return value;
};

},
   {}],

"/node_modules/es6-map/node_modules/es5-ext/string/#/contains/index.js": [function(require,module,exports){
'use strict';

module.exports = require('./is-implemented')()
	? String.prototype.contains
	: require('./shim');

},
   {"./is-implemented":"/node_modules/es6-map/node_modules/es5-ext/string/#/contains/is-implemented.js","./shim":"/node_modules/es6-map/node_modules/es5-ext/string/#/contains/shim.js"}],

"/node_modules/es6-map/node_modules/es5-ext/string/#/contains/is-implemented.js": [function(require,module,exports){
'use strict';

var str = 'razdwatrzy';

module.exports = function () {
	if (typeof str.contains !== 'function') return false;
	return ((str.contains('dwa') === true) && (str.contains('foo') === false));
};

},
   {}],

"/node_modules/es6-map/node_modules/es5-ext/string/#/contains/shim.js": [function(require,module,exports){
'use strict';

var indexOf = String.prototype.indexOf;

module.exports = function (searchString/*, position*/) {
	return indexOf.call(this, searchString, arguments[1]) > -1;
};

},
   {}],

"/node_modules/es6-map/node_modules/es5-ext/string/is-string.js": [function(require,module,exports){
'use strict';

var toString = Object.prototype.toString

  , id = toString.call('');

module.exports = function (x) {
	return (typeof x === 'string') || (x && (typeof x === 'object') &&
		((x instanceof String) || (toString.call(x) === id))) || false;
};

},
   {}],

"/node_modules/es6-map/node_modules/es6-iterator/array.js": [function(require,module,exports){
'use strict';

var setPrototypeOf = require('es5-ext/object/set-prototype-of')
  , contains       = require('es5-ext/string/#/contains')
  , d              = require('d')
  , Iterator       = require('./')

  , defineProperty = Object.defineProperty
  , ArrayIterator;

ArrayIterator = module.exports = function (arr, kind) {
	if (!(this instanceof ArrayIterator)) return new ArrayIterator(arr, kind);
	Iterator.call(this, arr);
	if (!kind) kind = 'value';
	else if (contains.call(kind, 'key+value')) kind = 'key+value';
	else if (contains.call(kind, 'key')) kind = 'key';
	else kind = 'value';
	defineProperty(this, '__kind__', d('', kind));
};
if (setPrototypeOf) setPrototypeOf(ArrayIterator, Iterator);

ArrayIterator.prototype = Object.create(Iterator.prototype, {
	constructor: d(ArrayIterator),
	_resolve: d(function (i) {
		if (this.__kind__ === 'value') return this.__list__[i];
		if (this.__kind__ === 'key+value') return [i, this.__list__[i]];
		return i;
	}),
	toString: d(function () { return '[object Array Iterator]'; })
});

},
   {"./":"/node_modules/es6-map/node_modules/es6-iterator/index.js","d":"/node_modules/es6-map/node_modules/d/index.js","es5-ext/object/set-prototype-of":"/node_modules/es6-map/node_modules/es5-ext/object/set-prototype-of/index.js","es5-ext/string/#/contains":"/node_modules/es6-map/node_modules/es5-ext/string/#/contains/index.js"}],

"/node_modules/es6-map/node_modules/es6-iterator/for-of.js": [function(require,module,exports){
'use strict';

var isArguments = require('es5-ext/function/is-arguments')
  , callable    = require('es5-ext/object/valid-callable')
  , isString    = require('es5-ext/string/is-string')
  , get         = require('./get')

  , isArray = Array.isArray, call = Function.prototype.call
  , some = Array.prototype.some;

module.exports = function (iterable, cb/*, thisArg*/) {
	var mode, thisArg = arguments[2], result, doBreak, broken, i, l, char, code;
	if (isArray(iterable) || isArguments(iterable)) mode = 'array';
	else if (isString(iterable)) mode = 'string';
	else iterable = get(iterable);

	callable(cb);
	doBreak = function () { broken = true; };
	if (mode === 'array') {
		some.call(iterable, function (value) {
			call.call(cb, thisArg, value, doBreak);
			if (broken) return true;
		});
		return;
	}
	if (mode === 'string') {
		l = iterable.length;
		for (i = 0; i < l; ++i) {
			char = iterable[i];
			if ((i + 1) < l) {
				code = char.charCodeAt(0);
				if ((code >= 0xD800) && (code <= 0xDBFF)) char += iterable[++i];
			}
			call.call(cb, thisArg, char, doBreak);
			if (broken) break;
		}
		return;
	}
	result = iterable.next();

	while (!result.done) {
		call.call(cb, thisArg, result.value, doBreak);
		if (broken) return;
		result = iterable.next();
	}
};

},
   {"./get":"/node_modules/es6-map/node_modules/es6-iterator/get.js","es5-ext/function/is-arguments":"/node_modules/es6-map/node_modules/es5-ext/function/is-arguments.js","es5-ext/object/valid-callable":"/node_modules/es6-map/node_modules/es5-ext/object/valid-callable.js","es5-ext/string/is-string":"/node_modules/es6-map/node_modules/es5-ext/string/is-string.js"}],

"/node_modules/es6-map/node_modules/es6-iterator/get.js": [function(require,module,exports){
'use strict';

var isArguments    = require('es5-ext/function/is-arguments')
  , isString       = require('es5-ext/string/is-string')
  , ArrayIterator  = require('./array')
  , StringIterator = require('./string')
  , iterable       = require('./valid-iterable')
  , iteratorSymbol = require('es6-symbol').iterator;

module.exports = function (obj) {
	if (typeof iterable(obj)[iteratorSymbol] === 'function') return obj[iteratorSymbol]();
	if (isArguments(obj)) return new ArrayIterator(obj);
	if (isString(obj)) return new StringIterator(obj);
	return new ArrayIterator(obj);
};

},
   {"./array":"/node_modules/es6-map/node_modules/es6-iterator/array.js","./string":"/node_modules/es6-map/node_modules/es6-iterator/string.js","./valid-iterable":"/node_modules/es6-map/node_modules/es6-iterator/valid-iterable.js","es5-ext/function/is-arguments":"/node_modules/es6-map/node_modules/es5-ext/function/is-arguments.js","es5-ext/string/is-string":"/node_modules/es6-map/node_modules/es5-ext/string/is-string.js","es6-symbol":"/node_modules/es6-map/node_modules/es6-symbol/index.js"}],

"/node_modules/es6-map/node_modules/es6-iterator/index.js": [function(require,module,exports){
'use strict';

var clear    = require('es5-ext/array/#/clear')
  , assign   = require('es5-ext/object/assign')
  , callable = require('es5-ext/object/valid-callable')
  , value    = require('es5-ext/object/valid-value')
  , d        = require('d')
  , autoBind = require('d/auto-bind')
  , Symbol   = require('es6-symbol')

  , defineProperty = Object.defineProperty
  , defineProperties = Object.defineProperties
  , Iterator;

module.exports = Iterator = function (list, context) {
	if (!(this instanceof Iterator)) return new Iterator(list, context);
	defineProperties(this, {
		__list__: d('w', value(list)),
		__context__: d('w', context),
		__nextIndex__: d('w', 0)
	});
	if (!context) return;
	callable(context.on);
	context.on('_add', this._onAdd);
	context.on('_delete', this._onDelete);
	context.on('_clear', this._onClear);
};

defineProperties(Iterator.prototype, assign({
	constructor: d(Iterator),
	_next: d(function () {
		var i;
		if (!this.__list__) return;
		if (this.__redo__) {
			i = this.__redo__.shift();
			if (i !== undefined) return i;
		}
		if (this.__nextIndex__ < this.__list__.length) return this.__nextIndex__++;
		this._unBind();
	}),
	next: d(function () { return this._createResult(this._next()); }),
	_createResult: d(function (i) {
		if (i === undefined) return { done: true, value: undefined };
		return { done: false, value: this._resolve(i) };
	}),
	_resolve: d(function (i) { return this.__list__[i]; }),
	_unBind: d(function () {
		this.__list__ = null;
		delete this.__redo__;
		if (!this.__context__) return;
		this.__context__.off('_add', this._onAdd);
		this.__context__.off('_delete', this._onDelete);
		this.__context__.off('_clear', this._onClear);
		this.__context__ = null;
	}),
	toString: d(function () { return '[object Iterator]'; })
}, autoBind({
	_onAdd: d(function (index) {
		if (index >= this.__nextIndex__) return;
		++this.__nextIndex__;
		if (!this.__redo__) {
			defineProperty(this, '__redo__', d('c', [index]));
			return;
		}
		this.__redo__.forEach(function (redo, i) {
			if (redo >= index) this.__redo__[i] = ++redo;
		}, this);
		this.__redo__.push(index);
	}),
	_onDelete: d(function (index) {
		var i;
		if (index >= this.__nextIndex__) return;
		--this.__nextIndex__;
		if (!this.__redo__) return;
		i = this.__redo__.indexOf(index);
		if (i !== -1) this.__redo__.splice(i, 1);
		this.__redo__.forEach(function (redo, i) {
			if (redo > index) this.__redo__[i] = --redo;
		}, this);
	}),
	_onClear: d(function () {
		if (this.__redo__) clear.call(this.__redo__);
		this.__nextIndex__ = 0;
	})
})));

defineProperty(Iterator.prototype, Symbol.iterator, d(function () {
	return this;
}));
defineProperty(Iterator.prototype, Symbol.toStringTag, d('', 'Iterator'));

},
   {"d":"/node_modules/es6-map/node_modules/d/index.js","d/auto-bind":"/node_modules/es6-map/node_modules/d/auto-bind.js","es5-ext/array/#/clear":"/node_modules/es6-map/node_modules/es5-ext/array/#/clear.js","es5-ext/object/assign":"/node_modules/es6-map/node_modules/es5-ext/object/assign/index.js","es5-ext/object/valid-callable":"/node_modules/es6-map/node_modules/es5-ext/object/valid-callable.js","es5-ext/object/valid-value":"/node_modules/es6-map/node_modules/es5-ext/object/valid-value.js","es6-symbol":"/node_modules/es6-map/node_modules/es6-symbol/index.js"}],

"/node_modules/es6-map/node_modules/es6-iterator/is-iterable.js": [function(require,module,exports){
'use strict';

var isArguments    = require('es5-ext/function/is-arguments')
  , isString       = require('es5-ext/string/is-string')
  , iteratorSymbol = require('es6-symbol').iterator

  , isArray = Array.isArray;

module.exports = function (value) {
	if (value == null) return false;
	if (isArray(value)) return true;
	if (isString(value)) return true;
	if (isArguments(value)) return true;
	return (typeof value[iteratorSymbol] === 'function');
};

},
   {"es5-ext/function/is-arguments":"/node_modules/es6-map/node_modules/es5-ext/function/is-arguments.js","es5-ext/string/is-string":"/node_modules/es6-map/node_modules/es5-ext/string/is-string.js","es6-symbol":"/node_modules/es6-map/node_modules/es6-symbol/index.js"}],

"/node_modules/es6-map/node_modules/es6-iterator/string.js": [function(require,module,exports){
'use strict';

var setPrototypeOf = require('es5-ext/object/set-prototype-of')
  , d              = require('d')
  , Iterator       = require('./')

  , defineProperty = Object.defineProperty
  , StringIterator;

StringIterator = module.exports = function (str) {
	if (!(this instanceof StringIterator)) return new StringIterator(str);
	str = String(str);
	Iterator.call(this, str);
	defineProperty(this, '__length__', d('', str.length));

};
if (setPrototypeOf) setPrototypeOf(StringIterator, Iterator);

StringIterator.prototype = Object.create(Iterator.prototype, {
	constructor: d(StringIterator),
	_next: d(function () {
		if (!this.__list__) return;
		if (this.__nextIndex__ < this.__length__) return this.__nextIndex__++;
		this._unBind();
	}),
	_resolve: d(function (i) {
		var char = this.__list__[i], code;
		if (this.__nextIndex__ === this.__length__) return char;
		code = char.charCodeAt(0);
		if ((code >= 0xD800) && (code <= 0xDBFF)) return char + this.__list__[this.__nextIndex__++];
		return char;
	}),
	toString: d(function () { return '[object String Iterator]'; })
});

},
   {"./":"/node_modules/es6-map/node_modules/es6-iterator/index.js","d":"/node_modules/es6-map/node_modules/d/index.js","es5-ext/object/set-prototype-of":"/node_modules/es6-map/node_modules/es5-ext/object/set-prototype-of/index.js"}],

"/node_modules/es6-map/node_modules/es6-iterator/valid-iterable.js": [function(require,module,exports){
'use strict';

var isIterable = require('./is-iterable');

module.exports = function (value) {
	if (!isIterable(value)) throw new TypeError(value + " is not iterable");
	return value;
};

},
   {"./is-iterable":"/node_modules/es6-map/node_modules/es6-iterator/is-iterable.js"}],

"/node_modules/es6-map/node_modules/es6-symbol/index.js": [function(require,module,exports){
'use strict';

module.exports = require('./is-implemented')() ? Symbol : require('./polyfill');

},
   {"./is-implemented":"/node_modules/es6-map/node_modules/es6-symbol/is-implemented.js","./polyfill":"/node_modules/es6-map/node_modules/es6-symbol/polyfill.js"}],

"/node_modules/es6-map/node_modules/es6-symbol/is-implemented.js": [function(require,module,exports){
'use strict';

module.exports = function () {
	var symbol;
	if (typeof Symbol !== 'function') return false;
	symbol = Symbol('test symbol');
	try { String(symbol); } catch (e) { return false; }
	if (typeof Symbol.iterator === 'symbol') return true;

	if (typeof Symbol.isConcatSpreadable !== 'object') return false;
	if (typeof Symbol.iterator !== 'object') return false;
	if (typeof Symbol.toPrimitive !== 'object') return false;
	if (typeof Symbol.toStringTag !== 'object') return false;
	if (typeof Symbol.unscopables !== 'object') return false;

	return true;
};

},
   {}],

"/node_modules/es6-map/node_modules/es6-symbol/is-symbol.js": [function(require,module,exports){
'use strict';

module.exports = function (x) {
	return (x && ((typeof x === 'symbol') || (x['@@toStringTag'] === 'Symbol'))) || false;
};

},
   {}],

"/node_modules/es6-map/node_modules/es6-symbol/polyfill.js": [function(require,module,exports){
'use strict';

var d              = require('d')
  , validateSymbol = require('./validate-symbol')

  , create = Object.create, defineProperties = Object.defineProperties
  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create(null);

if (typeof Symbol === 'function') NativeSymbol = Symbol;

var generateName = (function () {
	var created = create(null);
	return function (desc) {
		var postfix = 0, name, ie11BugWorkaround;
		while (created[desc + (postfix || '')]) ++postfix;
		desc += (postfix || '');
		created[desc] = true;
		name = '@@' + desc;
		defineProperty(objPrototype, name, d.gs(null, function (value) {
			if (ie11BugWorkaround) return;
			ie11BugWorkaround = true;
			defineProperty(this, name, d(value));
			ie11BugWorkaround = false;
		}));
		return name;
	};
}());

HiddenSymbol = function Symbol(description) {
	if (this instanceof HiddenSymbol) throw new TypeError('TypeError: Symbol is not a constructor');
	return SymbolPolyfill(description);
};

module.exports = SymbolPolyfill = function Symbol(description) {
	var symbol;
	if (this instanceof Symbol) throw new TypeError('TypeError: Symbol is not a constructor');
	symbol = create(HiddenSymbol.prototype);
	description = (description === undefined ? '' : String(description));
	return defineProperties(symbol, {
		__description__: d('', description),
		__name__: d('', generateName(description))
	});
};
defineProperties(SymbolPolyfill, {
	for: d(function (key) {
		if (globalSymbols[key]) return globalSymbols[key];
		return (globalSymbols[key] = SymbolPolyfill(String(key)));
	}),
	keyFor: d(function (s) {
		var key;
		validateSymbol(s);
		for (key in globalSymbols) if (globalSymbols[key] === s) return key;
	}),

	hasInstance: d('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
	isConcatSpreadable: d('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
		SymbolPolyfill('isConcatSpreadable')),
	iterator: d('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
	match: d('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
	replace: d('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
	search: d('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
	species: d('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
	split: d('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
	toPrimitive: d('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
	toStringTag: d('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
	unscopables: d('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
});

defineProperties(HiddenSymbol.prototype, {
	constructor: d(SymbolPolyfill),
	toString: d('', function () { return this.__name__; })
});

defineProperties(SymbolPolyfill.prototype, {
	toString: d(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
	valueOf: d(function () { return validateSymbol(this); })
});
defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d('',
	function () { return validateSymbol(this); }));
defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d('c', 'Symbol'));

defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
	d('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
	d('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

},
   {"./validate-symbol":"/node_modules/es6-map/node_modules/es6-symbol/validate-symbol.js","d":"/node_modules/es6-map/node_modules/d/index.js"}],

"/node_modules/es6-map/node_modules/es6-symbol/validate-symbol.js": [function(require,module,exports){
'use strict';

var isSymbol = require('./is-symbol');

module.exports = function (value) {
	if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
	return value;
};

},
   {"./is-symbol":"/node_modules/es6-map/node_modules/es6-symbol/is-symbol.js"}],

"/node_modules/es6-map/node_modules/event-emitter/index.js": [function(require,module,exports){
'use strict';

var d        = require('d')
  , callable = require('es5-ext/object/valid-callable')

  , apply = Function.prototype.apply, call = Function.prototype.call
  , create = Object.create, defineProperty = Object.defineProperty
  , defineProperties = Object.defineProperties
  , hasOwnProperty = Object.prototype.hasOwnProperty
  , descriptor = { configurable: true, enumerable: false, writable: true }

  , on, once, off, emit, methods, descriptors, base;

on = function (type, listener) {
	var data;

	callable(listener);

	if (!hasOwnProperty.call(this, '__ee__')) {
		data = descriptor.value = create(null);
		defineProperty(this, '__ee__', descriptor);
		descriptor.value = null;
	} else {
		data = this.__ee__;
	}
	if (!data[type]) data[type] = listener;
	else if (typeof data[type] === 'object') data[type].push(listener);
	else data[type] = [data[type], listener];

	return this;
};

once = function (type, listener) {
	var once, self;

	callable(listener);
	self = this;
	on.call(this, type, once = function () {
		off.call(self, type, once);
		apply.call(listener, this, arguments);
	});

	once.__eeOnceListener__ = listener;
	return this;
};

off = function (type, listener) {
	var data, listeners, candidate, i;

	callable(listener);

	if (!hasOwnProperty.call(this, '__ee__')) return this;
	data = this.__ee__;
	if (!data[type]) return this;
	listeners = data[type];

	if (typeof listeners === 'object') {
		for (i = 0; (candidate = listeners[i]); ++i) {
			if ((candidate === listener) ||
					(candidate.__eeOnceListener__ === listener)) {
				if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
				else listeners.splice(i, 1);
			}
		}
	} else {
		if ((listeners === listener) ||
				(listeners.__eeOnceListener__ === listener)) {
			delete data[type];
		}
	}

	return this;
};

emit = function (type) {
	var i, l, listener, listeners, args;

	if (!hasOwnProperty.call(this, '__ee__')) return;
	listeners = this.__ee__[type];
	if (!listeners) return;

	if (typeof listeners === 'object') {
		l = arguments.length;
		args = new Array(l - 1);
		for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

		listeners = listeners.slice();
		for (i = 0; (listener = listeners[i]); ++i) {
			apply.call(listener, this, args);
		}
	} else {
		switch (arguments.length) {
		case 1:
			call.call(listeners, this);
			break;
		case 2:
			call.call(listeners, this, arguments[1]);
			break;
		case 3:
			call.call(listeners, this, arguments[1], arguments[2]);
			break;
		default:
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) {
				args[i - 1] = arguments[i];
			}
			apply.call(listeners, this, args);
		}
	}
};

methods = {
	on: on,
	once: once,
	off: off,
	emit: emit
};

descriptors = {
	on: d(on),
	once: d(once),
	off: d(off),
	emit: d(emit)
};

base = defineProperties({}, descriptors);

module.exports = exports = function (o) {
	return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
};
exports.methods = methods;

},
   {"d":"/node_modules/es6-map/node_modules/d/index.js","es5-ext/object/valid-callable":"/node_modules/es6-map/node_modules/es5-ext/object/valid-callable.js"}],

"/node_modules/es6-map/polyfill.js": [function(require,module,exports){
'use strict';

var clear          = require('es5-ext/array/#/clear')
  , eIndexOf       = require('es5-ext/array/#/e-index-of')
  , setPrototypeOf = require('es5-ext/object/set-prototype-of')
  , callable       = require('es5-ext/object/valid-callable')
  , validValue     = require('es5-ext/object/valid-value')
  , d              = require('d')
  , ee             = require('event-emitter')
  , Symbol         = require('es6-symbol')
  , iterator       = require('es6-iterator/valid-iterable')
  , forOf          = require('es6-iterator/for-of')
  , Iterator       = require('./lib/iterator')
  , isNative       = require('./is-native-implemented')

  , call = Function.prototype.call
  , defineProperties = Object.defineProperties, getPrototypeOf = Object.getPrototypeOf
  , MapPoly;

module.exports = MapPoly = function (/*iterable*/) {
	var iterable = arguments[0], keys, values, self;
	if (!(this instanceof MapPoly)) throw new TypeError('Constructor requires \'new\'');
	if (isNative && setPrototypeOf && (Map !== MapPoly)) {
		self = setPrototypeOf(new Map(), getPrototypeOf(this));
	} else {
		self = this;
	}
	if (iterable != null) iterator(iterable);
	defineProperties(self, {
		__mapKeysData__: d('c', keys = []),
		__mapValuesData__: d('c', values = [])
	});
	if (!iterable) return self;
	forOf(iterable, function (value) {
		var key = validValue(value)[0];
		value = value[1];
		if (eIndexOf.call(keys, key) !== -1) return;
		keys.push(key);
		values.push(value);
	}, self);
	return self;
};

if (isNative) {
	if (setPrototypeOf) setPrototypeOf(MapPoly, Map);
	MapPoly.prototype = Object.create(Map.prototype, {
		constructor: d(MapPoly)
	});
}

ee(defineProperties(MapPoly.prototype, {
	clear: d(function () {
		if (!this.__mapKeysData__.length) return;
		clear.call(this.__mapKeysData__);
		clear.call(this.__mapValuesData__);
		this.emit('_clear');
	}),
	delete: d(function (key) {
		var index = eIndexOf.call(this.__mapKeysData__, key);
		if (index === -1) return false;
		this.__mapKeysData__.splice(index, 1);
		this.__mapValuesData__.splice(index, 1);
		this.emit('_delete', index, key);
		return true;
	}),
	entries: d(function () { return new Iterator(this, 'key+value'); }),
	forEach: d(function (cb/*, thisArg*/) {
		var thisArg = arguments[1], iterator, result;
		callable(cb);
		iterator = this.entries();
		result = iterator._next();
		while (result !== undefined) {
			call.call(cb, thisArg, this.__mapValuesData__[result],
				this.__mapKeysData__[result], this);
			result = iterator._next();
		}
	}),
	get: d(function (key) {
		var index = eIndexOf.call(this.__mapKeysData__, key);
		if (index === -1) return;
		return this.__mapValuesData__[index];
	}),
	has: d(function (key) {
		return (eIndexOf.call(this.__mapKeysData__, key) !== -1);
	}),
	keys: d(function () { return new Iterator(this, 'key'); }),
	set: d(function (key, value) {
		var index = eIndexOf.call(this.__mapKeysData__, key), emit;
		if (index === -1) {
			index = this.__mapKeysData__.push(key) - 1;
			emit = true;
		}
		this.__mapValuesData__[index] = value;
		if (emit) this.emit('_add', index, key);
		return this;
	}),
	size: d.gs(function () { return this.__mapKeysData__.length; }),
	values: d(function () { return new Iterator(this, 'value'); }),
	toString: d(function () { return '[object Map]'; })
}));
Object.defineProperty(MapPoly.prototype, Symbol.iterator, d(function () {
	return this.entries();
}));
Object.defineProperty(MapPoly.prototype, Symbol.toStringTag, d('c', 'Map'));

},
   {"./is-native-implemented":"/node_modules/es6-map/is-native-implemented.js","./lib/iterator":"/node_modules/es6-map/lib/iterator.js","d":"/node_modules/es6-map/node_modules/d/index.js","es5-ext/array/#/clear":"/node_modules/es6-map/node_modules/es5-ext/array/#/clear.js","es5-ext/array/#/e-index-of":"/node_modules/es6-map/node_modules/es5-ext/array/#/e-index-of.js","es5-ext/object/set-prototype-of":"/node_modules/es6-map/node_modules/es5-ext/object/set-prototype-of/index.js","es5-ext/object/valid-callable":"/node_modules/es6-map/node_modules/es5-ext/object/valid-callable.js","es5-ext/object/valid-value":"/node_modules/es6-map/node_modules/es5-ext/object/valid-value.js","es6-iterator/for-of":"/node_modules/es6-map/node_modules/es6-iterator/for-of.js","es6-iterator/valid-iterable":"/node_modules/es6-map/node_modules/es6-iterator/valid-iterable.js","es6-symbol":"/node_modules/es6-map/node_modules/es6-symbol/index.js","event-emitter":"/node_modules/es6-map/node_modules/event-emitter/index.js"}],

"/node_modules/escope/lib/definition.js": [function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Definition = exports.ParameterDefinition = undefined;

var _variable = require('./variable');

var _variable2 = _interopRequireDefault(_variable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
                                                                                                                                                            Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>
                                                                                                                                                          
                                                                                                                                                            Redistribution and use in source and binary forms, with or without
                                                                                                                                                            modification, are permitted provided that the following conditions are met:
                                                                                                                                                          
                                                                                                                                                              * Redistributions of source code must retain the above copyright
                                                                                                                                                                notice, this list of conditions and the following disclaimer.
                                                                                                                                                              * Redistributions in binary form must reproduce the above copyright
                                                                                                                                                                notice, this list of conditions and the following disclaimer in the
                                                                                                                                                                documentation and/or other materials provided with the distribution.
                                                                                                                                                          
                                                                                                                                                            THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                                                                                                                                                            AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                                                                                                                                                            IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
                                                                                                                                                            ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
                                                                                                                                                            DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
                                                                                                                                                            (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
                                                                                                                                                            LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
                                                                                                                                                            ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
                                                                                                                                                            (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
                                                                                                                                                            THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                                                                                                                                          */

var Definition = function Definition(type, name, node, parent, index, kind) {
  _classCallCheck(this, Definition);

  this.type = type;
  this.name = name;
  this.node = node;
  this.parent = parent;
  this.index = index;
  this.kind = kind;
};


exports.default = Definition;

var ParameterDefinition = function (_Definition) {
  _inherits(ParameterDefinition, _Definition);

  function ParameterDefinition(name, node, index, rest) {
    _classCallCheck(this, ParameterDefinition);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ParameterDefinition).call(this, _variable2.default.Parameter, name, node, null, index, null));

    _this.rest = rest;
    return _this;
  }

  return ParameterDefinition;
}(Definition);

exports.ParameterDefinition = ParameterDefinition;
exports.Definition = Definition;


},
   {"./variable":"/node_modules/escope/lib/variable.js"}],

"/node_modules/escope/lib/index.js": [function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ScopeManager = exports.Scope = exports.Variable = exports.Reference = exports.version = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; }; /*
                                                                                                                                                                                                                                                    Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>
                                                                                                                                                                                                                                                    Copyright (C) 2013 Alex Seville <hi@alexanderseville.com>
                                                                                                                                                                                                                                                    Copyright (C) 2014 Thiago de Arruda <tpadilha84@gmail.com>
                                                                                                                                                                                                                                                  
                                                                                                                                                                                                                                                    Redistribution and use in source and binary forms, with or without
                                                                                                                                                                                                                                                    modification, are permitted provided that the following conditions are met:
                                                                                                                                                                                                                                                  
                                                                                                                                                                                                                                                      * Redistributions of source code must retain the above copyright
                                                                                                                                                                                                                                                        notice, this list of conditions and the following disclaimer.
                                                                                                                                                                                                                                                      * Redistributions in binary form must reproduce the above copyright
                                                                                                                                                                                                                                                        notice, this list of conditions and the following disclaimer in the
                                                                                                                                                                                                                                                        documentation and/or other materials provided with the distribution.
                                                                                                                                                                                                                                                  
                                                                                                                                                                                                                                                    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                                                                                                                                                                                                                                                    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                                                                                                                                                                                                                                                    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
                                                                                                                                                                                                                                                    ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
                                                                                                                                                                                                                                                    DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
                                                                                                                                                                                                                                                    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
                                                                                                                                                                                                                                                    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
                                                                                                                                                                                                                                                    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
                                                                                                                                                                                                                                                    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
                                                                                                                                                                                                                                                    THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                                                                                                                                                                                                                                  */

exports.analyze = analyze;

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _scopeManager = require('./scope-manager');

var _scopeManager2 = _interopRequireDefault(_scopeManager);

var _referencer = require('./referencer');

var _referencer2 = _interopRequireDefault(_referencer);

var _reference = require('./reference');

var _reference2 = _interopRequireDefault(_reference);

var _variable = require('./variable');

var _variable2 = _interopRequireDefault(_variable);

var _scope = require('./scope');

var _scope2 = _interopRequireDefault(_scope);

var _package = require('../package.json');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function defaultOptions() {
    return {
        optimistic: false,
        directive: false,
        nodejsScope: false,
        impliedStrict: false,
        sourceType: 'script', // one of ['script', 'module']
        ecmaVersion: 5,
        childVisitorKeys: null,
        fallback: 'iteration'
    };
}

function updateDeeply(target, override) {
    var key, val;

    function isHashObject(target) {
        return (typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object' && target instanceof Object && !(target instanceof Array) && !(target instanceof RegExp);
    }

    for (key in override) {
        if (override.hasOwnProperty(key)) {
            val = override[key];
            if (isHashObject(val)) {
                if (isHashObject(target[key])) {
                    updateDeeply(target[key], val);
                } else {
                    target[key] = updateDeeply({}, val);
                }
            } else {
                target[key] = val;
            }
        }
    }
    return target;
}

function analyze(tree, providedOptions) {
    var scopeManager, referencer, options;

    options = updateDeeply(defaultOptions(), providedOptions);

    scopeManager = new _scopeManager2.default(options);

    referencer = new _referencer2.default(options, scopeManager);
    referencer.visit(tree);

    (0, _assert2.default)(scopeManager.__currentScope === null, 'currentScope should be null.');

    return scopeManager;
}

exports.
version = _package.version;
exports.
Reference = _reference2.default;
exports.
Variable = _variable2.default;
exports.
Scope = _scope2.default;
exports.
ScopeManager = _scopeManager2.default;


},
   {"../package.json":"/node_modules/escope/package.json","./reference":"/node_modules/escope/lib/reference.js","./referencer":"/node_modules/escope/lib/referencer.js","./scope":"/node_modules/escope/lib/scope.js","./scope-manager":"/node_modules/escope/lib/scope-manager.js","./variable":"/node_modules/escope/lib/variable.js","assert":"/node_modules/browserify/node_modules/assert/assert.js"}],

"/node_modules/escope/lib/pattern-visitor.js": [function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _estraverse = require('estraverse');

var _esrecurse = require('esrecurse');

var _esrecurse2 = _interopRequireDefault(_esrecurse);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Redistribution and use in source and binary forms, with or without
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 modification, are permitted provided that the following conditions are met:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * Redistributions of source code must retain the above copyright
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     notice, this list of conditions and the following disclaimer.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * Redistributions in binary form must reproduce the above copyright
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     notice, this list of conditions and the following disclaimer in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     documentation and/or other materials provided with the distribution.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */

function getLast(xs) {
    return xs[xs.length - 1] || null;
}

var PatternVisitor = function (_esrecurse$Visitor) {
    _inherits(PatternVisitor, _esrecurse$Visitor);

    _createClass(PatternVisitor, null, [{
        key: 'isPattern',
        value: function isPattern(node) {
            var nodeType = node.type;
            return nodeType === _estraverse.Syntax.Identifier || nodeType === _estraverse.Syntax.ObjectPattern || nodeType === _estraverse.Syntax.ArrayPattern || nodeType === _estraverse.Syntax.SpreadElement || nodeType === _estraverse.Syntax.RestElement || nodeType === _estraverse.Syntax.AssignmentPattern;
        }
    }]);

    function PatternVisitor(options, rootPattern, callback) {
        _classCallCheck(this, PatternVisitor);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PatternVisitor).call(this, null, options));

        _this.rootPattern = rootPattern;
        _this.callback = callback;
        _this.assignments = [];
        _this.rightHandNodes = [];
        _this.restElements = [];
        return _this;
    }

    _createClass(PatternVisitor, [{
        key: 'Identifier',
        value: function Identifier(pattern) {
            var lastRestElement = getLast(this.restElements);
            this.callback(pattern, {
                topLevel: pattern === this.rootPattern,
                rest: lastRestElement != null && lastRestElement.argument === pattern,
                assignments: this.assignments
            });
        }
    }, {
        key: 'Property',
        value: function Property(property) {
            if (property.computed) {
                this.rightHandNodes.push(property.key);
            }

            this.visit(property.value);
        }
    }, {
        key: 'ArrayPattern',
        value: function ArrayPattern(pattern) {
            var i, iz, element;
            for (i = 0, iz = pattern.elements.length; i < iz; ++i) {
                element = pattern.elements[i];
                this.visit(element);
            }
        }
    }, {
        key: 'AssignmentPattern',
        value: function AssignmentPattern(pattern) {
            this.assignments.push(pattern);
            this.visit(pattern.left);
            this.rightHandNodes.push(pattern.right);
            this.assignments.pop();
        }
    }, {
        key: 'RestElement',
        value: function RestElement(pattern) {
            this.restElements.push(pattern);
            this.visit(pattern.argument);
            this.restElements.pop();
        }
    }, {
        key: 'MemberExpression',
        value: function MemberExpression(node) {
            if (node.computed) {
                this.rightHandNodes.push(node.property);
            }
            this.rightHandNodes.push(node.object);
        }

    }, {
        key: 'SpreadElement',
        value: function SpreadElement(node) {
            this.visit(node.argument);
        }
    }, {
        key: 'ArrayExpression',
        value: function ArrayExpression(node) {
            node.elements.forEach(this.visit, this);
        }
    }, {
        key: 'AssignmentExpression',
        value: function AssignmentExpression(node) {
            this.assignments.push(node);
            this.visit(node.left);
            this.rightHandNodes.push(node.right);
            this.assignments.pop();
        }
    }, {
        key: 'CallExpression',
        value: function CallExpression(node) {
            var _this2 = this;

            node.arguments.forEach(function (a) {
                _this2.rightHandNodes.push(a);
            });
            this.visit(node.callee);
        }
    }]);

    return PatternVisitor;
}(_esrecurse2.default.Visitor);


exports.default = PatternVisitor;

},
   {"esrecurse":"/node_modules/escope/node_modules/esrecurse/esrecurse.js","estraverse":"/node_modules/estraverse/estraverse.js"}],

"/node_modules/escope/lib/reference.js": [function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var READ = 0x1;
var WRITE = 0x2;
var RW = READ | WRITE;

var Reference = function () {
  function Reference(ident, scope, flag, writeExpr, maybeImplicitGlobal, partial, init) {
    _classCallCheck(this, Reference);

    this.identifier = ident;
    this.from = scope;
    this.tainted = false;
    this.resolved = null;
    this.flag = flag;
    if (this.isWrite()) {
      this.writeExpr = writeExpr;
      this.partial = partial;
      this.init = init;
    }
    this.__maybeImplicitGlobal = maybeImplicitGlobal;
  }


  _createClass(Reference, [{
    key: "isStatic",
    value: function isStatic() {
      return !this.tainted && this.resolved && this.resolved.scope.isStatic();
    }

  }, {
    key: "isWrite",
    value: function isWrite() {
      return !!(this.flag & Reference.WRITE);
    }

  }, {
    key: "isRead",
    value: function isRead() {
      return !!(this.flag & Reference.READ);
    }

  }, {
    key: "isReadOnly",
    value: function isReadOnly() {
      return this.flag === Reference.READ;
    }

  }, {
    key: "isWriteOnly",
    value: function isWriteOnly() {
      return this.flag === Reference.WRITE;
    }

  }, {
    key: "isReadWrite",
    value: function isReadWrite() {
      return this.flag === Reference.RW;
    }
  }]);

  return Reference;
}();


exports.default = Reference;
Reference.READ = READ;
Reference.WRITE = WRITE;
Reference.RW = RW;


},
   {}],

"/node_modules/escope/lib/referencer.js": [function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _estraverse = require('estraverse');

var _esrecurse = require('esrecurse');

var _esrecurse2 = _interopRequireDefault(_esrecurse);

var _reference = require('./reference');

var _reference2 = _interopRequireDefault(_reference);

var _variable = require('./variable');

var _variable2 = _interopRequireDefault(_variable);

var _patternVisitor = require('./pattern-visitor');

var _patternVisitor2 = _interopRequireDefault(_patternVisitor);

var _definition = require('./definition');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Redistribution and use in source and binary forms, with or without
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 modification, are permitted provided that the following conditions are met:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * Redistributions of source code must retain the above copyright
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     notice, this list of conditions and the following disclaimer.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * Redistributions in binary form must reproduce the above copyright
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     notice, this list of conditions and the following disclaimer in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     documentation and/or other materials provided with the distribution.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */


function traverseIdentifierInPattern(options, rootPattern, referencer, callback) {
    var visitor = new _patternVisitor2.default(options, rootPattern, callback);
    visitor.visit(rootPattern);

    if (referencer != null) {
        visitor.rightHandNodes.forEach(referencer.visit, referencer);
    }
}

var Importer = function (_esrecurse$Visitor) {
    _inherits(Importer, _esrecurse$Visitor);

    function Importer(declaration, referencer) {
        _classCallCheck(this, Importer);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Importer).call(this, null, referencer.options));

        _this.declaration = declaration;
        _this.referencer = referencer;
        return _this;
    }

    _createClass(Importer, [{
        key: 'visitImport',
        value: function visitImport(id, specifier) {
            var _this2 = this;

            this.referencer.visitPattern(id, function (pattern) {
                _this2.referencer.currentScope().__define(pattern, new _definition.Definition(_variable2.default.ImportBinding, pattern, specifier, _this2.declaration, null, null));
            });
        }
    }, {
        key: 'ImportNamespaceSpecifier',
        value: function ImportNamespaceSpecifier(node) {
            var local = node.local || node.id;
            if (local) {
                this.visitImport(local, node);
            }
        }
    }, {
        key: 'ImportDefaultSpecifier',
        value: function ImportDefaultSpecifier(node) {
            var local = node.local || node.id;
            this.visitImport(local, node);
        }
    }, {
        key: 'ImportSpecifier',
        value: function ImportSpecifier(node) {
            var local = node.local || node.id;
            if (node.name) {
                this.visitImport(node.name, node);
            } else {
                this.visitImport(local, node);
            }
        }
    }]);

    return Importer;
}(_esrecurse2.default.Visitor);


var Referencer = function (_esrecurse$Visitor2) {
    _inherits(Referencer, _esrecurse$Visitor2);

    function Referencer(options, scopeManager) {
        _classCallCheck(this, Referencer);

        var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(Referencer).call(this, null, options));

        _this3.options = options;
        _this3.scopeManager = scopeManager;
        _this3.parent = null;
        _this3.isInnerMethodDefinition = false;
        return _this3;
    }

    _createClass(Referencer, [{
        key: 'currentScope',
        value: function currentScope() {
            return this.scopeManager.__currentScope;
        }
    }, {
        key: 'close',
        value: function close(node) {
            while (this.currentScope() && node === this.currentScope().block) {
                this.scopeManager.__currentScope = this.currentScope().__close(this.scopeManager);
            }
        }
    }, {
        key: 'pushInnerMethodDefinition',
        value: function pushInnerMethodDefinition(isInnerMethodDefinition) {
            var previous = this.isInnerMethodDefinition;
            this.isInnerMethodDefinition = isInnerMethodDefinition;
            return previous;
        }
    }, {
        key: 'popInnerMethodDefinition',
        value: function popInnerMethodDefinition(isInnerMethodDefinition) {
            this.isInnerMethodDefinition = isInnerMethodDefinition;
        }
    }, {
        key: 'materializeTDZScope',
        value: function materializeTDZScope(node, iterationNode) {
            this.scopeManager.__nestTDZScope(node, iterationNode);
            this.visitVariableDeclaration(this.currentScope(), _variable2.default.TDZ, iterationNode.left, 0, true);
        }
    }, {
        key: 'materializeIterationScope',
        value: function materializeIterationScope(node) {
            var _this4 = this;

            var letOrConstDecl;
            this.scopeManager.__nestForScope(node);
            letOrConstDecl = node.left;
            this.visitVariableDeclaration(this.currentScope(), _variable2.default.Variable, letOrConstDecl, 0);
            this.visitPattern(letOrConstDecl.declarations[0].id, function (pattern) {
                _this4.currentScope().__referencing(pattern, _reference2.default.WRITE, node.right, null, true, true);
            });
        }
    }, {
        key: 'referencingDefaultValue',
        value: function referencingDefaultValue(pattern, assignments, maybeImplicitGlobal, init) {
            var scope = this.currentScope();
            assignments.forEach(function (assignment) {
                scope.__referencing(pattern, _reference2.default.WRITE, assignment.right, maybeImplicitGlobal, pattern !== assignment.left, init);
            });
        }
    }, {
        key: 'visitPattern',
        value: function visitPattern(node, options, callback) {
            if (typeof options === 'function') {
                callback = options;
                options = { processRightHandNodes: false };
            }
            traverseIdentifierInPattern(this.options, node, options.processRightHandNodes ? this : null, callback);
        }
    }, {
        key: 'visitFunction',
        value: function visitFunction(node) {
            var _this5 = this;

            var i, iz;
            if (node.type === _estraverse.Syntax.FunctionDeclaration) {
                this.currentScope().__define(node.id, new _definition.Definition(_variable2.default.FunctionName, node.id, node, null, null, null));
            }

            if (node.type === _estraverse.Syntax.FunctionExpression && node.id) {
                this.scopeManager.__nestFunctionExpressionNameScope(node);
            }

            this.scopeManager.__nestFunctionScope(node, this.isInnerMethodDefinition);

            for (i = 0, iz = node.params.length; i < iz; ++i) {
                this.visitPattern(node.params[i], { processRightHandNodes: true }, function (pattern, info) {
                    _this5.currentScope().__define(pattern, new _definition.ParameterDefinition(pattern, node, i, info.rest));

                    _this5.referencingDefaultValue(pattern, info.assignments, null, true);
                });
            }

            if (node.rest) {
                this.visitPattern({
                    type: 'RestElement',
                    argument: node.rest
                }, function (pattern) {
                    _this5.currentScope().__define(pattern, new _definition.ParameterDefinition(pattern, node, node.params.length, true));
                });
            }

            if (node.body.type === _estraverse.Syntax.BlockStatement) {
                this.visitChildren(node.body);
            } else {
                this.visit(node.body);
            }

            this.close(node);
        }
    }, {
        key: 'visitClass',
        value: function visitClass(node) {
            if (node.type === _estraverse.Syntax.ClassDeclaration) {
                this.currentScope().__define(node.id, new _definition.Definition(_variable2.default.ClassName, node.id, node, null, null, null));
            }

            this.visit(node.superClass);

            this.scopeManager.__nestClassScope(node);

            if (node.id) {
                this.currentScope().__define(node.id, new _definition.Definition(_variable2.default.ClassName, node.id, node));
            }
            this.visit(node.body);

            this.close(node);
        }
    }, {
        key: 'visitProperty',
        value: function visitProperty(node) {
            var previous, isMethodDefinition;
            if (node.computed) {
                this.visit(node.key);
            }

            isMethodDefinition = node.type === _estraverse.Syntax.MethodDefinition;
            if (isMethodDefinition) {
                previous = this.pushInnerMethodDefinition(true);
            }
            this.visit(node.value);
            if (isMethodDefinition) {
                this.popInnerMethodDefinition(previous);
            }
        }
    }, {
        key: 'visitForIn',
        value: function visitForIn(node) {
            var _this6 = this;

            if (node.left.type === _estraverse.Syntax.VariableDeclaration && node.left.kind !== 'var') {
                this.materializeTDZScope(node.right, node);
                this.visit(node.right);
                this.close(node.right);

                this.materializeIterationScope(node);
                this.visit(node.body);
                this.close(node);
            } else {
                if (node.left.type === _estraverse.Syntax.VariableDeclaration) {
                    this.visit(node.left);
                    this.visitPattern(node.left.declarations[0].id, function (pattern) {
                        _this6.currentScope().__referencing(pattern, _reference2.default.WRITE, node.right, null, true, true);
                    });
                } else {
                    this.visitPattern(node.left, { processRightHandNodes: true }, function (pattern, info) {
                        var maybeImplicitGlobal = null;
                        if (!_this6.currentScope().isStrict) {
                            maybeImplicitGlobal = {
                                pattern: pattern,
                                node: node
                            };
                        }
                        _this6.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);
                        _this6.currentScope().__referencing(pattern, _reference2.default.WRITE, node.right, maybeImplicitGlobal, true, false);
                    });
                }
                this.visit(node.right);
                this.visit(node.body);
            }
        }
    }, {
        key: 'visitVariableDeclaration',
        value: function visitVariableDeclaration(variableTargetScope, type, node, index, fromTDZ) {
            var _this7 = this;

            var decl, init;

            decl = node.declarations[index];
            init = decl.init;
            this.visitPattern(decl.id, { processRightHandNodes: !fromTDZ }, function (pattern, info) {
                variableTargetScope.__define(pattern, new _definition.Definition(type, pattern, decl, node, index, node.kind));

                if (!fromTDZ) {
                    _this7.referencingDefaultValue(pattern, info.assignments, null, true);
                }
                if (init) {
                    _this7.currentScope().__referencing(pattern, _reference2.default.WRITE, init, null, !info.topLevel, true);
                }
            });
        }
    }, {
        key: 'AssignmentExpression',
        value: function AssignmentExpression(node) {
            var _this8 = this;

            if (_patternVisitor2.default.isPattern(node.left)) {
                if (node.operator === '=') {
                    this.visitPattern(node.left, { processRightHandNodes: true }, function (pattern, info) {
                        var maybeImplicitGlobal = null;
                        if (!_this8.currentScope().isStrict) {
                            maybeImplicitGlobal = {
                                pattern: pattern,
                                node: node
                            };
                        }
                        _this8.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);
                        _this8.currentScope().__referencing(pattern, _reference2.default.WRITE, node.right, maybeImplicitGlobal, !info.topLevel, false);
                    });
                } else {
                    this.currentScope().__referencing(node.left, _reference2.default.RW, node.right);
                }
            } else {
                this.visit(node.left);
            }
            this.visit(node.right);
        }
    }, {
        key: 'CatchClause',
        value: function CatchClause(node) {
            var _this9 = this;

            this.scopeManager.__nestCatchScope(node);

            this.visitPattern(node.param, { processRightHandNodes: true }, function (pattern, info) {
                _this9.currentScope().__define(pattern, new _definition.Definition(_variable2.default.CatchClause, node.param, node, null, null, null));
                _this9.referencingDefaultValue(pattern, info.assignments, null, true);
            });
            this.visit(node.body);

            this.close(node);
        }
    }, {
        key: 'Program',
        value: function Program(node) {
            this.scopeManager.__nestGlobalScope(node);

            if (this.scopeManager.__isNodejsScope()) {
                this.currentScope().isStrict = false;
                this.scopeManager.__nestFunctionScope(node, false);
            }

            if (this.scopeManager.__isES6() && this.scopeManager.isModule()) {
                this.scopeManager.__nestModuleScope(node);
            }

            if (this.scopeManager.isStrictModeSupported() && this.scopeManager.isImpliedStrict()) {
                this.currentScope().isStrict = true;
            }

            this.visitChildren(node);
            this.close(node);
        }
    }, {
        key: 'Identifier',
        value: function Identifier(node) {
            this.currentScope().__referencing(node);
        }
    }, {
        key: 'UpdateExpression',
        value: function UpdateExpression(node) {
            if (_patternVisitor2.default.isPattern(node.argument)) {
                this.currentScope().__referencing(node.argument, _reference2.default.RW, null);
            } else {
                this.visitChildren(node);
            }
        }
    }, {
        key: 'MemberExpression',
        value: function MemberExpression(node) {
            this.visit(node.object);
            if (node.computed) {
                this.visit(node.property);
            }
        }
    }, {
        key: 'Property',
        value: function Property(node) {
            this.visitProperty(node);
        }
    }, {
        key: 'MethodDefinition',
        value: function MethodDefinition(node) {
            this.visitProperty(node);
        }
    }, {
        key: 'BreakStatement',
        value: function BreakStatement() {}
    }, {
        key: 'ContinueStatement',
        value: function ContinueStatement() {}
    }, {
        key: 'LabeledStatement',
        value: function LabeledStatement(node) {
            this.visit(node.body);
        }
    }, {
        key: 'ForStatement',
        value: function ForStatement(node) {
            if (node.init && node.init.type === _estraverse.Syntax.VariableDeclaration && node.init.kind !== 'var') {
                this.scopeManager.__nestForScope(node);
            }

            this.visitChildren(node);

            this.close(node);
        }
    }, {
        key: 'ClassExpression',
        value: function ClassExpression(node) {
            this.visitClass(node);
        }
    }, {
        key: 'ClassDeclaration',
        value: function ClassDeclaration(node) {
            this.visitClass(node);
        }
    }, {
        key: 'CallExpression',
        value: function CallExpression(node) {
            if (!this.scopeManager.__ignoreEval() && node.callee.type === _estraverse.Syntax.Identifier && node.callee.name === 'eval') {
                this.currentScope().variableScope.__detectEval();
            }
            this.visitChildren(node);
        }
    }, {
        key: 'BlockStatement',
        value: function BlockStatement(node) {
            if (this.scopeManager.__isES6()) {
                this.scopeManager.__nestBlockScope(node);
            }

            this.visitChildren(node);

            this.close(node);
        }
    }, {
        key: 'ThisExpression',
        value: function ThisExpression() {
            this.currentScope().variableScope.__detectThis();
        }
    }, {
        key: 'WithStatement',
        value: function WithStatement(node) {
            this.visit(node.object);
            this.scopeManager.__nestWithScope(node);

            this.visit(node.body);

            this.close(node);
        }
    }, {
        key: 'VariableDeclaration',
        value: function VariableDeclaration(node) {
            var variableTargetScope, i, iz, decl;
            variableTargetScope = node.kind === 'var' ? this.currentScope().variableScope : this.currentScope();
            for (i = 0, iz = node.declarations.length; i < iz; ++i) {
                decl = node.declarations[i];
                this.visitVariableDeclaration(variableTargetScope, _variable2.default.Variable, node, i);
                if (decl.init) {
                    this.visit(decl.init);
                }
            }
        }

    }, {
        key: 'SwitchStatement',
        value: function SwitchStatement(node) {
            var i, iz;

            this.visit(node.discriminant);

            if (this.scopeManager.__isES6()) {
                this.scopeManager.__nestSwitchScope(node);
            }

            for (i = 0, iz = node.cases.length; i < iz; ++i) {
                this.visit(node.cases[i]);
            }

            this.close(node);
        }
    }, {
        key: 'FunctionDeclaration',
        value: function FunctionDeclaration(node) {
            this.visitFunction(node);
        }
    }, {
        key: 'FunctionExpression',
        value: function FunctionExpression(node) {
            this.visitFunction(node);
        }
    }, {
        key: 'ForOfStatement',
        value: function ForOfStatement(node) {
            this.visitForIn(node);
        }
    }, {
        key: 'ForInStatement',
        value: function ForInStatement(node) {
            this.visitForIn(node);
        }
    }, {
        key: 'ArrowFunctionExpression',
        value: function ArrowFunctionExpression(node) {
            this.visitFunction(node);
        }
    }, {
        key: 'ImportDeclaration',
        value: function ImportDeclaration(node) {
            var importer;

            // (0, _assert2.default)(this.scopeManager.__isES6() && this.scopeManager.isModule(), 'ImportDeclaration should appear when the mode is ES6 and in the module context.');

            importer = new Importer(node, this);
            importer.visit(node);
        }
    }, {
        key: 'visitExportDeclaration',
        value: function visitExportDeclaration(node) {
            if (node.source) {
                return;
            }
            if (node.declaration) {
                this.visit(node.declaration);
                return;
            }

            this.visitChildren(node);
        }
    }, {
        key: 'ExportDeclaration',
        value: function ExportDeclaration(node) {
            this.visitExportDeclaration(node);
        }
    }, {
        key: 'ExportNamedDeclaration',
        value: function ExportNamedDeclaration(node) {
            this.visitExportDeclaration(node);
        }
    }, {
        key: 'ExportSpecifier',
        value: function ExportSpecifier(node) {
            var local = node.id || node.local;
            this.visit(local);
        }
    }, {
        key: 'MetaProperty',
        value: function MetaProperty() {
        }
    }]);

    return Referencer;
}(_esrecurse2.default.Visitor);


exports.default = Referencer;

},
   {"./definition":"/node_modules/escope/lib/definition.js","./pattern-visitor":"/node_modules/escope/lib/pattern-visitor.js","./reference":"/node_modules/escope/lib/reference.js","./variable":"/node_modules/escope/lib/variable.js","assert":"/node_modules/browserify/node_modules/assert/assert.js","esrecurse":"/node_modules/escope/node_modules/esrecurse/esrecurse.js","estraverse":"/node_modules/estraverse/estraverse.js"}],

"/node_modules/escope/lib/scope-manager.js": [function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Redistribution and use in source and binary forms, with or without
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       modification, are permitted provided that the following conditions are met:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         * Redistributions of source code must retain the above copyright
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           notice, this list of conditions and the following disclaimer.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         * Redistributions in binary form must reproduce the above copyright
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           notice, this list of conditions and the following disclaimer in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           documentation and/or other materials provided with the distribution.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _es6WeakMap = require('es6-weak-map');

var _es6WeakMap2 = _interopRequireDefault(_es6WeakMap);

var _scope = require('./scope');

var _scope2 = _interopRequireDefault(_scope);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ScopeManager = function () {
    function ScopeManager(options) {
        _classCallCheck(this, ScopeManager);

        this.scopes = [];
        this.globalScope = null;
        this.__nodeToScope = new _es6WeakMap2.default();
        this.__currentScope = null;
        this.__options = options;
        this.__declaredVariables = new _es6WeakMap2.default();
    }

    _createClass(ScopeManager, [{
        key: '__useDirective',
        value: function __useDirective() {
            return this.__options.directive;
        }
    }, {
        key: '__isOptimistic',
        value: function __isOptimistic() {
            return this.__options.optimistic;
        }
    }, {
        key: '__ignoreEval',
        value: function __ignoreEval() {
            return this.__options.ignoreEval;
        }
    }, {
        key: '__isNodejsScope',
        value: function __isNodejsScope() {
            return this.__options.nodejsScope;
        }
    }, {
        key: 'isModule',
        value: function isModule() {
            return this.__options.sourceType === 'module';
        }
    }, {
        key: 'isImpliedStrict',
        value: function isImpliedStrict() {
            return this.__options.impliedStrict;
        }
    }, {
        key: 'isStrictModeSupported',
        value: function isStrictModeSupported() {
            return this.__options.ecmaVersion >= 5;
        }

    }, {
        key: '__get',
        value: function __get(node) {
            return this.__nodeToScope.get(node);
        }

    }, {
        key: 'getDeclaredVariables',
        value: function getDeclaredVariables(node) {
            return this.__declaredVariables.get(node) || [];
        }

    }, {
        key: 'acquire',
        value: function acquire(node, inner) {
            var scopes, scope, i, iz;

            function predicate(scope) {
                if (scope.type === 'function' && scope.functionExpressionScope) {
                    return false;
                }
                if (scope.type === 'TDZ') {
                    return false;
                }
                return true;
            }

            scopes = this.__get(node);
            if (!scopes || scopes.length === 0) {
                return null;
            }

            if (scopes.length === 1) {
                return scopes[0];
            }

            if (inner) {
                for (i = scopes.length - 1; i >= 0; --i) {
                    scope = scopes[i];
                    if (predicate(scope)) {
                        return scope;
                    }
                }
            } else {
                for (i = 0, iz = scopes.length; i < iz; ++i) {
                    scope = scopes[i];
                    if (predicate(scope)) {
                        return scope;
                    }
                }
            }

            return null;
        }

    }, {
        key: 'acquireAll',
        value: function acquireAll(node) {
            return this.__get(node);
        }

    }, {
        key: 'release',
        value: function release(node, inner) {
            var scopes, scope;
            scopes = this.__get(node);
            if (scopes && scopes.length) {
                scope = scopes[0].upper;
                if (!scope) {
                    return null;
                }
                return this.acquire(scope.block, inner);
            }
            return null;
        }
    }, {
        key: 'attach',
        value: function attach() {}
    }, {
        key: 'detach',
        value: function detach() {}
    }, {
        key: '__nestScope',
        value: function __nestScope(scope) {
            if (scope instanceof _scope.GlobalScope) {
                (0, _assert2.default)(this.__currentScope === null);
                this.globalScope = scope;
            }
            this.__currentScope = scope;
            return scope;
        }
    }, {
        key: '__nestGlobalScope',
        value: function __nestGlobalScope(node) {
            return this.__nestScope(new _scope.GlobalScope(this, node));
        }
    }, {
        key: '__nestBlockScope',
        value: function __nestBlockScope(node, isMethodDefinition) {
            return this.__nestScope(new _scope.BlockScope(this, this.__currentScope, node));
        }
    }, {
        key: '__nestFunctionScope',
        value: function __nestFunctionScope(node, isMethodDefinition) {
            return this.__nestScope(new _scope.FunctionScope(this, this.__currentScope, node, isMethodDefinition));
        }
    }, {
        key: '__nestForScope',
        value: function __nestForScope(node) {
            return this.__nestScope(new _scope.ForScope(this, this.__currentScope, node));
        }
    }, {
        key: '__nestCatchScope',
        value: function __nestCatchScope(node) {
            return this.__nestScope(new _scope.CatchScope(this, this.__currentScope, node));
        }
    }, {
        key: '__nestWithScope',
        value: function __nestWithScope(node) {
            return this.__nestScope(new _scope.WithScope(this, this.__currentScope, node));
        }
    }, {
        key: '__nestClassScope',
        value: function __nestClassScope(node) {
            return this.__nestScope(new _scope.ClassScope(this, this.__currentScope, node));
        }
    }, {
        key: '__nestSwitchScope',
        value: function __nestSwitchScope(node) {
            return this.__nestScope(new _scope.SwitchScope(this, this.__currentScope, node));
        }
    }, {
        key: '__nestModuleScope',
        value: function __nestModuleScope(node) {
            return this.__nestScope(new _scope.ModuleScope(this, this.__currentScope, node));
        }
    }, {
        key: '__nestTDZScope',
        value: function __nestTDZScope(node) {
            return this.__nestScope(new _scope.TDZScope(this, this.__currentScope, node));
        }
    }, {
        key: '__nestFunctionExpressionNameScope',
        value: function __nestFunctionExpressionNameScope(node) {
            return this.__nestScope(new _scope.FunctionExpressionNameScope(this, this.__currentScope, node));
        }
    }, {
        key: '__isES6',
        value: function __isES6() {
            return this.__options.ecmaVersion >= 6;
        }
    }]);

    return ScopeManager;
}();


exports.default = ScopeManager;

},
   {"./scope":"/node_modules/escope/lib/scope.js","assert":"/node_modules/browserify/node_modules/assert/assert.js","es6-weak-map":"/node_modules/escope/node_modules/es6-weak-map/index.js"}],

"/node_modules/escope/lib/scope.js": [function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ClassScope = exports.ForScope = exports.FunctionScope = exports.SwitchScope = exports.BlockScope = exports.TDZScope = exports.WithScope = exports.CatchScope = exports.FunctionExpressionNameScope = exports.ModuleScope = exports.GlobalScope = undefined;

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Redistribution and use in source and binary forms, with or without
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       modification, are permitted provided that the following conditions are met:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         * Redistributions of source code must retain the above copyright
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           notice, this list of conditions and the following disclaimer.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         * Redistributions in binary form must reproduce the above copyright
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           notice, this list of conditions and the following disclaimer in the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           documentation and/or other materials provided with the distribution.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */

var _estraverse = require('estraverse');

var _es6Map = require('es6-map');

var _es6Map2 = _interopRequireDefault(_es6Map);

var _reference = require('./reference');

var _reference2 = _interopRequireDefault(_reference);

var _variable = require('./variable');

var _variable2 = _interopRequireDefault(_variable);

var _definition = require('./definition');

var _definition2 = _interopRequireDefault(_definition);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function isStrictScope(scope, block, isMethodDefinition, useDirective) {
    var body, i, iz, stmt, expr;

    if (scope.upper && scope.upper.isStrict) {
        return true;
    }

    if (block.type === _estraverse.Syntax.ArrowFunctionExpression) {
        return true;
    }

    if (isMethodDefinition) {
        return true;
    }

    if (scope.type === 'class' || scope.type === 'module') {
        return true;
    }

    if (scope.type === 'block' || scope.type === 'switch') {
        return false;
    }

    if (scope.type === 'function') {
        if (block.type === _estraverse.Syntax.Program) {
            body = block;
        } else {
            body = block.body;
        }
    } else if (scope.type === 'global') {
        body = block;
    } else {
        return false;
    }

    if (useDirective) {
        for (i = 0, iz = body.body.length; i < iz; ++i) {
            stmt = body.body[i];
            if (stmt.type !== _estraverse.Syntax.DirectiveStatement) {
                break;
            }
            if (stmt.raw === '"use strict"' || stmt.raw === '\'use strict\'') {
                return true;
            }
        }
    } else {
        for (i = 0, iz = body.body.length; i < iz; ++i) {
            stmt = body.body[i];
            if (stmt.type !== _estraverse.Syntax.ExpressionStatement) {
                break;
            }
            expr = stmt.expression;
            if (expr.type !== _estraverse.Syntax.Literal || typeof expr.value !== 'string') {
                break;
            }
            if (expr.raw != null) {
                if (expr.raw === '"use strict"' || expr.raw === '\'use strict\'') {
                    return true;
                }
            } else {
                if (expr.value === 'use strict') {
                    return true;
                }
            }
        }
    }
    return false;
}

function registerScope(scopeManager, scope) {
    var scopes;

    scopeManager.scopes.push(scope);

    scopes = scopeManager.__nodeToScope.get(scope.block);
    if (scopes) {
        scopes.push(scope);
    } else {
        scopeManager.__nodeToScope.set(scope.block, [scope]);
    }
}

function shouldBeStatically(def) {
    return def.type === _variable2.default.ClassName || def.type === _variable2.default.Variable && def.parent.kind !== 'var';
}

var Scope = function () {
    function Scope(scopeManager, type, upperScope, block, isMethodDefinition) {
        _classCallCheck(this, Scope);

        this.type = type;
        this.set = new _es6Map2.default();
        this.taints = new _es6Map2.default();
        this.dynamic = this.type === 'global' || this.type === 'with';
        this.block = block;
        this.through = [];
        this.variables = [];
        this.references = [];

        this.variableScope = this.type === 'global' || this.type === 'function' || this.type === 'module' ? this : upperScope.variableScope;
        this.functionExpressionScope = false;
        this.directCallToEvalScope = false;
        this.thisFound = false;

        this.__left = [];

        this.upper = upperScope;
        this.isStrict = isStrictScope(this, block, isMethodDefinition, scopeManager.__useDirective());

        this.childScopes = [];
        if (this.upper) {
            this.upper.childScopes.push(this);
        }

        this.__declaredVariables = scopeManager.__declaredVariables;

        registerScope(scopeManager, this);
    }

    _createClass(Scope, [{
        key: '__shouldStaticallyClose',
        value: function __shouldStaticallyClose(scopeManager) {
            return !this.dynamic || scopeManager.__isOptimistic();
        }
    }, {
        key: '__shouldStaticallyCloseForGlobal',
        value: function __shouldStaticallyCloseForGlobal(ref) {
            var name = ref.identifier.name;
            if (!this.set.has(name)) {
                return false;
            }

            var variable = this.set.get(name);
            var defs = variable.defs;
            return defs.length > 0 && defs.every(shouldBeStatically);
        }
    }, {
        key: '__staticCloseRef',
        value: function __staticCloseRef(ref) {
            if (!this.__resolve(ref)) {
                this.__delegateToUpperScope(ref);
            }
        }
    }, {
        key: '__dynamicCloseRef',
        value: function __dynamicCloseRef(ref) {
            var current = this;
            do {
                current.through.push(ref);
                current = current.upper;
            } while (current);
        }
    }, {
        key: '__globalCloseRef',
        value: function __globalCloseRef(ref) {
            if (this.__shouldStaticallyCloseForGlobal(ref)) {
                this.__staticCloseRef(ref);
            } else {
                this.__dynamicCloseRef(ref);
            }
        }
    }, {
        key: '__close',
        value: function __close(scopeManager) {
            var closeRef;
            if (this.__shouldStaticallyClose(scopeManager)) {
                closeRef = this.__staticCloseRef;
            } else if (this.type !== 'global') {
                closeRef = this.__dynamicCloseRef;
            } else {
                closeRef = this.__globalCloseRef;
            }

            for (var i = 0, iz = this.__left.length; i < iz; ++i) {
                var ref = this.__left[i];
                closeRef.call(this, ref);
            }
            this.__left = null;

            return this.upper;
        }
    }, {
        key: '__resolve',
        value: function __resolve(ref) {
            var variable, name;
            name = ref.identifier.name;
            if (this.set.has(name)) {
                variable = this.set.get(name);
                variable.references.push(ref);
                variable.stack = variable.stack && ref.from.variableScope === this.variableScope;
                if (ref.tainted) {
                    variable.tainted = true;
                    this.taints.set(variable.name, true);
                }
                ref.resolved = variable;
                return true;
            }
            return false;
        }
    }, {
        key: '__delegateToUpperScope',
        value: function __delegateToUpperScope(ref) {
            if (this.upper) {
                this.upper.__left.push(ref);
            }
            this.through.push(ref);
        }
    }, {
        key: '__addDeclaredVariablesOfNode',
        value: function __addDeclaredVariablesOfNode(variable, node) {
            if (node == null) {
                return;
            }

            var variables = this.__declaredVariables.get(node);
            if (variables == null) {
                variables = [];
                this.__declaredVariables.set(node, variables);
            }
            if (variables.indexOf(variable) === -1) {
                variables.push(variable);
            }
        }
    }, {
        key: '__defineGeneric',
        value: function __defineGeneric(name, set, variables, node, def) {
            var variable;

            variable = set.get(name);
            if (!variable) {
                variable = new _variable2.default(name, this);
                set.set(name, variable);
                variables.push(variable);
            }

            if (def) {
                variable.defs.push(def);
                if (def.type !== _variable2.default.TDZ) {
                    this.__addDeclaredVariablesOfNode(variable, def.node);
                    this.__addDeclaredVariablesOfNode(variable, def.parent);
                }
            }
            if (node) {
                variable.identifiers.push(node);
            }
        }
    }, {
        key: '__define',
        value: function __define(node, def) {
            if (node && node.type === _estraverse.Syntax.Identifier) {
                this.__defineGeneric(node.name, this.set, this.variables, node, def);
            }
        }
    }, {
        key: '__referencing',
        value: function __referencing(node, assign, writeExpr, maybeImplicitGlobal, partial, init) {
            if (!node || node.type !== _estraverse.Syntax.Identifier) {
                return;
            }

            if (node.name === 'super') {
                return;
            }

            var ref = new _reference2.default(node, this, assign || _reference2.default.READ, writeExpr, maybeImplicitGlobal, !!partial, !!init);
            this.references.push(ref);
            this.__left.push(ref);
        }
    }, {
        key: '__detectEval',
        value: function __detectEval() {
            var current;
            current = this;
            this.directCallToEvalScope = true;
            do {
                current.dynamic = true;
                current = current.upper;
            } while (current);
        }
    }, {
        key: '__detectThis',
        value: function __detectThis() {
            this.thisFound = true;
        }
    }, {
        key: '__isClosed',
        value: function __isClosed() {
            return this.__left === null;
        }

    }, {
        key: 'resolve',
        value: function resolve(ident) {
            var ref, i, iz;
            (0, _assert2.default)(this.__isClosed(), 'Scope should be closed.');
            (0, _assert2.default)(ident.type === _estraverse.Syntax.Identifier, 'Target should be identifier.');
            for (i = 0, iz = this.references.length; i < iz; ++i) {
                ref = this.references[i];
                if (ref.identifier === ident) {
                    return ref;
                }
            }
            return null;
        }

    }, {
        key: 'isStatic',
        value: function isStatic() {
            return !this.dynamic;
        }

    }, {
        key: 'isArgumentsMaterialized',
        value: function isArgumentsMaterialized() {
            return true;
        }

    }, {
        key: 'isThisMaterialized',
        value: function isThisMaterialized() {
            return true;
        }
    }, {
        key: 'isUsedName',
        value: function isUsedName(name) {
            if (this.set.has(name)) {
                return true;
            }
            for (var i = 0, iz = this.through.length; i < iz; ++i) {
                if (this.through[i].identifier.name === name) {
                    return true;
                }
            }
            return false;
        }
    }]);

    return Scope;
}();

exports.default = Scope;

var GlobalScope = exports.GlobalScope = function (_Scope) {
    _inherits(GlobalScope, _Scope);

    function GlobalScope(scopeManager, block) {
        _classCallCheck(this, GlobalScope);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(GlobalScope).call(this, scopeManager, 'global', null, block, false));

        _this.implicit = {
            set: new _es6Map2.default(),
            variables: [],
            left: []
        };
        return _this;
    }

    _createClass(GlobalScope, [{
        key: '__close',
        value: function __close(scopeManager) {
            var implicit = [];
            for (var i = 0, iz = this.__left.length; i < iz; ++i) {
                var ref = this.__left[i];
                if (ref.__maybeImplicitGlobal && !this.set.has(ref.identifier.name)) {
                    implicit.push(ref.__maybeImplicitGlobal);
                }
            }

            for (var i = 0, iz = implicit.length; i < iz; ++i) {
                var info = implicit[i];
                this.__defineImplicit(info.pattern, new _definition2.default(_variable2.default.ImplicitGlobalVariable, info.pattern, info.node, null, null, null));
            }

            this.implicit.left = this.__left;

            return _get(Object.getPrototypeOf(GlobalScope.prototype), '__close', this).call(this, scopeManager);
        }
    }, {
        key: '__defineImplicit',
        value: function __defineImplicit(node, def) {
            if (node && node.type === _estraverse.Syntax.Identifier) {
                this.__defineGeneric(node.name, this.implicit.set, this.implicit.variables, node, def);
            }
        }
    }]);

    return GlobalScope;
}(Scope);

var ModuleScope = exports.ModuleScope = function (_Scope2) {
    _inherits(ModuleScope, _Scope2);

    function ModuleScope(scopeManager, upperScope, block) {
        _classCallCheck(this, ModuleScope);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(ModuleScope).call(this, scopeManager, 'module', upperScope, block, false));
    }

    return ModuleScope;
}(Scope);

var FunctionExpressionNameScope = exports.FunctionExpressionNameScope = function (_Scope3) {
    _inherits(FunctionExpressionNameScope, _Scope3);

    function FunctionExpressionNameScope(scopeManager, upperScope, block) {
        _classCallCheck(this, FunctionExpressionNameScope);

        var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(FunctionExpressionNameScope).call(this, scopeManager, 'function-expression-name', upperScope, block, false));

        _this3.__define(block.id, new _definition2.default(_variable2.default.FunctionName, block.id, block, null, null, null));
        _this3.functionExpressionScope = true;
        return _this3;
    }

    return FunctionExpressionNameScope;
}(Scope);

var CatchScope = exports.CatchScope = function (_Scope4) {
    _inherits(CatchScope, _Scope4);

    function CatchScope(scopeManager, upperScope, block) {
        _classCallCheck(this, CatchScope);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(CatchScope).call(this, scopeManager, 'catch', upperScope, block, false));
    }

    return CatchScope;
}(Scope);

var WithScope = exports.WithScope = function (_Scope5) {
    _inherits(WithScope, _Scope5);

    function WithScope(scopeManager, upperScope, block) {
        _classCallCheck(this, WithScope);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(WithScope).call(this, scopeManager, 'with', upperScope, block, false));
    }

    _createClass(WithScope, [{
        key: '__close',
        value: function __close(scopeManager) {
            if (this.__shouldStaticallyClose(scopeManager)) {
                return _get(Object.getPrototypeOf(WithScope.prototype), '__close', this).call(this, scopeManager);
            }

            for (var i = 0, iz = this.__left.length; i < iz; ++i) {
                var ref = this.__left[i];
                ref.tainted = true;
                this.__delegateToUpperScope(ref);
            }
            this.__left = null;

            return this.upper;
        }
    }]);

    return WithScope;
}(Scope);

var TDZScope = exports.TDZScope = function (_Scope6) {
    _inherits(TDZScope, _Scope6);

    function TDZScope(scopeManager, upperScope, block) {
        _classCallCheck(this, TDZScope);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(TDZScope).call(this, scopeManager, 'TDZ', upperScope, block, false));
    }

    return TDZScope;
}(Scope);

var BlockScope = exports.BlockScope = function (_Scope7) {
    _inherits(BlockScope, _Scope7);

    function BlockScope(scopeManager, upperScope, block) {
        _classCallCheck(this, BlockScope);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(BlockScope).call(this, scopeManager, 'block', upperScope, block, false));
    }

    return BlockScope;
}(Scope);

var SwitchScope = exports.SwitchScope = function (_Scope8) {
    _inherits(SwitchScope, _Scope8);

    function SwitchScope(scopeManager, upperScope, block) {
        _classCallCheck(this, SwitchScope);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(SwitchScope).call(this, scopeManager, 'switch', upperScope, block, false));
    }

    return SwitchScope;
}(Scope);

var FunctionScope = exports.FunctionScope = function (_Scope9) {
    _inherits(FunctionScope, _Scope9);

    function FunctionScope(scopeManager, upperScope, block, isMethodDefinition) {
        _classCallCheck(this, FunctionScope);

        var _this9 = _possibleConstructorReturn(this, Object.getPrototypeOf(FunctionScope).call(this, scopeManager, 'function', upperScope, block, isMethodDefinition));

        if (_this9.block.type !== _estraverse.Syntax.ArrowFunctionExpression) {
            _this9.__defineArguments();
        }
        return _this9;
    }

    _createClass(FunctionScope, [{
        key: 'isArgumentsMaterialized',
        value: function isArgumentsMaterialized() {
            if (this.block.type === _estraverse.Syntax.ArrowFunctionExpression) {
                return false;
            }

            if (!this.isStatic()) {
                return true;
            }

            var variable = this.set.get('arguments');
            (0, _assert2.default)(variable, 'Always have arguments variable.');
            return variable.tainted || variable.references.length !== 0;
        }
    }, {
        key: 'isThisMaterialized',
        value: function isThisMaterialized() {
            if (!this.isStatic()) {
                return true;
            }
            return this.thisFound;
        }
    }, {
        key: '__defineArguments',
        value: function __defineArguments() {
            this.__defineGeneric('arguments', this.set, this.variables, null, null);
            this.taints.set('arguments', true);
        }
    }]);

    return FunctionScope;
}(Scope);

var ForScope = exports.ForScope = function (_Scope10) {
    _inherits(ForScope, _Scope10);

    function ForScope(scopeManager, upperScope, block) {
        _classCallCheck(this, ForScope);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(ForScope).call(this, scopeManager, 'for', upperScope, block, false));
    }

    return ForScope;
}(Scope);

var ClassScope = exports.ClassScope = function (_Scope11) {
    _inherits(ClassScope, _Scope11);

    function ClassScope(scopeManager, upperScope, block) {
        _classCallCheck(this, ClassScope);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(ClassScope).call(this, scopeManager, 'class', upperScope, block, false));
    }

    return ClassScope;
}(Scope);


},
   {"./definition":"/node_modules/escope/lib/definition.js","./reference":"/node_modules/escope/lib/reference.js","./variable":"/node_modules/escope/lib/variable.js","assert":"/node_modules/browserify/node_modules/assert/assert.js","es6-map":"/node_modules/es6-map/index.js","estraverse":"/node_modules/estraverse/estraverse.js"}],

"/node_modules/escope/lib/variable.js": [function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Variable = function Variable(name, scope) {
  _classCallCheck(this, Variable);

  this.name = name;
  this.identifiers = [];
  this.references = [];

  this.defs = [];

  this.tainted = false;
  this.stack = true;
  this.scope = scope;
};

exports.default = Variable;


Variable.CatchClause = 'CatchClause';
Variable.Parameter = 'Parameter';
Variable.FunctionName = 'FunctionName';
Variable.ClassName = 'ClassName';
Variable.Variable = 'Variable';
Variable.ImportBinding = 'ImportBinding';
Variable.TDZ = 'TDZ';
Variable.ImplicitGlobalVariable = 'ImplicitGlobalVariable';


},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/index.js": [function(require,module,exports){
'use strict';

module.exports = require('./is-implemented')() ? WeakMap : require('./polyfill');

},
   {"./is-implemented":"/node_modules/escope/node_modules/es6-weak-map/is-implemented.js","./polyfill":"/node_modules/escope/node_modules/es6-weak-map/polyfill.js"}],

"/node_modules/escope/node_modules/es6-weak-map/is-implemented.js": [function(require,module,exports){
'use strict';

module.exports = function () {
	var weakMap, x;
	if (typeof WeakMap !== 'function') return false;
	try {
		weakMap = new WeakMap([[x = {}, 'one'], [{}, 'two'], [{}, 'three']]);
	} catch (e) {
		return false;
	}
	if (String(weakMap) !== '[object WeakMap]') return false;
	if (typeof weakMap.set !== 'function') return false;
	if (weakMap.set({}, 1) !== weakMap) return false;
	if (typeof weakMap.delete !== 'function') return false;
	if (typeof weakMap.has !== 'function') return false;
	if (weakMap.get(x) !== 'one') return false;

	return true;
};

},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/is-native-implemented.js": [function(require,module,exports){
'use strict';

module.exports = (function () {
	if (typeof WeakMap !== 'function') return false;
	return (Object.prototype.toString.call(new WeakMap()) === '[object WeakMap]');
}());

},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/d/auto-bind.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/d/auto-bind.js"][0].apply(exports,arguments)
},
   {"es5-ext/object/copy":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/copy.js","es5-ext/object/map":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/map.js","es5-ext/object/valid-callable":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-callable.js","es5-ext/object/valid-value":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-value.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/d/index.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/d/index.js"][0].apply(exports,arguments)
},
   {"es5-ext/object/assign":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/assign/index.js","es5-ext/object/is-callable":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/is-callable.js","es5-ext/object/normalize-options":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/normalize-options.js","es5-ext/string/#/contains":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/string/#/contains/index.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/array/#/clear.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/array/#/clear.js"][0].apply(exports,arguments)
},
   {"../../object/valid-value":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-value.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/function/is-arguments.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/function/is-arguments.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/_iterate.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/_iterate.js"][0].apply(exports,arguments)
},
   {"./valid-callable":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-callable.js","./valid-value":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-value.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/assign/index.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/assign/index.js"][0].apply(exports,arguments)
},
   {"./is-implemented":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/assign/is-implemented.js","./shim":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/assign/shim.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/assign/is-implemented.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/assign/is-implemented.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/assign/shim.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/assign/shim.js"][0].apply(exports,arguments)
},
   {"../keys":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/keys/index.js","../valid-value":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-value.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/copy.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/copy.js"][0].apply(exports,arguments)
},
   {"./assign":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/assign/index.js","./valid-value":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-value.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/create.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/create.js"][0].apply(exports,arguments)
},
   {"./set-prototype-of/is-implemented":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/set-prototype-of/is-implemented.js","./set-prototype-of/shim":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/set-prototype-of/shim.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/for-each.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/for-each.js"][0].apply(exports,arguments)
},
   {"./_iterate":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/_iterate.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/is-callable.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/is-callable.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/is-object.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/is-object.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/keys/index.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/keys/index.js"][0].apply(exports,arguments)
},
   {"./is-implemented":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/keys/is-implemented.js","./shim":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/keys/shim.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/keys/is-implemented.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/keys/is-implemented.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/keys/shim.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/keys/shim.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/map.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/map.js"][0].apply(exports,arguments)
},
   {"./for-each":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/for-each.js","./valid-callable":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-callable.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/normalize-options.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/normalize-options.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/set-prototype-of/index.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/set-prototype-of/index.js"][0].apply(exports,arguments)
},
   {"./is-implemented":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/set-prototype-of/is-implemented.js","./shim":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/set-prototype-of/shim.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/set-prototype-of/is-implemented.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/set-prototype-of/is-implemented.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/set-prototype-of/shim.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/set-prototype-of/shim.js"][0].apply(exports,arguments)
},
   {"../create":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/create.js","../is-object":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/is-object.js","../valid-value":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-value.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-callable.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/valid-callable.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-object.js": [function(require,module,exports){
'use strict';

var isObject = require('./is-object');

module.exports = function (value) {
	if (!isObject(value)) throw new TypeError(value + " is not an Object");
	return value;
};

},
   {"./is-object":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/is-object.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-value.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/object/valid-value.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/string/#/contains/index.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/string/#/contains/index.js"][0].apply(exports,arguments)
},
   {"./is-implemented":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/string/#/contains/is-implemented.js","./shim":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/string/#/contains/shim.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/string/#/contains/is-implemented.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/string/#/contains/is-implemented.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/string/#/contains/shim.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/string/#/contains/shim.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/string/is-string.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es5-ext/string/is-string.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/string/random-uniq.js": [function(require,module,exports){
'use strict';

var generated = Object.create(null)

  , random = Math.random;

module.exports = function () {
	var str;
	do { str = random().toString(36).slice(2); } while (generated[str]);
	return str;
};

},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/array.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es6-iterator/array.js"][0].apply(exports,arguments)
},
   {"./":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/index.js","d":"/node_modules/escope/node_modules/es6-weak-map/node_modules/d/index.js","es5-ext/object/set-prototype-of":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/set-prototype-of/index.js","es5-ext/string/#/contains":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/string/#/contains/index.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/for-of.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es6-iterator/for-of.js"][0].apply(exports,arguments)
},
   {"./get":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/get.js","es5-ext/function/is-arguments":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/function/is-arguments.js","es5-ext/object/valid-callable":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-callable.js","es5-ext/string/is-string":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/string/is-string.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/get.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es6-iterator/get.js"][0].apply(exports,arguments)
},
   {"./array":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/array.js","./string":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/string.js","./valid-iterable":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/valid-iterable.js","es5-ext/function/is-arguments":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/function/is-arguments.js","es5-ext/string/is-string":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/string/is-string.js","es6-symbol":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-symbol/index.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/index.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es6-iterator/index.js"][0].apply(exports,arguments)
},
   {"d":"/node_modules/escope/node_modules/es6-weak-map/node_modules/d/index.js","d/auto-bind":"/node_modules/escope/node_modules/es6-weak-map/node_modules/d/auto-bind.js","es5-ext/array/#/clear":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/array/#/clear.js","es5-ext/object/assign":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/assign/index.js","es5-ext/object/valid-callable":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-callable.js","es5-ext/object/valid-value":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-value.js","es6-symbol":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-symbol/index.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/is-iterable.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es6-iterator/is-iterable.js"][0].apply(exports,arguments)
},
   {"es5-ext/function/is-arguments":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/function/is-arguments.js","es5-ext/string/is-string":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/string/is-string.js","es6-symbol":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-symbol/index.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/string.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es6-iterator/string.js"][0].apply(exports,arguments)
},
   {"./":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/index.js","d":"/node_modules/escope/node_modules/es6-weak-map/node_modules/d/index.js","es5-ext/object/set-prototype-of":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/set-prototype-of/index.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/valid-iterable.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es6-iterator/valid-iterable.js"][0].apply(exports,arguments)
},
   {"./is-iterable":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/is-iterable.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-symbol/index.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es6-symbol/index.js"][0].apply(exports,arguments)
},
   {"./is-implemented":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-symbol/is-implemented.js","./polyfill":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-symbol/polyfill.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-symbol/is-implemented.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es6-symbol/is-implemented.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-symbol/is-symbol.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es6-symbol/is-symbol.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-symbol/polyfill.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es6-symbol/polyfill.js"][0].apply(exports,arguments)
},
   {"./validate-symbol":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-symbol/validate-symbol.js","d":"/node_modules/escope/node_modules/es6-weak-map/node_modules/d/index.js"}],

"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-symbol/validate-symbol.js": [function(require,module,exports){
arguments[4]["/node_modules/es6-map/node_modules/es6-symbol/validate-symbol.js"][0].apply(exports,arguments)
},
   {"./is-symbol":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-symbol/is-symbol.js"}],

"/node_modules/escope/node_modules/es6-weak-map/polyfill.js": [function(require,module,exports){
'use strict';

var setPrototypeOf    = require('es5-ext/object/set-prototype-of')
  , object            = require('es5-ext/object/valid-object')
  , value             = require('es5-ext/object/valid-value')
  , randomUniq        = require('es5-ext/string/random-uniq')
  , d                 = require('d')
  , getIterator       = require('es6-iterator/get')
  , forOf             = require('es6-iterator/for-of')
  , toStringTagSymbol = require('es6-symbol').toStringTag
  , isNative          = require('./is-native-implemented')

  , isArray = Array.isArray, defineProperty = Object.defineProperty
  , hasOwnProperty = Object.prototype.hasOwnProperty, getPrototypeOf = Object.getPrototypeOf
  , WeakMapPoly;

module.exports = WeakMapPoly = function (/*iterable*/) {
	var iterable = arguments[0], self;
	if (!(this instanceof WeakMapPoly)) throw new TypeError('Constructor requires \'new\'');
	if (isNative && setPrototypeOf && (WeakMap !== WeakMapPoly)) {
		self = setPrototypeOf(new WeakMap(), getPrototypeOf(this));
	} else {
		self = this;
	}
	if (iterable != null) {
		if (!isArray(iterable)) iterable = getIterator(iterable);
	}
	defineProperty(self, '__weakMapData__', d('c', '$weakMap$' + randomUniq()));
	if (!iterable) return self;
	forOf(iterable, function (val) {
		value(val);
		self.set(val[0], val[1]);
	});
	return self;
};

if (isNative) {
	if (setPrototypeOf) setPrototypeOf(WeakMapPoly, WeakMap);
	WeakMapPoly.prototype = Object.create(WeakMap.prototype, {
		constructor: d(WeakMapPoly)
	});
}

Object.defineProperties(WeakMapPoly.prototype, {
	delete: d(function (key) {
		if (hasOwnProperty.call(object(key), this.__weakMapData__)) {
			delete key[this.__weakMapData__];
			return true;
		}
		return false;
	}),
	get: d(function (key) {
		if (hasOwnProperty.call(object(key), this.__weakMapData__)) {
			return key[this.__weakMapData__];
		}
	}),
	has: d(function (key) {
		return hasOwnProperty.call(object(key), this.__weakMapData__);
	}),
	set: d(function (key, value) {
		defineProperty(object(key), this.__weakMapData__, d('c', value));
		return this;
	}),
	toString: d(function () { return '[object WeakMap]'; })
});
defineProperty(WeakMapPoly.prototype, toStringTagSymbol, d('c', 'WeakMap'));

},
   {"./is-native-implemented":"/node_modules/escope/node_modules/es6-weak-map/is-native-implemented.js","d":"/node_modules/escope/node_modules/es6-weak-map/node_modules/d/index.js","es5-ext/object/set-prototype-of":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/set-prototype-of/index.js","es5-ext/object/valid-object":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-object.js","es5-ext/object/valid-value":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/object/valid-value.js","es5-ext/string/random-uniq":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es5-ext/string/random-uniq.js","es6-iterator/for-of":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/for-of.js","es6-iterator/get":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-iterator/get.js","es6-symbol":"/node_modules/escope/node_modules/es6-weak-map/node_modules/es6-symbol/index.js"}],

"/node_modules/escope/node_modules/esrecurse/esrecurse.js": [function(require,module,exports){
(function () {
    'use strict';

    var assign,
        estraverse,
        isArray,
        objectKeys;

    assign = require('object-assign');
    estraverse = require('estraverse');

    isArray = Array.isArray || function isArray(array) {
        return Object.prototype.toString.call(array) === '[object Array]';
    };

    objectKeys = Object.keys || function (o) {
        var keys = [], key;
        for (key in o) {
            keys.push(key);
        }
        return keys;
    };

    function isNode(node) {
        if (node == null) {
            return false;
        }
        return typeof node === 'object' && typeof node.type === 'string';
    }

    function isProperty(nodeType, key) {
        return (nodeType === estraverse.Syntax.ObjectExpression || nodeType === estraverse.Syntax.ObjectPattern) && key === 'properties';
    }

    function Visitor(visitor, options) {
        options = options || {};

        this.__visitor = visitor ||  this;
        this.__childVisitorKeys = options.childVisitorKeys
            ? assign({}, estraverse.VisitorKeys, options.childVisitorKeys)
            : estraverse.VisitorKeys;
        this.__fallback = options.fallback === 'iteration';
    }

    Visitor.prototype.visitChildren = function (node) {
        var type, children, i, iz, j, jz, child;

        if (node == null) {
            return;
        }

        type = node.type || estraverse.Syntax.Property;

        children = this.__childVisitorKeys[type];
        if (!children) {
            if (this.__fallback) {
                children = objectKeys(node);
            } else {
                throw new Error('Unknown node type ' + type + '.');
            }
        }

        for (i = 0, iz = children.length; i < iz; ++i) {
            child = node[children[i]];
            if (child) {
                if (isArray(child)) {
                    for (j = 0, jz = child.length; j < jz; ++j) {
                        if (child[j]) {
                            if (isNode(child[j]) || isProperty(type, children[i])) {
                                this.visit(child[j]);
                            }
                        }
                    }
                } else if (isNode(child)) {
                    this.visit(child);
                }
            }
        }
    };

    Visitor.prototype.visit = function (node) {
        var type;

        if (node == null) {
            return;
        }

        type = node.type || estraverse.Syntax.Property;
        if (this.__visitor[type]) {
            this.__visitor[type].call(this, node);
            return;
        }
        this.visitChildren(node);
    };

    exports.version = require('./package.json').version;
    exports.Visitor = Visitor;
    exports.visit = function (node, visitor, options) {
        var v = new Visitor(visitor, options);
        v.visit(node);
    };
}());

},
   {"./package.json":"/node_modules/escope/node_modules/esrecurse/package.json","estraverse":"/node_modules/estraverse/estraverse.js","object-assign":"/node_modules/object-assign/index.js"}],

"/node_modules/escope/node_modules/esrecurse/package.json": [function(require,module,exports){
module.exports={
  "name": "esrecurse",
  "description": "ECMAScript AST recursive visitor",
  "homepage": "https://github.com/estools/esrecurse",
  "main": "esrecurse.js",
  "version": "4.0.0",
  "engines": {
    "node": ">=0.10.0"
  },
  "maintainers": [
    {
      "name": "constellation",
      "email": "utatane.tea@gmail.com"
    },
    {
      "name": "michaelficarra",
      "email": "npm@michael.ficarra.me"
    }
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/estools/esrecurse.git"
  },
  "dependencies": {
    "estraverse": "~4.1.0",
    "object-assign": "^4.0.1"
  },
  "devDependencies": {
    "chai": "^3.3.0",
    "coffee-script": "^1.9.1",
    "esprima": "^2.1.0",
    "gulp": "^3.9.0",
    "gulp-bump": "^1.0.0",
    "gulp-eslint": "^1.0.0",
    "gulp-filter": "^3.0.1",
    "gulp-git": "^1.1.0",
    "gulp-mocha": "^2.1.3",
    "gulp-tag-version": "^1.2.1",
    "jsdoc": "^3.3.0-alpha10",
    "minimist": "^1.1.0"
  },
  "license": "BSD-2-Clause",
  "scripts": {
    "test": "gulp travis",
    "unit-test": "gulp test",
    "lint": "gulp lint"
  },
  "gitHead": "fc4b0d9b1e9ce493761e97af9a1afb5afd489f87",
  "bugs": {
    "url": "https://github.com/estools/esrecurse/issues"
  },
  "_id": "esrecurse@4.0.0",
  "_shasum": "c7b50295f9af5ff9a0073d139eb011476128e9e6",
  "_from": "esrecurse@>=4.0.0 <5.0.0",
  "_npmVersion": "2.14.4",
  "_nodeVersion": "4.1.1",
  "_npmUser": {
    "name": "constellation",
    "email": "utatane.tea@gmail.com"
  },
  "dist": {
    "shasum": "c7b50295f9af5ff9a0073d139eb011476128e9e6",
    "tarball": "http://registry.npmjs.org/esrecurse/-/esrecurse-4.0.0.tgz"
  },
  "_npmOperationalInternal": {
    "host": "packages-5-east.internal.npmjs.com",
    "tmp": "tmp/esrecurse-4.0.0.tgz_1454512903651_0.6128629888407886"
  },
  "directories": {},
  "_resolved": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.0.0.tgz"
}

},
   {}],

"/node_modules/escope/package.json": [function(require,module,exports){
module.exports={
  "name": "escope",
  "description": "ECMAScript scope analyzer",
  "homepage": "http://github.com/estools/escope",
  "main": "lib/index.js",
  "version": "3.5.0",
  "engines": {
    "node": ">=0.4.0"
  },
  "maintainers": [
    {
      "name": "constellation",
      "email": "utatane.tea@gmail.com"
    },
    {
      "name": "michaelficarra",
      "email": "npm@michael.ficarra.me"
    },
    {
      "name": "nzakas",
      "email": "nicholas@nczconsulting.com"
    }
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/estools/escope.git"
  },
  "dependencies": {
    "es6-map": "^0.1.3",
    "es6-weak-map": "^2.0.1",
    "esrecurse": "^4.0.0",
    "estraverse": "^4.1.1"
  },
  "devDependencies": {
    "babel": "^6.3.26",
    "babel-preset-es2015": "^6.3.13",
    "babel-register": "^6.3.13",
    "browserify": "^13.0.0",
    "chai": "^3.4.1",
    "espree": "^3.1.1",
    "esprima": "^2.7.1",
    "gulp": "^3.9.0",
    "gulp-babel": "^6.1.1",
    "gulp-bump": "^1.0.0",
    "gulp-eslint": "^1.1.1",
    "gulp-espower": "^1.0.2",
    "gulp-filter": "^3.0.1",
    "gulp-git": "^1.6.1",
    "gulp-mocha": "^2.2.0",
    "gulp-plumber": "^1.0.1",
    "gulp-sourcemaps": "^1.6.0",
    "gulp-tag-version": "^1.3.0",
    "jsdoc": "^3.4.0",
    "lazypipe": "^1.0.1",
    "vinyl-source-stream": "^1.1.0"
  },
  "license": "BSD-2-Clause",
  "scripts": {
    "test": "gulp travis",
    "unit-test": "gulp test",
    "lint": "gulp lint",
    "jsdoc": "jsdoc src/*.js README.md"
  },
  "gitHead": "5b6a2ba88db85ec847c5d88ac9d771e36fb4b55a",
  "bugs": {
    "url": "https://github.com/estools/escope/issues"
  },
  "_id": "escope@3.5.0",
  "_shasum": "23724471bcb53b40ac810cf3face549fd32ab5f6",
  "_from": "escope@>=3.5.0 <4.0.0",
  "_npmVersion": "2.14.4",
  "_nodeVersion": "4.1.1",
  "_npmUser": {
    "name": "constellation",
    "email": "utatane.tea@gmail.com"
  },
  "dist": {
    "shasum": "23724471bcb53b40ac810cf3face549fd32ab5f6",
    "tarball": "http://registry.npmjs.org/escope/-/escope-3.5.0.tgz"
  },
  "_npmOperationalInternal": {
    "host": "packages-9-west.internal.npmjs.com",
    "tmp": "tmp/escope-3.5.0.tgz_1456758694258_0.07843037159182131"
  },
  "directories": {},
  "_resolved": "https://registry.npmjs.org/escope/-/escope-3.5.0.tgz"
}

},
   {}],

"/node_modules/eslint-plugin-react/index.js": [function(require,module,exports){
'use strict';

module.exports = {
  rules: {
    'jsx-uses-react': require('./lib/rules/jsx-uses-react'),
    'no-multi-comp': require('./lib/rules/no-multi-comp'),
    'prop-types': require('./lib/rules/prop-types'),
    'display-name': require('./lib/rules/display-name'),
    'wrap-multilines': require('./lib/rules/wrap-multilines'),
    'self-closing-comp': require('./lib/rules/self-closing-comp'),
    'no-danger': require('./lib/rules/no-danger'),
    'no-set-state': require('./lib/rules/no-set-state'),
    'no-is-mounted': require('./lib/rules/no-is-mounted'),
    'no-deprecated': require('./lib/rules/no-deprecated'),
    'no-did-mount-set-state': require('./lib/rules/no-did-mount-set-state'),
    'no-did-update-set-state': require('./lib/rules/no-did-update-set-state'),
    'react-in-jsx-scope': require('./lib/rules/react-in-jsx-scope'),
    'jsx-uses-vars': require('./lib/rules/jsx-uses-vars'),
    'jsx-handler-names': require('./lib/rules/jsx-handler-names'),
    'jsx-pascal-case': require('./lib/rules/jsx-pascal-case'),
    'jsx-no-bind': require('./lib/rules/jsx-no-bind'),
    'jsx-no-undef': require('./lib/rules/jsx-no-undef'),
    'jsx-quotes': require('./lib/rules/jsx-quotes'),
    'no-unknown-property': require('./lib/rules/no-unknown-property'),
    'jsx-curly-spacing': require('./lib/rules/jsx-curly-spacing'),
    'jsx-equals-spacing': require('./lib/rules/jsx-equals-spacing'),
    'jsx-sort-props': require('./lib/rules/jsx-sort-props'),
    'jsx-sort-prop-types': require('./lib/rules/jsx-sort-prop-types'),
    'sort-prop-types': require('./lib/rules/jsx-sort-prop-types'),
    'jsx-boolean-value': require('./lib/rules/jsx-boolean-value'),
    'sort-comp': require('./lib/rules/sort-comp'),
    'require-extension': require('./lib/rules/require-extension'),
    'jsx-no-duplicate-props': require('./lib/rules/jsx-no-duplicate-props'),
    'jsx-max-props-per-line': require('./lib/rules/jsx-max-props-per-line'),
    'jsx-no-literals': require('./lib/rules/jsx-no-literals'),
    'jsx-indent-props': require('./lib/rules/jsx-indent-props'),
    'jsx-indent': require('./lib/rules/jsx-indent'),
    'jsx-closing-bracket-location': require('./lib/rules/jsx-closing-bracket-location'),
    'no-direct-mutation-state': require('./lib/rules/no-direct-mutation-state'),
    'forbid-prop-types': require('./lib/rules/forbid-prop-types'),
    'prefer-es6-class': require('./lib/rules/prefer-es6-class'),
    'jsx-key': require('./lib/rules/jsx-key'),
    'no-string-refs': require('./lib/rules/no-string-refs')
  },
  rulesConfig: {
    'jsx-uses-react': 0,
    'no-multi-comp': 0,
    'prop-types': 0,
    'display-name': 0,
    'wrap-multilines': 0,
    'self-closing-comp': 0,
    'no-deprecated': 0,
    'no-danger': 0,
    'no-set-state': 0,
    'no-is-mounted': 0,
    'no-did-mount-set-state': 0,
    'no-did-update-set-state': 0,
    'react-in-jsx-scope': 0,
    'jsx-uses-vars': 1,
    'jsx-handler-names': 0,
    'jsx-pascal-case': 0,
    'jsx-no-bind': 0,
    'jsx-no-undef': 0,
    'jsx-quotes': 0,
    'no-unknown-property': 0,
    'jsx-curly-spacing': 0,
    'jsx-equals-spacing': 0,
    'jsx-sort-props': 0,
    'jsx-sort-prop-types': 0,
    'jsx-boolean-value': 0,
    'sort-comp': 0,
    'require-extension': 0,
    'jsx-no-duplicate-props': 0,
    'jsx-max-props-per-line': 0,
    'jsx-no-literals': 0,
    'jsx-indent-props': 0,
    'jsx-indent': 0,
    'jsx-closing-bracket-location': 0,
    'no-direct-mutation-state': 0,
    'forbid-prop-types': 0,
    'prefer-es6-class': 0,
    'jsx-key': 0,
    'no-string-refs': 0
  }
};

},
   {"./lib/rules/display-name":"/node_modules/eslint-plugin-react/lib/rules/display-name.js","./lib/rules/forbid-prop-types":"/node_modules/eslint-plugin-react/lib/rules/forbid-prop-types.js","./lib/rules/jsx-boolean-value":"/node_modules/eslint-plugin-react/lib/rules/jsx-boolean-value.js","./lib/rules/jsx-closing-bracket-location":"/node_modules/eslint-plugin-react/lib/rules/jsx-closing-bracket-location.js","./lib/rules/jsx-curly-spacing":"/node_modules/eslint-plugin-react/lib/rules/jsx-curly-spacing.js","./lib/rules/jsx-equals-spacing":"/node_modules/eslint-plugin-react/lib/rules/jsx-equals-spacing.js","./lib/rules/jsx-handler-names":"/node_modules/eslint-plugin-react/lib/rules/jsx-handler-names.js","./lib/rules/jsx-indent":"/node_modules/eslint-plugin-react/lib/rules/jsx-indent.js","./lib/rules/jsx-indent-props":"/node_modules/eslint-plugin-react/lib/rules/jsx-indent-props.js","./lib/rules/jsx-key":"/node_modules/eslint-plugin-react/lib/rules/jsx-key.js","./lib/rules/jsx-max-props-per-line":"/node_modules/eslint-plugin-react/lib/rules/jsx-max-props-per-line.js","./lib/rules/jsx-no-bind":"/node_modules/eslint-plugin-react/lib/rules/jsx-no-bind.js","./lib/rules/jsx-no-duplicate-props":"/node_modules/eslint-plugin-react/lib/rules/jsx-no-duplicate-props.js","./lib/rules/jsx-no-literals":"/node_modules/eslint-plugin-react/lib/rules/jsx-no-literals.js","./lib/rules/jsx-no-undef":"/node_modules/eslint-plugin-react/lib/rules/jsx-no-undef.js","./lib/rules/jsx-pascal-case":"/node_modules/eslint-plugin-react/lib/rules/jsx-pascal-case.js","./lib/rules/jsx-quotes":"/node_modules/eslint-plugin-react/lib/rules/jsx-quotes.js","./lib/rules/jsx-sort-prop-types":"/node_modules/eslint-plugin-react/lib/rules/jsx-sort-prop-types.js","./lib/rules/jsx-sort-props":"/node_modules/eslint-plugin-react/lib/rules/jsx-sort-props.js","./lib/rules/jsx-uses-react":"/node_modules/eslint-plugin-react/lib/rules/jsx-uses-react.js","./lib/rules/jsx-uses-vars":"/node_modules/eslint-plugin-react/lib/rules/jsx-uses-vars.js","./lib/rules/no-danger":"/node_modules/eslint-plugin-react/lib/rules/no-danger.js","./lib/rules/no-deprecated":"/node_modules/eslint-plugin-react/lib/rules/no-deprecated.js","./lib/rules/no-did-mount-set-state":"/node_modules/eslint-plugin-react/lib/rules/no-did-mount-set-state.js","./lib/rules/no-did-update-set-state":"/node_modules/eslint-plugin-react/lib/rules/no-did-update-set-state.js","./lib/rules/no-direct-mutation-state":"/node_modules/eslint-plugin-react/lib/rules/no-direct-mutation-state.js","./lib/rules/no-is-mounted":"/node_modules/eslint-plugin-react/lib/rules/no-is-mounted.js","./lib/rules/no-multi-comp":"/node_modules/eslint-plugin-react/lib/rules/no-multi-comp.js","./lib/rules/no-set-state":"/node_modules/eslint-plugin-react/lib/rules/no-set-state.js","./lib/rules/no-string-refs":"/node_modules/eslint-plugin-react/lib/rules/no-string-refs.js","./lib/rules/no-unknown-property":"/node_modules/eslint-plugin-react/lib/rules/no-unknown-property.js","./lib/rules/prefer-es6-class":"/node_modules/eslint-plugin-react/lib/rules/prefer-es6-class.js","./lib/rules/prop-types":"/node_modules/eslint-plugin-react/lib/rules/prop-types.js","./lib/rules/react-in-jsx-scope":"/node_modules/eslint-plugin-react/lib/rules/react-in-jsx-scope.js","./lib/rules/require-extension":"/node_modules/eslint-plugin-react/lib/rules/require-extension.js","./lib/rules/self-closing-comp":"/node_modules/eslint-plugin-react/lib/rules/self-closing-comp.js","./lib/rules/sort-comp":"/node_modules/eslint-plugin-react/lib/rules/sort-comp.js","./lib/rules/wrap-multilines":"/node_modules/eslint-plugin-react/lib/rules/wrap-multilines.js"}],

"/node_modules/eslint-plugin-react/lib/rules/display-name.js": [function(require,module,exports){
'use strict';

var Components = require('../util/Components');

module.exports = Components.detect(function(context, components, utils) {

  var config = context.options[0] || {};
  var acceptTranspilerName = config.acceptTranspilerName || false;

  var MISSING_MESSAGE = 'Component definition is missing display name';

  function isDisplayNameDeclaration(node) {
    if (node.type === /*ClassProperty*/'Property' && node.kind == 'class') {
      var tokens = context.getFirstTokens(node, 2);
      if (
        tokens[0].value === 'displayName' ||
        (tokens[1] && tokens[1].value === 'displayName')
      ) {
        return true;
      }
      return false;
    }

    return Boolean(
      node &&
      node.name === 'displayName'
    );
  }

  function markDisplayNameAsDeclared(node) {
    components.set(node, {
      hasDisplayName: true
    });
  }

  function reportMissingDisplayName(component) {
    context.report(
      component.node,
      MISSING_MESSAGE, {
        component: component.name
      }
    );
  }

  function hasTranspilerName(node) {
    var namedObjectAssignment = (
      node.type === 'ObjectExpression' &&
      node.parent &&
      node.parent.parent &&
      node.parent.parent.type === 'AssignmentExpression' && (
        !node.parent.parent.left.object ||
        node.parent.parent.left.object.name !== 'module' ||
        node.parent.parent.left.property.name !== 'exports'
      )
    );
    var namedObjectDeclaration = (
        node.type === 'ObjectExpression' &&
        node.parent &&
        node.parent.parent &&
        node.parent.parent.type === 'VariableDeclarator'
    );
    var namedClass = (
      node.type === 'ClassDeclaration' &&
      node.id && node.id.name
    );

    var namedFunctionDeclaration = (
      (node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression') &&
      node.id &&
      node.id.name
    );

    var namedFunctionExpression = (
      (node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression') &&
      node.parent &&
      (node.parent.type === 'VariableDeclarator' || node.parent.method === true)
    );

    if (
      namedObjectAssignment || namedObjectDeclaration ||
      namedClass ||
      namedFunctionDeclaration || namedFunctionExpression
    ) {
      return true;
    }
    return false;
  }

  return {

    /*ClassProperty*/Property: function(node) {
      if (node.kind == 'class' && !isDisplayNameDeclaration(node)) {
        return;
      }
      markDisplayNameAsDeclared(node);
    },

    MemberExpression: function(node) {
      if (!isDisplayNameDeclaration(node.property)) {
        return;
      }
      var component = utils.getRelatedComponent(node);
      if (!component) {
        return;
      }
      markDisplayNameAsDeclared(component.node);
    },

    FunctionExpression: function(node) {
      if (!acceptTranspilerName || !hasTranspilerName(node)) {
        return;
      }
      markDisplayNameAsDeclared(node);
    },

    FunctionDeclaration: function(node) {
      if (!acceptTranspilerName || !hasTranspilerName(node)) {
        return;
      }
      markDisplayNameAsDeclared(node);
    },

    ArrowFunctionExpression: function(node) {
      if (!acceptTranspilerName || !hasTranspilerName(node)) {
        return;
      }
      markDisplayNameAsDeclared(node);
    },

    MethodDefinition: function(node) {
      if (!isDisplayNameDeclaration(node.key)) {
        return;
      }
      markDisplayNameAsDeclared(node);
    },

    ClassDeclaration: function(node) {
      if (!acceptTranspilerName || !hasTranspilerName(node)) {
        return;
      }
      markDisplayNameAsDeclared(node);
    },

    ObjectExpression: function(node) {
      if (!acceptTranspilerName || !hasTranspilerName(node)) {
        node.properties.forEach(function(property) {
          if (!property.key || !isDisplayNameDeclaration(property.key)) {
            return;
          }
          markDisplayNameAsDeclared(node);
        });
        return;
      }
      markDisplayNameAsDeclared(node);
    },

    'Program:exit': function() {
      var list = components.list();
      for (var component in list) {
        if (!list.hasOwnProperty(component) || list[component].hasDisplayName) {
          continue;
        }
        reportMissingDisplayName(list[component]);
      }
    }
  };
});

module.exports.schema = [{
  type: 'object',
  properties: {
    acceptTranspilerName: {
      type: 'boolean'
    }
  },
  additionalProperties: false
}];

},
   {"../util/Components":"/node_modules/eslint-plugin-react/lib/util/Components.js"}],

"/node_modules/eslint-plugin-react/lib/rules/forbid-prop-types.js": [function(require,module,exports){
'use strict';

var DEFAULTS = ['any', 'array', 'object'];

module.exports = function(context) {

  function isForbidden(type) {
    var configuration = context.options[0] || {};

    var forbid = configuration.forbid || DEFAULTS;
    return forbid.indexOf(type) >= 0;
  }

  function isPropTypesDeclaration(node) {

    if (node.type === /*ClassProperty*/'Property' && node.kind == 'class') {
      var tokens = context.getFirstTokens(node, 2);
      if (tokens[0].value === 'propTypes' || (tokens[1] && tokens[1].value === 'propTypes')) {
        return true;
      }
      return false;
    }

    return Boolean(
      node &&
      node.name === 'propTypes'
    );
  }


  function checkForbidden(declarations) {
    declarations.forEach(function(declaration) {
      var target;
      var value = declaration.value;
      if (
        value.type === 'MemberExpression' &&
        value.property &&
        value.property.name &&
        value.property.name === 'isRequired'
      ) {
        value = value.object;
      }
      if (
        value.type === 'CallExpression' &&
        value.callee.type === 'MemberExpression'
      ) {
        value = value.callee;
      }
      if (value.property) {
        target = value.property.name;
      } else if (value.type === 'Identifier') {
        target = value.name;
      }
      if (isForbidden(target)) {
        context.report(declaration, 'Prop type `' + target + '` is forbidden');
      }
    });
  }

  return {
    /*ClassProperty*/Property: function(node) {
      if (node.kind == 'class' && isPropTypesDeclaration(node) && node.value && node.value.type === 'ObjectExpression') {
        checkForbidden(node.value.properties);
      }
    },

    MemberExpression: function(node) {
      if (isPropTypesDeclaration(node.property)) {
        var right = node.parent.right;
        if (right && right.type === 'ObjectExpression') {
          checkForbidden(right.properties);
        }
      }
    },

    ObjectExpression: function(node) {
      node.properties.forEach(function(property) {
        if (!property.key) {
          return;
        }

        if (!isPropTypesDeclaration(property.key)) {
          return;
        }
        if (property.value.type === 'ObjectExpression') {
          checkForbidden(property.value.properties);
        }
      });
    }

  };
};

module.exports.schema = [{
  type: 'object',
  properties: {
    forbid: {
      type: 'array',
      items: {
        type: 'string'
      }
    }
  },
  additionalProperties: true
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-boolean-value.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {

  var configuration = context.options[0] || 'never';

  var NEVER_MESSAGE = 'Value must be omitted for boolean attributes';
  var ALWAYS_MESSAGE = 'Value must be set for boolean attributes';

  return {
    JSXAttribute: function(node) {
      switch (configuration) {
        case 'always':
          if (node.value === null) {
            context.report({
              node: node,
              message: ALWAYS_MESSAGE,
              fix: function(fixer) {
                return fixer.insertTextAfter(node, '={true}');
              }
            });
          }
          break;
        case 'never':
          if (node.value && node.value.type === 'JSXExpressionContainer' && node.value.expression.value === true) {
            context.report({
              node: node,
              message: NEVER_MESSAGE,
              fix: function(fixer) {
                return fixer.removeRange([node.name.range[1], node.value.range[1]]);
              }
            });
          }
          break;
        default:
          break;
      }
    }
  };
};

module.exports.schema = [{
  enum: ['always', 'never']
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-closing-bracket-location.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {

  var MESSAGE = 'The closing bracket must be {{location}}{{details}}';
  var MESSAGE_LOCATION = {
    'after-props': 'placed after the last prop',
    'after-tag': 'placed after the opening tag',
    'props-aligned': 'aligned with the last prop',
    'tag-aligned': 'aligned with the opening tag',
    'line-aligned': 'aligned with the line containing the opening tag'
  };
  var DEFAULT_LOCATION = 'tag-aligned';

  var config = context.options[0];
  var options = {
    nonEmpty: DEFAULT_LOCATION,
    selfClosing: DEFAULT_LOCATION
  };

  if (typeof config === 'string') {
    options.nonEmpty = config;
    options.selfClosing = config;
  } else if (typeof config === 'object') {
    if (config.hasOwnProperty('location')) {
      options.nonEmpty = config.location;
      options.selfClosing = config.location;
    }
    if (config.hasOwnProperty('nonEmpty')) {
      options.nonEmpty = config.nonEmpty;
    }
    if (config.hasOwnProperty('selfClosing')) {
      options.selfClosing = config.selfClosing;
    }
  }

  function getExpectedLocation(tokens) {
    var location;
    if (typeof tokens.lastProp === 'undefined') {
      location = 'after-tag';
    } else if (tokens.opening.line === tokens.lastProp.line) {
      location = 'after-props';
    } else {
      location = tokens.selfClosing ? options.selfClosing : options.nonEmpty;
    }
    return location;
  }

  function getCorrectColumn(tokens, expectedLocation) {
    switch (expectedLocation) {
      case 'props-aligned':
        return tokens.lastProp.column;
      case 'tag-aligned':
        return tokens.opening.column;
      case 'line-aligned':
        return tokens.openingStartOfLine.column;
      default:
        return null;
    }
  }

  function hasCorrectLocation(tokens, expectedLocation) {
    switch (expectedLocation) {
      case 'after-tag':
        return tokens.tag.line === tokens.closing.line;
      case 'after-props':
        return tokens.lastProp.line === tokens.closing.line;
      case 'props-aligned':
      case 'tag-aligned':
      case 'line-aligned':
        var correctColumn = getCorrectColumn(tokens, expectedLocation);
        return correctColumn === tokens.closing.column;
      default:
        return true;
    }
  }

  function getTokensLocations(node) {
    var opening = context.getFirstToken(node).loc.start;
    var closing = context.getLastTokens(node, node.selfClosing ? 2 : 1)[0].loc.start;
    var tag = context.getFirstToken(node.name).loc.start;
    var lastProp;
    if (node.attributes.length) {
      lastProp = node.attributes[node.attributes.length - 1];
      lastProp = {
        column: context.getFirstToken(lastProp).loc.start.column,
        line: context.getLastToken(lastProp).loc.end.line
      };
    }
    var openingLine = context.getSourceCode().lines[opening.line - 1];
    var openingStartOfLine = {
      column: /^\s*/.exec(openingLine)[0].length,
      line: opening.line
    };
    return {
      tag: tag,
      opening: opening,
      closing: closing,
      lastProp: lastProp,
      selfClosing: node.selfClosing,
      openingStartOfLine: openingStartOfLine
    };
  }

  return {
    JSXOpeningElement: function(node) {
      var tokens = getTokensLocations(node);
      var expectedLocation = getExpectedLocation(tokens);
      if (hasCorrectLocation(tokens, expectedLocation)) {
        return;
      }

      var data = {location: MESSAGE_LOCATION[expectedLocation], details: ''};
      var correctColumn = getCorrectColumn(tokens, expectedLocation);

      if (correctColumn !== null) {
        var expectedNextLine = tokens.lastProp &&
          (tokens.lastProp.line === tokens.closing.line);
        data.details = ' (expected column ' + (correctColumn + 1) +
          (expectedNextLine ? ' on the next line)' : ')');
      }

      context.report({
        node: node,
        loc: tokens.closing,
        message: MESSAGE,
        data: data
      });
    }
  };

};

module.exports.schema = [{
  oneOf: [
    {
      enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned']
    },
    {
      type: 'object',
      properties: {
        location: {
          enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned']
        }
      },
      additionalProperties: false
    }, {
      type: 'object',
      properties: {
        nonEmpty: {
          enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned', false]
        },
        selfClosing: {
          enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned', false]
        }
      },
      additionalProperties: false
    }
  ]
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-curly-spacing.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {
  var spaced = context.options[0] === 'always';
  var multiline = context.options[1] ? context.options[1].allowMultiline : true;

  function isMultiline(left, right) {
    return left.loc.start.line !== right.loc.start.line;
  }

  function isSpaced(left, right) {
    return left.range[1] < right.range[0];
  }

  function reportNoBeginningNewline(node, token) {
    context.report({
      node: node,
      loc: token.loc.start,
      message: 'There should be no newline after \'' + token.value + '\'',
      fix: function(fixer) {
        var nextToken = context.getSourceCode().getTokenAfter(token);
        return fixer.replaceTextRange([token.range[1], nextToken.range[0]], spaced ? ' ' : '');
      }
    });
  }

  function reportNoEndingNewline(node, token) {
    context.report({
      node: node,
      loc: token.loc.start,
      message: 'There should be no newline before \'' + token.value + '\'',
      fix: function(fixer) {
        var previousToken = context.getSourceCode().getTokenBefore(token);
        return fixer.replaceTextRange([previousToken.range[1], token.range[0]], spaced ? ' ' : '');
      }
    });
  }

  function reportNoBeginningSpace(node, token) {
    context.report({
      node: node,
      loc: token.loc.start,
      message: 'There should be no space after \'' + token.value + '\'',
      fix: function(fixer) {
        var nextToken = context.getSourceCode().getTokenAfter(token);
        return fixer.removeRange([token.range[1], nextToken.range[0]]);
      }
    });
  }

  function reportNoEndingSpace(node, token) {
    context.report({
      node: node,
      loc: token.loc.start,
      message: 'There should be no space before \'' + token.value + '\'',
      fix: function(fixer) {
        var previousToken = context.getSourceCode().getTokenBefore(token);
        return fixer.removeRange([previousToken.range[1], token.range[0]]);
      }
    });
  }

  function reportRequiredBeginningSpace(node, token) {
    context.report({
      node: node,
      loc: token.loc.start,
      message: 'A space is required after \'' + token.value + '\'',
      fix: function(fixer) {
        return fixer.insertTextAfter(token, ' ');
      }
    });
  }

  function reportRequiredEndingSpace(node, token) {
    context.report({
      node: node,
      loc: token.loc.start,
      message: 'A space is required before \'' + token.value + '\'',
      fix: function(fixer) {
        return fixer.insertTextBefore(token, ' ');
      }
    });
  }

  function validateBraceSpacing(node, first, second, penultimate, last) {
    if (spaced) {
      if (!isSpaced(first, second)) {
        reportRequiredBeginningSpace(node, first);
      } else if (!multiline && isMultiline(first, second)) {
        reportNoBeginningNewline(node, first);
      }

      if (!isSpaced(penultimate, last)) {
        reportRequiredEndingSpace(node, last);
      } else if (!multiline && isMultiline(penultimate, last)) {
        reportNoEndingNewline(node, last);
      }

      return;
    }

    if (isSpaced(first, second) && !(multiline && isMultiline(first, second))) {
      reportNoBeginningSpace(node, first);
    }

    if (isSpaced(penultimate, last) && !(multiline && isMultiline(penultimate, last))) {
      reportNoEndingSpace(node, last);
    }
  }

  return {
    JSXExpressionContainer: function(node) {
      var first = context.getFirstToken(node);
      var second = context.getFirstToken(node, 1);
      var penultimate = context.getLastToken(node, 1);
      var last = context.getLastToken(node);

      if (first === penultimate && second === last) {
        return;
      }

      validateBraceSpacing(node, first, second, penultimate, last);
    }
  };
};

module.exports.schema = [{
  enum: ['always', 'never']
}, {
  type: 'object',
  properties: {
    allowMultiline: {
      type: 'boolean'
    }
  },
  additionalProperties: false
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-equals-spacing.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {
  var config = context.options[0];
  var sourceCode = context.getSourceCode();

  function hasEqual(attrNode) {
    return attrNode.type !== 'JSXSpreadAttribute' && attrNode.value !== null;
  }

  return {
    JSXOpeningElement: function(node) {
      node.attributes.forEach(function(attrNode) {
        if (!hasEqual(attrNode)) {
          return;
        }

        var equalToken = sourceCode.getTokenAfter(attrNode.name);
        var spacedBefore = sourceCode.isSpaceBetweenTokens(attrNode.name, equalToken);
        var spacedAfter = sourceCode.isSpaceBetweenTokens(equalToken, attrNode.value);

        switch (config) {
          default:
          case 'never':
            if (spacedBefore) {
              context.report(attrNode, equalToken.loc.start,
                'There should be no space before \'=\'');
            }
            if (spacedAfter) {
              context.report(attrNode, equalToken.loc.start,
                'There should be no space after \'=\'');
            }
            break;
          case 'always':
            if (!spacedBefore) {
              context.report(attrNode, equalToken.loc.start,
                'A space is required before \'=\'');
            }
            if (!spacedAfter) {
              context.report(attrNode, equalToken.loc.start,
                'A space is required after \'=\'');
            }
            break;
        }
      });
    }
  };
};

module.exports.schema = [{
  enum: ['always', 'never']
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-handler-names.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {

  var configuration = context.options[0] || {};
  var eventHandlerPrefix = configuration.eventHandlerPrefix || 'handle';
  var eventHandlerPropPrefix = configuration.eventHandlerPropPrefix || 'on';

  var EVENT_HANDLER_REGEX = new RegExp('^((props\.' + eventHandlerPropPrefix + ')'
                                       + '|((.*\.)?' + eventHandlerPrefix + ')).+$');
  var PROP_EVENT_HANDLER_REGEX = new RegExp('^(' + eventHandlerPropPrefix + '.+|ref)$');

  return {
    JSXAttribute: function(node) {
      if (!node.value || !node.value.expression || !node.value.expression.object) {
        return;
      }

      var propKey = typeof node.name === 'object' ? node.name.name : node.name;
      var propValue = context.getSource(node.value.expression).replace(/^this\./, '');

      if (propKey === 'ref') {
        return;
      }

      var propIsEventHandler = PROP_EVENT_HANDLER_REGEX.test(propKey);
      var propFnIsNamedCorrectly = EVENT_HANDLER_REGEX.test(propValue);

      if (propIsEventHandler && !propFnIsNamedCorrectly) {
        context.report(
          node,
          'Handler function for ' + propKey + ' prop key must begin with \'' + eventHandlerPrefix + '\''
        );
      } else if (propFnIsNamedCorrectly && !propIsEventHandler) {
        context.report(
          node,
          'Prop key for ' + propValue + ' must begin with \'' + eventHandlerPropPrefix + '\''
        );
      }
    }
  };

};

module.exports.schema = [{
  type: 'object',
  properties: {
    eventHandlerPrefix: {
      type: 'string'
    },
    eventHandlerPropPrefix: {
      type: 'string'
    }
  },
  additionalProperties: false
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-indent-props.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {

  var MESSAGE = 'Expected indentation of {{needed}} {{type}} {{characters}} but found {{gotten}}.';

  var extraColumnStart = 0;
  var indentType = 'space';
  var indentSize = 4;

  if (context.options.length) {
    if (context.options[0] === 'tab') {
      indentSize = 1;
      indentType = 'tab';
    } else if (typeof context.options[0] === 'number') {
      indentSize = context.options[0];
      indentType = 'space';
    }
  }

  function report(node, needed, gotten, loc) {
    var msgContext = {
      needed: needed,
      type: indentType,
      characters: needed === 1 ? 'character' : 'characters',
      gotten: gotten
    };

    if (loc) {
      context.report(node, loc, MESSAGE, msgContext);
    } else {
      context.report(node, MESSAGE, msgContext);
    }
  }

  function getNodeIndent(node, byLastLine, excludeCommas) {
    byLastLine = byLastLine || false;
    excludeCommas = excludeCommas || false;

    var src = context.getSource(node, node.loc.start.column + extraColumnStart);
    var lines = src.split('\n');
    if (byLastLine) {
      src = lines[lines.length - 1];
    } else {
      src = lines[0];
    }

    var skip = excludeCommas ? ',' : '';

    var regExp;
    if (indentType === 'space') {
      regExp = new RegExp('^[ ' + skip + ']+');
    } else {
      regExp = new RegExp('^[\t' + skip + ']+');
    }

    var indent = regExp.exec(src);
    return indent ? indent[0].length : 0;
  }

  function isNodeFirstInLine(node, byEndLocation) {
    var firstToken = byEndLocation === true ? context.getLastToken(node, 1) : context.getTokenBefore(node);
    var startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line;
    var endLine = firstToken ? firstToken.loc.end.line : -1;

    return startLine !== endLine;
  }

  function checkNodesIndent(nodes, indent, excludeCommas) {
    nodes.forEach(function(node) {
      var nodeIndent = getNodeIndent(node, false, excludeCommas);
      if (
        node.type !== 'ArrayExpression' && node.type !== 'ObjectExpression' &&
        nodeIndent !== indent && isNodeFirstInLine(node)
      ) {
        report(node, indent, nodeIndent);
      }
    });
  }

  return {
    JSXOpeningElement: function(node) {
      var elementIndent = getNodeIndent(node);
      checkNodesIndent(node.attributes, elementIndent + indentSize);
    }
  };

};

module.exports.schema = [{
  oneOf: [{
    enum: ['tab']
  }, {
    type: 'integer'
  }]
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-indent.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {

  var MESSAGE = 'Expected indentation of {{needed}} {{type}} {{characters}} but found {{gotten}}.';

  var extraColumnStart = 0;
  var indentType = 'space';
  var indentSize = 4;

  if (context.options.length) {
    if (context.options[0] === 'tab') {
      indentSize = 1;
      indentType = 'tab';
    } else if (typeof context.options[0] === 'number') {
      indentSize = context.options[0];
      indentType = 'space';
    }
  }

  function report(node, needed, gotten, loc) {
    var msgContext = {
      needed: needed,
      type: indentType,
      characters: needed === 1 ? 'character' : 'characters',
      gotten: gotten
    };

    if (loc) {
      context.report(node, loc, MESSAGE, msgContext);
    } else {
      context.report(node, MESSAGE, msgContext);
    }
  }

  function getNodeIndent(node, byLastLine, excludeCommas) {
    byLastLine = byLastLine || false;
    excludeCommas = excludeCommas || false;

    var src = context.getSource(node, node.loc.start.column + extraColumnStart);
    var lines = src.split('\n');
    if (byLastLine) {
      src = lines[lines.length - 1];
    } else {
      src = lines[0];
    }

    var skip = excludeCommas ? ',' : '';

    var regExp;
    if (indentType === 'space') {
      regExp = new RegExp('^[ ' + skip + ']+');
    } else {
      regExp = new RegExp('^[\t' + skip + ']+');
    }

    var indent = regExp.exec(src);
    return indent ? indent[0].length : 0;
  }

  function isNodeFirstInLine(node) {
    var token = node;
    do {
      token = context.getTokenBefore(token);
    } while (token.type === 'JSXText');
    var startLine = node.loc.start.line;
    var endLine = token ? token.loc.end.line : -1;

    return startLine !== endLine;
  }

  function checkNodesIndent(node, indent, excludeCommas) {
    var nodeIndent = getNodeIndent(node, false, excludeCommas);
    if (nodeIndent !== indent && isNodeFirstInLine(node)) {
      report(node, indent, nodeIndent);
    }
  }

  return {
    JSXOpeningElement: function(node) {
      if (!node.parent || !node.parent.parent) {
        return;
      }
      var parentElementIndent = getNodeIndent(node.parent.parent);
      var indent = node.parent.parent.loc.start.line === node.loc.start.line ? 0 : indentSize;
      checkNodesIndent(node, parentElementIndent + indent);
    },
    JSXClosingElement: function(node) {
      if (!node.parent) {
        return;
      }
      var peerElementIndent = getNodeIndent(node.parent.openingElement);
      checkNodesIndent(node, peerElementIndent);
    }
  };

};

module.exports.schema = [{
  oneOf: [{
    enum: ['tab']
  }, {
    type: 'integer'
  }]
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-key.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {

  function hasKeyProp(node) {
    return node.openingElement.attributes.some(function(decl) {
      if (decl.type === 'JSXSpreadAttribute') {
        return false;
      }
      return (decl.name.name === 'key');
    });
  }

  function checkIteratorElement(node) {
    if (node.type === 'JSXElement' && !hasKeyProp(node)) {
      context.report(node, 'Missing "key" prop for element in iterator');
    }
  }

  function getReturnStatement(body) {
    return body.filter(function(item) {
      return item.type === 'ReturnStatement';
    })[0];
  }

  return {
    JSXElement: function(node) {
      if (hasKeyProp(node)) {
        return;
      }

      if (node.parent.type === 'ArrayExpression') {
        context.report(node, 'Missing "key" prop for element in array');
      }
    },

    CallExpression: function (node) {
      if (node.callee && node.callee.property && node.callee.property.name !== 'map') {
        return;
      }

      var fn = node.arguments[0];
      var isFn = fn && fn.type === 'FunctionExpression';
      var isArrFn = fn && fn.type === 'ArrowFunctionExpression';

      if (isArrFn && fn.body.type === 'JSXElement') {
        checkIteratorElement(fn.body);
      }

      if (isFn || isArrFn) {
        if (fn.body.type === 'BlockStatement') {
          var returnStatement = getReturnStatement(fn.body.body);
          if (returnStatement && returnStatement.argument) {
            checkIteratorElement(returnStatement.argument);
          }
        }
      }
    }
  };
};

module.exports.schema = [];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-max-props-per-line.js": [function(require,module,exports){
'use strict';

module.exports = function (context) {

  var configuration = context.options[0] || {};
  var maximum = configuration.maximum || 1;

  function getPropName(propNode) {
    if (propNode.type === 'JSXSpreadAttribute') {
      return context.getSource(propNode.argument);
    }
    return propNode.name.name;
  }

  return {
    JSXOpeningElement: function (node) {
      var props = {};

      node.attributes.forEach(function(decl) {
        var line = decl.loc.start.line;
        if (props[line]) {
          props[line].push(decl);
        } else {
          props[line] = [decl];
        }
      });

      for (var line in props) {
        if (!props.hasOwnProperty(line)) {
          continue;
        }
        if (props[line].length > maximum) {
          var name = getPropName(props[line][maximum]);
          context.report(props[line][maximum], 'Prop `' + name + '` must be placed on a new line');
          break;
        }
      }
    }
  };
};

module.exports.schema = [{
  type: 'object',
  properties: {
    maximum: {
      type: 'integer',
      minimum: 1
    }
  }
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-no-bind.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {
  var configuration = context.options[0] || {};

  return {
    JSXAttribute: function(node) {
      var isRef = configuration.ignoreRefs && node.name.name === 'ref';
      if (isRef || !node.value || !node.value.expression) {
        return;
      }
      var valueNode = node.value.expression;
      if (
        !configuration.allowBind &&
        valueNode.type === 'CallExpression' &&
        valueNode.callee.type === 'MemberExpression' &&
        valueNode.callee.property.name === 'bind'
      ) {
        context.report(node, 'JSX props should not use .bind()');
      } else if (
        !configuration.allowArrowFunctions &&
        valueNode.type === 'ArrowFunctionExpression'
      ) {
        context.report(node, 'JSX props should not use arrow functions');
      }
    }
  };
};

module.exports.schema = [{
  type: 'object',
  properties: {
    allowArrowFunctions: {
      default: false,
      type: 'boolean'
    },
    allowBind: {
      default: false,
      type: 'boolean'
    },
    ignoreRefs: {
      default: false,
      type: 'boolean'
    }
  },
  additionalProperties: false
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-no-duplicate-props.js": [function(require,module,exports){
'use strict';

module.exports = function (context) {

  var configuration = context.options[0] || {};
  var ignoreCase = configuration.ignoreCase || false;

  return {
    JSXOpeningElement: function (node) {
      var props = {};

      node.attributes.forEach(function(decl) {
        if (decl.type === 'JSXSpreadAttribute') {
          return;
        }

        var name = decl.name.name;

        if (ignoreCase) {
          name = name.toLowerCase();
        }

        if (props.hasOwnProperty(name)) {
          context.report(decl, 'No duplicate props allowed');
        } else {
          props[name] = 1;
        }
      });
    }
  };
};

module.exports.schema = [{
  type: 'object',
  properties: {
    ignoreCase: {
      type: 'boolean'
    }
  },
  additionalProperties: false
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-no-literals.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {

  function reportLiteralNode(node) {
    context.report(node, 'Missing JSX expression container around literal string');
  }

  return {

    Literal: function(node) {
      if (
       !/^[\s]+$/.test(node.value) &&
        node.parent &&
        node.parent.type !== 'JSXExpressionContainer' &&
        node.parent.type !== 'JSXAttribute' &&
        node.parent.type.indexOf('JSX') !== -1
      ) {
        reportLiteralNode(node);
      }
    }

  };

};

module.exports.schema = [{
  type: 'object',
  properties: {},
  additionalProperties: false
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-no-undef.js": [function(require,module,exports){
'use strict';

var tagConvention = /^[a-z]|\-/;
function isTagName(name) {
  return tagConvention.test(name);
}

module.exports = function(context) {

  function checkIdentifierInJSX(node) {
    var scope = context.getScope();
    var variables = scope.variables;
    var i;
    var len;

    while (scope.type !== 'global') {
      scope = scope.upper;
      variables = scope.variables.concat(variables);
    }
    if (scope.childScopes.length) {
      variables = scope.childScopes[0].variables.concat(variables);
      if (scope.childScopes[0].childScopes.length) {
        variables = scope.childScopes[0].childScopes[0].variables.concat(variables);
      }
    }

    for (i = 0, len = variables.length; i < len; i++) {
      if (variables[i].name === node.name) {
        return;
      }
    }

    context.report(node, '\'' + node.name + '\' is not defined.');
  }

  return {
    JSXOpeningElement: function(node) {
      switch (node.name.type) {
        case 'JSXIdentifier':
          node = node.name;
          break;
        case 'JSXMemberExpression':
          node = node.name.object;
          break;
        case 'JSXNamespacedName':
          node = node.name.namespace;
          break;
        default:
          break;
      }
      if (isTagName(node.name)) {
        return;
      }
      checkIdentifierInJSX(node);
    }
  };

};

module.exports.schema = [];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-pascal-case.js": [function(require,module,exports){
'use strict';

var PASCAL_CASE_REGEX = /^[A-Z0-9]+[a-z0-9]+(?:[A-Z0-9]+[a-z0-9]*)*$/;
var COMPAT_TAG_REGEX = /^[a-z]|\-/;

module.exports = function(context) {

  return {
    JSXOpeningElement: function(node) {
      switch (node.name.type) {
        case 'JSXIdentifier':
          node = node.name;
          break;
        case 'JSXMemberExpression':
          node = node.name.object;
          break;
        case 'JSXNamespacedName':
          node = node.name.namespace;
          break;
        default:
          break;
      }

      var isPascalCase = PASCAL_CASE_REGEX.test(node.name);
      var isCompatTag = COMPAT_TAG_REGEX.test(node.name);

      if (!isPascalCase && !isCompatTag) {
        context.report(node, 'Imported JSX component ' + node.name + ' must be in PascalCase');
      }
    }
  };

};

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-quotes.js": [function(require,module,exports){
(function (process){
'use strict';

var QUOTE_SETTINGS = {
  double: {
    quote: '"',
    alternateQuote: '\'',
    description: 'doublequote'
  },
  single: {
    quote: '\'',
    alternateQuote: '"',
    description: 'singlequote'
  }
};

var AVOID_ESCAPE = 'avoid-escape';

var isWarnedForDeprecation = false;

module.exports = function(context) {

  function isSurroundedBy(val, character) {
    return val[0] === character && val[val.length - 1] === character;
  }

  return {

    Program: function() {
      if (isWarnedForDeprecation || /\=-(f|-format)=/.test(process.argv.join('='))) {
        return;
      }
      console.log('The react/jsx-quotes rule is deprecated. Please use the jsx-quotes rule instead.');
      isWarnedForDeprecation = true;
    },

    Literal: function(node) {

      if (node.parent.type !== 'JSXAttribute') {
        return;
      }
      var val = node.value;
      var rawVal = node.raw;
      var quoteOption = context.options[0];
      var settings = QUOTE_SETTINGS[quoteOption];
      var avoidEscape = context.options[1] === AVOID_ESCAPE;
      var isValid;

      if (settings && typeof val === 'string') {
        isValid = isSurroundedBy(rawVal, settings.quote);

        if (!isValid && avoidEscape) {
          isValid = isSurroundedBy(rawVal, settings.alternateQuote) && rawVal.indexOf(settings.quote) >= 0;
        }

        if (!isValid) {
          context.report(node, 'JSX attributes must use ' + settings.description + '.');
        }
      }
    }
  };

};

module.exports.schema = [{
  enum: ['single', 'double']
}, {
  enum: ['avoid-escape']
}];

}).call(this,require('_process'))
},
   {"_process":"/node_modules/browserify/node_modules/process/browser.js"}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-sort-prop-types.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {

  var configuration = context.options[0] || {};
  var requiredFirst = configuration.requiredFirst || false;
  var callbacksLast = configuration.callbacksLast || false;
  var ignoreCase = configuration.ignoreCase || false;

  function isPropTypesDeclaration(node) {

    if (node.type === /*ClassProperty*/'Property' && node.kind == 'class') {
      var tokens = context.getFirstTokens(node, 2);
      return (tokens[0] && tokens[0].value === 'propTypes') ||
             (tokens[1] && tokens[1].value === 'propTypes');
    }

    return Boolean(
      node &&
      node.name === 'propTypes'
    );
  }

  function getKey(node) {
    return node.key.type === 'Identifier' ? node.key.name : node.key.value;
  }

  function getValueName(node) {
    return node.value.property && node.value.property.name;
  }

  function isCallbackPropName(propName) {
    return /^on[A-Z]/.test(propName);
  }

  function isRequiredProp(node) {
    return getValueName(node) === 'isRequired';
  }

  function checkSorted(declarations) {
    declarations.reduce(function(prev, curr) {
      var prevPropName = getKey(prev);
      var currentPropName = getKey(curr);
      var previousIsRequired = isRequiredProp(prev);
      var currentIsRequired = isRequiredProp(curr);
      var previousIsCallback = isCallbackPropName(prevPropName);
      var currentIsCallback = isCallbackPropName(currentPropName);

      if (ignoreCase) {
        prevPropName = prevPropName.toLowerCase();
        currentPropName = currentPropName.toLowerCase();
      }

      if (requiredFirst) {
        if (previousIsRequired && !currentIsRequired) {
          return curr;
        }
        if (!previousIsRequired && currentIsRequired) {
          context.report(curr, 'Required prop types must be listed before all other prop types');
          return curr;
        }
      }

      if (callbacksLast) {
        if (!previousIsCallback && currentIsCallback) {
          return curr;
        }
        if (previousIsCallback && !currentIsCallback) {
          context.report(prev, 'Callback prop types must be listed after all other prop types');
          return prev;
        }
      }

      if (currentPropName < prevPropName) {
        context.report(curr, 'Prop types declarations should be sorted alphabetically');
        return prev;
      }

      return curr;
    }, declarations[0]);
  }

  return {
    /*ClassProperty*/Property: function(node) {
      if (node.kind == 'class' && isPropTypesDeclaration(node) && node.value && node.value.type === 'ObjectExpression') {
        checkSorted(node.value.properties);
      }
    },

    MemberExpression: function(node) {
      if (isPropTypesDeclaration(node.property)) {
        var right = node.parent.right;
        if (right && right.type === 'ObjectExpression') {
          checkSorted(right.properties);
        }
      }
    },

    ObjectExpression: function(node) {
      node.properties.forEach(function(property) {
        if (!property.key) {
          return;
        }

        if (!isPropTypesDeclaration(property.key)) {
          return;
        }
        if (property.value.type === 'ObjectExpression') {
          checkSorted(property.value.properties);
        }
      });
    }

  };
};

module.exports.schema = [{
  type: 'object',
  properties: {
    requiredFirst: {
      type: 'boolean'
    },
    callbacksLast: {
      type: 'boolean'
    },
    ignoreCase: {
      type: 'boolean'
    }
  },
  additionalProperties: false
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-sort-props.js": [function(require,module,exports){
'use strict';

function isCallbackPropName(propName) {
  return /^on[A-Z]/.test(propName);
}

module.exports = function(context) {

  var configuration = context.options[0] || {};
  var ignoreCase = configuration.ignoreCase || false;
  var callbacksLast = configuration.callbacksLast || false;
  var shorthandFirst = configuration.shorthandFirst || false;

  return {
    JSXOpeningElement: function(node) {
      node.attributes.reduce(function(memo, decl, idx, attrs) {
        if (decl.type === 'JSXSpreadAttribute') {
          return attrs[idx + 1];
        }

        var previousPropName = memo.name.name;
        var currentPropName = decl.name.name;
        var previousValue = memo.value;
        var currentValue = decl.value;
        var previousIsCallback = isCallbackPropName(previousPropName);
        var currentIsCallback = isCallbackPropName(currentPropName);

        if (ignoreCase) {
          previousPropName = previousPropName.toLowerCase();
          currentPropName = currentPropName.toLowerCase();
        }

        if (callbacksLast) {
          if (!previousIsCallback && currentIsCallback) {
            return decl;
          }
          if (previousIsCallback && !currentIsCallback) {
            context.report(memo, 'Callbacks must be listed after all other props');
            return memo;
          }
        }

        if (shorthandFirst) {
          if (currentValue && !previousValue) {
            return decl;
          }
          if (!currentValue && previousValue) {
            context.report(memo, 'Shorthand props must be listed before all other props');
            return memo;
          }
        }

        if (currentPropName < previousPropName) {
          context.report(decl, 'Props should be sorted alphabetically');
          return memo;
        }

        return decl;
      }, node.attributes[0]);
    }
  };
};

module.exports.schema = [{
  type: 'object',
  properties: {
    callbacksLast: {
      type: 'boolean'
    },
    shorthandFirst: {
      type: 'boolean'
    },
    ignoreCase: {
      type: 'boolean'
    }
  },
  additionalProperties: false
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-uses-react.js": [function(require,module,exports){
'use strict';

var variableUtil = require('../util/variable');
var pragmaUtil = require('../util/pragma');

module.exports = function(context) {

  var pragma = pragmaUtil.getFromContext(context);

  return {

    JSXOpeningElement: function() {
      variableUtil.markVariableAsUsed(context, pragma);
    },

    BlockComment: function(node) {
      pragma = pragmaUtil.getFromNode(node) || pragma;
    }

  };

};

module.exports.schema = [{
  type: 'object',
  properties: {
    pragma: {
      type: 'string'
    }
  },
  additionalProperties: false
}];

},
   {"../util/pragma":"/node_modules/eslint-plugin-react/lib/util/pragma.js","../util/variable":"/node_modules/eslint-plugin-react/lib/util/variable.js"}],

"/node_modules/eslint-plugin-react/lib/rules/jsx-uses-vars.js": [function(require,module,exports){
'use strict';

var variableUtil = require('../util/variable');

module.exports = function(context) {

  return {
    JSXExpressionContainer: function(node) {
      if (node.expression.type !== 'Identifier') {
        return;
      }
      variableUtil.markVariableAsUsed(context, node.expression.name);
    },

    JSXIdentifier: function(node) {
      if (node.parent.type === 'JSXAttribute') {
        return;
      }
      variableUtil.markVariableAsUsed(context, node.name);
    }

  };

};

module.exports.schema = [];

},
   {"../util/variable":"/node_modules/eslint-plugin-react/lib/util/variable.js"}],

"/node_modules/eslint-plugin-react/lib/rules/no-danger.js": [function(require,module,exports){
'use strict';

var DANGEROUS_MESSAGE = 'Dangerous property \'{{name}}\' found';

var DANGEROUS_PROPERTY_NAMES = [
  'dangerouslySetInnerHTML'
];

var DANGEROUS_PROPERTIES = DANGEROUS_PROPERTY_NAMES.reduce(function (props, prop) {
  props[prop] = prop;
  return props;
}, Object.create(null));

var tagConvention = /^[a-z]|\-/;
function isTagName(name) {
  return tagConvention.test(name);
}

function isDangerous(name) {
  return name in DANGEROUS_PROPERTIES;
}

module.exports = function(context) {

  return {

    JSXAttribute: function(node) {
      if (isTagName(node.parent.name.name) && isDangerous(node.name.name)) {
        context.report(node, DANGEROUS_MESSAGE, {
          name: node.name.name
        });
      }
    }

  };

};

module.exports.schema = [];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/no-deprecated.js": [function(require,module,exports){
'use strict';

var pragmaUtil = require('../util/pragma');

var DEPRECATED_MESSAGE = '{{oldMethod}} is deprecated since React {{version}}{{newMethod}}';

module.exports = function(context) {

  var optVer = context.options[0] ? context.options[0].react : '999.999.999';
  optVer = /^[0-9]+\.[0-9]+$/.test(optVer) ? optVer + '.0' : optVer;
  optVer = optVer.split('.').map(function(part) {
    return Number(part);
  });

  var pragma = pragmaUtil.getFromContext(context);

  function getDeprecated() {
    var deprecated = {
      MemberExpression: {}
    };
    deprecated.MemberExpression[pragma + '.renderComponent'] = ['0.12.0', pragma + '.render'];
    deprecated.MemberExpression[pragma + '.renderComponentToString'] = ['0.12.0', pragma + '.renderToString'];
    deprecated.MemberExpression[pragma + '.renderComponentToStaticMarkup'] = [
      '0.12.0',
      pragma + '.renderToStaticMarkup'
    ];
    deprecated.MemberExpression[pragma + '.isValidComponent'] = ['0.12.0', pragma + '.isValidElement'];
    deprecated.MemberExpression[pragma + '.PropTypes.component'] = ['0.12.0', pragma + '.PropTypes.element'];
    deprecated.MemberExpression[pragma + '.PropTypes.renderable'] = ['0.12.0', pragma + '.PropTypes.node'];
    deprecated.MemberExpression[pragma + '.isValidClass'] = ['0.12.0'];
    deprecated.MemberExpression['this.transferPropsTo'] = ['0.12.0', 'spread operator ({...})'];
    deprecated.MemberExpression[pragma + '.addons.classSet'] = ['0.13.0', 'the npm module classnames'];
    deprecated.MemberExpression[pragma + '.addons.cloneWithProps'] = ['0.13.0', pragma + '.cloneElement'];
    deprecated.MemberExpression[pragma + '.render'] = ['0.14.0', 'ReactDOM.render'];
    deprecated.MemberExpression[pragma + '.unmountComponentAtNode'] = ['0.14.0', 'ReactDOM.unmountComponentAtNode'];
    deprecated.MemberExpression[pragma + '.findDOMNode'] = ['0.14.0', 'ReactDOM.findDOMNode'];
    deprecated.MemberExpression[pragma + '.renderToString'] = ['0.14.0', 'ReactDOMServer.renderToString'];
    deprecated.MemberExpression[pragma + '.renderToStaticMarkup'] = ['0.14.0', 'ReactDOMServer.renderToStaticMarkup'];

    return deprecated;
  }

  function checkVersion(methodVer) {
    methodVer = methodVer.split('.').map(function(part) {
      return Number(part);
    });
    var higherMajor = methodVer[0] < optVer[0];
    var higherMinor = methodVer[0] === optVer[0] && methodVer[1] < optVer[1];
    var higherOrEqualPatch = methodVer[0] === optVer[0] && methodVer[1] === optVer[1] && methodVer[2] <= optVer[2];

    return higherMajor || higherMinor || higherOrEqualPatch;
  }

  function isDeprecated(type, method) {
    var deprecated = getDeprecated();

    return (
      deprecated[type] &&
      deprecated[type][method] &&
      checkVersion(deprecated[type][method][0])
    );
  }

  return {

    MemberExpression: function(node) {
      var method = context.getSource(node);
      if (!isDeprecated(node.type, method)) {
        return;
      }
      var deprecated = getDeprecated();
      context.report(node, DEPRECATED_MESSAGE, {
        oldMethod: method,
        version: deprecated[node.type][method][0],
        newMethod: deprecated[node.type][method][1] ? ', use ' + deprecated[node.type][method][1] + ' instead' : ''
      });
    },

    BlockComment: function(node) {
      pragma = pragmaUtil.getFromNode(node) || pragma;
    }

  };

};

module.exports.schema = [{
  type: 'object',
  properties: {
    react: {
      type: 'string',
      pattern: '^[0-9]+\.[0-9]+(\.[0-9]+)?$'
    }
  },
  additionalProperties: false
}];

},
   {"../util/pragma":"/node_modules/eslint-plugin-react/lib/util/pragma.js"}],

"/node_modules/eslint-plugin-react/lib/rules/no-did-mount-set-state.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {

  var mode = context.options[0] || 'never';

  return {

    CallExpression: function(node) {
      var callee = node.callee;
      if (
        callee.type !== 'MemberExpression' ||
        callee.object.type !== 'ThisExpression' ||
        callee.property.name !== 'setState'
      ) {
        return;
      }
      var ancestors = context.getAncestors(callee).reverse();
      var depth = 0;
      for (var i = 0, j = ancestors.length; i < j; i++) {
        if (/Function(Expression|Declaration)$/.test(ancestors[i].type)) {
          depth++;
        }
        if (
          (ancestors[i].type !== 'Property' && ancestors[i].type !== 'MethodDefinition') ||
          ancestors[i].key.name !== 'componentDidMount' ||
          (mode === 'allow-in-func' && depth > 1)
        ) {
          continue;
        }
        context.report(callee, 'Do not use setState in componentDidMount');
        break;
      }
    }
  };

};

module.exports.schema = [{
  enum: ['allow-in-func']
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/no-did-update-set-state.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {

  var mode = context.options[0] || 'never';

  return {

    CallExpression: function(node) {
      var callee = node.callee;
      if (
        callee.type !== 'MemberExpression' ||
        callee.object.type !== 'ThisExpression' ||
        callee.property.name !== 'setState'
      ) {
        return;
      }
      var ancestors = context.getAncestors(callee).reverse();
      var depth = 0;
      for (var i = 0, j = ancestors.length; i < j; i++) {
        if (/Function(Expression|Declaration)$/.test(ancestors[i].type)) {
          depth++;
        }
        if (
          (ancestors[i].type !== 'Property' && ancestors[i].type !== 'MethodDefinition') ||
          ancestors[i].key.name !== 'componentDidUpdate' ||
          (mode === 'allow-in-func' && depth > 1)
        ) {
          continue;
        }
        context.report(callee, 'Do not use setState in componentDidUpdate');
        break;
      }
    }
  };

};

module.exports.schema = [{
  enum: ['allow-in-func']
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/no-direct-mutation-state.js": [function(require,module,exports){
'use strict';

var Components = require('../util/Components');

module.exports = Components.detect(function(context, components, utils) {

  function isValid(component) {
    return Boolean(component && !component.mutateSetState);
  }

  function reportMutations(component) {
    var mutation;
    for (var i = 0, j = component.mutations.length; i < j; i++) {
      mutation = component.mutations[i];
      context.report(mutation, 'Do not mutate state directly. Use setState().');
    }
  }

  return {
    AssignmentExpression: function(node) {
      var item;
      if (!node.left || !node.left.object || !node.left.object.object) {
        return;
      }
      item = node.left.object;
      while (item.object.property) {
        item = item.object;
      }
      if (
        item.object.type === 'ThisExpression' &&
        item.property.name === 'state'
      ) {
        var component = components.get(utils.getParentComponent());
        var mutations = component && component.mutations || [];
        mutations.push(node.left.object);
        components.set(node, {
          mutateSetState: true,
          mutations: mutations
        });
      }
    },

    'Program:exit': function() {
      var list = components.list();
      for (var component in list) {
        if (!list.hasOwnProperty(component) || isValid(list[component])) {
          continue;
        }
        reportMutations(list[component]);
      }
    }
  };

});

},
   {"../util/Components":"/node_modules/eslint-plugin-react/lib/util/Components.js"}],

"/node_modules/eslint-plugin-react/lib/rules/no-is-mounted.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {

  return {

    CallExpression: function(node) {
      var callee = node.callee;
      if (callee.type !== 'MemberExpression') {
        return;
      }
      if (callee.object.type !== 'ThisExpression' || callee.property.name !== 'isMounted') {
        return;
      }
      var ancestors = context.getAncestors(callee);
      for (var i = 0, j = ancestors.length; i < j; i++) {
        if (ancestors[i].type === 'Property' || ancestors[i].type === 'MethodDefinition') {
          context.report(callee, 'Do not use isMounted');
          break;
        }
      }
    }
  };

};

module.exports.schema = [];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/no-multi-comp.js": [function(require,module,exports){
'use strict';

var Components = require('../util/Components');

module.exports = Components.detect(function(context, components) {

  var configuration = context.options[0] || {};
  var ignoreStateless = configuration.ignoreStateless || false;

  var MULTI_COMP_MESSAGE = 'Declare only one React component per file';

  function isIgnored(component) {
    return ignoreStateless === true && /Function/.test(component.node.type);
  }

  return {
    'Program:exit': function() {
      if (components.length() <= 1) {
        return;
      }

      var list = components.list();
      var i = 0;

      for (var component in list) {
        if (!list.hasOwnProperty(component) || isIgnored(list[component]) || ++i === 1) {
          continue;
        }
        context.report(list[component].node, MULTI_COMP_MESSAGE);
      }
    }
  };
});

module.exports.schema = [{
  type: 'object',
  properties: {
    ignoreStateless: {
      default: false,
      type: 'boolean'
    }
  },
  additionalProperties: false
}];

},
   {"../util/Components":"/node_modules/eslint-plugin-react/lib/util/Components.js"}],

"/node_modules/eslint-plugin-react/lib/rules/no-set-state.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {

  return {

    CallExpression: function(node) {
      var callee = node.callee;
      if (callee.type !== 'MemberExpression') {
        return;
      }
      if (callee.object.type !== 'ThisExpression' || callee.property.name !== 'setState') {
        return;
      }
      var ancestors = context.getAncestors(callee);
      for (var i = 0, j = ancestors.length; i < j; i++) {
        if (ancestors[i].type === 'Property' || ancestors[i].type === 'MethodDefinition') {
          context.report(callee, 'Do not use setState');
          break;
        }
      }
    }
  };

};

module.exports.schema = [];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/no-string-refs.js": [function(require,module,exports){
'use strict';

var Components = require('../util/Components');

module.exports = Components.detect(function(context, components, utils) {
  function isRefsUsage(node) {
    return Boolean(
      (
        utils.getParentES6Component() ||
        utils.getParentES5Component()
      ) &&
      node.object.type === 'ThisExpression' &&
      node.property.name === 'refs'
    );
  }

  function isRefAttribute(node) {
    return Boolean(
      node.type === 'JSXAttribute' &&
      node.name &&
      node.name.name === 'ref'
    );
  }

  function containsStringLiteral(node) {
    return Boolean(
      node.value &&
      node.value.type === 'Literal' &&
      typeof node.value.value === 'string'
    );
  }

  function containsStringExpressionContainer(node) {
    return Boolean(
      node.value &&
      node.value.type === 'JSXExpressionContainer' &&
      node.value.expression &&
      node.value.expression.type === 'Literal' &&
      typeof node.value.expression.value === 'string'
    );
  }

  return {
    MemberExpression: function(node) {
      if (isRefsUsage(node)) {
        context.report(node, 'Using this.refs is deprecated.');
      }
    },
    JSXAttribute: function(node) {
      if (
        isRefAttribute(node) &&
        (containsStringLiteral(node) || containsStringExpressionContainer(node))
      ) {
        context.report(node, 'Using string literals in ref attributes is deprecated.');
      }
    }
  };
});

module.exports.schema = [];

},
   {"../util/Components":"/node_modules/eslint-plugin-react/lib/util/Components.js"}],

"/node_modules/eslint-plugin-react/lib/rules/no-unknown-property.js": [function(require,module,exports){
'use strict';

var UNKNOWN_MESSAGE = 'Unknown property \'{{name}}\' found, use \'{{standardName}}\' instead';

var DOM_ATTRIBUTE_NAMES = {
  'accept-charset': 'acceptCharset',
  class: 'className',
  for: 'htmlFor',
  'http-equiv': 'httpEquiv',
  'clip-path': 'clipPath',
  'fill-opacity': 'fillOpacity',
  'font-family': 'fontFamily',
  'font-size': 'fontSize',
  'marker-end': 'markerEnd',
  'marker-mid': 'markerMid',
  'marker-start': 'markerStart',
  'stop-color': 'stopColor',
  'stop-opacity': 'stopOpacity',
  'stroke-dasharray': 'strokeDasharray',
  'stroke-linecap': 'strokeLinecap',
  'stroke-opacity': 'strokeOpacity',
  'stroke-width': 'strokeWidth',
  'text-anchor': 'textAnchor',
  'xlink:actuate': 'xlinkActuate',
  'xlink:arcrole': 'xlinkArcrole',
  'xlink:href': 'xlinkHref',
  'xlink:role': 'xlinkRole',
  'xlink:show': 'xlinkShow',
  'xlink:title': 'xlinkTitle',
  'xlink:type': 'xlinkType',
  'xml:base': 'xmlBase',
  'xml:lang': 'xmlLang',
  'xml:space': 'xmlSpace'
};

var DOM_PROPERTY_NAMES = [
  'acceptCharset', 'accessKey', 'allowFullScreen', 'allowTransparency', 'autoComplete', 'autoFocus', 'autoPlay',
  'cellPadding', 'cellSpacing', 'charSet', 'classID', 'className', 'colSpan', 'contentEditable', 'contextMenu',
  'crossOrigin', 'dateTime', 'encType', 'formAction', 'formEncType', 'formMethod', 'formNoValidate', 'formTarget',
  'frameBorder', 'hrefLang', 'htmlFor', 'httpEquiv', 'marginHeight', 'marginWidth', 'maxLength', 'mediaGroup',
  'noValidate', 'onBlur', 'onChange', 'onClick', 'onContextMenu', 'onCopy', 'onCut', 'onDoubleClick',
  'onDrag', 'onDragEnd', 'onDragEnter', 'onDragExit', 'onDragLeave', 'onDragOver', 'onDragStart', 'onDrop',
  'onFocus', 'onInput', 'onKeyDown', 'onKeyPress', 'onKeyUp', 'onMouseDown', 'onMouseEnter', 'onMouseLeave',
  'onMouseMove', 'onMouseOut', 'onMouseOver', 'onMouseUp', 'onPaste', 'onScroll', 'onSubmit', 'onTouchCancel',
  'onTouchEnd', 'onTouchMove', 'onTouchStart', 'onWheel',
  'radioGroup', 'readOnly', 'rowSpan', 'spellCheck', 'srcDoc', 'srcSet', 'tabIndex', 'useMap',
  'autoCapitalize', 'autoCorrect',
  'autoSave',
  'itemProp', 'itemScope', 'itemType', 'itemRef', 'itemID'
];

var tagConvention = /^[a-z][^-]*$/;
function isTagName(node) {
  if (tagConvention.test(node.parent.name.name)) {
    return !node.parent.attributes.some(function(attrNode) {
      return (
        attrNode.type === 'JSXAttribute' &&
        attrNode.name.type === 'JSXIdentifier' &&
        attrNode.name.name === 'is'
      );
    });
  }
  return false;
}

function getStandardName(name) {
  if (DOM_ATTRIBUTE_NAMES[name]) {
    return DOM_ATTRIBUTE_NAMES[name];
  }
  var i;
  var found = DOM_PROPERTY_NAMES.some(function(element, index) {
    i = index;
    return element.toLowerCase() === name;
  });
  return found ? DOM_PROPERTY_NAMES[i] : null;
}

module.exports = function(context) {

  return {

    JSXAttribute: function(node) {
      var name = context.getSource(node.name);
      var standardName = getStandardName(name);
      if (!isTagName(node) || !standardName) {
        return;
      }
      context.report({
        node: node,
        message: UNKNOWN_MESSAGE,
        data: {
          name: name,
          standardName: standardName
        },
        fix: function(fixer) {
          return fixer.replaceText(node.name, standardName);
        }
      });
    }
  };

};

module.exports.schema = [];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/prefer-es6-class.js": [function(require,module,exports){
'use strict';

var Components = require('../util/Components');

module.exports = Components.detect(function(context, components, utils) {
  var configuration = context.options[0] || 'always';

  return {
    ObjectExpression: function(node) {
      if (utils.isES5Component(node) && configuration === 'always') {
        context.report(node, 'Component should use es6 class instead of createClass');
      }
    },
    ClassDeclaration: function(node) {
      if (utils.isES6Component(node) && configuration === 'never') {
        context.report(node, 'Component should use createClass instead of es6 class');
      }
    }
  };
});

module.exports.schema = [{
  enum: ['always', 'never']
}];

},
   {"../util/Components":"/node_modules/eslint-plugin-react/lib/util/Components.js"}],

"/node_modules/eslint-plugin-react/lib/rules/prop-types.js": [function(require,module,exports){
'use strict';

var Components = require('../util/Components');
var variable = require('../util/variable');

module.exports = Components.detect(function(context, components, utils) {

  var configuration = context.options[0] || {};
  var ignored = configuration.ignore || [];
  var customValidators = configuration.customValidators || [];
  var stack = null;

  var MISSING_MESSAGE = '\'{{name}}\' is missing in props validation';

  function typeScope(key, value) {
    if (arguments.length === 0) {
      return stack[stack.length - 1];
    } else if (arguments.length === 1) {
      return stack[stack.length - 1][key];
    }
    stack[stack.length - 1][key] = value;
    return value;
  }

  function isPropTypesUsage(node) {
    var isClassUsage = (
      (utils.getParentES6Component() || utils.getParentES5Component()) &&
      node.object.type === 'ThisExpression' && node.property.name === 'props'
    );
    var isStatelessFunctionUsage = node.object.name === 'props';
    return isClassUsage || isStatelessFunctionUsage;
  }

  function isAnnotatedPropsDeclaration(node) {
    if (node && node.type === /*ClassProperty*/'Property' && node.kind == 'class') {
      var tokens = context.getFirstTokens(node, 2);
      if (
        node.typeAnnotation && (
          tokens[0].value === 'props' ||
          (tokens[1] && tokens[1].value === 'props')
        )
      ) {
        return true;
      }
    }
    return false;
  }

  function isPropTypesDeclaration(node) {

    if (node && node.type === /*ClassProperty*/'Property' && node.kind == 'class') {
      var tokens = context.getFirstTokens(node, 2);
      if (
        tokens[0].value === 'propTypes' ||
        (tokens[1] && tokens[1].value === 'propTypes')
      ) {
        return true;
      }
      return false;
    }

    return Boolean(
      node &&
      node.name === 'propTypes'
    );

  }

  function isIgnored(name) {
    return ignored.indexOf(name) !== -1;
  }

  function hasCustomValidator(validator) {
    return customValidators.indexOf(validator) !== -1;
  }

  function mustBeValidated(component) {
    return Boolean(
      component &&
      component.usedPropTypes &&
      !component.ignorePropsValidation
    );
  }

  function _isDeclaredInComponent(declaredPropTypes, keyList) {
    for (var i = 0, j = keyList.length; i < j; i++) {
      var key = keyList[i];
      var propType = (
        declaredPropTypes[key] ||
        declaredPropTypes.__ANY_KEY__
      );

      if (!propType) {
        return key === '__COMPUTED_PROP__';
      }
      if (propType === true) {
        return true;
      }
      if (propType.children === true) {
        return true;
      }
      if (propType.acceptedProperties) {
        return key in propType.acceptedProperties;
      }
      if (propType.type === 'union') {
        if (i + 1 >= j) {
          return true;
        }
        var unionTypes = propType.children;
        var unionPropType = {};
        for (var k = 0, z = unionTypes.length; k < z; k++) {
          unionPropType[key] = unionTypes[k];
          var isValid = _isDeclaredInComponent(
            unionPropType,
            keyList.slice(i)
          );
          if (isValid) {
            return true;
          }
        }

        return false;
      }
      declaredPropTypes = propType.children;
    }
    return true;
  }

  function isDeclaredInComponent(node, names) {
    while (node) {
      var component = components.get(node);
      var isDeclared =
        component && component.confidence === 2 &&
        _isDeclaredInComponent(component.declaredPropTypes || {}, names)
      ;
      if (isDeclared) {
        return true;
      }
      node = node.parent;
    }
    return false;
  }

  function hasSpreadOperator(node) {
    var tokens = context.getTokens(node);
    return tokens.length && tokens[0].value === '...';
  }

  function getKeyValue(node) {
    if (node.type === 'ObjectTypeProperty') {
      var tokens = context.getFirstTokens(node, 1);
      return tokens[0].value;
    }
    var key = node.key || node.argument;
    return key.type === 'Identifier' ? key.name : key.value;
  }

  function iterateProperties(properties, fn) {
    if (properties.length && typeof fn === 'function') {
      for (var i = 0, j = properties.length; i < j; i++) {
        var node = properties[i];
        var key = getKeyValue(node);

        var value = node.value;
        fn(key, value);
      }
    }
  }

  function buildReactDeclarationTypes(value) {
    if (
      value &&
      value.callee &&
      value.callee.object &&
      hasCustomValidator(value.callee.object.name)
    ) {
      return true;
    }

    if (
      value &&
      value.type === 'MemberExpression' &&
      value.property &&
      value.property.name &&
      value.property.name === 'isRequired'
    ) {
      value = value.object;
    }

    if (
      value &&
      value.type === 'CallExpression' &&
      value.callee &&
      value.callee.property &&
      value.callee.property.name &&
      value.arguments &&
      value.arguments.length > 0
    ) {
      var callName = value.callee.property.name;
      var argument = value.arguments[0];
      switch (callName) {
        case 'shape':
          if (argument.type !== 'ObjectExpression') {
            return true;
          }
          var shapeTypeDefinition = {
            type: 'shape',
            children: {}
          };
          iterateProperties(argument.properties, function(childKey, childValue) {
            shapeTypeDefinition.children[childKey] = buildReactDeclarationTypes(childValue);
          });
          return shapeTypeDefinition;
        case 'arrayOf':
        case 'objectOf':
          return {
            type: 'object',
            children: {
              __ANY_KEY__: buildReactDeclarationTypes(argument)
            }
          };
        case 'oneOfType':
          if (
            !argument.elements ||
            !argument.elements.length
          ) {
            return true;
          }
          var unionTypeDefinition = {
            type: 'union',
            children: []
          };
          for (var i = 0, j = argument.elements.length; i < j; i++) {
            var type = buildReactDeclarationTypes(argument.elements[i]);
            if (type !== true) {
              if (type.children === true) {
                unionTypeDefinition.children = true;
                return unionTypeDefinition;
              }
            }

            unionTypeDefinition.children.push(type);
          }
          if (unionTypeDefinition.length === 0) {
            return true;
          }
          return unionTypeDefinition;
        case 'instanceOf':
          return {
            type: 'instance',
            children: true
          };
        case 'oneOf':
        default:
          return true;
      }
    }
    return true;
  }

  function buildTypeAnnotationDeclarationTypes(annotation) {
    switch (annotation.type) {
      case 'GenericTypeAnnotation':
        if (typeScope(annotation.id.name)) {
          return buildTypeAnnotationDeclarationTypes(typeScope(annotation.id.name));
        }
        return true;
      case 'ObjectTypeAnnotation':
        var shapeTypeDefinition = {
          type: 'shape',
          children: {}
        };
        iterateProperties(annotation.properties, function(childKey, childValue) {
          shapeTypeDefinition.children[childKey] = buildTypeAnnotationDeclarationTypes(childValue);
        });
        return shapeTypeDefinition;
      case 'UnionTypeAnnotation':
        var unionTypeDefinition = {
          type: 'union',
          children: []
        };
        for (var i = 0, j = annotation.types.length; i < j; i++) {
          var type = buildTypeAnnotationDeclarationTypes(annotation.types[i]);
          if (type !== true) {
            if (type.children === true) {
              unionTypeDefinition.children = true;
              return unionTypeDefinition;
            }
          }

          unionTypeDefinition.children.push(type);
        }
        if (unionTypeDefinition.children.length === 0) {
          return true;
        }
        return unionTypeDefinition;
      case 'ArrayTypeAnnotation':
        return {
          type: 'object',
          children: {
            __ANY_KEY__: buildTypeAnnotationDeclarationTypes(annotation.elementType)
          }
        };
      default:
        return true;
    }
  }

  function inConstructor() {
    var scope = context.getScope();
    while (scope) {
      if (scope.block && scope.block.parent && scope.block.parent.kind === 'constructor') {
        return true;
      }
      scope = scope.upper;
    }
    return false;
  }

  function getPropertyName(node) {
    var isDirectProp = /^props(\.|\[)/.test(context.getSource(node));
    var isInClassComponent = utils.getParentES6Component() || utils.getParentES5Component();
    var isNotInConstructor = !inConstructor(node);
    if (isDirectProp && isInClassComponent && isNotInConstructor) {
      return void 0;
    }
    if (!isDirectProp) {
      node = node.parent;
    }
    var property = node.property;
    if (property) {
      switch (property.type) {
        case 'Identifier':
          if (node.computed) {
            return '__COMPUTED_PROP__';
          }
          return property.name;
        case 'MemberExpression':
          return void 0;
        case 'Literal':
          if (typeof property.value === 'string') {
            return property.value;
          }
        default:
          if (node.computed) {
            return '__COMPUTED_PROP__';
          }
          break;
      }
    }
    return void 0;
  }

  function markPropTypesAsUsed(node, parentNames) {
    parentNames = parentNames || [];
    var type;
    var name;
    var allNames;
    var properties;
    switch (node.type) {
      case 'MemberExpression':
        name = getPropertyName(node);
        if (name) {
          allNames = parentNames.concat(name);
          if (node.parent.type === 'MemberExpression') {
            markPropTypesAsUsed(node.parent, allNames);
          }
          type = name !== '__COMPUTED_PROP__' ? 'direct' : null;
        } else if (
          node.parent.id &&
          node.parent.id.properties &&
          node.parent.id.properties.length &&
          getKeyValue(node.parent.id.properties[0])
        ) {
          type = 'destructuring';
          properties = node.parent.id.properties;
        }
        break;
      case 'VariableDeclarator':
        for (var i = 0, j = node.id.properties.length; i < j; i++) {
          var thisDestructuring = (
            (node.id.properties[i].key.name === 'props' || node.id.properties[i].key.value === 'props') &&
            node.id.properties[i].value.type === 'ObjectPattern'
          );
          var statelessDestructuring = node.init.name === 'props' && utils.getParentStatelessComponent();

          if (thisDestructuring) {
            properties = node.id.properties[i].value.properties;
          } else if (statelessDestructuring) {
            properties = node.id.properties;
          } else {
            continue;
          }
          type = 'destructuring';
          break;
        }
        break;
      default:
        throw new Error(node.type + ' ASTNodes are not handled by markPropTypesAsUsed');
    }

    var component = components.get(utils.getParentComponent());
    var usedPropTypes = component && component.usedPropTypes || [];

    switch (type) {
      case 'direct':
        if (Object.prototype[name]) {
          break;
        }

        var isDirectProp = /^props(\.|\[)/.test(context.getSource(node));

        usedPropTypes.push({
          name: name,
          allNames: allNames,
          node: !isDirectProp && !inConstructor(node) ? node.parent.property : node.property
        });
        break;
      case 'destructuring':
        for (var k = 0, l = properties.length; k < l; k++) {
          if (hasSpreadOperator(properties[k]) || properties[k].computed) {
            continue;
          }
          var propName = getKeyValue(properties[k]);

          var currentNode = node;
          allNames = [];
          while (currentNode.property && currentNode.property.name !== 'props') {
            allNames.unshift(currentNode.property.name);
            currentNode = currentNode.object;
          }
          allNames.push(propName);

          if (propName) {
            usedPropTypes.push({
              name: propName,
              allNames: allNames,
              node: properties[k]
            });
          }
        }
        break;
      default:
        break;
    }

    components.set(node, {
      usedPropTypes: usedPropTypes
    });
  }

  function markPropTypesAsDeclared(node, propTypes) {
    var component = components.get(node);
    var declaredPropTypes = component && component.declaredPropTypes || {};
    var ignorePropsValidation = false;

    switch (propTypes && propTypes.type) {
      case 'ObjectTypeAnnotation':
        iterateProperties(propTypes.properties, function(key, value) {
          declaredPropTypes[key] = buildTypeAnnotationDeclarationTypes(value);
        });
        break;
      case 'ObjectExpression':
        iterateProperties(propTypes.properties, function(key, value) {
          if (!value) {
            ignorePropsValidation = true;
            return;
          }
          declaredPropTypes[key] = buildReactDeclarationTypes(value);
        });
        break;
      case 'MemberExpression':
        var curDeclaredPropTypes = declaredPropTypes;
        while (
          propTypes &&
          propTypes.parent &&
          propTypes.parent.type !== 'AssignmentExpression' &&
          propTypes.property &&
          curDeclaredPropTypes
        ) {
          var propName = propTypes.property.name;
          if (propName in curDeclaredPropTypes) {
            curDeclaredPropTypes = curDeclaredPropTypes[propName].children;
            propTypes = propTypes.parent;
          } else {
            propTypes = null;
          }
        }
        if (propTypes && propTypes.parent && propTypes.property) {
          curDeclaredPropTypes[propTypes.property.name] =
            buildReactDeclarationTypes(propTypes.parent.right);
        }
        break;
      case 'Identifier':
        var variablesInScope = variable.variablesInScope(context);
        for (var i = 0, j = variablesInScope.length; i < j; i++) {
          if (variablesInScope[i].name !== propTypes.name) {
            continue;
          }
          var defInScope = variablesInScope[i].defs[variablesInScope[i].defs.length - 1];
          markPropTypesAsDeclared(node, defInScope.node && defInScope.node.init);
          return;
        }
        ignorePropsValidation = true;
        break;
      case null:
        break;
      default:
        ignorePropsValidation = true;
        break;
    }

    components.set(node, {
      declaredPropTypes: declaredPropTypes,
      ignorePropsValidation: ignorePropsValidation
    });
  }

  function reportUndeclaredPropTypes(component) {
    var allNames;
    for (var i = 0, j = component.usedPropTypes.length; i < j; i++) {
      allNames = component.usedPropTypes[i].allNames;
      if (
        isIgnored(allNames[0]) ||
        isDeclaredInComponent(component.node, allNames)
      ) {
        continue;
      }
      context.report(
        component.usedPropTypes[i].node,
        MISSING_MESSAGE, {
          name: allNames.join('.').replace(/\.__COMPUTED_PROP__/g, '[]')
        }
      );
    }
  }

  function resolveTypeAnnotation(node) {
    var annotation = node.typeAnnotation || node;
    while (annotation && (annotation.type === 'TypeAnnotation' || annotation.type === 'NullableTypeAnnotation')) {
      annotation = annotation.typeAnnotation;
    }
    if (annotation.type === 'GenericTypeAnnotation' && typeScope(annotation.id.name)) {
      return typeScope(annotation.id.name);
    }
    return annotation;
  }

  return {
    /*ClassProperty*/Property: function(node) {
      if (node.kind == 'class' && isAnnotatedPropsDeclaration(node)) {
        markPropTypesAsDeclared(node, resolveTypeAnnotation(node));
      } else if (isPropTypesDeclaration(node)) {
        markPropTypesAsDeclared(node, node.value);
      }
    },

    VariableDeclarator: function(node) {
      var destructuring = node.init && node.id && node.id.type === 'ObjectPattern';
      var thisDestructuring = destructuring && node.init.type === 'ThisExpression';
      var statelessDestructuring = destructuring && node.init.name === 'props' && utils.getParentStatelessComponent();

      if (!thisDestructuring && !statelessDestructuring) {
        return;
      }
      markPropTypesAsUsed(node);
    },

    MemberExpression: function(node) {
      var type;
      if (isPropTypesUsage(node)) {
        type = 'usage';
      } else if (isPropTypesDeclaration(node.property)) {
        type = 'declaration';
      }

      switch (type) {
        case 'usage':
          markPropTypesAsUsed(node);
          break;
        case 'declaration':
          var component = utils.getRelatedComponent(node);
          if (!component) {
            return;
          }
          markPropTypesAsDeclared(component.node, node.parent.right || node.parent);
          break;
        default:
          break;
      }
    },

    MethodDefinition: function(node) {
      if (!isPropTypesDeclaration(node.key)) {
        return;
      }

      var i = node.value.body.body.length - 1;
      for (; i >= 0; i--) {
        if (node.value.body.body[i].type === 'ReturnStatement') {
          break;
        }
      }

      if (i >= 0) {
        markPropTypesAsDeclared(node, node.value.body.body[i].argument);
      }
    },

    ObjectExpression: function(node) {
      node.properties.forEach(function(property) {
        if (!isPropTypesDeclaration(property.key)) {
          return;
        }
        markPropTypesAsDeclared(node, property.value);
      });
    },

    TypeAlias: function(node) {
      typeScope(node.id.name, node.right);
    },

    Program: function() {
      stack = [{}];
    },

    BlockStatement: function () {
      stack.push(Object.create(typeScope()));
    },

    'BlockStatement:exit': function () {
      stack.pop();
    },

    'Program:exit': function() {
      stack = null;
      var list = components.list();
      for (var component in list) {
        if (!list.hasOwnProperty(component) || !mustBeValidated(list[component])) {
          continue;
        }
        reportUndeclaredPropTypes(list[component]);
      }
    }
  };

});

module.exports.schema = [{
  type: 'object',
  properties: {
    ignore: {
      type: 'array',
      items: {
        type: 'string'
      }
    },
    customValidators: {
      type: 'array',
      items: {
        type: 'string'
      }
    }
  },
  additionalProperties: false
}];

},
   {"../util/Components":"/node_modules/eslint-plugin-react/lib/util/Components.js","../util/variable":"/node_modules/eslint-plugin-react/lib/util/variable.js"}],

"/node_modules/eslint-plugin-react/lib/rules/react-in-jsx-scope.js": [function(require,module,exports){
'use strict';

var variableUtil = require('../util/variable');
var pragmaUtil = require('../util/pragma');

module.exports = function(context) {

  var pragma = pragmaUtil.getFromContext(context);
  var NOT_DEFINED_MESSAGE = '\'{{name}}\' must be in scope when using JSX';

  return {

    JSXOpeningElement: function(node) {
      var variables = variableUtil.variablesInScope(context);
      if (variableUtil.findVariable(variables, pragma)) {
        return;
      }
      context.report(node, NOT_DEFINED_MESSAGE, {
        name: pragma
      });
    },

    BlockComment: function(node) {
      pragma = pragmaUtil.getFromNode(node) || pragma;
    }

  };

};

module.exports.schema = [];

},
   {"../util/pragma":"/node_modules/eslint-plugin-react/lib/util/pragma.js","../util/variable":"/node_modules/eslint-plugin-react/lib/util/variable.js"}],

"/node_modules/eslint-plugin-react/lib/rules/require-extension.js": [function(require,module,exports){
'use strict';

var path = require('path');

var DEFAULTS = {
  extentions: ['.jsx']
};

var PKG_REGEX = /^[^\.]((?!\/).)*$/;

module.exports = function(context) {

  function isPackage(id) {
    return PKG_REGEX.test(id);
  }

  function isRequire(expression) {
    return expression.callee.name === 'require';
  }

  function getId(expression) {
    return expression.arguments[0] && expression.arguments[0].value;
  }

  function getExtension(id) {
    return path.extname(id || '');
  }

  function getExtentionsConfig() {
    return context.options[0] && context.options[0].extensions || DEFAULTS.extentions;
  }

  var forbiddenExtensions = getExtentionsConfig().reduce(function (extensions, extension) {
    extensions[extension] = true;
    return extensions;
  }, Object.create(null));

  function isForbiddenExtension(ext) {
    return ext in forbiddenExtensions;
  }

  return {

    CallExpression: function(node) {
      if (isRequire(node)) {
        var id = getId(node);
        var ext = getExtension(id);
        if (!isPackage(id) && isForbiddenExtension(ext)) {
          context.report(node, 'Unable to require module with extension \'' + ext + '\'');
        }
      }
    }

  };

};

module.exports.schema = [{
  type: 'object',
  properties: {
    extensions: {
      type: 'array',
      items: {
        type: 'string'
      }
    }
  },
  additionalProperties: false
}];

},
   {"path":"/node_modules/browserify/node_modules/path-browserify/index.js"}],

"/node_modules/eslint-plugin-react/lib/rules/self-closing-comp.js": [function(require,module,exports){
'use strict';

module.exports = function(context) {

  var tagConvention = /^[a-z]|\-/;
  function isTagName(name) {
    return tagConvention.test(name);
  }

  function isComponent(node) {
    return node.name && node.name.type === 'JSXIdentifier' && !isTagName(node.name.name);
  }

  function hasChildren(node) {
    var childrens = node.parent.children;
    if (
      !childrens.length ||
      (childrens.length === 1 && childrens[0].type === 'Literal' && !childrens[0].value.trim())
    ) {
      return false;
    }
    return true;
  }

  return {

    JSXOpeningElement: function(node) {
      if (!isComponent(node) || node.selfClosing || hasChildren(node)) {
        return;
      }
      context.report(node, 'Empty components are self-closing');
    }
  };

};

module.exports.schema = [];

},
   {}],

"/node_modules/eslint-plugin-react/lib/rules/sort-comp.js": [function(require,module,exports){
'use strict';

var util = require('util');

var Components = require('../util/Components');

function getMethodsOrder(defaultConfig, userConfig) {
  userConfig = userConfig || {};

  var groups = util._extend(defaultConfig.groups, userConfig.groups);
  var order = userConfig.order || defaultConfig.order;

  var config = [];
  var entry;
  for (var i = 0, j = order.length; i < j; i++) {
    entry = order[i];
    if (groups.hasOwnProperty(entry)) {
      config = config.concat(groups[entry]);
    } else {
      config.push(entry);
    }
  }

  return config;
}

module.exports = Components.detect(function(context, components) {

  var errors = {};

  var MISPOSITION_MESSAGE = '{{propA}} should be placed {{position}} {{propB}}';

  var methodsOrder = getMethodsOrder({
    order: [
      'lifecycle',
      'everything-else',
      'render'
    ],
    groups: {
      lifecycle: [
        'displayName',
        'propTypes',
        'contextTypes',
        'childContextTypes',
        'mixins',
        'statics',
        'defaultProps',
        'constructor',
        'getDefaultProps',
        'state',
        'getInitialState',
        'getChildContext',
        'componentWillMount',
        'componentDidMount',
        'componentWillReceiveProps',
        'shouldComponentUpdate',
        'componentWillUpdate',
        'componentDidUpdate',
        'componentWillUnmount'
      ]
    }
  }, context.options[0]);

  var regExpRegExp = /\/(.*)\/([g|y|i|m]*)/;

  function getRefPropIndexes(method) {
    var isRegExp;
    var matching;
    var i;
    var j;
    var indexes = [];
    for (i = 0, j = methodsOrder.length; i < j; i++) {
      isRegExp = methodsOrder[i].match(regExpRegExp);
      if (isRegExp) {
        matching = new RegExp(isRegExp[1], isRegExp[2]).test(method);
      } else {
        matching = methodsOrder[i] === method;
      }
      if (matching) {
        indexes.push(i);
      }
    }

    if (indexes.length === 0) {
      for (i = 0, j = methodsOrder.length; i < j; i++) {
        if (methodsOrder[i] === 'everything-else') {
          indexes.push(i);
        }
      }
    }

    if (indexes.length === 0) {
      indexes.push(Infinity);
    }

    return indexes;
  }

  function getPropertyName(node) {

    if (node.type === /*ClassProperty*/'Property' && node.kind == 'class') {
      var tokens = context.getFirstTokens(node, 2);
      return tokens[1] && tokens[1].type === 'Identifier' ? tokens[1].value : tokens[0].value;
    }

    return node.key.name;
  }

  function storeError(propA, propB) {
    if (!errors[propA.index]) {
      errors[propA.index] = {
        node: propA.node,
        score: 0,
        closest: {
          distance: Infinity,
          ref: {
            node: null,
            index: 0
          }
        }
      };
    }
    errors[propA.index].score++;
    if (Math.abs(propA.index - propB.index) > errors[propA.index].closest.distance) {
      return;
    }
    errors[propA.index].closest.distance = Math.abs(propA.index - propB.index);
    errors[propA.index].closest.ref.node = propB.node;
    errors[propA.index].closest.ref.index = propB.index;
  }

  function dedupeErrors() {
    for (var i in errors) {
      if (!errors.hasOwnProperty(i)) {
        continue;
      }
      var index = errors[i].closest.ref.index;
      if (!errors[index]) {
        continue;
      }
      if (errors[i].score > errors[index].score) {
        delete errors[index];
      } else {
        delete errors[i];
      }
    }
  }

  function reportErrors() {
    dedupeErrors();

    var nodeA;
    var nodeB;
    var indexA;
    var indexB;
    for (var i in errors) {
      if (!errors.hasOwnProperty(i)) {
        continue;
      }

      nodeA = errors[i].node;
      nodeB = errors[i].closest.ref.node;
      indexA = i;
      indexB = errors[i].closest.ref.index;

      context.report(nodeA, MISPOSITION_MESSAGE, {
        propA: getPropertyName(nodeA),
        propB: getPropertyName(nodeB),
        position: indexA < indexB ? 'before' : 'after'
      });
    }
  }

  function getComponentProperties(node) {
    switch (node.type) {
      case 'ClassDeclaration':
        return node.body.body;
      case 'ObjectExpression':
        return node.properties;
      default:
        return [];
    }
  }

  function comparePropsOrder(propertiesNames, propA, propB) {
    var i;
    var j;
    var k;
    var l;
    var refIndexA;
    var refIndexB;

    var refIndexesA = getRefPropIndexes(propA);
    var refIndexesB = getRefPropIndexes(propB);

    var classIndexA = propertiesNames.indexOf(propA);
    var classIndexB = propertiesNames.indexOf(propB);

    for (i = 0, j = refIndexesA.length; i < j; i++) {
      refIndexA = refIndexesA[i];

      for (k = 0, l = refIndexesB.length; k < l; k++) {
        refIndexB = refIndexesB[k];

        if (
          refIndexA === refIndexB ||
          refIndexA < refIndexB && classIndexA < classIndexB ||
          refIndexA > refIndexB && classIndexA > classIndexB
        ) {
          return {
            correct: true,
            indexA: classIndexA,
            indexB: classIndexB
          };
        }

      }
    }

    return {
      correct: false,
      indexA: refIndexA,
      indexB: refIndexB
    };
  }

  function checkPropsOrder(properties) {
    var propertiesNames = properties.map(getPropertyName);
    var i;
    var j;
    var k;
    var l;
    var propA;
    var propB;
    var order;

    for (i = 0, j = propertiesNames.length; i < j; i++) {
      propA = propertiesNames[i];

      for (k = 0, l = propertiesNames.length; k < l; k++) {
        propB = propertiesNames[k];

        order = comparePropsOrder(propertiesNames, propA, propB);

        if (order.correct === true) {
          continue;
        }

        storeError({
          node: properties[i],
          index: order.indexA
        }, {
          node: properties[k],
          index: order.indexB
        });
      }
    }

  }

  return {
    'Program:exit': function() {
      var list = components.list();
      for (var component in list) {
        if (!list.hasOwnProperty(component)) {
          continue;
        }
        var properties = getComponentProperties(list[component].node);
        checkPropsOrder(properties);
      }

      reportErrors();
    }
  };

});

module.exports.schema = [{
  type: 'object',
  properties: {
    order: {
      type: 'array',
      items: {
        type: 'string'
      }
    },
    groups: {
      type: 'object',
      patternProperties: {
        '^.*$': {
          type: 'array',
          items: {
            type: 'string'
          }
        }
      }
    }
  },
  additionalProperties: false
}];

},
   {"../util/Components":"/node_modules/eslint-plugin-react/lib/util/Components.js","util":"/node_modules/browserify/node_modules/util/util.js"}],

"/node_modules/eslint-plugin-react/lib/rules/wrap-multilines.js": [function(require,module,exports){
'use strict';

var DEFAULTS = {
  declaration: true,
  assignment: true,
  return: true
};

module.exports = function(context) {

  var sourceCode = context.getSourceCode();

  function isParenthesised(node) {
    var previousToken = context.getTokenBefore(node);
    var nextToken = context.getTokenAfter(node);

    return previousToken && nextToken &&
      previousToken.value === '(' && previousToken.range[1] <= node.range[0] &&
      nextToken.value === ')' && nextToken.range[0] >= node.range[1];
  }

  function isMultilines(node) {
    return node.loc.start.line !== node.loc.end.line;
  }

  function check(node) {
    if (!node || node.type !== 'JSXElement') {
      return;
    }

    if (!isParenthesised(node) && isMultilines(node)) {
      context.report({
        node: node,
        message: 'Missing parentheses around multilines JSX',
        fix: function(fixer) {
          return fixer.replaceText(node, '(' + sourceCode.getText(node) + ')');
        }
      });
    }
  }

  function isEnabled(type) {
    var userOptions = context.options[0] || {};
    if (({}).hasOwnProperty.call(userOptions, type)) {
      return userOptions[type];
    }
    return DEFAULTS[type];
  }

  return {

    VariableDeclarator: function(node) {
      if (isEnabled('declaration')) {
        check(node.init);
      }
    },

    AssignmentExpression: function(node) {
      if (isEnabled('assignment')) {
        check(node.right);
      }
    },

    ReturnStatement: function(node) {
      if (isEnabled('return')) {
        check(node.argument);
      }
    }
  };

};

module.exports.schema = [{
  type: 'object',
  properties: {
    declaration: {
      type: 'boolean'
    },
    assignment: {
      type: 'boolean'
    },
    return: {
      type: 'boolean'
    }
  },
  additionalProperties: false
}];

},
   {}],

"/node_modules/eslint-plugin-react/lib/util/Components.js": [function(require,module,exports){
'use strict';

var util = require('util');
var variableUtil = require('./variable');
var pragmaUtil = require('./pragma');

function Components() {
  this._list = {};
  this._getId = function(node) {
    return node && node.range.join(':');
  };
}

Components.prototype.add = function(node, confidence) {
  var id = this._getId(node);
  if (this._list[id]) {
    if (confidence === 0 || this._list[id].confidence === 0) {
      this._list[id].confidence = 0;
    } else {
      this._list[id].confidence = Math.max(this._list[id].confidence, confidence);
    }
    return;
  }
  this._list[id] = {
    node: node,
    confidence: confidence
  };
};

Components.prototype.get = function(node) {
  var id = this._getId(node);
  return this._list[id];
};

Components.prototype.set = function(node, props) {
  while (node && !this._list[this._getId(node)]) {
    node = node.parent;
  }
  if (!node) {
    return;
  }
  var id = this._getId(node);
  this._list[id] = util._extend(this._list[id], props);
};

Components.prototype.list = function() {
  var list = {};
  for (var i in this._list) {
    if (!this._list.hasOwnProperty(i) || this._list[i].confidence < 2) {
      continue;
    }
    list[i] = this._list[i];
  }
  return list;
};

Components.prototype.length = function() {
  var length = 0;
  for (var i in this._list) {
    if (!this._list.hasOwnProperty(i) || this._list[i].confidence < 2) {
      continue;
    }
    length++;
  }
  return length;
};

function componentRule(rule, context) {

  var pragma = pragmaUtil.getFromContext(context);
  var sourceCode = context.getSourceCode();
  var components = new Components();

  var utils = {

    isES5Component: function(node) {
      if (!node.parent) {
        return false;
      }
      return new RegExp('^(' + pragma + '\\.)?createClass$').test(sourceCode.getText(node.parent.callee));
    },

    isES6Component: function(node) {
      if (!node.superClass) {
        return false;
      }
      return new RegExp('^(' + pragma + '\\.)?Component$').test(sourceCode.getText(node.superClass));
    },

    isReturningJSX: function(node) {
      var property;
      switch (node.type) {
        case 'ReturnStatement':
          property = 'argument';
          break;
        case 'ArrowFunctionExpression':
          property = 'body';
          break;
        default:
          return false;
      }

      var returnsJSX =
        node[property] &&
        node[property].type === 'JSXElement'
      ;
      var returnsReactCreateElement =
        node[property] &&
        node[property].callee &&
        node[property].callee.property &&
        node[property].callee.property.name === 'createElement'
      ;

      return Boolean(returnsJSX || returnsReactCreateElement);
    },

    getParentComponent: function() {
      return (
        utils.getParentES6Component() ||
        utils.getParentES5Component() ||
        utils.getParentStatelessComponent()
      );
    },

    getParentES5Component: function() {
      var scope = context.getScope();
      while (scope) {
        var node = scope.block && scope.block.parent && scope.block.parent.parent;
        if (node && utils.isES5Component(node)) {
          return node;
        }
        scope = scope.upper;
      }
      return null;
    },

    getParentES6Component: function() {
      var scope = context.getScope();
      while (scope && scope.type !== 'class') {
        scope = scope.upper;
      }
      var node = scope && scope.block;
      if (!node || !utils.isES6Component(node)) {
        return null;
      }
      return node;
    },

    getParentStatelessComponent: function() {
      var scope = context.getScope();
      while (scope) {
        var node = scope.block;
        var isFunction = /Function/.test(node.type); // Ignore non functions
        var isNotMethod = !node.parent || node.parent.type !== 'MethodDefinition'; // Ignore classes methods
        var isNotArgument = !node.parent || node.parent.type !== 'CallExpression'; // Ignore arguments (callback, etc.)
        if (isFunction && isNotMethod && isNotArgument) {
          return node;
        }
        scope = scope.upper;
      }
      return null;
    },

    getRelatedComponent: function(node) {
      var i;
      var j;
      var k;
      var l;
      var componentPath = [];
      while (node) {
        if (node.property && node.property.type === 'Identifier') {
          componentPath.push(node.property.name);
        }
        if (node.object && node.object.type === 'Identifier') {
          componentPath.push(node.object.name);
        }
        node = node.object;
      }
      componentPath.reverse();

      var variableName = componentPath.shift();
      if (!variableName) {
        return null;
      }
      var variableInScope;
      var variables = variableUtil.variablesInScope(context);
      for (i = 0, j = variables.length; i < j; i++) {
        if (variables[i].name === variableName) {
          variableInScope = variables[i];
          break;
        }
      }
      if (!variableInScope) {
        return null;
      }

      var defInScope;
      var defs = variableInScope.defs;
      for (i = 0, j = defs.length; i < j; i++) {
        if (defs[i].type === 'ClassName' || defs[i].type === 'FunctionName' || defs[i].type === 'Variable') {
          defInScope = defs[i];
          break;
        }
      }
      if (!defInScope || !defInScope.node) {
        return null;
      }
      node = defInScope.node.init || defInScope.node;

      for (i = 0, j = componentPath.length; i < j; i++) {
        if (!node.properties) {
          continue;
        }
        for (k = 0, l = node.properties.length; k < l; k++) {
          if (node.properties[k].key.name === componentPath[i]) {
            node = node.properties[k];
            break;
          }
        }
        if (!node || !node.value) {
          return null;
        }
        node = node.value;
      }

      return components.get(node);
    }
  };

  var detectionInstructions = {
    ClassDeclaration: function(node) {
      if (!utils.isES6Component(node)) {
        return;
      }
      components.add(node, 2);
    },

    /*ClassProperty*/Property: function(node) {
      node = node.kind == 'class' && utils.getParentComponent();
      if (!node) {
        return;
      }
      components.add(node, 2);
    },

    ObjectExpression: function(node) {
      if (!utils.isES5Component(node)) {
        return;
      }
      components.add(node, 2);
    },

    FunctionExpression: function(node) {
      node = utils.getParentComponent();
      if (!node) {
        return;
      }
      components.add(node, 1);
    },

    FunctionDeclaration: function(node) {
      node = utils.getParentComponent();
      if (!node) {
        return;
      }
      components.add(node, 1);
    },

    ArrowFunctionExpression: function(node) {
      node = utils.getParentComponent();
      if (!node) {
        return;
      }
      if (node.expression && utils.isReturningJSX(node)) {
        components.add(node, 2);
      } else {
        components.add(node, 1);
      }
    },

    ThisExpression: function(node) {
      node = utils.getParentComponent();
      if (!node || !/Function/.test(node.type)) {
        return;
      }
      components.add(node, 0);
    },

    BlockComment: function(node) {
      pragma = pragmaUtil.getFromNode(node) || pragma;
    },

    ReturnStatement: function(node) {
      if (!utils.isReturningJSX(node)) {
        return;
      }
      node = utils.getParentComponent();
      if (!node) {
        return;
      }
      components.add(node, 2);
    }
  };

  var ruleInstructions = rule(context, components, utils);
  var updatedRuleInstructions = util._extend({}, ruleInstructions);
  Object.keys(detectionInstructions).forEach(function(instruction) {
    updatedRuleInstructions[instruction] = function(node) {
      detectionInstructions[instruction](node);
      return ruleInstructions[instruction] ? ruleInstructions[instruction](node) : void 0;
    };
  });
  return updatedRuleInstructions;
}

Components.detect = function(rule) {
  return componentRule.bind(this, rule);
};

module.exports = Components;

},
   {"./pragma":"/node_modules/eslint-plugin-react/lib/util/pragma.js","./variable":"/node_modules/eslint-plugin-react/lib/util/variable.js","util":"/node_modules/browserify/node_modules/util/util.js"}],

"/node_modules/eslint-plugin-react/lib/util/pragma.js": [function(require,module,exports){
'use strict';

var JSX_ANNOTATION_REGEX = /^\*\s*@jsx\s+([^\s]+)/;

function getFromContext(context) {
  var pragma = 'React';
  if (context.settings.react && context.settings.react.pragma) {
    pragma = context.settings.react.pragma;
  } else if (context.options[0] && context.options[0].pragma) {
    pragma = context.options[0].pragma;
  }
  return pragma.split('.')[0];
}

function getFromNode(node) {
  var matches = JSX_ANNOTATION_REGEX.exec(node.value);
  if (!matches) {
    return false;
  }
  return matches[1].split('.')[0];
}

module.exports = {
  getFromContext: getFromContext,
  getFromNode: getFromNode
};

},
   {}],

"/node_modules/eslint-plugin-react/lib/util/variable.js": [function(require,module,exports){
'use strict';

function markVariableAsUsed(context, name) {
  var scope = context.getScope();
  var variables;
  var i;
  var len;
  var found = false;

  if (scope.type === 'global') {
    while (scope.childScopes.length) {
      scope = scope.childScopes[0];
    }
  }

  do {
    variables = scope.variables;
    for (i = 0, len = variables.length; i < len; i++) {
      if (variables[i].name === name) {
        variables[i].eslintUsed = true;
        found = true;
      }
    }
    scope = scope.upper;
  } while (scope);

  return found;
}

function findVariable(variables, name) {
  var i;
  var len;

  for (i = 0, len = variables.length; i < len; i++) {
    if (variables[i].name === name) {
      return true;
    }
  }

  return false;
}

function variablesInScope(context) {
  var scope = context.getScope();
  var variables = scope.variables;

  while (scope.type !== 'global') {
    scope = scope.upper;
    variables = scope.variables.concat(variables);
  }
  if (scope.childScopes.length) {
    variables = scope.childScopes[0].variables.concat(variables);
    if (scope.childScopes[0].childScopes.length) {
      variables = scope.childScopes[0].childScopes[0].variables.concat(variables);
    }
  }

  return variables;
}

module.exports = {
  findVariable: findVariable,
  variablesInScope: variablesInScope,
  markVariableAsUsed: markVariableAsUsed
};

},
   {}],

"/node_modules/estraverse/estraverse.js": [function(require,module,exports){
(function clone(exports) {
    'use strict';

    var Syntax,
        isArray,
        VisitorOption,
        VisitorKeys,
        objectCreate,
        objectKeys,
        BREAK,
        SKIP,
        REMOVE;

    function ignoreJSHintError() { }

    isArray = Array.isArray;
    if (!isArray) {
        isArray = function isArray(array) {
            return Object.prototype.toString.call(array) === '[object Array]';
        };
    }

    function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                val = obj[key];
                if (typeof val === 'object' && val !== null) {
                    ret[key] = deepCopy(val);
                } else {
                    ret[key] = val;
                }
            }
        }
        return ret;
    }

    function shallowCopy(obj) {
        var ret = {}, key;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    ignoreJSHintError(shallowCopy);

    function upperBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                len = diff;
            } else {
                i = current + 1;
                len -= diff + 1;
            }
        }
        return i;
    }

    function lowerBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                i = current + 1;
                len -= diff + 1;
            } else {
                len = diff;
            }
        }
        return i;
    }
    ignoreJSHintError(lowerBound);

    objectCreate = Object.create || (function () {
        function F() { }

        return function (o) {
            F.prototype = o;
            return new F();
        };
    })();

    objectKeys = Object.keys || function (o) {
        var keys = [], key;
        for (key in o) {
            keys.push(key);
        }
        return keys;
    };

    function extend(to, from) {
        var keys = objectKeys(from), key, i, len;
        for (i = 0, len = keys.length; i < len; i += 1) {
            key = keys[i];
            to[key] = from[key];
        }
        return to;
    }

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        AssignmentPattern: 'AssignmentPattern',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExportAllDeclaration: 'ExportAllDeclaration',
        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
        ExportNamedDeclaration: 'ExportNamedDeclaration',
        ExportSpecifier: 'ExportSpecifier',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        ForOfStatement: 'ForOfStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        ImportDeclaration: 'ImportDeclaration',
        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
        ImportSpecifier: 'ImportSpecifier',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MetaProperty: 'MetaProperty',
        MethodDefinition: 'MethodDefinition',
        ModuleSpecifier: 'ModuleSpecifier',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        RestElement: 'RestElement',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SpreadElement: 'SpreadElement',
        Super: 'Super',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        TaggedTemplateExpression: 'TaggedTemplateExpression',
        TemplateElement: 'TemplateElement',
        TemplateLiteral: 'TemplateLiteral',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
    };

    VisitorKeys = {
        AssignmentExpression: ['left', 'right'],
        AssignmentPattern: ['left', 'right'],
        ArrayExpression: ['elements'],
        ArrayPattern: ['elements'],
        ArrowFunctionExpression: ['params', 'body'],
        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.
        BlockStatement: ['body'],
        BinaryExpression: ['left', 'right'],
        BreakStatement: ['label'],
        CallExpression: ['callee', 'arguments'],
        CatchClause: ['param', 'body'],
        ClassBody: ['body'],
        ClassDeclaration: ['id', 'superClass', 'body'],
        ClassExpression: ['id', 'superClass', 'body'],
        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        ConditionalExpression: ['test', 'consequent', 'alternate'],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ['body', 'test'],
        EmptyStatement: [],
        ExportAllDeclaration: ['source'],
        ExportDefaultDeclaration: ['declaration'],
        ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],
        ExportSpecifier: ['exported', 'local'],
        ExpressionStatement: ['expression'],
        ForStatement: ['init', 'test', 'update', 'body'],
        ForInStatement: ['left', 'right', 'body'],
        ForOfStatement: ['left', 'right', 'body'],
        FunctionDeclaration: ['id', 'params', 'body'],
        FunctionExpression: ['id', 'params', 'body'],
        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ['test', 'consequent', 'alternate'],
        ImportDeclaration: ['specifiers', 'source'],
        ImportDefaultSpecifier: ['local'],
        ImportNamespaceSpecifier: ['local'],
        ImportSpecifier: ['imported', 'local'],
        Literal: [],
        LabeledStatement: ['label', 'body'],
        LogicalExpression: ['left', 'right'],
        MemberExpression: ['object', 'property'],
        MetaProperty: ['meta', 'property'],
        MethodDefinition: ['key', 'value'],
        ModuleSpecifier: [],
        NewExpression: ['callee', 'arguments'],
        ObjectExpression: ['properties'],
        ObjectPattern: ['properties'],
        Program: ['body'],
        Property: ['key', 'value'],
        RestElement: [ 'argument' ],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SpreadElement: ['argument'],
        Super: [],
        SwitchStatement: ['discriminant', 'cases'],
        SwitchCase: ['test', 'consequent'],
        TaggedTemplateExpression: ['tag', 'quasi'],
        TemplateElement: [],
        TemplateLiteral: ['quasis', 'expressions'],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: ['block', 'handler', 'finalizer'],
        UnaryExpression: ['argument'],
        UpdateExpression: ['argument'],
        VariableDeclaration: ['declarations'],
        VariableDeclarator: ['id', 'init'],
        WhileStatement: ['test', 'body'],
        WithStatement: ['object', 'body'],
        YieldExpression: ['argument']
    };

    BREAK = {};
    SKIP = {};
    REMOVE = {};

    VisitorOption = {
        Break: BREAK,
        Skip: SKIP,
        Remove: REMOVE
    };

    function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
    }

    Reference.prototype.replace = function replace(node) {
        this.parent[this.key] = node;
    };

    Reference.prototype.remove = function remove() {
        if (isArray(this.parent)) {
            this.parent.splice(this.key, 1);
            return true;
        } else {
            this.replace(null);
            return false;
        }
    };

    function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
    }

    function Controller() { }

    Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;

        function addToPath(result, path) {
            if (isArray(path)) {
                for (j = 0, jz = path.length; j < jz; ++j) {
                    result.push(path[j]);
                }
            } else {
                result.push(path);
            }
        }

        if (!this.__current.path) {
            return null;
        }

        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
            element = this.__leavelist[i];
            addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
    };

    Controller.prototype.type = function () {
        var node = this.current();
        return node.type || this.__current.wrap;
    };

    Controller.prototype.parents = function parents() {
        var i, iz, result;

        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
            result.push(this.__leavelist[i].node);
        }

        return result;
    };

    Controller.prototype.current = function current() {
        return this.__current.node;
    };

    Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;

        result = undefined;

        previous  = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;

        return result;
    };

    Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
    };

    Controller.prototype.skip = function () {
        this.notify(SKIP);
    };

    Controller.prototype['break'] = function () {
        this.notify(BREAK);
    };

    Controller.prototype.remove = function () {
        this.notify(REMOVE);
    };

    Controller.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
        this.__fallback = visitor.fallback === 'iteration';
        this.__keys = VisitorKeys;
        if (visitor.keys) {
            this.__keys = extend(objectCreate(this.__keys), visitor.keys);
        }
    };

    function isNode(node) {
        if (node == null) {
            return false;
        }
        return typeof node === 'object' && typeof node.type === 'string';
    }

    function isProperty(nodeType, key) {
        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
    }

    Controller.prototype.traverse = function traverse(root, visitor) {
        var worklist,
            leavelist,
            element,
            node,
            nodeType,
            ret,
            key,
            current,
            current2,
            candidates,
            candidate,
            sentinel;

        this.__initialize(root, visitor);

        sentinel = {};

        worklist = this.__worklist;
        leavelist = this.__leavelist;

        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                ret = this.__execute(visitor.leave, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }
                continue;
            }

            if (element.node) {

                ret = this.__execute(visitor.enter, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }

                worklist.push(sentinel);
                leavelist.push(element);

                if (this.__state === SKIP || ret === SKIP) {
                    continue;
                }

                node = element.node;
                nodeType = node.type || element.wrap;
                candidates = this.__keys[nodeType];
                if (!candidates) {
                    if (this.__fallback) {
                        candidates = objectKeys(node);
                    } else {
                        throw new Error('Unknown node type ' + nodeType + '.');
                    }
                }

                current = candidates.length;
                while ((current -= 1) >= 0) {
                    key = candidates[current];
                    candidate = node[key];
                    if (!candidate) {
                        continue;
                    }

                    if (isArray(candidate)) {
                        current2 = candidate.length;
                        while ((current2 -= 1) >= 0) {
                            if (!candidate[current2]) {
                                continue;
                            }
                            if (isProperty(nodeType, candidates[current])) {
                                element = new Element(candidate[current2], [key, current2], 'Property', null);
                            } else if (isNode(candidate[current2])) {
                                element = new Element(candidate[current2], [key, current2], null, null);
                            } else {
                                continue;
                            }
                            worklist.push(element);
                        }
                    } else if (isNode(candidate)) {
                        worklist.push(new Element(candidate, key, null, null));
                    }
                }
            }
        }
    };

    Controller.prototype.replace = function replace(root, visitor) {
        function removeElem(element) {
            var i,
                key,
                nextElem,
                parent;

            if (element.ref.remove()) {
                key = element.ref.key;
                parent = element.ref.parent;

                i = worklist.length;
                while (i--) {
                    nextElem = worklist[i];
                    if (nextElem.ref && nextElem.ref.parent === parent) {
                        if  (nextElem.ref.key < key) {
                            break;
                        }
                        --nextElem.ref.key;
                    }
                }
            }
        }

        var worklist,
            leavelist,
            node,
            nodeType,
            target,
            element,
            current,
            current2,
            candidates,
            candidate,
            sentinel,
            outer,
            key;

        this.__initialize(root, visitor);

        sentinel = {};

        worklist = this.__worklist;
        leavelist = this.__leavelist;

        outer = {
            root: root
        };
        element = new Element(root, null, null, new Reference(outer, 'root'));
        worklist.push(element);
        leavelist.push(element);

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                target = this.__execute(visitor.leave, element);

                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                    element.ref.replace(target);
                }

                if (this.__state === REMOVE || target === REMOVE) {
                    removeElem(element);
                }

                if (this.__state === BREAK || target === BREAK) {
                    return outer.root;
                }
                continue;
            }

            target = this.__execute(visitor.enter, element);

            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
                element.ref.replace(target);
                element.node = target;
            }

            if (this.__state === REMOVE || target === REMOVE) {
                removeElem(element);
                element.node = null;
            }

            if (this.__state === BREAK || target === BREAK) {
                return outer.root;
            }

            node = element.node;
            if (!node) {
                continue;
            }

            worklist.push(sentinel);
            leavelist.push(element);

            if (this.__state === SKIP || target === SKIP) {
                continue;
            }

            nodeType = node.type || element.wrap;
            candidates = this.__keys[nodeType];
            if (!candidates) {
                if (this.__fallback) {
                    candidates = objectKeys(node);
                } else {
                    throw new Error('Unknown node type ' + nodeType + '.');
                }
            }

            current = candidates.length;
            while ((current -= 1) >= 0) {
                key = candidates[current];
                candidate = node[key];
                if (!candidate) {
                    continue;
                }

                if (isArray(candidate)) {
                    current2 = candidate.length;
                    while ((current2 -= 1) >= 0) {
                        if (!candidate[current2]) {
                            continue;
                        }
                        if (isProperty(nodeType, candidates[current])) {
                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
                        } else if (isNode(candidate[current2])) {
                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                        } else {
                            continue;
                        }
                        worklist.push(element);
                    }
                } else if (isNode(candidate)) {
                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));
                }
            }
        }

        return outer.root;
    };

    function traverse(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
    }

    function replace(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
    }

    function extendCommentRange(comment, tokens) {
        var target;

        target = upperBound(tokens, function search(token) {
            return token.range[0] > comment.range[0];
        });

        comment.extendedRange = [comment.range[0], comment.range[1]];

        if (target !== tokens.length) {
            comment.extendedRange[1] = tokens[target].range[0];
        }

        target -= 1;
        if (target >= 0) {
            comment.extendedRange[0] = tokens[target].range[1];
        }

        return comment;
    }

    function attachComments(tree, providedComments, tokens) {
        var comments = [], comment, len, i, cursor;

        if (!tree.range) {
            throw new Error('attachComments needs range information');
        }

        if (!tokens.length) {
            if (providedComments.length) {
                for (i = 0, len = providedComments.length; i < len; i += 1) {
                    comment = deepCopy(providedComments[i]);
                    comment.extendedRange = [0, tree.range[0]];
                    comments.push(comment);
                }
                tree.leadingComments = comments;
            }
            return tree;
        }

        for (i = 0, len = providedComments.length; i < len; i += 1) {
            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }

        cursor = 0;
        traverse(tree, {
            enter: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (comment.extendedRange[1] > node.range[0]) {
                        break;
                    }

                    if (comment.extendedRange[1] === node.range[0]) {
                        if (!node.leadingComments) {
                            node.leadingComments = [];
                        }
                        node.leadingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        cursor = 0;
        traverse(tree, {
            leave: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (node.range[1] < comment.extendedRange[0]) {
                        break;
                    }

                    if (node.range[1] === comment.extendedRange[0]) {
                        if (!node.trailingComments) {
                            node.trailingComments = [];
                        }
                        node.trailingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        return tree;
    }

    exports.version = require('./package.json').version;
    exports.Syntax = Syntax;
    exports.traverse = traverse;
    exports.replace = replace;
    exports.attachComments = attachComments;
    exports.VisitorKeys = VisitorKeys;
    exports.VisitorOption = VisitorOption;
    exports.Controller = Controller;
    exports.cloneEnvironment = function () { return clone({}); };

    return exports;
}(exports));

},
   {"./package.json":"/node_modules/estraverse/package.json"}],

"/node_modules/estraverse/package.json": [function(require,module,exports){
module.exports={
  "name": "estraverse",
  "description": "ECMAScript JS AST traversal functions",
  "homepage": "https://github.com/estools/estraverse",
  "main": "estraverse.js",
  "version": "4.1.1",
  "engines": {
    "node": ">=0.10.0"
  },
  "maintainers": [
    {
      "name": "constellation",
      "email": "utatane.tea@gmail.com"
    },
    {
      "name": "michaelficarra",
      "email": "npm@michael.ficarra.me"
    },
    {
      "name": "nzakas",
      "email": "nicholas@nczconsulting.com"
    }
  ],
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/estools/estraverse.git"
  },
  "devDependencies": {
    "chai": "^2.1.1",
    "coffee-script": "^1.8.0",
    "espree": "^1.11.0",
    "gulp": "^3.8.10",
    "gulp-bump": "^0.2.2",
    "gulp-filter": "^2.0.0",
    "gulp-git": "^1.0.1",
    "gulp-tag-version": "^1.2.1",
    "jshint": "^2.5.6",
    "mocha": "^2.1.0"
  },
  "license": "BSD-2-Clause",
  "scripts": {
    "test": "npm run-script lint && npm run-script unit-test",
    "lint": "jshint estraverse.js",
    "unit-test": "mocha --compilers coffee:coffee-script/register"
  },
  "gitHead": "bbcccbfe98296585e4311c8755e1d00dcd581e3c",
  "bugs": {
    "url": "https://github.com/estools/estraverse/issues"
  },
  "_id": "estraverse@4.1.1",
  "_shasum": "f6caca728933a850ef90661d0e17982ba47111a2",
  "_from": "estraverse@>=4.1.1 <5.0.0",
  "_npmVersion": "2.14.4",
  "_nodeVersion": "4.1.1",
  "_npmUser": {
    "name": "constellation",
    "email": "utatane.tea@gmail.com"
  },
  "dist": {
    "shasum": "f6caca728933a850ef90661d0e17982ba47111a2",
    "tarball": "http://registry.npmjs.org/estraverse/-/estraverse-4.1.1.tgz"
  },
  "directories": {},
  "_resolved": "https://registry.npmjs.org/estraverse/-/estraverse-4.1.1.tgz",
  "readme": "ERROR: No README data found!"
}

},
   {}],

"/node_modules/esutils/lib/ast.js": [function(require,module,exports){
arguments[4]["/node_modules/doctrine/node_modules/esutils/lib/ast.js"][0].apply(exports,arguments)
},
   {}],

"/node_modules/esutils/lib/code.js": [function(require,module,exports){
(function () {
    'use strict';

    var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;

    ES5Regex = {
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
    };

    ES6Regex = {
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    };

    function isDecimalDigit(ch) {
        return 0x30 <= ch && ch <= 0x39;  // 0..9
    }

    function isHexDigit(ch) {
        return 0x30 <= ch && ch <= 0x39 ||  // 0..9
            0x61 <= ch && ch <= 0x66 ||     // a..f
            0x41 <= ch && ch <= 0x46;       // A..F
    }

    function isOctalDigit(ch) {
        return ch >= 0x30 && ch <= 0x37;  // 0..7
    }

    NON_ASCII_WHITESPACES = [
        0x1680, 0x180E,
        0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,
        0x202F, 0x205F,
        0x3000,
        0xFEFF
    ];

    function isWhiteSpace(ch) {
        return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 ||
            ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
    }

    function isLineTerminator(ch) {
        return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
    }

    function fromCodePoint(cp) {
        if (cp <= 0xFFFF) { return String.fromCharCode(cp); }
        var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
        var cu2 = String.fromCharCode(((cp - 0x10000) % 0x400) + 0xDC00);
        return cu1 + cu2;
    }

    IDENTIFIER_START = new Array(0x80);
    for(ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_START[ch] =
            ch >= 0x61 && ch <= 0x7A ||  // a..z
            ch >= 0x41 && ch <= 0x5A ||  // A..Z
            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
    }

    IDENTIFIER_PART = new Array(0x80);
    for(ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_PART[ch] =
            ch >= 0x61 && ch <= 0x7A ||  // a..z
            ch >= 0x41 && ch <= 0x5A ||  // A..Z
            ch >= 0x30 && ch <= 0x39 ||  // 0..9
            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
    }

    function isIdentifierStartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
    }

    function isIdentifierPartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
    }

    function isIdentifierStartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
    }

    function isIdentifierPartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
    }

    module.exports = {
        isDecimalDigit: isDecimalDigit,
        isHexDigit: isHexDigit,
        isOctalDigit: isOctalDigit,
        isWhiteSpace: isWhiteSpace,
        isLineTerminator: isLineTerminator,
        isIdentifierStartES5: isIdentifierStartES5,
        isIdentifierPartES5: isIdentifierPartES5,
        isIdentifierStartES6: isIdentifierStartES6,
        isIdentifierPartES6: isIdentifierPartES6
    };
}());

},
   {}],

"/node_modules/esutils/lib/keyword.js": [function(require,module,exports){
(function () {
    'use strict';

    var code = require('./code');

    function isStrictModeReservedWordES6(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isKeywordES5(id, strict) {
        if (!strict && id === 'yield') {
            return false;
        }
        return isKeywordES6(id, strict);
    }

    function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
            return true;
        }

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    function isReservedWordES5(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
    }

    function isReservedWordES6(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    function isIdentifierNameES5(id) {
        var i, iz, ch;

        if (id.length === 0) { return false; }

        ch = id.charCodeAt(0);
        if (!code.isIdentifierStartES5(ch)) {
            return false;
        }

        for (i = 1, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (!code.isIdentifierPartES5(ch)) {
                return false;
            }
        }
        return true;
    }

    function decodeUtf16(lead, trail) {
        return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
    }

    function isIdentifierNameES6(id) {
        var i, iz, ch, lowCh, check;

        if (id.length === 0) { return false; }

        check = code.isIdentifierStartES6;
        for (i = 0, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (0xD800 <= ch && ch <= 0xDBFF) {
                ++i;
                if (i >= iz) { return false; }
                lowCh = id.charCodeAt(i);
                if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
                    return false;
                }
                ch = decodeUtf16(ch, lowCh);
            }
            if (!check(ch)) {
                return false;
            }
            check = code.isIdentifierPartES6;
        }
        return true;
    }

    function isIdentifierES5(id, strict) {
        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
    }

    function isIdentifierES6(id, strict) {
        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
    }

    module.exports = {
        isKeywordES5: isKeywordES5,
        isKeywordES6: isKeywordES6,
        isReservedWordES5: isReservedWordES5,
        isReservedWordES6: isReservedWordES6,
        isRestrictedWord: isRestrictedWord,
        isIdentifierNameES5: isIdentifierNameES5,
        isIdentifierNameES6: isIdentifierNameES6,
        isIdentifierES5: isIdentifierES5,
        isIdentifierES6: isIdentifierES6
    };
}());

},
   {"./code":"/node_modules/esutils/lib/code.js"}],

"/node_modules/esutils/lib/utils.js": [function(require,module,exports){
arguments[4]["/node_modules/doctrine/node_modules/esutils/lib/utils.js"][0].apply(exports,arguments)
},
   {"./ast":"/node_modules/esutils/lib/ast.js","./code":"/node_modules/esutils/lib/code.js","./keyword":"/node_modules/esutils/lib/keyword.js"}],

"/node_modules/globals/globals.json": [function(require,module,exports){
module.exports={
	"builtin": {
		"Array": false,
		"ArrayBuffer": false,
		"Boolean": false,
		"constructor": false,
		"DataView": false,
		"Date": false,
		"decodeURI": false,
		"decodeURIComponent": false,
		"encodeURI": false,
		"encodeURIComponent": false,
		"Error": false,
		"escape": false,
		"eval": false,
		"EvalError": false,
		"Float32Array": false,
		"Float64Array": false,
		"Function": false,
		"hasOwnProperty": false,
		"Infinity": false,
		"Int16Array": false,
		"Int32Array": false,
		"Int8Array": false,
		"isFinite": false,
		"isNaN": false,
		"isPrototypeOf": false,
		"JSON": false,
		"Map": false,
		"Math": false,
		"NaN": false,
		"Number": false,
		"Object": false,
		"parseFloat": false,
		"parseInt": false,
		"Promise": false,
		"propertyIsEnumerable": false,
		"Proxy": false,
		"RangeError": false,
		"ReferenceError": false,
		"Reflect": false,
		"RegExp": false,
		"Set": false,
		"String": false,
		"Symbol": false,
		"SyntaxError": false,
		"System": false,
		// "toLocaleString": false,
		// "toString": false,
		"TypeError": false,
		"Uint16Array": false,
		"Uint32Array": false,
		"Uint8Array": false,
		"Uint8ClampedArray": false,
		"undefined": false,
		"unescape": false,
		"URIError": false,
		"valueOf": false,
		"WeakMap": false,
		"WeakSet": false
	},
	"es5": {
		"Array": false,
		"Boolean": false,
		"constructor": false,
		"Date": false,
		"decodeURI": false,
		"decodeURIComponent": false,
		"encodeURI": false,
		"encodeURIComponent": false,
		"Error": false,
		"escape": false,
		"eval": false,
		"EvalError": false,
		"Float32Array": false,
		"Float64Array": false,
		"Function": false,
		"hasOwnProperty": false,
		"Infinity": false,
		"isFinite": false,
		"isNaN": false,
		"isPrototypeOf": false,
		"JSON": false,
		"Math": false,
		"NaN": false,
		"Number": false,
		"Object": false,
		"parseFloat": false,
		"parseInt": false,
		"propertyIsEnumerable": false,
		"RangeError": false,
		"ReferenceError": false,
		"RegExp": false,
		"String": false,
		"SyntaxError": false,
		"toLocaleString": false,
		"toString": false,
		"TypeError": false,
		"undefined": false,
		"unescape": false,
		"URIError": false,
		"valueOf": false
	},
	"es6": {
		"Array": false,
		"ArrayBuffer": false,
		"Boolean": false,
		"constructor": false,
		"DataView": false,
		"Date": false,
		"decodeURI": false,
		"decodeURIComponent": false,
		"encodeURI": false,
		"encodeURIComponent": false,
		"Error": false,
		"escape": false,
		"eval": false,
		"EvalError": false,
		"Float32Array": false,
		"Float64Array": false,
		"Function": false,
		"hasOwnProperty": false,
		"Infinity": false,
		"Int16Array": false,
		"Int32Array": false,
		"Int8Array": false,
		"isFinite": false,
		"isNaN": false,
		"isPrototypeOf": false,
		"JSON": false,
		"Map": false,
		"Math": false,
		"NaN": false,
		"Number": false,
		"Object": false,
		"parseFloat": false,
		"parseInt": false,
		"Promise": false,
		"propertyIsEnumerable": false,
		"Proxy": false,
		"RangeError": false,
		"ReferenceError": false,
		"Reflect": false,
		"RegExp": false,
		"Set": false,
		"String": false,
		"Symbol": false,
		"SyntaxError": false,
		"System": false,
		"toLocaleString": false,
		"toString": false,
		"TypeError": false,
		"Uint16Array": false,
		"Uint32Array": false,
		"Uint8Array": false,
		"Uint8ClampedArray": false,
		"undefined": false,
		"unescape": false,
		"URIError": false,
		"valueOf": false,
		"WeakMap": false,
		"WeakSet": false
	},
	"browser": {
		"addEventListener": false,
		"alert": false,
		"AnalyserNode": false,
		"AnimationEvent": false,
		"applicationCache": false,
		"ApplicationCache": false,
		"ApplicationCacheErrorEvent": false,
		"atob": false,
		"Attr": false,
		"Audio": false,
		"AudioBuffer": false,
		"AudioBufferSourceNode": false,
		"AudioContext": false,
		"AudioDestinationNode": false,
		"AudioListener": false,
		"AudioNode": false,
		"AudioParam": false,
		"AudioProcessingEvent": false,
		"AutocompleteErrorEvent": false,
		"BarProp": false,
		"BatteryManager": false,
		"BeforeUnloadEvent": false,
		"BiquadFilterNode": false,
		"Blob": false,
		"blur": false,
		"btoa": false,
		"Cache": false,
		"caches": false,
		"CacheStorage": false,
		"cancelAnimationFrame": false,
		"CanvasGradient": false,
		"CanvasPattern": false,
		"CanvasRenderingContext2D": false,
		"CDATASection": false,
		"ChannelMergerNode": false,
		"ChannelSplitterNode": false,
		"CharacterData": false,
		"clearInterval": false,
		"clearTimeout": false,
		"clientInformation": false,
		"ClientRect": false,
		"ClientRectList": false,
		"ClipboardEvent": false,
		// "close": false,
		// "closed": false,
		"CloseEvent": false,
		"Comment": false,
		"CompositionEvent": false,
		"confirm": false,
		"console": false,
		"ConvolverNode": false,
		"crypto": false,
		"Crypto": false,
		"CryptoKey": false,
		"CSS": false,
		"CSSFontFaceRule": false,
		"CSSImportRule": false,
		"CSSKeyframeRule": false,
		"CSSKeyframesRule": false,
		"CSSMediaRule": false,
		"CSSPageRule": false,
		"CSSRule": false,
		"CSSRuleList": false,
		"CSSStyleDeclaration": false,
		"CSSStyleRule": false,
		"CSSStyleSheet": false,
		"CSSSupportsRule": false,
		"CSSUnknownRule": false,
		"CSSViewportRule": false,
		"CustomEvent": false,
		"DataTransfer": false,
		"DataTransferItem": false,
		"DataTransferItemList": false,
		"Debug": false,
		"defaultStatus": false,
		"defaultstatus": false,
		"DelayNode": false,
		"DeviceMotionEvent": false,
		"DeviceOrientationEvent": false,
		"devicePixelRatio": false,
		"dispatchEvent": false,
		"document": false,
		"Document": false,
		"DocumentFragment": false,
		"DocumentType": false,
		"DOMError": false,
		"DOMException": false,
		"DOMImplementation": false,
		"DOMParser": false,
		"DOMSettableTokenList": false,
		"DOMStringList": false,
		"DOMStringMap": false,
		"DOMTokenList": false,
		"DragEvent": false,
		"DynamicsCompressorNode": false,
		"Element": false,
		"ElementTimeControl": false,
		"ErrorEvent": false,
		"event": false,
		"Event": false,
		"EventSource": false,
		"EventTarget": false,
		"external": false,
		"fetch": false,
		"File": false,
		"FileError": false,
		"FileList": false,
		"FileReader": false,
		// "find": false,
		// "focus": false,
		"FocusEvent": false,
		"FontFace": false,
		"FormData": false,
		"frameElement": false,
		"frames": false,
		"GainNode": false,
		"Gamepad": false,
		"GamepadButton": false,
		"GamepadEvent": false,
		"getComputedStyle": false,
		"getSelection": false,
		"HashChangeEvent": false,
		"Headers": false,
		// "history": false,
		"History": false,
		"HTMLAllCollection": false,
		"HTMLAnchorElement": false,
		"HTMLAppletElement": false,
		"HTMLAreaElement": false,
		"HTMLAudioElement": false,
		"HTMLBaseElement": false,
		"HTMLBlockquoteElement": false,
		"HTMLBodyElement": false,
		"HTMLBRElement": false,
		"HTMLButtonElement": false,
		"HTMLCanvasElement": false,
		"HTMLCollection": false,
		"HTMLContentElement": false,
		"HTMLDataListElement": false,
		"HTMLDetailsElement": false,
		"HTMLDialogElement": false,
		"HTMLDirectoryElement": false,
		"HTMLDivElement": false,
		"HTMLDListElement": false,
		"HTMLDocument": false,
		"HTMLElement": false,
		"HTMLEmbedElement": false,
		"HTMLFieldSetElement": false,
		"HTMLFontElement": false,
		"HTMLFormControlsCollection": false,
		"HTMLFormElement": false,
		"HTMLFrameElement": false,
		"HTMLFrameSetElement": false,
		"HTMLHeadElement": false,
		"HTMLHeadingElement": false,
		"HTMLHRElement": false,
		"HTMLHtmlElement": false,
		"HTMLIFrameElement": false,
		"HTMLImageElement": false,
		"HTMLInputElement": false,
		"HTMLIsIndexElement": false,
		"HTMLKeygenElement": false,
		"HTMLLabelElement": false,
		"HTMLLayerElement": false,
		"HTMLLegendElement": false,
		"HTMLLIElement": false,
		"HTMLLinkElement": false,
		"HTMLMapElement": false,
		"HTMLMarqueeElement": false,
		"HTMLMediaElement": false,
		"HTMLMenuElement": false,
		"HTMLMetaElement": false,
		"HTMLMeterElement": false,
		"HTMLModElement": false,
		"HTMLObjectElement": false,
		"HTMLOListElement": false,
		"HTMLOptGroupElement": false,
		"HTMLOptionElement": false,
		"HTMLOptionsCollection": false,
		"HTMLOutputElement": false,
		"HTMLParagraphElement": false,
		"HTMLParamElement": false,
		"HTMLPictureElement": false,
		"HTMLPreElement": false,
		"HTMLProgressElement": false,
		"HTMLQuoteElement": false,
		"HTMLScriptElement": false,
		"HTMLSelectElement": false,
		"HTMLShadowElement": false,
		"HTMLSourceElement": false,
		"HTMLSpanElement": false,
		"HTMLStyleElement": false,
		"HTMLTableCaptionElement": false,
		"HTMLTableCellElement": false,
		"HTMLTableColElement": false,
		"HTMLTableElement": false,
		"HTMLTableRowElement": false,
		"HTMLTableSectionElement": false,
		"HTMLTemplateElement": false,
		"HTMLTextAreaElement": false,
		"HTMLTitleElement": false,
		"HTMLTrackElement": false,
		"HTMLUListElement": false,
		"HTMLUnknownElement": false,
		"HTMLVideoElement": false,
		"IDBCursor": false,
		"IDBCursorWithValue": false,
		"IDBDatabase": false,
		"IDBEnvironment": false,
		"IDBFactory": false,
		"IDBIndex": false,
		"IDBKeyRange": false,
		"IDBObjectStore": false,
		"IDBOpenDBRequest": false,
		"IDBRequest": false,
		"IDBTransaction": false,
		"IDBVersionChangeEvent": false,
		"Image": false,
		"ImageBitmap": false,
		"ImageData": false,
		"indexedDB": false,
		"innerHeight": false,
		"innerWidth": false,
		"InputEvent": false,
		"InputMethodContext": false,
		"Intl": false,
		"KeyboardEvent": false,
		"length": false,
		"localStorage": false,
		"location": false,
		"Location": false,
		"locationbar": false,
		"matchMedia": false,
		"MediaElementAudioSourceNode": false,
		"MediaEncryptedEvent": false,
		"MediaError": false,
		"MediaKeyError": false,
		"MediaKeyEvent": false,
		"MediaKeyMessageEvent": false,
		"MediaKeys": false,
		"MediaKeySession": false,
		"MediaKeyStatusMap": false,
		"MediaKeySystemAccess": false,
		"MediaList": false,
		"MediaQueryList": false,
		"MediaQueryListEvent": false,
		"MediaSource": false,
		"MediaStreamAudioDestinationNode": false,
		"MediaStreamAudioSourceNode": false,
		"MediaStreamEvent": false,
		"MediaStreamTrack": false,
		"menubar": false,
		"MessageChannel": false,
		"MessageEvent": false,
		"MessagePort": false,
		"MIDIAccess": false,
		"MIDIConnectionEvent": false,
		"MIDIInput": false,
		"MIDIInputMap": false,
		"MIDIMessageEvent": false,
		"MIDIOutput": false,
		"MIDIOutputMap": false,
		"MIDIPort": false,
		"MimeType": false,
		"MimeTypeArray": false,
		"MouseEvent": false,
		// "moveBy": false,
		// "moveTo": false,
		"MutationEvent": false,
		"MutationObserver": false,
		"MutationRecord": false,
		"NamedNodeMap": false,
		"navigator": false,
		"Navigator": false,
		"Node": false,
		"NodeFilter": false,
		"NodeIterator": false,
		"NodeList": false,
		"Notification": false,
		"OfflineAudioCompletionEvent": false,
		"OfflineAudioContext": false,
		"offscreenBuffering": false,
		"onbeforeunload": true,
		"onblur": true,
		"onerror": true,
		"onfocus": true,
		"onload": true,
		"onresize": true,
		"onunload": true,
		// "open": false,
		"openDatabase": false,
		// "opener": false,
		// "opera": false,
		"Option": false,
		"OscillatorNode": false,
		// "outerHeight": false,
		// "outerWidth": false,
		"PageTransitionEvent": false,
		"pageXOffset": false,
		"pageYOffset": false,
		// "parent": false,
		"Path2D": false,
		"performance": false,
		"Performance": false,
		"PerformanceEntry": false,
		"PerformanceMark": false,
		"PerformanceMeasure": false,
		"PerformanceNavigation": false,
		"PerformanceResourceTiming": false,
		"PerformanceTiming": false,
		"PeriodicWave": false,
		"Permissions": false,
		"PermissionStatus": false,
		"personalbar": false,
		"Plugin": false,
		"PluginArray": false,
		"PopStateEvent": false,
		"postMessage": false,
		// "print": false,
		"ProcessingInstruction": false,
		"ProgressEvent": false,
		"prompt": false,
		"PushManager": false,
		"PushSubscription": false,
		"RadioNodeList": false,
		"Range": false,
		"ReadableByteStream": false,
		"ReadableStream": false,
		"removeEventListener": false,
		"Request": false,
		"requestAnimationFrame": false,
		// "resizeBy": false,
		// "resizeTo": false,
		"Response": false,
		"RTCIceCandidate": false,
		"RTCSessionDescription": false,
		// "screen": false,
		"Screen": false,
		// "screenLeft": false,
		"ScreenOrientation": false,
		// "screenTop": false,
		// "screenX": false,
		// "screenY": false,
		"ScriptProcessorNode": false,
		// "scroll": false,
		// "scrollbars": false,
		// "scrollBy": false,
		// "scrollTo": false,
		// "scrollX": false,
		// "scrollY": false,
		"SecurityPolicyViolationEvent": false,
		"Selection": false,
		// "self": false,
		"ServiceWorker": false,
		"ServiceWorkerContainer": false,
		"ServiceWorkerRegistration": false,
		"sessionStorage": false,
		"setInterval": false,
		"setTimeout": false,
		"ShadowRoot": false,
		"SharedWorker": false,
		"showModalDialog": false,
		"speechSynthesis": false,
		"SpeechSynthesisEvent": false,
		"SpeechSynthesisUtterance": false,
		// "status": false,
		// "statusbar": false,
		// "stop": false,
		"Storage": false,
		"StorageEvent": false,
		"styleMedia": false,
		"StyleSheet": false,
		"StyleSheetList": false,
		"SubtleCrypto": false,
		"SVGAElement": false,
		"SVGAltGlyphDefElement": false,
		"SVGAltGlyphElement": false,
		"SVGAltGlyphItemElement": false,
		"SVGAngle": false,
		"SVGAnimateColorElement": false,
		"SVGAnimatedAngle": false,
		"SVGAnimatedBoolean": false,
		"SVGAnimatedEnumeration": false,
		"SVGAnimatedInteger": false,
		"SVGAnimatedLength": false,
		"SVGAnimatedLengthList": false,
		"SVGAnimatedNumber": false,
		"SVGAnimatedNumberList": false,
		"SVGAnimatedPathData": false,
		"SVGAnimatedPoints": false,
		"SVGAnimatedPreserveAspectRatio": false,
		"SVGAnimatedRect": false,
		"SVGAnimatedString": false,
		"SVGAnimatedTransformList": false,
		"SVGAnimateElement": false,
		"SVGAnimateMotionElement": false,
		"SVGAnimateTransformElement": false,
		"SVGAnimationElement": false,
		"SVGCircleElement": false,
		"SVGClipPathElement": false,
		"SVGColor": false,
		"SVGColorProfileElement": false,
		"SVGColorProfileRule": false,
		"SVGComponentTransferFunctionElement": false,
		"SVGCSSRule": false,
		"SVGCursorElement": false,
		"SVGDefsElement": false,
		"SVGDescElement": false,
		"SVGDiscardElement": false,
		"SVGDocument": false,
		"SVGElement": false,
		"SVGElementInstance": false,
		"SVGElementInstanceList": false,
		"SVGEllipseElement": false,
		"SVGEvent": false,
		"SVGExternalResourcesRequired": false,
		"SVGFEBlendElement": false,
		"SVGFEColorMatrixElement": false,
		"SVGFEComponentTransferElement": false,
		"SVGFECompositeElement": false,
		"SVGFEConvolveMatrixElement": false,
		"SVGFEDiffuseLightingElement": false,
		"SVGFEDisplacementMapElement": false,
		"SVGFEDistantLightElement": false,
		"SVGFEDropShadowElement": false,
		"SVGFEFloodElement": false,
		"SVGFEFuncAElement": false,
		"SVGFEFuncBElement": false,
		"SVGFEFuncGElement": false,
		"SVGFEFuncRElement": false,
		"SVGFEGaussianBlurElement": false,
		"SVGFEImageElement": false,
		"SVGFEMergeElement": false,
		"SVGFEMergeNodeElement": false,
		"SVGFEMorphologyElement": false,
		"SVGFEOffsetElement": false,
		"SVGFEPointLightElement": false,
		"SVGFESpecularLightingElement": false,
		"SVGFESpotLightElement": false,
		"SVGFETileElement": false,
		"SVGFETurbulenceElement": false,
		"SVGFilterElement": false,
		"SVGFilterPrimitiveStandardAttributes": false,
		"SVGFitToViewBox": false,
		"SVGFontElement": false,
		"SVGFontFaceElement": false,
		"SVGFontFaceFormatElement": false,
		"SVGFontFaceNameElement": false,
		"SVGFontFaceSrcElement": false,
		"SVGFontFaceUriElement": false,
		"SVGForeignObjectElement": false,
		"SVGGElement": false,
		"SVGGeometryElement": false,
		"SVGGlyphElement": false,
		"SVGGlyphRefElement": false,
		"SVGGradientElement": false,
		"SVGGraphicsElement": false,
		"SVGHKernElement": false,
		"SVGICCColor": false,
		"SVGImageElement": false,
		"SVGLangSpace": false,
		"SVGLength": false,
		"SVGLengthList": false,
		"SVGLinearGradientElement": false,
		"SVGLineElement": false,
		"SVGLocatable": false,
		"SVGMarkerElement": false,
		"SVGMaskElement": false,
		"SVGMatrix": false,
		"SVGMetadataElement": false,
		"SVGMissingGlyphElement": false,
		"SVGMPathElement": false,
		"SVGNumber": false,
		"SVGNumberList": false,
		"SVGPaint": false,
		"SVGPathElement": false,
		"SVGPathSeg": false,
		"SVGPathSegArcAbs": false,
		"SVGPathSegArcRel": false,
		"SVGPathSegClosePath": false,
		"SVGPathSegCurvetoCubicAbs": false,
		"SVGPathSegCurvetoCubicRel": false,
		"SVGPathSegCurvetoCubicSmoothAbs": false,
		"SVGPathSegCurvetoCubicSmoothRel": false,
		"SVGPathSegCurvetoQuadraticAbs": false,
		"SVGPathSegCurvetoQuadraticRel": false,
		"SVGPathSegCurvetoQuadraticSmoothAbs": false,
		"SVGPathSegCurvetoQuadraticSmoothRel": false,
		"SVGPathSegLinetoAbs": false,
		"SVGPathSegLinetoHorizontalAbs": false,
		"SVGPathSegLinetoHorizontalRel": false,
		"SVGPathSegLinetoRel": false,
		"SVGPathSegLinetoVerticalAbs": false,
		"SVGPathSegLinetoVerticalRel": false,
		"SVGPathSegList": false,
		"SVGPathSegMovetoAbs": false,
		"SVGPathSegMovetoRel": false,
		"SVGPatternElement": false,
		"SVGPoint": false,
		"SVGPointList": false,
		"SVGPolygonElement": false,
		"SVGPolylineElement": false,
		"SVGPreserveAspectRatio": false,
		"SVGRadialGradientElement": false,
		"SVGRect": false,
		"SVGRectElement": false,
		"SVGRenderingIntent": false,
		"SVGScriptElement": false,
		"SVGSetElement": false,
		"SVGStopElement": false,
		"SVGStringList": false,
		"SVGStylable": false,
		"SVGStyleElement": false,
		"SVGSVGElement": false,
		"SVGSwitchElement": false,
		"SVGSymbolElement": false,
		"SVGTests": false,
		"SVGTextContentElement": false,
		"SVGTextElement": false,
		"SVGTextPathElement": false,
		"SVGTextPositioningElement": false,
		"SVGTitleElement": false,
		"SVGTransform": false,
		"SVGTransformable": false,
		"SVGTransformList": false,
		"SVGTRefElement": false,
		"SVGTSpanElement": false,
		"SVGUnitTypes": false,
		"SVGURIReference": false,
		"SVGUseElement": false,
		"SVGViewElement": false,
		"SVGViewSpec": false,
		"SVGVKernElement": false,
		"SVGZoomAndPan": false,
		"SVGZoomEvent": false,
		"Text": false,
		"TextDecoder": false,
		"TextEncoder": false,
		"TextEvent": false,
		"TextMetrics": false,
		"TextTrack": false,
		"TextTrackCue": false,
		"TextTrackCueList": false,
		"TextTrackList": false,
		"TimeEvent": false,
		"TimeRanges": false,
		// "toolbar": false,
		// "top": false,
		"Touch": false,
		"TouchEvent": false,
		"TouchList": false,
		"TrackEvent": false,
		"TransitionEvent": false,
		"TreeWalker": false,
		"UIEvent": false,
		"URL": false,
		"ValidityState": false,
		"VTTCue": false,
		"WaveShaperNode": false,
		"WebGLActiveInfo": false,
		"WebGLBuffer": false,
		"WebGLContextEvent": false,
		"WebGLFramebuffer": false,
		"WebGLProgram": false,
		"WebGLRenderbuffer": false,
		"WebGLRenderingContext": false,
		"WebGLShader": false,
		"WebGLShaderPrecisionFormat": false,
		"WebGLTexture": false,
		"WebGLUniformLocation": false,
		"WebSocket": false,
		"WheelEvent": false,
		"window": false,
		"Window": false,
		"Worker": false,
		"XDomainRequest": false,
		"XMLDocument": false,
		"XMLHttpRequest": false,
		"XMLHttpRequestEventTarget": false,
		"XMLHttpRequestProgressEvent": false,
		"XMLHttpRequestUpload": false,
		"XMLSerializer": false,
		"XPathEvaluator": false,
		"XPathException": false,
		"XPathExpression": false,
		"XPathNamespace": false,
		"XPathNSResolver": false,
		"XPathResult": false,
		"XSLTProcessor": false
	},
	"worker": {
		"applicationCache": false,
		"atob": false,
		"Blob": false,
		"BroadcastChannel": false,
		"btoa": false,
		"Cache": false,
		"caches": false,
		"clearInterval": false,
		"clearTimeout": false,
		"close": true,
		"console": false,
		"fetch": false,
		"FileReaderSync": false,
		"FormData": false,
		"Headers": false,
		"IDBCursor": false,
		"IDBCursorWithValue": false,
		"IDBDatabase": false,
		"IDBFactory": false,
		"IDBIndex": false,
		"IDBKeyRange": false,
		"IDBObjectStore": false,
		"IDBOpenDBRequest": false,
		"IDBRequest": false,
		"IDBTransaction": false,
		"IDBVersionChangeEvent": false,
		"ImageData": false,
		"importScripts": true,
		"indexedDB": false,
		"location": false,
		"MessageChannel": false,
		"MessagePort": false,
		"name": false,
		"navigator": false,
		"Notification": false,
		"onclose": true,
		"onconnect": true,
		"onerror": true,
		"onlanguagechange": true,
		"onmessage": true,
		"onoffline": true,
		"ononline": true,
		"onrejectionhandled": true,
		"onunhandledrejection": true,
		"performance": false,
		"Performance": false,
		"PerformanceEntry": false,
		"PerformanceMark": false,
		"PerformanceMeasure": false,
		"PerformanceNavigation": false,
		"PerformanceResourceTiming": false,
		"PerformanceTiming": false,
		"postMessage": true,
		"Promise": false,
		"Request": false,
		"Response": false,
		"self": true,
		"ServiceWorkerRegistration": false,
		"setInterval": false,
		"setTimeout": false,
		"TextDecoder": false,
		"TextEncoder": false,
		"URL": false,
		"WebSocket": false,
		"Worker": false,
		"XMLHttpRequest": false
	},
	"node": {
		"__dirname": false,
		"__filename": false,
		"arguments": false,
		"Buffer": false,
		"clearImmediate": false,
		"clearInterval": false,
		"clearTimeout": false,
		"console": false,
		"exports": true,
		"GLOBAL": false,
		"global": false,
		"module": false,
		"process": false,
		"require": false,
		"root": false,
		"setImmediate": false,
		"setInterval": false,
		"setTimeout": false
	},
	"commonjs": {
		"exports": true,
		"module": false,
		"require": false,
		"global": false
	},
	"amd": {
		"define": false,
		"require": false
	},
	"mocha": {
		"after": false,
		"afterEach": false,
		"before": false,
		"beforeEach": false,
		"context": false,
		"describe": false,
		"it": false,
		"mocha": false,
		"setup": false,
		"specify": false,
		"suite": false,
		"suiteSetup": false,
		"suiteTeardown": false,
		"teardown": false,
		"test": false,
		"xcontext": false,
		"xdescribe": false,
		"xit": false,
		"xspecify": false
	},
	"jasmine": {
		"afterAll": false,
		"afterEach": false,
		"beforeAll": false,
		"beforeEach": false,
		"describe": false,
		"expect": false,
		"fail": false,
		"fdescribe": false,
		"fit": false,
		"it": false,
		"jasmine": false,
		"pending": false,
		"runs": false,
		"spyOn": false,
		"waits": false,
		"waitsFor": false,
		"xdescribe": false,
		"xit": false
	},
	"jest": {
		"afterEach": false,
		"beforeEach": false,
		"describe": false,
		"expect": false,
		"it": false,
		"jest": false,
		"pit": false,
		"require": false,
		"xdescribe": false,
		"xit": false
	},
	"qunit": {
		"asyncTest": false,
		"deepEqual": false,
		"equal": false,
		"expect": false,
		"module": false,
		"notDeepEqual": false,
		"notEqual": false,
		"notOk": false,
		"notPropEqual": false,
		"notStrictEqual": false,
		"ok": false,
		"propEqual": false,
		"QUnit": false,
		"raises": false,
		"start": false,
		"stop": false,
		"strictEqual": false,
		"test": false,
		"throws": false
	},
	"phantomjs": {
		"console": true,
		"exports": true,
		"phantom": true,
		"require": true,
		"WebPage": true
	},
	"couch": {
		"emit": false,
		"exports": false,
		"getRow": false,
		"log": false,
		"module": false,
		"provides": false,
		"require": false,
		"respond": false,
		"send": false,
		"start": false,
		"sum": false
	},
	"rhino": {
		"defineClass": false,
		"deserialize": false,
		"gc": false,
		"help": false,
		"importClass": false,
		"importPackage": false,
		"java": false,
		"load": false,
		"loadClass": false,
		"Packages": false,
		"print": false,
		"quit": false,
		"readFile": false,
		"readUrl": false,
		"runCommand": false,
		"seal": false,
		"serialize": false,
		"spawn": false,
		"sync": false,
		"toint32": false,
		"version": false
	},
	"nashorn": {
		"__DIR__": false,
		"__FILE__": false,
		"__LINE__": false,
		"com": false,
		"edu": false,
		"exit": false,
		"Java": false,
		"java": false,
		"javafx": false,
		"JavaImporter": false,
		"javax": false,
		"JSAdapter": false,
		"load": false,
		"loadWithNewGlobal": false,
		"org": false,
		"Packages": false,
		"print": false,
		"quit": false
	},
	"wsh": {
		"ActiveXObject": true,
		"Enumerator": true,
		"GetObject": true,
		"ScriptEngine": true,
		"ScriptEngineBuildVersion": true,
		"ScriptEngineMajorVersion": true,
		"ScriptEngineMinorVersion": true,
		"VBArray": true,
		"WScript": true,
		"WSH": true,
		"XDomainRequest": true
	},
	"jquery": {
		"$": false,
		"jQuery": false
	},
	"yui": {
		"Y": false,
		"YUI": false,
		"YUI_config": false
	},
	"shelljs": {
		"cat": false,
		"cd": false,
		"chmod": false,
		"config": false,
		"cp": false,
		"dirs": false,
		"echo": false,
		"env": false,
		"error": false,
		"exec": false,
		"exit": false,
		"find": false,
		"grep": false,
		"ls": false,
		"ln": false,
		"mkdir": false,
		"mv": false,
		"popd": false,
		"pushd": false,
		"pwd": false,
		"rm": false,
		"sed": false,
		"target": false,
		"tempdir": false,
		"test": false,
		"which": false
	},
	"prototypejs": {
		"$": false,
		"$$": false,
		"$A": false,
		"$break": false,
		"$continue": false,
		"$F": false,
		"$H": false,
		"$R": false,
		"$w": false,
		"Abstract": false,
		"Ajax": false,
		"Autocompleter": false,
		"Builder": false,
		"Class": false,
		"Control": false,
		"Draggable": false,
		"Draggables": false,
		"Droppables": false,
		"Effect": false,
		"Element": false,
		"Enumerable": false,
		"Event": false,
		"Field": false,
		"Form": false,
		"Hash": false,
		"Insertion": false,
		"ObjectRange": false,
		"PeriodicalExecuter": false,
		"Position": false,
		"Prototype": false,
		"Scriptaculous": false,
		"Selector": false,
		"Sortable": false,
		"SortableObserver": false,
		"Sound": false,
		"Template": false,
		"Toggle": false,
		"Try": false
	},
	"meteor": {
		"$": false,
		"_": false,
		"Accounts": false,
		"App": false,
		"Assets": false,
		"Blaze": false,
		"check": false,
		"Cordova": false,
		"DDP": false,
		"DDPServer": false,
		"Deps": false,
		"EJSON": false,
		"Email": false,
		"HTTP": false,
		"Log": false,
		"Match": false,
		"Meteor": false,
		"Mongo": false,
		"MongoInternals": false,
		"Npm": false,
		"Package": false,
		"Plugin": false,
		"process": false,
		"Random": false,
		"ReactiveDict": false,
		"ReactiveVar": false,
		"Router": false,
		"Session": false,
		"share": false,
		"Spacebars": false,
		"Template": false,
		"Tinytest": false,
		"Tracker": false,
		"UI": false,
		"Utils": false,
		"WebApp": false,
		"WebAppInternals": false
	},
	"mongo": {
		"_isWindows": false,
		"_rand": false,
		"BulkWriteResult": false,
		"cat": false,
		"cd": false,
		"connect": false,
		"db": false,
		"getHostName": false,
		"getMemInfo": false,
		"hostname": false,
		"listFiles": false,
		"load": false,
		"ls": false,
		"md5sumFile": false,
		"mkdir": false,
		"Mongo": false,
		"ObjectId": false,
		"PlanCache": false,
		"print": false,
		"printjson": false,
		"pwd": false,
		"quit": false,
		"removeFile": false,
		"rs": false,
		"sh": false,
		"UUID": false,
		"version": false,
		"WriteResult": false
	},
	"applescript": {
		"$": false,
		"Application": false,
		"Automation": false,
		"console": false,
		"delay": false,
		"Library": false,
		"ObjC": false,
		"ObjectSpecifier": false,
		"Path": false,
		"Progress": false,
		"Ref": false
	},
	"serviceworker": {
		"caches": false,
		"Cache": false,
		"CacheStorage": false,
		"Client": false,
		"clients": false,
		"Clients": false,
		"ExtendableEvent": false,
		"ExtendableMessageEvent": false,
		"FetchEvent": false,
		"importScripts": false,
		"registration": false,
		"self": false,
		"ServiceWorker": false,
		"ServiceWorkerContainer": false,
		"ServiceWorkerGlobalScope": false,
		"ServiceWorkerMessageEvent": false,
		"ServiceWorkerRegistration": false,
		"skipWaiting": false,
		"WindowClient": false
	},
	"atomtest": {
		"advanceClock": false,
		"fakeClearInterval": false,
		"fakeClearTimeout": false,
		"fakeSetInterval": false,
		"fakeSetTimeout": false,
		"resetTimeouts": false,
		"waitsForPromise": false
	},
	"embertest": {
		"andThen": false,
		"click": false,
		"currentPath": false,
		"currentRouteName": false,
		"currentURL": false,
		"fillIn": false,
		"find": false,
		"findWithAssert": false,
		"keyEvent": false,
		"pauseTest": false,
		"triggerEvent": false,
		"visit": false
	},
	"protractor": {
		"$": false,
		"$$": false,
		"browser": false,
		"By": false,
		"by": false,
		"DartObject": false,
		"element": false,
		"protractor": false
	},
	"shared-node-browser": {
		"clearInterval": false,
		"clearTimeout": false,
		"console": false,
		"setInterval": false,
		"setTimeout": false
	},
	"webextensions": {
		"browser": false,
		"chrome": false,
		"opr": false
	},
	"greasemonkey": {
		"GM_addStyle": false,
		"GM_deleteValue": false,
		"GM_getResourceText": false,
		"GM_getResourceURL": false,
		"GM_getValue": false,
		"GM_info": false,
		"GM_listValues": false,
		"GM_log": false,
		"GM_openInTab": false,
		"GM_registerMenuCommand": false,
		"GM_setClipboard": false,
		"GM_setValue": false,
		"GM_xmlhttpRequest": false,
		"unsafeWindow": false
	}
}

},
   {}],

"/node_modules/globals/index.js": [function(require,module,exports){
module.exports = require('./globals.json');

},
   {"./globals.json":"/node_modules/globals/globals.json"}],

"/node_modules/is-my-json-valid/formats.js": [function(require,module,exports){
exports['date-time'] = /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}[tT ]\d{2}:\d{2}:\d{2}(\.\d+)?([zZ]|[+-]\d{2}:\d{2})$/
exports['date'] = /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}$/
exports['time'] = /^\d{2}:\d{2}:\d{2}$/
exports['email'] = /^\S+@\S+$/
exports['ip-address'] = exports['ipv4'] = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/
exports['ipv6'] = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/
exports['uri'] = /^[a-zA-Z][a-zA-Z0-9+-.]*:[^\s]*$/
exports['color'] = /(#?([0-9A-Fa-f]{3,6})\b)|(aqua)|(black)|(blue)|(fuchsia)|(gray)|(green)|(lime)|(maroon)|(navy)|(olive)|(orange)|(purple)|(red)|(silver)|(teal)|(white)|(yellow)|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\))/
exports['hostname'] = /^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])(\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]{0,61}[a-zA-Z0-9]))*$/
exports['alpha'] = /^[a-zA-Z]+$/
exports['alphanumeric'] = /^[a-zA-Z0-9]+$/
exports['style'] = /\s*(.+?):\s*([^;]+);?/g
exports['phone'] = /^\+(?:[0-9] ?){6,14}[0-9]$/
exports['utc-millisec'] = /^[0-9]+(\.?[0-9]+)?$/

},
   {}],

"/node_modules/is-my-json-valid/index.js": [function(require,module,exports){
var genobj = require('generate-object-property')
var genfun = require('generate-function')
var jsonpointer = require('jsonpointer')
var xtend = require('xtend')
var formats = require('./formats')

var get = function(obj, additionalSchemas, ptr) {
  if (/^https?:\/\//.test(ptr)) return null

  var visit = function(sub) {
    if (sub && sub.id === ptr) return sub
    if (typeof sub !== 'object' || !sub) return null
    return Object.keys(sub).reduce(function(res, k) {
      return res || visit(sub[k])
    }, null)
  }

  var res = visit(obj)
  if (res) return res

  ptr = ptr.replace(/^#/, '')
  ptr = ptr.replace(/\/$/, '')

  try {
    return jsonpointer.get(obj, decodeURI(ptr))
  } catch (err) {
    var end = ptr.indexOf('#')
    var other
    if (end !== 0) {
      if (end === -1) {
        other = additionalSchemas[ptr]
      } else {
        var ext = ptr.slice(0, end)
        other = additionalSchemas[ext]
        var fragment = ptr.slice(end).replace(/^#/, '')
        try {
          return jsonpointer.get(other, fragment)
        } catch (err) {}
      }
    } else {
      other = additionalSchemas[ptr]
    }
    return other || null
  }
}

var formatName = function(field) {
  field = JSON.stringify(field)
  var pattern = /\[([^\[\]"]+)\]/
  while (pattern.test(field)) field = field.replace(pattern, '."+$1+"')
  return field
}

var types = {}

types.any = function() {
  return 'true'
}

types.null = function(name) {
  return name+' === null'
}

types.boolean = function(name) {
  return 'typeof '+name+' === "boolean"'
}

types.array = function(name) {
  return 'Array.isArray('+name+')'
}

types.object = function(name) {
  return 'typeof '+name+' === "object" && '+name+' && !Array.isArray('+name+')'
}

types.number = function(name) {
  return 'typeof '+name+' === "number"'
}

types.integer = function(name) {
  return 'typeof '+name+' === "number" && (Math.floor('+name+') === '+name+' || '+name+' > 9007199254740992 || '+name+' < -9007199254740992)'
}

types.string = function(name) {
  return 'typeof '+name+' === "string"'
}

var unique = function(array) {
  var list = []
  for (var i = 0; i < array.length; i++) {
    list.push(typeof array[i] === 'object' ? JSON.stringify(array[i]) : array[i])
  }
  for (var i = 1; i < list.length; i++) {
    if (list.indexOf(list[i]) !== i) return false
  }
  return true
}

var toType = function(node) {
  return node.type
}

var compile = function(schema, cache, root, reporter, opts) {
  var fmts = opts ? xtend(formats, opts.formats) : formats
  var scope = {unique:unique, formats:fmts}
  var verbose = opts ? !!opts.verbose : false;
  var greedy = opts && opts.greedy !== undefined ?
    opts.greedy : false;

  var syms = {}
  var gensym = function(name) {
    return name+(syms[name] = (syms[name] || 0)+1)
  }

  var reversePatterns = {}
  var patterns = function(p) {
    if (reversePatterns[p]) return reversePatterns[p]
    var n = gensym('pattern')
    scope[n] = new RegExp(p)
    reversePatterns[p] = n
    return n
  }

  var vars = ['i','j','k','l','m','n','o','p','q','r','s','t','u','v','x','y','z']
  var genloop = function() {
    var v = vars.shift()
    vars.push(v+v[0])
    return v
  }

  var visit = function(name, node, reporter, filter) {
    var properties = node.properties
    var type = node.type
    var tuple = false

    if (Array.isArray(node.items)) { // tuple type
      properties = {}
      node.items.forEach(function(item, i) {
        properties[i] = item
      })
      type = 'array'
      tuple = true
    }

    var indent = 0
    var error = function(msg, prop, value) {
      validate('errors++')
      if (reporter === true) {
        validate('if (validate.errors === null) validate.errors = []')
        if (verbose) {
          validate('validate.errors.push({field:%s,message:%s,value:%s})', formatName(prop || name), JSON.stringify(msg), value || name)
        } else {
          validate('validate.errors.push({field:%s,message:%s})', formatName(prop || name), JSON.stringify(msg))
        }
      }
    }

    if (node.required === true) {
      indent++
      validate('if (%s === undefined) {', name)
      error('is required')
      validate('} else {')
    } else {
      indent++
      validate('if (%s !== undefined) {', name)
    }

    var valid = [].concat(type)
      .map(function(t) {
        return types[t || 'any'](name)
      })
      .join(' || ') || 'true'

    if (valid !== 'true') {
      indent++
      validate('if (!(%s)) {', valid)
      error('is the wrong type')
      validate('} else {')
    }

    if (tuple) {
      if (node.additionalItems === false) {
        validate('if (%s.length > %d) {', name, node.items.length)
        error('has additional items')
        validate('}')
      } else if (node.additionalItems) {
        var i = genloop()
        validate('for (var %s = %d; %s < %s.length; %s++) {', i, node.items.length, i, name, i)
        visit(name+'['+i+']', node.additionalItems, reporter, filter)
        validate('}')
      }
    }

    if (node.format && fmts[node.format]) {
      if (type !== 'string' && formats[node.format]) validate('if (%s) {', types.string(name))
      var n = gensym('format')
      scope[n] = fmts[node.format]

      if (typeof scope[n] === 'function') validate('if (!%s(%s)) {', n, name)
      else validate('if (!%s.test(%s)) {', n, name)
      error('must be '+node.format+' format')
      validate('}')
      if (type !== 'string' && formats[node.format]) validate('}')
    }

    if (Array.isArray(node.required)) {
      var isUndefined = function(req) {
        return genobj(name, req) + ' === undefined'
      }

      var checkRequired = function (req) {
        var prop = genobj(name, req);
        validate('if (%s === undefined) {', prop)
        error('is required', prop)
        validate('missing++')
        validate('}')
      }
      validate('if ((%s)) {', type !== 'object' ? types.object(name) : 'true')
      validate('var missing = 0')
      node.required.map(checkRequired)
      validate('}');
      if (!greedy) {
        validate('if (missing === 0) {')
        indent++
      }
    }

    if (node.uniqueItems) {
      if (type !== 'array') validate('if (%s) {', types.array(name))
      validate('if (!(unique(%s))) {', name)
      error('must be unique')
      validate('}')
      if (type !== 'array') validate('}')
    }

    if (node.enum) {
      var complex = node.enum.some(function(e) {
        return typeof e === 'object'
      })

      var compare = complex ?
        function(e) {
          return 'JSON.stringify('+name+')'+' !== JSON.stringify('+JSON.stringify(e)+')'
        } :
        function(e) {
          return name+' !== '+JSON.stringify(e)
        }

      validate('if (%s) {', node.enum.map(compare).join(' && ') || 'false')
      error('must be an enum value')
      validate('}')
    }

    if (node.dependencies) {
      if (type !== 'object') validate('if (%s) {', types.object(name))

      Object.keys(node.dependencies).forEach(function(key) {
        var deps = node.dependencies[key]
        if (typeof deps === 'string') deps = [deps]

        var exists = function(k) {
          return genobj(name, k) + ' !== undefined'
        }

        if (Array.isArray(deps)) {
          validate('if (%s !== undefined && !(%s)) {', genobj(name, key), deps.map(exists).join(' && ') || 'true')
          error('dependencies not set')
          validate('}')
        }
        if (typeof deps === 'object') {
          validate('if (%s !== undefined) {', genobj(name, key))
          visit(name, deps, reporter, filter)
          validate('}')
        }
      })

      if (type !== 'object') validate('}')
    }

    if (node.additionalProperties || node.additionalProperties === false) {
      if (type !== 'object') validate('if (%s) {', types.object(name))

      var i = genloop()
      var keys = gensym('keys')

      var toCompare = function(p) {
        return keys+'['+i+'] !== '+JSON.stringify(p)
      }

      var toTest = function(p) {
        return '!'+patterns(p)+'.test('+keys+'['+i+'])'
      }

      var additionalProp = Object.keys(properties || {}).map(toCompare)
        .concat(Object.keys(node.patternProperties || {}).map(toTest))
        .join(' && ') || 'true'

      validate('var %s = Object.keys(%s)', keys, name)
        ('for (var %s = 0; %s < %s.length; %s++) {', i, i, keys, i)
          ('if (%s) {', additionalProp)

      if (node.additionalProperties === false) {
        if (filter) validate('delete %s', name+'['+keys+'['+i+']]')
        error('has additional properties', null, JSON.stringify(name+'.') + ' + ' + keys + '['+i+']')
      } else {
        visit(name+'['+keys+'['+i+']]', node.additionalProperties, reporter, filter)
      }

      validate
          ('}')
        ('}')

      if (type !== 'object') validate('}')
    }

    if (node.$ref) {
      var sub = get(root, opts && opts.schemas || {}, node.$ref)
      if (sub) {
        var fn = cache[node.$ref]
        if (!fn) {
          cache[node.$ref] = function proxy(data) {
            return fn(data)
          }
          fn = compile(sub, cache, root, false, opts)
        }
        var n = gensym('ref')
        scope[n] = fn
        validate('if (!(%s(%s))) {', n, name)
        error('referenced schema does not match')
        validate('}')
      }
    }

    if (node.not) {
      var prev = gensym('prev')
      validate('var %s = errors', prev)
      visit(name, node.not, false, filter)
      validate('if (%s === errors) {', prev)
      error('negative schema matches')
      validate('} else {')
        ('errors = %s', prev)
      ('}')
    }

    if (node.items && !tuple) {
      if (type !== 'array') validate('if (%s) {', types.array(name))

      var i = genloop()
      validate('for (var %s = 0; %s < %s.length; %s++) {', i, i, name, i)
      visit(name+'['+i+']', node.items, reporter, filter)
      validate('}')

      if (type !== 'array') validate('}')
    }

    if (node.patternProperties) {
      if (type !== 'object') validate('if (%s) {', types.object(name))
      var keys = gensym('keys')
      var i = genloop()
      validate
        ('var %s = Object.keys(%s)', keys, name)
        ('for (var %s = 0; %s < %s.length; %s++) {', i, i, keys, i)

      Object.keys(node.patternProperties).forEach(function(key) {
        var p = patterns(key)
        validate('if (%s.test(%s)) {', p, keys+'['+i+']')
        visit(name+'['+keys+'['+i+']]', node.patternProperties[key], reporter, filter)
        validate('}')
      })

      validate('}')
      if (type !== 'object') validate('}')
    }

    if (node.pattern) {
      var p = patterns(node.pattern)
      if (type !== 'string') validate('if (%s) {', types.string(name))
      validate('if (!(%s.test(%s))) {', p, name)
      error('pattern mismatch')
      validate('}')
      if (type !== 'string') validate('}')
    }

    if (node.allOf) {
      node.allOf.forEach(function(sch) {
        visit(name, sch, reporter, filter)
      })
    }

    if (node.anyOf && node.anyOf.length) {
      var prev = gensym('prev')

      node.anyOf.forEach(function(sch, i) {
        if (i === 0) {
          validate('var %s = errors', prev)
        } else {
          validate('if (errors !== %s) {', prev)
            ('errors = %s', prev)
        }
        visit(name, sch, false, false)
      })
      node.anyOf.forEach(function(sch, i) {
        if (i) validate('}')
      })
      validate('if (%s !== errors) {', prev)
      error('no schemas match')
      validate('}')
    }

    if (node.oneOf && node.oneOf.length) {
      var prev = gensym('prev')
      var passes = gensym('passes')

      validate
        ('var %s = errors', prev)
        ('var %s = 0', passes)

      node.oneOf.forEach(function(sch, i) {
        visit(name, sch, false, false)
        validate('if (%s === errors) {', prev)
          ('%s++', passes)
        ('} else {')
          ('errors = %s', prev)
        ('}')
      })

      validate('if (%s !== 1) {', passes)
      error('no (or more than one) schemas match')
      validate('}')
    }

    if (node.multipleOf !== undefined) {
      if (type !== 'number' && type !== 'integer') validate('if (%s) {', types.number(name))

      var factor = ((node.multipleOf | 0) !== node.multipleOf) ? Math.pow(10, node.multipleOf.toString().split('.').pop().length) : 1
      if (factor > 1) validate('if ((%d*%s) % %d) {', factor, name, factor*node.multipleOf)
      else validate('if (%s % %d) {', name, node.multipleOf)

      error('has a remainder')
      validate('}')

      if (type !== 'number' && type !== 'integer') validate('}')
    }

    if (node.maxProperties !== undefined) {
      if (type !== 'object') validate('if (%s) {', types.object(name))

      validate('if (Object.keys(%s).length > %d) {', name, node.maxProperties)
      error('has more properties than allowed')
      validate('}')

      if (type !== 'object') validate('}')
    }

    if (node.minProperties !== undefined) {
      if (type !== 'object') validate('if (%s) {', types.object(name))

      validate('if (Object.keys(%s).length < %d) {', name, node.minProperties)
      error('has less properties than allowed')
      validate('}')

      if (type !== 'object') validate('}')
    }

    if (node.maxItems !== undefined) {
      if (type !== 'array') validate('if (%s) {', types.array(name))

      validate('if (%s.length > %d) {', name, node.maxItems)
      error('has more items than allowed')
      validate('}')

      if (type !== 'array') validate('}')
    }

    if (node.minItems !== undefined) {
      if (type !== 'array') validate('if (%s) {', types.array(name))

      validate('if (%s.length < %d) {', name, node.minItems)
      error('has less items than allowed')
      validate('}')

      if (type !== 'array') validate('}')
    }

    if (node.maxLength !== undefined) {
      if (type !== 'string') validate('if (%s) {', types.string(name))

      validate('if (%s.length > %d) {', name, node.maxLength)
      error('has longer length than allowed')
      validate('}')

      if (type !== 'string') validate('}')
    }

    if (node.minLength !== undefined) {
      if (type !== 'string') validate('if (%s) {', types.string(name))

      validate('if (%s.length < %d) {', name, node.minLength)
      error('has less length than allowed')
      validate('}')

      if (type !== 'string') validate('}')
    }

    if (node.minimum !== undefined) {
      validate('if (%s %s %d) {', name, node.exclusiveMinimum ? '<=' : '<', node.minimum)
      error('is less than minimum')
      validate('}')
    }

    if (node.maximum !== undefined) {
      validate('if (%s %s %d) {', name, node.exclusiveMaximum ? '>=' : '>', node.maximum)
      error('is more than maximum')
      validate('}')
    }

    if (properties) {
      Object.keys(properties).forEach(function(p) {
        if (Array.isArray(type) && type.indexOf('null') !== -1) validate('if (%s !== null) {', name)

        visit(genobj(name, p), properties[p], reporter, filter)

        if (Array.isArray(type) && type.indexOf('null') !== -1) validate('}')
      })
    }

    while (indent--) validate('}')
  }

  var validate = genfun
    ('function validate(data) {')
      ('validate.errors = null')
      ('var errors = 0')

  visit('data', schema, reporter, opts && opts.filter)

  validate
      ('return errors === 0')
    ('}')

  validate = validate.toFunction(scope)
  validate.errors = null

  if (Object.defineProperty) {
    Object.defineProperty(validate, 'error', {
      get: function() {
        if (!validate.errors) return ''
        return validate.errors.map(function(err) {
          return err.field + ' ' + err.message;
        }).join('\n')
      }
    })
  }

  validate.toJSON = function() {
    return schema
  }

  return validate
}

module.exports = function(schema, opts) {
  if (typeof schema === 'string') schema = JSON.parse(schema)
  return compile(schema, {}, schema, true, opts)
}

module.exports.filter = function(schema, opts) {
  var validate = module.exports(schema, xtend(opts, {filter: true}))
  return function(sch) {
    validate(sch)
    return sch
  }
}

},
   {"./formats":"/node_modules/is-my-json-valid/formats.js","generate-function":"/node_modules/is-my-json-valid/node_modules/generate-function/index.js","generate-object-property":"/node_modules/is-my-json-valid/node_modules/generate-object-property/index.js","jsonpointer":"/node_modules/is-my-json-valid/node_modules/jsonpointer/jsonpointer.js","xtend":"/node_modules/is-my-json-valid/node_modules/xtend/immutable.js"}],

"/node_modules/is-my-json-valid/node_modules/generate-function/index.js": [function(require,module,exports){
var util = require('util')

var INDENT_START = /[\{\[]/
var INDENT_END = /[\}\]]/

module.exports = function() {
  var lines = []
  var indent = 0

  var push = function(str) {
    var spaces = ''
    while (spaces.length < indent*2) spaces += '  '
    lines.push(spaces+str)
  }

  var line = function(fmt) {
    if (!fmt) return line

    if (INDENT_END.test(fmt.trim()[0]) && INDENT_START.test(fmt[fmt.length-1])) {
      indent--
      push(util.format.apply(util, arguments))
      indent++
      return line
    }
    if (INDENT_START.test(fmt[fmt.length-1])) {
      push(util.format.apply(util, arguments))
      indent++
      return line
    }
    if (INDENT_END.test(fmt.trim()[0])) {
      indent--
      push(util.format.apply(util, arguments))
      return line
    }

    push(util.format.apply(util, arguments))
    return line
  }

  line.toString = function() {
    return lines.join('\n')
  }

  line.toFunction = function(scope) {
    var src = 'return ('+line.toString()+')'

    var keys = Object.keys(scope || {}).map(function(key) {
      return key
    })

    var vals = keys.map(function(key) {
      return scope[key]
    })

    return Function.apply(null, keys.concat(src)).apply(null, vals)
  }

  if (arguments.length) line.apply(null, arguments)

  return line
}

},
   {"util":"/node_modules/browserify/node_modules/util/util.js"}],

"/node_modules/is-my-json-valid/node_modules/generate-object-property/index.js": [function(require,module,exports){
var isProperty = require('is-property')

var gen = function(obj, prop) {
  return isProperty(prop) ? obj+'.'+prop : obj+'['+JSON.stringify(prop)+']'
}

gen.valid = isProperty
gen.property = function (prop) {
 return isProperty(prop) ? prop : JSON.stringify(prop)
}

module.exports = gen

},
   {"is-property":"/node_modules/is-my-json-valid/node_modules/generate-object-property/node_modules/is-property/is-property.js"}],

"/node_modules/is-my-json-valid/node_modules/generate-object-property/node_modules/is-property/is-property.js": [function(require,module,exports){
"use strict"
function isProperty(str) {
  return /^[$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc][$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc0-9\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19b0-\u19c0\u19c8\u19c9\u19d0-\u19d9\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1dc0-\u1de6\u1dfc-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f]*$/.test(str)
}
module.exports = isProperty
},
   {}],

"/node_modules/is-my-json-valid/node_modules/jsonpointer/jsonpointer.js": [function(require,module,exports){
var untilde = function(str) {
  return str.replace(/~./g, function(m) {
    switch (m) {
      case "~0":
        return "~";
      case "~1":
        return "/";
    }
    throw new Error("Invalid tilde escape: " + m);
  });
}

var traverse = function(obj, pointer, value) {
  var part = untilde(pointer.shift());
  if(!obj.hasOwnProperty(part)) {
    return null;
  }
  if(pointer.length !== 0) { // keep traversin!
    return traverse(obj[part], pointer, value);
  }
  if(typeof value === "undefined") {
    return obj[part];
  }
  var old_value = obj[part];
  if(value === null) {
    delete obj[part];
  } else {
    obj[part] = value;
  }
  return old_value;
}

var validate_input = function(obj, pointer) {
  if(typeof obj !== "object") {
    throw new Error("Invalid input object.");
  }

  if(pointer === "") {
    return [];
  }

  if(!pointer) {
    throw new Error("Invalid JSON pointer.");
  }

  pointer = pointer.split("/");
  var first = pointer.shift();
  if (first !== "") {
    throw new Error("Invalid JSON pointer.");
  }

  return pointer;
}

var get = function(obj, pointer) {
  pointer = validate_input(obj, pointer);
  if (pointer.length === 0) {
    return obj;
  }
  return traverse(obj, pointer);
}

var set = function(obj, pointer, value) {
  pointer = validate_input(obj, pointer);
  if (pointer.length === 0) {
    throw new Error("Invalid JSON pointer for set.")
  }
  return traverse(obj, pointer, value);
}

exports.get = get
exports.set = set

},
   {}],

"/node_modules/is-my-json-valid/node_modules/xtend/immutable.js": [function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},
   {}],

"/node_modules/lodash/lodash.js": [function(require,module,exports){
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar.source);
    exports.escapeRegExp = function escapeRegExp(string) {
      return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
    }

    exports.assign = Object.assign;
},
   {}],

"/node_modules/object-assign/index.js": [function(require,module,exports){
'use strict';
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

module.exports = Object.assign || function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (Object.getOwnPropertySymbols) {
			symbols = Object.getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},
   {}],

"/tmp/ast-utils.js": [function(require,module,exports){
"use strict";

var esutils = require("esutils");

var anyFunctionPattern = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/;
var arrayOrTypedArrayPattern = /Array$/;
var arrayMethodPattern = /^(?:every|filter|find|findIndex|forEach|map|some)$/;
var bindOrCallOrApplyPattern = /^(?:bind|call|apply)$/;
var breakableTypePattern = /^(?:(?:Do)?While|For(?:In|Of)?|Switch)Statement$/;
var thisTagPattern = /^[\s\*]*@this/m;

function isModifyingReference(reference, index, references) {
    var identifier = reference.identifier;

    return (identifier &&
        reference.init === false &&
        reference.isWrite() &&
        (index === 0 || references[index - 1].identifier !== identifier)
    );
}

function isES5Constructor(node) {
    return (
        node.id &&
        node.id.name[0] === node.id.name[0].toLocaleUpperCase()
    );
}

function getUpperFunction(node) {
    while (node) {
        if (anyFunctionPattern.test(node.type)) {
            return node;
        }
        node = node.parent;
    }
    return null;
}

function isNullOrUndefined(node) {
    return (
        (node.type === "Literal" && node.value === null) ||
        (node.type === "Identifier" && node.name === "undefined") ||
        (node.type === "UnaryExpression" && node.operator === "void")
    );
}

function isCallee(node) {
    return node.parent.type === "CallExpression" && node.parent.callee === node;
}

function isReflectApply(node) {
    return (
        node.type === "MemberExpression" &&
        node.object.type === "Identifier" &&
        node.object.name === "Reflect" &&
        node.property.type === "Identifier" &&
        node.property.name === "apply" &&
        node.computed === false
    );
}

function isArrayFromMethod(node) {
    return (
        node.type === "MemberExpression" &&
        node.object.type === "Identifier" &&
        arrayOrTypedArrayPattern.test(node.object.name) &&
        node.property.type === "Identifier" &&
        node.property.name === "from" &&
        node.computed === false
    );
}

function isMethodWhichHasThisArg(node) {
    while (node) {
        if (node.type === "Identifier") {
            return arrayMethodPattern.test(node.name);
        }
        if (node.type === "MemberExpression" && !node.computed) {
            node = node.property;
            continue;
        }

        break;
    }

    return false;
}

function hasJSDocThisTag(node, sourceCode) {
    var jsdocComment = sourceCode.getJSDocComment(node);
    if (jsdocComment && thisTagPattern.test(jsdocComment.value)) {
        return true;
    }

    return sourceCode.getComments(node).leading.some(function(comment) {
        return thisTagPattern.test(comment.value);
    });
}

module.exports = {

    isTokenOnSameLine: function(left, right) {
        return left.loc.end.line === right.loc.start.line;
    },

    isNullOrUndefined: isNullOrUndefined,
    isCallee: isCallee,
    isES5Constructor: isES5Constructor,
    getUpperFunction: getUpperFunction,
    isArrayFromMethod: isArrayFromMethod,

    isStringLiteral: function(node) {
        return (
            (node.type === "Literal" && typeof node.value === "string") ||
            node.type === "TemplateLiteral"
        );
    },

    isBreakableStatement: function(node) {
        return breakableTypePattern.test(node.type);
    },

    getLabel: function(node) {
        if (node.parent.type === "LabeledStatement") {
            return node.parent.label.name;
        }
        return null;
    },

    getModifyingReferences: function(references) {
        return references.filter(isModifyingReference);
    },

    isSurroundedBy: function(val, character) {
        return val[0] === character && val[val.length - 1] === character;
    },

    isDirectiveComment: function(node) {
        var comment = node.value.trim();
        return (
            node.type === "Line" && comment.indexOf("eslint-") === 0 ||
            node.type === "Block" && (
                comment.indexOf("global ") === 0 ||
                comment.indexOf("eslint ") === 0 ||
                comment.indexOf("eslint-") === 0
            )
        );
    },

    getTrailingStatement: esutils.ast.trailingStatement,

    getVariableByName: function(initScope, name) {
        var scope = initScope;
        while (scope) {
            var variable = scope.set.get(name);
            if (variable) {
                return variable;
            }

            scope = scope.upper;
        }

        return null;
    },

    isDefaultThisBinding: function(node, sourceCode) {
        if (isES5Constructor(node) || hasJSDocThisTag(node, sourceCode)) {
            return false;
        }

        while (node) {
            var parent = node.parent;
            switch (parent.type) {
                case "LogicalExpression":
                case "ConditionalExpression":
                    node = parent;
                    break;

                case "ReturnStatement":
                    var func = getUpperFunction(parent);
                    if (func === null || !isCallee(func)) {
                        return true;
                    }
                    node = func.parent;
                    break;

                case "Property":
                    return false;

                case "AssignmentExpression":
                    return (
                        parent.right !== node ||
                        parent.left.type !== "MemberExpression"
                    );

                case "MethodDefinition":
                    return false;

                case "MemberExpression":
                    return (
                        parent.object !== node ||
                        parent.property.type !== "Identifier" ||
                        !bindOrCallOrApplyPattern.test(parent.property.name) ||
                        !isCallee(parent) ||
                        parent.parent.arguments.length === 0 ||
                        isNullOrUndefined(parent.parent.arguments[0])
                    );

                case "CallExpression":
                    if (isReflectApply(parent.callee)) {
                        return (
                            parent.arguments.length !== 3 ||
                            parent.arguments[0] !== node ||
                            isNullOrUndefined(parent.arguments[1])
                        );
                    }
                    if (isArrayFromMethod(parent.callee)) {
                        return (
                            parent.arguments.length !== 3 ||
                            parent.arguments[1] !== node ||
                            isNullOrUndefined(parent.arguments[2])
                        );
                    }
                    if (isMethodWhichHasThisArg(parent.callee)) {
                        return (
                            parent.arguments.length !== 2 ||
                            parent.arguments[0] !== node ||
                            isNullOrUndefined(parent.arguments[1])
                        );
                    }
                    return true;

                default:
                    return true;
            }
        }

        return true;
    }
};

},
   {"esutils":"/node_modules/esutils/lib/utils.js"}],

"/tmp/code-path-analysis/code-path-analyzer.js": [function(require,module,exports){
"use strict";

var assert = require("assert"),
    CodePath = require("./code-path"),
    CodePathSegment = require("./code-path-segment"),
    IdGenerator = require("./id-generator"),
    debug = require("./debug-helpers"),
    astUtils = require("../ast-utils");

function isCaseNode(node) {
    return Boolean(node.test);
}

function isForkingByTrueOrFalse(node) {
    var parent = node.parent;
    switch (parent.type) {
        case "ConditionalExpression":
        case "IfStatement":
        case "WhileStatement":
        case "DoWhileStatement":
        case "ForStatement":
            return parent.test === node;

        case "LogicalExpression":
            return true;

        default:
            return false;
    }
}

function getBooleanValueIfSimpleConstant(node) {
    if (node.type === "Literal") {
        return Boolean(node.value);
    }
    return void 0;
}

function isIdentifierReference(node) {
    var parent = node.parent;

    switch (parent.type) {
        case "LabeledStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "ArrayPattern":
        case "RestElement":
        case "ImportSpecifier":
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "CatchClause":
            return false;

        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ArrowFunctionExpression":
        case "ClassDeclaration":
        case "ClassExpression":
        case "VariableDeclarator":
            return parent.id !== node;

        case "Property":
        case "MethodDefinition":
            return (
                parent.key !== node ||
                parent.computed ||
                parent.shorthand
            );

        case "AssignmentPattern":
            return parent.key !== node;

        default:
            return true;
    }
}

function forwardCurrentToHead(analyzer, node) {
    var codePath = analyzer.codePath;
    var state = CodePath.getState(codePath);
    var currentSegments = state.currentSegments;
    var headSegments = state.headSegments;
    var end = Math.max(currentSegments.length, headSegments.length);
    var i, currentSegment, headSegment;

    for (i = 0; i < end; ++i) {
        currentSegment = currentSegments[i];
        headSegment = headSegments[i];

        if (currentSegment !== headSegment && currentSegment) {
            debug.dump("onCodePathSegmentEnd " + currentSegment.id);

            if (currentSegment.reachable) {
                analyzer.emitter.emit(
                    "onCodePathSegmentEnd",
                    currentSegment,
                    node);
            }
        }
    }

    state.currentSegments = headSegments;

    for (i = 0; i < end; ++i) {
        currentSegment = currentSegments[i];
        headSegment = headSegments[i];

        if (currentSegment !== headSegment && headSegment) {
            debug.dump("onCodePathSegmentStart " + headSegment.id);

            CodePathSegment.markUsed(headSegment);
            if (headSegment.reachable) {
                analyzer.emitter.emit(
                    "onCodePathSegmentStart",
                    headSegment,
                    node);
            }
        }
    }

}

function leaveFromCurrentSegment(analyzer, node) {
    var state = CodePath.getState(analyzer.codePath);
    var currentSegments = state.currentSegments;

    for (var i = 0; i < currentSegments.length; ++i) {
        var currentSegment = currentSegments[i];

        debug.dump("onCodePathSegmentEnd " + currentSegment.id);
        if (currentSegment.reachable) {
            analyzer.emitter.emit(
                "onCodePathSegmentEnd",
                currentSegment,
                node);
        }
    }
    state.currentSegments = [];
}

function preprocess(analyzer, node) {
    var codePath = analyzer.codePath;
    var state = CodePath.getState(codePath);
    var parent = node.parent;

    switch (parent.type) {
        case "LogicalExpression":
            if (parent.right === node) {
                state.makeLogicalRight();
            }
            break;

        case "ConditionalExpression":
        case "IfStatement":
            if (parent.consequent === node) {
                state.makeIfConsequent();
            } else if (parent.alternate === node) {
                state.makeIfAlternate();
            }
            break;

        case "SwitchCase":
            if (parent.consequent[0] === node) {
                state.makeSwitchCaseBody(false, !parent.test);
            }
            break;

        case "TryStatement":
            if (parent.handler === node) {
                state.makeCatchBlock();
            } else if (parent.finalizer === node) {
                state.makeFinallyBlock();
            }
            break;

        case "WhileStatement":
            if (parent.test === node) {
                state.makeWhileTest(getBooleanValueIfSimpleConstant(node));
            } else {
                assert(parent.body === node);
                state.makeWhileBody();
            }
            break;

        case "DoWhileStatement":
            if (parent.body === node) {
                state.makeDoWhileBody();
            } else {
                assert(parent.test === node);
                state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));
            }
            break;

        case "ForStatement":
            if (parent.test === node) {
                state.makeForTest(getBooleanValueIfSimpleConstant(node));
            } else if (parent.update === node) {
                state.makeForUpdate();
            } else if (parent.body === node) {
                state.makeForBody();
            }
            break;

        case "ForInStatement":
        case "ForOfStatement":
            if (parent.left === node) {
                state.makeForInOfLeft();
            } else if (parent.right === node) {
                state.makeForInOfRight();
            } else {
                assert(parent.body === node);
                state.makeForInOfBody();
            }
            break;

        case "AssignmentPattern":
            if (parent.right === node) {
                state.pushForkContext();
                state.forkBypassPath();
                state.forkPath();
            }
            break;

        default:
            break;
    }
}

function processCodePathToEnter(analyzer, node) {
    var codePath = analyzer.codePath;
    var state = codePath && CodePath.getState(codePath);
    var parent = node.parent;

    switch (node.type) {
        case "Program":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ArrowFunctionExpression":
            if (codePath) {
                forwardCurrentToHead(analyzer, node);
                debug.dumpState(node, state, false);
            }

            codePath = analyzer.codePath = new CodePath(
                analyzer.idGenerator.next(),
                codePath,
                analyzer.onLooped
            );
            state = CodePath.getState(codePath);

            debug.dump("onCodePathStart " + codePath.id);
            analyzer.emitter.emit("onCodePathStart", codePath, node);
            break;

        case "LogicalExpression":
            state.pushChoiceContext(node.operator, isForkingByTrueOrFalse(node));
            break;

        case "ConditionalExpression":
        case "IfStatement":
            state.pushChoiceContext("test", false);
            break;

        case "SwitchStatement":
            state.pushSwitchContext(
                node.cases.some(isCaseNode),
                astUtils.getLabel(node));
            break;

        case "TryStatement":
            state.pushTryContext(Boolean(node.finalizer));
            break;

        case "SwitchCase":
            if (parent.discriminant !== node && parent.cases[0] !== node) {
                state.forkPath();
            }
            break;

        case "WhileStatement":
        case "DoWhileStatement":
        case "ForStatement":
        case "ForInStatement":
        case "ForOfStatement":
            state.pushLoopContext(node.type, astUtils.getLabel(node));
            break;

        case "LabeledStatement":
            if (!astUtils.isBreakableStatement(node.body)) {
                state.pushBreakContext(false, node.label.name);
            }
            break;

        default:
            break;
    }

    forwardCurrentToHead(analyzer, node);
    debug.dumpState(node, state, false);
}

function processCodePathToExit(analyzer, node) {
    var codePath = analyzer.codePath;
    var state = CodePath.getState(codePath);
    var dontForward = false;

    switch (node.type) {
        case "IfStatement":
        case "ConditionalExpression":
        case "LogicalExpression":
            state.popChoiceContext();
            break;

        case "SwitchStatement":
            state.popSwitchContext();
            break;

        case "SwitchCase":
            if (node.consequent.length === 0) {
                state.makeSwitchCaseBody(true, !node.test);
            }
            if (state.forkContext.reachable) {
                dontForward = true;
            }
            break;

        case "TryStatement":
            state.popTryContext();
            break;

        case "BreakStatement":
            forwardCurrentToHead(analyzer, node);
            state.makeBreak(node.label && node.label.name);
            dontForward = true;
            break;

        case "ContinueStatement":
            forwardCurrentToHead(analyzer, node);
            state.makeContinue(node.label && node.label.name);
            dontForward = true;
            break;

        case "ReturnStatement":
            forwardCurrentToHead(analyzer, node);
            state.makeReturn();
            dontForward = true;
            break;

        case "ThrowStatement":
            forwardCurrentToHead(analyzer, node);
            state.makeThrow();
            dontForward = true;
            break;

        case "Identifier":
            if (isIdentifierReference(node)) {
                state.makeFirstThrowablePathInTryBlock();
                dontForward = true;
            }
            break;

        case "CallExpression":
        case "MemberExpression":
        case "NewExpression":
            state.makeFirstThrowablePathInTryBlock();
            break;

        case "WhileStatement":
        case "DoWhileStatement":
        case "ForStatement":
        case "ForInStatement":
        case "ForOfStatement":
            state.popLoopContext();
            break;

        case "AssignmentPattern":
            state.popForkContext();
            break;

        case "LabeledStatement":
            if (!astUtils.isBreakableStatement(node.body)) {
                state.popBreakContext();
            }
            break;

        default:
            break;
    }

    if (!dontForward && (!node.parent || node.type !== node.parent.type)) {
        forwardCurrentToHead(analyzer, node);
    }
    debug.dumpState(node, state, true);
}

function postprocess(analyzer, node) {
    switch (node.type) {
        case "Program":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ArrowFunctionExpression":
            var codePath = analyzer.codePath;

            CodePath.getState(codePath).makeFinal();

            leaveFromCurrentSegment(analyzer, node);

            debug.dump("onCodePathEnd " + codePath.id);
            analyzer.emitter.emit("onCodePathEnd", codePath, node);
            debug.dumpDot(codePath);

            codePath = analyzer.codePath = analyzer.codePath.upper;
            if (codePath) {
                debug.dumpState(node, CodePath.getState(codePath), true);
            }
            break;

        default:
            break;
    }
}

function CodePathAnalyzer(eventGenerator) {
    this.original = eventGenerator;
    this.emitter = eventGenerator.emitter;
    this.codePath = null;
    this.idGenerator = new IdGenerator("s");
    this.currentNode = null;
    this.onLooped = this.onLooped.bind(this);
}

CodePathAnalyzer.prototype = {
    constructor: CodePathAnalyzer,

    enterNode: function(node) {
        this.currentNode = node;

        if (node.parent) {
            preprocess(this, node);
        }

        processCodePathToEnter(this, node);

        this.original.enterNode(node);

        this.currentNode = null;
    },

    leaveNode: function(node) {
        this.currentNode = node;

        processCodePathToExit(this, node);

        this.original.leaveNode(node);

        postprocess(this, node);

        this.currentNode = null;
    },

    onLooped: function(fromSegment, toSegment) {
        if (fromSegment.reachable && toSegment.reachable) {
            debug.dump("onCodePathSegmentLoop " + fromSegment.id + " -> " + toSegment.id);
            this.emitter.emit(
                "onCodePathSegmentLoop",
                fromSegment,
                toSegment,
                this.currentNode
            );
        }
    }
};

module.exports = CodePathAnalyzer;

},
   {"../ast-utils":"/tmp/ast-utils.js","./code-path":"/tmp/code-path-analysis/code-path.js","./code-path-segment":"/tmp/code-path-analysis/code-path-segment.js","./debug-helpers":"/tmp/code-path-analysis/debug-helpers.js","./id-generator":"/tmp/code-path-analysis/id-generator.js","assert":"/node_modules/browserify/node_modules/assert/assert.js"}],

"/tmp/code-path-analysis/code-path-segment.js": [function(require,module,exports){
"use strict";

var assert = require("assert"),
    debug = require("./debug-helpers");

function flattenUnusedSegments(segments) {
    var done = Object.create(null);
    var retv = [];

    for (var i = 0; i < segments.length; ++i) {
        var segment = segments[i];

        if (done[segment.id]) {
            continue;
        }

        if (!segment.internal.used) {
            for (var j = 0; j < segment.allPrevSegments.length; ++j) {
                var prevSegment = segment.allPrevSegments[j];

                if (!done[prevSegment.id]) {
                    done[prevSegment.id] = true;
                    retv.push(prevSegment);
                }
            }
        } else {
            done[segment.id] = true;
            retv.push(segment);
        }
    }

    return retv;
}

function isReachable(segment) {
    return segment.reachable;
}

function CodePathSegment(id, allPrevSegments, reachable) {
    this.id = id;

    this.nextSegments = [];

    this.prevSegments = allPrevSegments.filter(isReachable);

    this.allNextSegments = [];

    this.allPrevSegments = allPrevSegments;

    this.reachable = reachable;

    Object.defineProperty(this, "internal", {value: {
        used: false,
        loopedPrevSegments: []
    }});

    if (debug.enabled) {
        this.internal.nodes = [];
        this.internal.exitNodes = [];
    }
}

CodePathSegment.prototype = {
    constructor: CodePathSegment,

    isLoopedPrevSegment: function(segment) {
        return this.internal.loopedPrevSegments.indexOf(segment) !== -1;
    }
};

CodePathSegment.newRoot = function(id) {
    return new CodePathSegment(id, [], true);
};

CodePathSegment.newNext = function(id, allPrevSegments) {
    return new CodePathSegment(
        id,
        flattenUnusedSegments(allPrevSegments),
        allPrevSegments.some(isReachable));
};

CodePathSegment.newUnreachable = function(id, allPrevSegments) {
    return new CodePathSegment(id, flattenUnusedSegments(allPrevSegments), false);
};

CodePathSegment.newDisconnected = function(id, allPrevSegments) {
    return new CodePathSegment(id, [], allPrevSegments.some(isReachable));
};

CodePathSegment.markUsed = function(segment) {
    assert(!segment.internal.used, segment.id + " is marked twice.");
    segment.internal.used = true;

    var i;
    if (segment.reachable) {
        for (i = 0; i < segment.allPrevSegments.length; ++i) {
            var prevSegment = segment.allPrevSegments[i];

            prevSegment.allNextSegments.push(segment);
            prevSegment.nextSegments.push(segment);
        }
    } else {
        for (i = 0; i < segment.allPrevSegments.length; ++i) {
            segment.allPrevSegments[i].allNextSegments.push(segment);
        }
    }
};

CodePathSegment.markPrevSegmentAsLooped = function(segment, prevSegment) {
    segment.internal.loopedPrevSegments.push(prevSegment);
};

module.exports = CodePathSegment;

},
   {"./debug-helpers":"/tmp/code-path-analysis/debug-helpers.js","assert":"/node_modules/browserify/node_modules/assert/assert.js"}],

"/tmp/code-path-analysis/code-path-state.js": [function(require,module,exports){
"use strict";

var CodePathSegment = require("./code-path-segment"),
    ForkContext = require("./fork-context");

function addToReturnedOrThrown(dest, others, all, segments) {
    for (var i = 0; i < segments.length; ++i) {
        var segment = segments[i];

        dest.push(segment);
        if (others.indexOf(segment) === -1) {
            all.push(segment);
        }
    }
}

function getContinueContext(state, label) {
    if (!label) {
        return state.loopContext;
    }

    var context = state.loopContext;
    while (context) {
        if (context.label === label) {
            return context;
        }
        context = context.upper;
    }

    return null;
}

function getBreakContext(state, label) {
    var context = state.breakContext;
    while (context) {
        if (label ? context.label === label : context.breakable) {
            return context;
        }
        context = context.upper;
    }

    return null;
}

function getReturnContext(state) {
    var context = state.tryContext;
    while (context) {
        if (context.hasFinalizer && context.position !== "finally") {
            return context;
        }
        context = context.upper;
    }

    return state;
}

function getThrowContext(state) {
    var context = state.tryContext;
    while (context) {
        if (context.position === "try" ||
            (context.hasFinalizer && context.position === "catch")
        ) {
            return context;
        }
        context = context.upper;
    }

    return state;
}

function remove(xs, x) {
    xs.splice(xs.indexOf(x), 1);
}

function removeConnection(prevSegments, nextSegments) {
    for (var i = 0; i < prevSegments.length; ++i) {
        var prevSegment = prevSegments[i];
        var nextSegment = nextSegments[i];

        remove(prevSegment.nextSegments, nextSegment);
        remove(prevSegment.allNextSegments, nextSegment);
        remove(nextSegment.prevSegments, prevSegment);
        remove(nextSegment.allPrevSegments, prevSegment);
    }
}

function makeLooped(state, fromSegments, toSegments) {
    var end = Math.min(fromSegments.length, toSegments.length);
    for (var i = 0; i < end; ++i) {
        var fromSegment = fromSegments[i];
        var toSegment = toSegments[i];

        if (toSegment.reachable) {
            fromSegment.nextSegments.push(toSegment);
        }
        if (fromSegment.reachable) {
            toSegment.prevSegments.push(fromSegment);
        }
        fromSegment.allNextSegments.push(toSegment);
        toSegment.allPrevSegments.push(fromSegment);

        if (toSegment.allPrevSegments.length >= 2) {
            CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);
        }

        state.notifyLooped(fromSegment, toSegment);
    }
}

function finalizeTestSegmentsOfFor(context, choiceContext, head) {
    if (!choiceContext.processed) {
        choiceContext.trueForkContext.add(head);
        choiceContext.falseForkContext.add(head);
    }

    if (context.test !== true) {
        context.brokenForkContext.addAll(choiceContext.falseForkContext);
    }
    context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);
}

function CodePathState(idGenerator, onLooped) {
    this.idGenerator = idGenerator;
    this.notifyLooped = onLooped;
    this.forkContext = ForkContext.newRoot(idGenerator);
    this.choiceContext = null;
    this.switchContext = null;
    this.tryContext = null;
    this.loopContext = null;
    this.breakContext = null;

    this.currentSegments = [];
    this.initialSegment = this.forkContext.head[0];

    var final = this.finalSegments = [];
    var returned = this.returnedForkContext = [];
    var thrown = this.thrownForkContext = [];
    returned.add = addToReturnedOrThrown.bind(null, returned, thrown, final);
    thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);
}

CodePathState.prototype = {
    constructor: CodePathState,

    get headSegments() {
        return this.forkContext.head;
    },

    get parentForkContext() {
        var current = this.forkContext;
        return current && current.upper;
    },

    pushForkContext: function(forkLeavingPath) {
        this.forkContext = ForkContext.newEmpty(
            this.forkContext,
            forkLeavingPath
        );

        return this.forkContext;
    },

    popForkContext: function() {
        var lastContext = this.forkContext;

        this.forkContext = lastContext.upper;
        this.forkContext.replaceHead(lastContext.makeNext(0, -1));

        return lastContext;
    },

    forkPath: function() {
        this.forkContext.add(this.parentForkContext.makeNext(-1, -1));
    },

    forkBypassPath: function() {
        this.forkContext.add(this.parentForkContext.head);
    },

    pushChoiceContext: function(kind, isForkingAsResult) {
        this.choiceContext = {
            upper: this.choiceContext,
            kind: kind,
            isForkingAsResult: isForkingAsResult,
            trueForkContext: ForkContext.newEmpty(this.forkContext),
            falseForkContext: ForkContext.newEmpty(this.forkContext),
            processed: false
        };
    },

    popChoiceContext: function() {
        var context = this.choiceContext;
        this.choiceContext = context.upper;

        var forkContext = this.forkContext;
        var headSegments = forkContext.head;

        switch (context.kind) {
            case "&&":
            case "||":
                if (!context.processed) {
                    context.trueForkContext.add(headSegments);
                    context.falseForkContext.add(headSegments);
                }

                if (context.isForkingAsResult) {
                    var parentContext = this.choiceContext;
                    parentContext.trueForkContext.addAll(context.trueForkContext);
                    parentContext.falseForkContext.addAll(context.falseForkContext);
                    parentContext.processed = true;

                    return context;
                }
                break;

            case "test":
                if (!context.processed) {
                    context.trueForkContext.clear();
                    context.trueForkContext.add(headSegments);
                } else {
                    context.falseForkContext.clear();
                    context.falseForkContext.add(headSegments);
                }
                break;

            case "loop":
                return context;

            default:
                throw new Error("unreachable");
        }

        var prevForkContext = context.trueForkContext;
        prevForkContext.addAll(context.falseForkContext);
        forkContext.replaceHead(prevForkContext.makeNext(0, -1));

        return context;
    },

    makeLogicalRight: function() {
        var context = this.choiceContext;
        var forkContext = this.forkContext;

        if (context.processed) {
            var prevForkContext =
                context.kind === "&&" ? context.trueForkContext :
                context.falseForkContext;

            forkContext.replaceHead(prevForkContext.makeNext(0, -1));
            prevForkContext.clear();

            context.processed = false;
        } else {
            if (context.kind === "&&") {
                context.falseForkContext.add(forkContext.head);
            } else {
                context.trueForkContext.add(forkContext.head);
            }

            forkContext.replaceHead(forkContext.makeNext(-1, -1));
        }
    },

    makeIfConsequent: function() {
        var context = this.choiceContext;
        var forkContext = this.forkContext;

        if (!context.processed) {
            context.trueForkContext.add(forkContext.head);
            context.falseForkContext.add(forkContext.head);
        }
        context.processed = false;

        forkContext.replaceHead(
            context.trueForkContext.makeNext(0, -1)
        );
    },

    makeIfAlternate: function() {
        var context = this.choiceContext;
        var forkContext = this.forkContext;

        context.trueForkContext.clear();
        context.trueForkContext.add(forkContext.head);
        context.processed = true;

        forkContext.replaceHead(
            context.falseForkContext.makeNext(0, -1)
        );
    },

    pushSwitchContext: function(hasCase, label) {
        this.switchContext = {
            upper: this.switchContext,
            hasCase: hasCase,
            defaultSegments: null,
            defaultBodySegments: null,
            foundDefault: false,
            lastIsDefault: false,
            countForks: 0
        };
        this.pushBreakContext(true, label);
    },

    popSwitchContext: function() {
        var context = this.switchContext;
        this.switchContext = context.upper;

        var forkContext = this.forkContext;
        var brokenForkContext = this.popBreakContext().brokenForkContext;

        if (context.countForks === 0) {
            if (!brokenForkContext.empty) {
                brokenForkContext.add(forkContext.makeNext(-1, -1));
                forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
            }
            return;
        }

        var lastSegments = forkContext.head;
        this.forkBypassPath();
        var lastCaseSegments = forkContext.head;

        brokenForkContext.add(lastSegments);

        if (!context.lastIsDefault) {
            if (context.defaultBodySegments) {
                removeConnection(context.defaultSegments, context.defaultBodySegments);
                makeLooped(this, lastCaseSegments, context.defaultBodySegments);
            } else {
                brokenForkContext.add(lastCaseSegments);
            }
        }

        for (var i = 0; i < context.countForks; ++i) {
            this.forkContext = this.forkContext.upper;
        }
        this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
    },

    makeSwitchCaseBody: function(isEmpty, isDefault) {
        var context = this.switchContext;
        if (!context.hasCase) {
            return;
        }

        var parentForkContext = this.forkContext;
        var forkContext = this.pushForkContext();
        forkContext.add(parentForkContext.makeNext(0, -1));

        if (isDefault) {
            context.defaultSegments = parentForkContext.head;
            if (isEmpty) {
                context.foundDefault = true;
            } else {
                context.defaultBodySegments = forkContext.head;
            }
        } else {
            if (!isEmpty && context.foundDefault) {
                context.foundDefault = false;
                context.defaultBodySegments = forkContext.head;
            }
        }
        context.lastIsDefault = isDefault;
        context.countForks += 1;
    },

    pushTryContext: function(hasFinalizer) {
        this.tryContext = {
            upper: this.tryContext,
            position: "try",
            hasFinalizer: hasFinalizer,
            returnedForkContext: hasFinalizer
                ? ForkContext.newEmpty(this.forkContext)
                : null,
            thrownForkContext: ForkContext.newEmpty(this.forkContext),
            lastOfTryIsReachable: false,
            lastOfCatchIsReachable: false
        };
    },

    popTryContext: function() {
        var context = this.tryContext;
        this.tryContext = context.upper;

        if (context.position === "catch") {
            this.popForkContext();
            return;
        }
        var returned = context.returnedForkContext;
        var thrown = context.thrownForkContext;
        if (returned.empty && thrown.empty) {
            return;
        }

        var headSegments = this.forkContext.head;
        this.forkContext = this.forkContext.upper;
        var normalSegments = headSegments.slice(0, headSegments.length / 2 | 0);
        var leavingSegments = headSegments.slice(headSegments.length / 2 | 0);

        if (!returned.empty) {
            getReturnContext(this).returnedForkContext.add(leavingSegments);
        }
        if (!thrown.empty) {
            getThrowContext(this).thrownForkContext.add(leavingSegments);
        }

        this.forkContext.replaceHead(normalSegments);

        if (!context.lastOfTryIsReachable && !context.lastOfCatchIsReachable) {
            this.forkContext.makeUnreachable();
        }
    },

    makeCatchBlock: function() {
        var context = this.tryContext;
        var forkContext = this.forkContext;
        var thrown = context.thrownForkContext;

        context.position = "catch";
        context.thrownForkContext = ForkContext.newEmpty(forkContext);
        context.lastOfTryIsReachable = forkContext.reachable;

        thrown.add(forkContext.head);
        var thrownSegments = thrown.makeNext(0, -1);

        this.pushForkContext();
        this.forkBypassPath();
        this.forkContext.add(thrownSegments);
    },

    makeFinallyBlock: function() {
        var context = this.tryContext;
        var forkContext = this.forkContext;
        var returned = context.returnedForkContext;
        var thrown = context.thrownForkContext;
        var headOfLeavingSegments = forkContext.head;

        if (context.position === "catch") {
            this.popForkContext();
            forkContext = this.forkContext;

            context.lastOfCatchIsReachable = forkContext.reachable;
        } else {
            context.lastOfTryIsReachable = forkContext.reachable;
        }
        context.position = "finally";

        if (returned.empty && thrown.empty) {
            return;
        }

        var segments = forkContext.makeNext(-1, -1);
        var j;
        for (var i = 0; i < forkContext.count; ++i) {
            var prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];

            for (j = 0; j < returned.segmentsList.length; ++j) {
                prevSegsOfLeavingSegment.push(returned.segmentsList[j][i]);
            }
            for (j = 0; j < thrown.segmentsList.length; ++j) {
                prevSegsOfLeavingSegment.push(thrown.segmentsList[j][i]);
            }

            segments.push(CodePathSegment.newNext(
                this.idGenerator.next(),
                prevSegsOfLeavingSegment));
        }

        this.pushForkContext(true);
        this.forkContext.add(segments);
    },

    makeFirstThrowablePathInTryBlock: function() {
        var forkContext = this.forkContext;
        if (!forkContext.reachable) {
            return;
        }

        var context = getThrowContext(this);
        if (context === this ||
            context.position !== "try" ||
            !context.thrownForkContext.empty
        ) {
            return;
        }

        context.thrownForkContext.add(forkContext.head);
        forkContext.replaceHead(forkContext.makeNext(-1, -1));
    },

    pushLoopContext: function(type, label) {
        var forkContext = this.forkContext;
        var breakContext = this.pushBreakContext(true, label);

        switch (type) {
            case "WhileStatement":
                this.pushChoiceContext("loop", false);
                this.loopContext = {
                    upper: this.loopContext,
                    type: type,
                    label: label,
                    test: void 0,
                    continueDestSegments: null,
                    brokenForkContext: breakContext.brokenForkContext
                };
                break;

            case "DoWhileStatement":
                this.pushChoiceContext("loop", false);
                this.loopContext = {
                    upper: this.loopContext,
                    type: type,
                    label: label,
                    test: void 0,
                    entrySegments: null,
                    continueForkContext: ForkContext.newEmpty(forkContext),
                    brokenForkContext: breakContext.brokenForkContext
                };
                break;

            case "ForStatement":
                this.pushChoiceContext("loop", false);
                this.loopContext = {
                    upper: this.loopContext,
                    type: type,
                    label: label,
                    test: void 0,
                    endOfInitSegments: null,
                    testSegments: null,
                    endOfTestSegments: null,
                    updateSegments: null,
                    endOfUpdateSegments: null,
                    continueDestSegments: null,
                    brokenForkContext: breakContext.brokenForkContext
                };
                break;

            case "ForInStatement":
            case "ForOfStatement":
                this.loopContext = {
                    upper: this.loopContext,
                    type: type,
                    label: label,
                    prevSegments: null,
                    leftSegments: null,
                    endOfLeftSegments: null,
                    continueDestSegments: null,
                    brokenForkContext: breakContext.brokenForkContext
                };
                break;

            default:
                throw new Error("unknown type: \"" + type + "\"");
        }
    },

    popLoopContext: function() {
        var context = this.loopContext;
        this.loopContext = context.upper;

        var forkContext = this.forkContext;
        var brokenForkContext = this.popBreakContext().brokenForkContext;
        var choiceContext;

        switch (context.type) {
            case "WhileStatement":
            case "ForStatement":
                choiceContext = this.popChoiceContext();
                makeLooped(
                    this,
                    forkContext.head,
                    context.continueDestSegments);
                break;

            case "DoWhileStatement":
                choiceContext = this.popChoiceContext();

                if (!choiceContext.processed) {
                    choiceContext.trueForkContext.add(forkContext.head);
                    choiceContext.falseForkContext.add(forkContext.head);
                }
                if (context.test !== true) {
                    brokenForkContext.addAll(choiceContext.falseForkContext);
                }

                var segmentsList = choiceContext.trueForkContext.segmentsList;
                for (var i = 0; i < segmentsList.length; ++i) {
                    makeLooped(
                        this,
                        segmentsList[i],
                        context.entrySegments);
                }
                break;

            case "ForInStatement":
            case "ForOfStatement":
                brokenForkContext.add(forkContext.head);
                makeLooped(
                    this,
                    forkContext.head,
                    context.leftSegments);
                break;

            default:
                throw new Error("unreachable");
        }

        if (brokenForkContext.empty) {
            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
        } else {
            forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
        }
    },

    makeWhileTest: function(test) {
        var context = this.loopContext;
        var forkContext = this.forkContext;
        var testSegments = forkContext.makeNext(0, -1);

        context.test = test;
        context.continueDestSegments = testSegments;
        forkContext.replaceHead(testSegments);
    },

    makeWhileBody: function() {
        var context = this.loopContext;
        var choiceContext = this.choiceContext;
        var forkContext = this.forkContext;

        if (!choiceContext.processed) {
            choiceContext.trueForkContext.add(forkContext.head);
            choiceContext.falseForkContext.add(forkContext.head);
        }

        if (context.test !== true) {
            context.brokenForkContext.addAll(choiceContext.falseForkContext);
        }
        forkContext.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));
    },

    makeDoWhileBody: function() {
        var context = this.loopContext;
        var forkContext = this.forkContext;
        var bodySegments = forkContext.makeNext(-1, -1);

        context.entrySegments = bodySegments;
        forkContext.replaceHead(bodySegments);
    },

    makeDoWhileTest: function(test) {
        var context = this.loopContext;
        var forkContext = this.forkContext;

        context.test = test;

        if (!context.continueForkContext.empty) {
            context.continueForkContext.add(forkContext.head);
            var testSegments = context.continueForkContext.makeNext(0, -1);

            forkContext.replaceHead(testSegments);
        }
    },

    makeForTest: function(test) {
        var context = this.loopContext;
        var forkContext = this.forkContext;
        var endOfInitSegments = forkContext.head;
        var testSegments = forkContext.makeNext(-1, -1);

        context.test = test;
        context.endOfInitSegments = endOfInitSegments;
        context.continueDestSegments = context.testSegments = testSegments;
        forkContext.replaceHead(testSegments);
    },

    makeForUpdate: function() {
        var context = this.loopContext;
        var choiceContext = this.choiceContext;
        var forkContext = this.forkContext;

        if (context.testSegments) {
            finalizeTestSegmentsOfFor(
                context,
                choiceContext,
                forkContext.head);
        } else {
            context.endOfInitSegments = forkContext.head;
        }

        var updateSegments = forkContext.makeDisconnected(-1, -1);
        context.continueDestSegments = context.updateSegments = updateSegments;
        forkContext.replaceHead(updateSegments);
    },

    makeForBody: function() {
        var context = this.loopContext;
        var choiceContext = this.choiceContext;
        var forkContext = this.forkContext;

        if (context.updateSegments) {
            context.endOfUpdateSegments = forkContext.head;

            if (context.testSegments) {
                makeLooped(
                    this,
                    context.endOfUpdateSegments,
                    context.testSegments);
            }
        } else if (context.testSegments) {
            finalizeTestSegmentsOfFor(
                context,
                choiceContext,
                forkContext.head);
        } else {
            context.endOfInitSegments = forkContext.head;
        }

        var bodySegments = context.endOfTestSegments;
        if (!bodySegments) {
            var prevForkContext = ForkContext.newEmpty(forkContext);
            prevForkContext.add(context.endOfInitSegments);
            if (context.endOfUpdateSegments) {
                prevForkContext.add(context.endOfUpdateSegments);
            }

            bodySegments = prevForkContext.makeNext(0, -1);
        }
        context.continueDestSegments = context.continueDestSegments || bodySegments;
        forkContext.replaceHead(bodySegments);
    },

    makeForInOfLeft: function() {
        var context = this.loopContext;
        var forkContext = this.forkContext;
        var leftSegments = forkContext.makeDisconnected(-1, -1);

        context.prevSegments = forkContext.head;
        context.leftSegments = context.continueDestSegments = leftSegments;
        forkContext.replaceHead(leftSegments);
    },

    makeForInOfRight: function() {
        var context = this.loopContext;
        var forkContext = this.forkContext;
        var temp = ForkContext.newEmpty(forkContext);
        temp.add(context.prevSegments);
        var rightSegments = temp.makeNext(-1, -1);

        context.endOfLeftSegments = forkContext.head;
        forkContext.replaceHead(rightSegments);
    },

    makeForInOfBody: function() {
        var context = this.loopContext;
        var forkContext = this.forkContext;
        var temp = ForkContext.newEmpty(forkContext);
        temp.add(context.endOfLeftSegments);
        var bodySegments = temp.makeNext(-1, -1);

        makeLooped(this, forkContext.head, context.leftSegments);

        context.brokenForkContext.add(forkContext.head);
        forkContext.replaceHead(bodySegments);
    },

    pushBreakContext: function(breakable, label) {
        this.breakContext = {
            upper: this.breakContext,
            breakable: breakable,
            label: label,
            brokenForkContext: ForkContext.newEmpty(this.forkContext)
        };
        return this.breakContext;
    },

    popBreakContext: function() {
        var context = this.breakContext;
        var forkContext = this.forkContext;
        this.breakContext = context.upper;

        if (!context.breakable) {
            var brokenForkContext = context.brokenForkContext;
            if (!brokenForkContext.empty) {
                brokenForkContext.add(forkContext.head);
                forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
            }
        }

        return context;
    },

    makeBreak: function(label) {
        var forkContext = this.forkContext;
        if (!forkContext.reachable) {
            return;
        }

        var context = getBreakContext(this, label);
        if (context) {
            context.brokenForkContext.add(forkContext.head);
        }
        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
    },

    makeContinue: function(label) {
        var forkContext = this.forkContext;
        if (!forkContext.reachable) {
            return;
        }

        var context = getContinueContext(this, label);
        if (context) {
            if (context.continueDestSegments) {
                makeLooped(this, forkContext.head, context.continueDestSegments);

                if (context.type === "ForInStatement" ||
                    context.type === "ForOfStatement"
                ) {
                    context.brokenForkContext.add(forkContext.head);
                }
            } else {
                context.continueForkContext.add(forkContext.head);
            }
        }
        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
    },

    makeReturn: function() {
        var forkContext = this.forkContext;
        if (forkContext.reachable) {
            getReturnContext(this).returnedForkContext.add(forkContext.head);
            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
        }
    },

    makeThrow: function() {
        var forkContext = this.forkContext;
        if (forkContext.reachable) {
            getThrowContext(this).thrownForkContext.add(forkContext.head);
            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
        }
    },

    makeFinal: function() {
        var segments = this.currentSegments;
        if (segments.length > 0 && segments[0].reachable) {
            this.returnedForkContext.add(segments);
        }
    }
};

module.exports = CodePathState;

},
   {"./code-path-segment":"/tmp/code-path-analysis/code-path-segment.js","./fork-context":"/tmp/code-path-analysis/fork-context.js"}],

"/tmp/code-path-analysis/code-path.js": [function(require,module,exports){
"use strict";

var CodePathState = require("./code-path-state");
var IdGenerator = require("./id-generator");

function CodePath(id, upper, onLooped) {
    this.id = id;

    this.upper = upper;

    this.childCodePaths = [];

    Object.defineProperty(
        this,
        "internal",
        {value: new CodePathState(new IdGenerator(id + "_"), onLooped)});

    if (upper) {
        upper.childCodePaths.push(this);
    }
}

CodePath.prototype = {
    constructor: CodePath,

    get initialSegment() {
        return this.internal.initialSegment;
    },

    get finalSegments() {
        return this.internal.finalSegments;
    },

    get returnedSegments() {
        return this.internal.returnedForkContext;
    },

    get thrownSegments() {
        return this.internal.thrownForkContext;
    },

    get currentSegments() {
        return this.internal.currentSegments;
    },

    traverseSegments: function(options, callback) {
        if (typeof options === "function") {
            callback = options;
            options = null;
        }

        options = options || {};
        var startSegment = options.first || this.internal.initialSegment;
        var lastSegment = options.last;

        var item = null;
        var index = 0;
        var end = 0;
        var segment = null;
        var visited = Object.create(null);
        var stack = [[startSegment, 0]];
        var skippedSegment = null;
        var broken = false;
        var controller = {
            skip: function() {
                if (stack.length <= 1) {
                    broken = true;
                } else {
                    skippedSegment = stack[stack.length - 2][0];
                }
            },
            break: function() {
                broken = true;
            }
        };

        function isVisited(prevSegment) {
            return (
                visited[prevSegment.id] ||
                segment.isLoopedPrevSegment(prevSegment)
            );
        }

        while (stack.length > 0) {
            item = stack[stack.length - 1];
            segment = item[0];
            index = item[1];

            if (index === 0) {
                if (visited[segment.id]) {
                    stack.pop();
                    continue;
                }
                if (segment !== startSegment &&
                    segment.prevSegments.length > 0 &&
                    !segment.prevSegments.every(isVisited)
                ) {
                    stack.pop();
                    continue;
                }
                if (skippedSegment && segment.prevSegments.indexOf(skippedSegment) !== -1) {
                    skippedSegment = null;
                }
                visited[segment.id] = true;

                if (!skippedSegment) {
                    callback.call(this, segment, controller); // eslint-disable-line callback-return
                    if (segment === lastSegment) {
                        controller.skip();
                    }
                    if (broken) {
                        break;
                    }
                }
            }

            end = segment.nextSegments.length - 1;
            if (index < end) {
                item[1] += 1;
                stack.push([segment.nextSegments[index], 0]);
            } else if (index === end) {
                item[0] = segment.nextSegments[index];
                item[1] = 0;
            } else {
                stack.pop();
            }
        }
    }
};

CodePath.getState = function getState(codePath) {
    return codePath.internal;
};

module.exports = CodePath;

},
   {"./code-path-state":"/tmp/code-path-analysis/code-path-state.js","./id-generator":"/tmp/code-path-analysis/id-generator.js"}],

"/tmp/code-path-analysis/debug-helpers.js": [function(require,module,exports){
"use strict";

var debug = require("debug")("eslint:code-path");

function getId(segment) { // eslint-disable-line require-jsdoc
    return segment.id + (segment.reachable ? "" : "!");
}

module.exports = {
    enabled: debug.enabled,

    dump: debug,

    dumpState: !debug.enabled ? debug : /* istanbul ignore next */ function(node, state, leaving) {
        for (var i = 0; i < state.currentSegments.length; ++i) {
            var segInternal = state.currentSegments[i].internal;
            if (leaving) {
                segInternal.exitNodes.push(node);
            } else {
                segInternal.nodes.push(node);
            }
        }

        debug(
            state.currentSegments.map(getId).join(",") + ") " +
            node.type + (leaving ? ":exit" : "")
        );
    },

    dumpDot: !debug.enabled ? debug : /* istanbul ignore next */ function(codePath) {
        var text =
            "\n" +
            "digraph {\n" +
            "node[shape=box,style=\"rounded,filled\",fillcolor=white];\n" +
            "initial[label=\"\",shape=circle,style=filled,fillcolor=black,width=0.25,height=0.25];\n";

        if (codePath.returnedSegments.length > 0) {
            text += "final[label=\"\",shape=doublecircle,style=filled,fillcolor=black,width=0.25,height=0.25];\n";
        }
        if (codePath.thrownSegments.length > 0) {
            text += "thrown[label=\"\",shape=circle,width=0.3,height=0.3,fixedsize];\n";
        }

        var traceMap = Object.create(null);
        var arrows = this.makeDotArrows(codePath, traceMap);

        for (var id in traceMap) { // eslint-disable-line guard-for-in
            var segment = traceMap[id];

            text += id + "[";

            if (segment.reachable) {
                text += "label=\"";
            } else {
                text += "style=\"rounded,dashed,filled\",fillcolor=\"#FF9800\",label=\"<<unreachable>>\\n";
            }

            if (segment.internal.nodes.length > 0) {
                text += segment.internal.nodes.map(function(node) {
                    switch (node.type) {
                        case "Identifier": return node.type + " (" + node.name + ")";
                        case "Literal": return node.type + " (" + node.value + ")";
                        default: return node.type;
                    }
                }).join("\\n");
            } else if (segment.internal.exitNodes.length > 0) {
                text += segment.internal.exitNodes.map(function(node) {
                    switch (node.type) {
                        case "Identifier": return node.type + ":exit (" + node.name + ")";
                        case "Literal": return node.type + ":exit (" + node.value + ")";
                        default: return node.type + ":exit";
                    }
                }).join("\\n");
            } else {
                text += "????";
            }

            text += "\"];\n";
        }

        text += arrows + "\n";
        text += "}";
        debug("DOT", text);
    },

    makeDotArrows: function(codePath, traceMap) {
        var stack = [[codePath.initialSegment, 0]];
        var done = traceMap || Object.create(null);
        var lastId = codePath.initialSegment.id;
        var text = "initial->" + codePath.initialSegment.id;

        while (stack.length > 0) {
            var item = stack.pop();
            var segment = item[0];
            var index = item[1];
            if (done[segment.id] && index === 0) {
                continue;
            }
            done[segment.id] = segment;

            var nextSegment = segment.allNextSegments[index];
            if (!nextSegment) {
                continue;
            }

            if (lastId === segment.id) {
                text += "->" + nextSegment.id;
            } else {
                text += ";\n" + segment.id + "->" + nextSegment.id;
            }
            lastId = nextSegment.id;

            stack.unshift([segment, 1 + index]);
            stack.push([nextSegment, 0]);
        }

        codePath.returnedSegments.forEach(function(finalSegment) {
            if (lastId === finalSegment.id) {
                text += "->final";
            } else {
                text += ";\n" + finalSegment.id + "->final";
            }
            lastId = null;
        });

        codePath.thrownSegments.forEach(function(finalSegment) {
            if (lastId === finalSegment.id) {
                text += "->thrown";
            } else {
                text += ";\n" + finalSegment.id + "->thrown";
            }
            lastId = null;
        });

        return text + ";";
    }
};

},
   {"debug":"/node_modules/debug/browser.js"}],

"/tmp/code-path-analysis/fork-context.js": [function(require,module,exports){
"use strict";

var assert = require("assert"),
    CodePathSegment = require("./code-path-segment");

function isReachable(segment) {
    return segment.reachable;
}

function makeSegments(context, begin, end, create) {
    var list = context.segmentsList;
    if (begin < 0) {
        begin = list.length + begin;
    }
    if (end < 0) {
        end = list.length + end;
    }

    var segments = [];
    for (var i = 0; i < context.count; ++i) {
        var allPrevSegments = [];

        for (var j = begin; j <= end; ++j) {
            allPrevSegments.push(list[j][i]);
        }

        segments.push(create(context.idGenerator.next(), allPrevSegments));
    }

    return segments;
}

function mergeExtraSegments(context, segments) {
    while (segments.length > context.count) {
        var merged = [];
        for (var i = 0, length = segments.length / 2 | 0; i < length; ++i) {
            merged.push(CodePathSegment.newNext(
                context.idGenerator.next(),
                [segments[i], segments[i + length]]
            ));
        }
        segments = merged;
    }
    return segments;
}

function ForkContext(idGenerator, upper, count) {
    this.idGenerator = idGenerator;
    this.upper = upper;
    this.count = count;
    this.segmentsList = [];
}

ForkContext.prototype = {
    constructor: ForkContext,

    get head() {
        var list = this.segmentsList;
        return list.length === 0 ? [] : list[list.length - 1];
    },

    get empty() {
        return this.segmentsList.length === 0;
    },

    get reachable() {
        var segments = this.head;
        return segments.length > 0 && segments.some(isReachable);
    },

    makeNext: function(begin, end) {
        return makeSegments(this, begin, end, CodePathSegment.newNext);
    },

    makeUnreachable: function(begin, end) {
        return makeSegments(this, begin, end, CodePathSegment.newUnreachable);
    },

    makeDisconnected: function(begin, end) {
        return makeSegments(this, begin, end, CodePathSegment.newDisconnected);
    },

    add: function(segments) {
        assert(segments.length >= this.count, segments.length + " >= " + this.count);

        this.segmentsList.push(mergeExtraSegments(this, segments));
    },

    replaceHead: function(segments) {
        assert(segments.length >= this.count, segments.length + " >= " + this.count);

        this.segmentsList.splice(-1, 1, mergeExtraSegments(this, segments));
    },

    addAll: function(context) {
        assert(context.count === this.count);

        var source = context.segmentsList;
        for (var i = 0; i < source.length; ++i) {
            this.segmentsList.push(source[i]);
        }
    },

    clear: function() {
        this.segmentsList = [];
    }
};

ForkContext.newRoot = function(idGenerator) {
    var context = new ForkContext(idGenerator, null, 1);

    context.add([CodePathSegment.newRoot(idGenerator.next())]);

    return context;
};

ForkContext.newEmpty = function(parentContext, forkLeavingPath) {
    return new ForkContext(
        parentContext.idGenerator,
        parentContext,
        (forkLeavingPath ? 2 : 1) * parentContext.count);
};

module.exports = ForkContext;

},
   {"./code-path-segment":"/tmp/code-path-analysis/code-path-segment.js","assert":"/node_modules/browserify/node_modules/assert/assert.js"}],

"/tmp/code-path-analysis/id-generator.js": [function(require,module,exports){
"use strict";

function IdGenerator(prefix) {
    this.prefix = String(prefix);
    this.n = 0;
}

IdGenerator.prototype.next = function() {
    this.n = 1 + this.n | 0;
    if (this.n < 0) {
        this.n = 1;
    }
    return this.prefix + this.n;
};

module.exports = IdGenerator;

},
   {}],

"/tmp/config/config-ops.js": [function(require,module,exports){
"use strict";

var lodash = require("lodash"),
    debug = require("debug"),
    Environments = require("./environments");

debug = debug("eslint:config-ops");

var RULE_SEVERITY_STRINGS = ["off", "warn", "error"],
    RULE_SEVERITY = RULE_SEVERITY_STRINGS.reduce(function(map, value, index) {
        map[value] = index;
        return map;
    }, {});

module.exports = {

    createEmptyConfig: function() {
        return {
            globals: {},
            env: {},
            rules: {},
            parserOptions: {}
        };
    },

    createEnvironmentConfig: function(env) {

        var envConfig = this.createEmptyConfig();

        if (env) {

            envConfig.env = env;

            Object.keys(env).filter(function(name) {
                return env[name];
            }).forEach(function(name) {
                var environment = Environments.get(name);

                if (environment) {
                    debug("Creating config for environment " + name);
                    if (environment.globals) {
                        lodash.assign(envConfig.globals, environment.globals);
                    }

                    if (environment.parserOptions) {
                        lodash.assign(envConfig.parserOptions, environment.parserOptions);
                    }
                }
            });
        }

        return envConfig;
    },

    applyEnvironments: function(config) {
        if (config.env && typeof config.env === "object") {
            debug("Apply environment settings to config");
            return this.merge(this.createEnvironmentConfig(config.env), config);
        }

        return config;
    },

    merge: function deepmerge(target, src, combine, isRule) {
        var array = Array.isArray(src) || Array.isArray(target);
        var dst = array && [] || {};

        combine = !!combine;
        isRule = !!isRule;
        if (array) {
            target = target || [];

            if (isRule && Array.isArray(src) && src.length > 1) {
                dst = dst.concat(src);
            } else {
                dst = dst.concat(target);
            }
            if (typeof src !== "object" && !Array.isArray(src)) {
                src = [src];
            }
            Object.keys(src).forEach(function(e, i) {
                e = src[i];
                if (typeof dst[i] === "undefined") {
                    dst[i] = e;
                } else if (typeof e === "object") {
                    if (isRule) {
                        dst[i] = e;
                    } else {
                        dst[i] = deepmerge(target[i], e, combine, isRule);
                    }
                } else {
                    if (!combine) {
                        dst[i] = e;
                    } else {
                        if (dst.indexOf(e) === -1) {
                            dst.push(e);
                        }
                    }
                }
            });
        } else {
            if (target && typeof target === "object") {
                Object.keys(target).forEach(function(key) {
                    dst[key] = target[key];
                });
            }
            Object.keys(src).forEach(function(key) {
                if (Array.isArray(src[key]) || Array.isArray(target[key])) {
                    dst[key] = deepmerge(target[key], src[key], key === "plugins", isRule);
                } else if (typeof src[key] !== "object" || !src[key] || key === "exported" || key === "astGlobals") {
                    dst[key] = src[key];
                } else {
                    dst[key] = deepmerge(target[key] || {}, src[key], combine, key === "rules");
                }
            });
        }

        return dst;
    },

    normalize: function(config) {

        if (config.rules) {
            Object.keys(config.rules).forEach(function(ruleId) {
                var ruleConfig = config.rules[ruleId];

                if (typeof ruleConfig === "string") {
                    config.rules[ruleId] = RULE_SEVERITY[ruleConfig.toLowerCase()] || 0;
                } else if (Array.isArray(ruleConfig) && typeof ruleConfig[0] === "string") {
                    ruleConfig[0] = RULE_SEVERITY[ruleConfig[0].toLowerCase()] || 0;
                }
            });
        }
    },

    normalizeToStrings: function(config) {

        if (config.rules) {
            Object.keys(config.rules).forEach(function(ruleId) {
                var ruleConfig = config.rules[ruleId];

                if (typeof ruleConfig === "number") {
                    config.rules[ruleId] = RULE_SEVERITY_STRINGS[ruleConfig] || RULE_SEVERITY_STRINGS[0];
                } else if (Array.isArray(ruleConfig) && typeof ruleConfig[0] === "number") {
                    ruleConfig[0] = RULE_SEVERITY_STRINGS[ruleConfig[0]] || RULE_SEVERITY_STRINGS[0];
                }
            });
        }
    },

    isErrorSeverity: function(ruleConfig) {

        var severity = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;

        if (typeof severity === "string") {
            severity = RULE_SEVERITY[severity.toLowerCase()] || 0;
        }

        return (typeof severity === "number" && severity === 2);
    }

};

},
   {"./environments":"/tmp/config/environments.js","debug":"/node_modules/debug/browser.js","lodash":"/node_modules/lodash/lodash.js"}],

"/tmp/config/config-validator.js": [function(require,module,exports){
"use strict";

var rules = require("../rules"),
    Environments = require("./environments"),
    schemaValidator = require("is-my-json-valid");

var validators = {
    rules: Object.create(null)
};

function getRuleOptionsSchema(id) {
    var rule = rules.get(id),
        schema = rule && rule.schema || rule && rule.meta && rule.meta.schema;

    if (Array.isArray(schema)) {
        if (schema.length) {
            return {
                "type": "array",
                "items": schema,
                "minItems": 0,
                "maxItems": schema.length
            };
        } else {
            return {
                "type": "array",
                "minItems": 0,
                "maxItems": 0
            };
        }
    }

    return schema || null;
}

function validateRuleOptions(id, options, source) {
    var validateRule = validators.rules[id],
        message,
        severity,
        localOptions,
        schema = getRuleOptionsSchema(id),
        validSeverity = true;

    if (!validateRule && schema) {
        validateRule = schemaValidator(schema, { verbose: true });
        validators.rules[id] = validateRule;
    }

    if (Array.isArray(options)) {
        localOptions = options.concat();    // clone
        severity = localOptions.shift();
    } else {
        severity = options;
        localOptions = [];
    }



    if (validateRule) {
        validateRule(localOptions);
    }

    if ((validateRule && validateRule.errors) || !validSeverity) {
        message = [
            source, ":\n",
            "\tConfiguration for rule \"", id, "\" is invalid:\n"
        ];

        if (!validSeverity) {
            message.push(
                "\tSeverity should be one of the following: 0 = off, 1 = warning, 2 = error (you passed \"", severity, "\").\n");
        }

        if (validateRule && validateRule.errors) {
            validateRule.errors.forEach(function(error) {
                message.push(
                    "\tValue \"", error.value, "\" ", error.message, ".\n"
                );
            });
        }

        throw new Error(message.join(""));
    }
}

function validateEnvironment(environment, source) {

    if (!environment) {
        return;
    }

    if (Array.isArray(environment)) {
        throw new Error("Environment must not be an array");
    }

    if (typeof environment === "object") {
        Object.keys(environment).forEach(function(env) {
            if (!Environments.get(env)) {
                var message = [
                    source, ":\n",
                    "\tEnvironment key \"", env, "\" is unknown\n"
                ];
                throw new Error(message.join(""));
            }
        });
    } else {
        throw new Error("Environment must be an object");
    }
}

function validate(config, source) {

    if (typeof config.rules === "object") {
        Object.keys(config.rules).forEach(function(id) {
            validateRuleOptions(id, config.rules[id], source);
        });
    }

    validateEnvironment(config.env, source);
}

module.exports = {
    getRuleOptionsSchema: getRuleOptionsSchema,
    validate: validate,
    validateRuleOptions: validateRuleOptions
};

},
   {"../rules":"/tmp/rules.js","./environments":"/tmp/config/environments.js","is-my-json-valid":"/node_modules/is-my-json-valid/index.js"}],

"/tmp/config/environments.js": [function(require,module,exports){
"use strict";

var debug = require("debug"),
    envs = require("../../conf/environments");

debug = debug("eslint:enviroments");

var environments = Object.create(null);

function load() {
    Object.keys(envs).forEach(function(envName) {
        environments[envName] = envs[envName];
    });
}

load();

module.exports = {

    load: load,

    get: function(name) {
        return environments[name] || null;
    },

    define: function(name, env) {
        environments[name] = env;
    },

    importPlugin: function(plugin, pluginName) {
        if (plugin.environments) {
            Object.keys(plugin.environments).forEach(function(envName) {
                this.define(pluginName + "/" + envName, plugin.environments[envName]);
            }, this);
        }
    },

    testReset: function() {
        environments = Object.create(null);
        load();
    }
};

},
   {"../../conf/environments":"/conf/environments.js","debug":"/node_modules/debug/browser.js"}],

"/tmp/eslint.js": [function(require,module,exports){
"use strict";

var lodash = require("lodash"),
    espree = require("espree"),
    estraverse = require("estraverse"),
    escope = require("escope"),
    Environments = require("./config/environments"),
    blankScriptAST = require("../conf/blank-script.json"),
    rules = require("./rules"),
    RuleContext = require("./rule-context"),
    timing = require("./timing"),
    SourceCode = require("./util/source-code"),
    NodeEventGenerator = require("./util/node-event-generator"),
    CommentEventGenerator = require("./util/comment-event-generator"),
    EventEmitter = require("events").EventEmitter,
    ConfigOps = require("./config/config-ops"),
    validator = require("./config/config-validator"),
    replacements = require("../conf/replacements.json"),
    assert = require("assert"),
    CodePathAnalyzer = require("./code-path-analysis/code-path-analyzer");

var DEFAULT_PARSER = require("../conf/eslint.json").parser;

function parseBooleanConfig(string, comment) {
    var items = {};
    string = string.replace(/\s*:\s*/g, ":");
    string = string.replace(/\s*,\s*/g, ",");
    string.split(/\s|,+/).forEach(function(name) {
        if (!name) {
            return;
        }
        var pos = name.indexOf(":"),
            value;
        if (pos !== -1) {
            value = name.substring(pos + 1, name.length);
            name = name.substring(0, pos);
        }

        items[name] = {
            value: (value === "true"),
            comment: comment
        };

    });
    return items;
}

function parseJsonConfig(string, location, messages) {
    var items = {};
    string = string.replace(/([a-zA-Z0-9\-\/]+):/g, "\"$1\":").replace(/(\]|[0-9])\s+(?=")/, "$1,");
    try {
        items = JSON.parse("{" + string + "}");
    } catch (ex) {

        messages.push({
            ruleId: null,
            fatal: true,
            severity: 2,
            source: null,
            message: "Failed to parse JSON from '" + string + "': " + ex.message,
            line: location.start.line,
            column: location.start.column + 1
        });

    }

    return items;
}

function parseListConfig(string) {
    var items = {};
    string = string.replace(/\s*,\s*/g, ",");
    string.split(/,+/).forEach(function(name) {
        name = name.trim();
        if (!name) {
            return;
        }
        items[name] = true;
    });
    return items;
}

function addDeclaredGlobals(program, globalScope, config) {
    var declaredGlobals = {},
        exportedGlobals = {},
        explicitGlobals = {},
        builtin = Environments.get("builtin");

    lodash.assign(declaredGlobals, builtin);

    Object.keys(config.env).forEach(function(name) {
        if (config.env[name]) {
            var env = Environments.get(name),
                environmentGlobals = env && env.globals;
            if (environmentGlobals) {
                lodash.assign(declaredGlobals, environmentGlobals);
            }
        }
    });

    lodash.assign(exportedGlobals, config.exported);
    lodash.assign(declaredGlobals, config.globals);
    lodash.assign(explicitGlobals, config.astGlobals);

    Object.keys(declaredGlobals).forEach(function(name) {
        var variable = globalScope.set.get(name);
        if (!variable) {
            variable = new escope.Variable(name, globalScope);
            variable.eslintExplicitGlobal = false;
            globalScope.variables.push(variable);
            globalScope.set.set(name, variable);
        }
        variable.writeable = declaredGlobals[name];
    });

    Object.keys(explicitGlobals).forEach(function(name) {
        var variable = globalScope.set.get(name);
        if (!variable) {
            variable = new escope.Variable(name, globalScope);
            variable.eslintExplicitGlobal = true;
            variable.eslintExplicitGlobalComment = explicitGlobals[name].comment;
            globalScope.variables.push(variable);
            globalScope.set.set(name, variable);
        }
        variable.writeable = explicitGlobals[name].value;
    });

    Object.keys(exportedGlobals).forEach(function(name) {
        var variable = globalScope.set.get(name);
        if (variable) {
            variable.eslintUsed = true;
        }
    });

    globalScope.through = globalScope.through.filter(function(reference) {
        var name = reference.identifier.name;
        var variable = globalScope.set.get(name);
        if (variable) {
            reference.resolved = variable;
            variable.references.push(reference);
            return false;
        }
        return true;
    });
}

function disableReporting(reportingConfig, start, rulesToDisable) {

    if (rulesToDisable.length) {
        rulesToDisable.forEach(function(rule) {
            reportingConfig.push({
                start: start,
                end: null,
                rule: rule
            });
        });
    } else {
        reportingConfig.push({
            start: start,
            end: null,
            rule: null
        });
    }
}

function enableReporting(reportingConfig, start, rulesToEnable) {
    var i;

    if (rulesToEnable.length) {
        rulesToEnable.forEach(function(rule) {
            for (i = reportingConfig.length - 1; i >= 0; i--) {
                if (!reportingConfig[i].end && reportingConfig[i].rule === rule ) {
                    reportingConfig[i].end = start;
                    break;
                }
            }
        });
    } else {
        var prevStart;
        for (i = reportingConfig.length - 1; i >= 0; i--) {
            if (prevStart && prevStart !== reportingConfig[i].start) {
                break;
            }

            if (!reportingConfig[i].end) {
                reportingConfig[i].end = start;
                prevStart = reportingConfig[i].start;
            }
        }
    }
}

function modifyConfigsFromComments(filename, ast, config, reportingConfig, messages) {

    var commentConfig = {
        exported: {},
        astGlobals: {},
        rules: {},
        env: {}
    };
    var commentRules = {};

    ast.comments.forEach(function(comment) {

        var value = comment.value.trim();
        var match = /^(eslint(-\w+){0,3}|exported|globals?)(\s|$)/.exec(value);

        if (match) {
            value = value.substring(match.index + match[1].length);

            if (comment.type === "Block") {
                switch (match[1]) {
                    case "exported":
                        lodash.assign(commentConfig.exported, parseBooleanConfig(value, comment));
                        break;

                    case "globals":
                    case "global":
                        lodash.assign(commentConfig.astGlobals, parseBooleanConfig(value, comment));
                        break;

                    case "eslint-env":
                        lodash.assign(commentConfig.env, parseListConfig(value));
                        break;

                    case "eslint-disable":
                        disableReporting(reportingConfig, comment.loc.start, Object.keys(parseListConfig(value)));
                        break;

                    case "eslint-enable":
                        enableReporting(reportingConfig, comment.loc.start, Object.keys(parseListConfig(value)));
                        break;

                    case "eslint":
                        var items = parseJsonConfig(value, comment.loc, messages);
                        Object.keys(items).forEach(function(name) {
                            var ruleValue = items[name];
                            validator.validateRuleOptions(name, ruleValue, filename + " line " + comment.loc.start.line);
                            commentRules[name] = ruleValue;
                        });
                        break;

                }
            } else {
                if (match[1] === "eslint-disable-line") {
                    disableReporting(reportingConfig, { "line": comment.loc.start.line, "column": 0 }, Object.keys(parseListConfig(value)));
                    enableReporting(reportingConfig, comment.loc.end, Object.keys(parseListConfig(value)));
                } else if (match[1] === "eslint-disable-next-line") {
                    disableReporting(reportingConfig, comment.loc.start, Object.keys(parseListConfig(value)));
                    enableReporting(reportingConfig, { "line": comment.loc.start.line + 2 }, Object.keys(parseListConfig(value)));
                }
            }
        }
    });

    Object.keys(commentConfig.env).forEach(function(name) {
        var env = Environments.get(name);
        if (env) {
            commentConfig = ConfigOps.merge(commentConfig, env);
        }
    });
    lodash.assign(commentConfig.rules, commentRules);

    return ConfigOps.merge(config, commentConfig);
}

function isDisabledByReportingConfig(reportingConfig, ruleId, location) {

    for (var i = 0, c = reportingConfig.length; i < c; i++) {

        var ignore = reportingConfig[i];
        if ((!ignore.rule || ignore.rule === ruleId) &&
            (location.line > ignore.start.line || (location.line === ignore.start.line && location.column >= ignore.start.column)) &&
            (!ignore.end || (location.line < ignore.end.line || (location.line === ignore.end.line && location.column <= ignore.end.column)))) {
            return true;
        }
    }

    return false;
}

function prepareConfig(config) {

    config.globals = config.globals || config.global || {};
    delete config.global;

    var copiedRules = {},
        parserOptions = {},
        preparedConfig;

    if (typeof config.rules === "object") {
        Object.keys(config.rules).forEach(function(k) {
            var rule = config.rules[k];
            if (rule === null) {
                throw new Error("Invalid config for rule '" + k + "'\.");
            }
            if (Array.isArray(rule)) {
                copiedRules[k] = rule.slice();
            } else {
                copiedRules[k] = rule;
            }
        });
    }

    if (typeof config.env === "object") {
        Object.keys(config.env).forEach(function(envName) {
            var env = Environments.get(envName);
            if (config.env[envName] && env && env.parserOptions) {
                parserOptions = ConfigOps.merge(parserOptions, env.parserOptions);
            }
        });
    }

    preparedConfig = {
        rules: copiedRules,
        parser: config.parser || DEFAULT_PARSER,
        globals: ConfigOps.merge({}, config.globals),
        env: ConfigOps.merge({}, config.env || {}),
        settings: ConfigOps.merge({}, config.settings || {}),
        parserOptions: ConfigOps.merge(parserOptions, config.parserOptions || {})
    };

    if (preparedConfig.parserOptions.sourceType === "module") {
        if (!preparedConfig.parserOptions.ecmaFeatures) {
            preparedConfig.parserOptions.ecmaFeatures = {};
        }

        preparedConfig.parserOptions.ecmaFeatures.globalReturn = false;

        if (!preparedConfig.parserOptions.ecmaVersion || preparedConfig.parserOptions.ecmaVersion < 6) {
            preparedConfig.parserOptions.ecmaVersion = 6;
        }
    }

    return preparedConfig;
}

function createStubRule(message) {

    function createRuleModule(context) {
        return {
            Program: function(node) {
                context.report(node, message);
            }
        };
    }

    if (message) {
        return createRuleModule;
    } else {
        throw new Error("No message passed to stub rule");
    }
}

function getRuleReplacementMessage(ruleId) {
    if (ruleId in replacements.rules) {
        var newRules = replacements.rules[ruleId];
        return "Rule \'" + ruleId + "\' was removed and replaced by: " + newRules.join(", ");
    }
    return null;
}

var eslintEnvPattern = /\/\*\s*eslint-env\s(.+?)\*\//g;

function findEslintEnv(text) {
    var match, retv;

    eslintEnvPattern.lastIndex = 0;
    while ((match = eslintEnvPattern.exec(text))) {
        retv = lodash.assign(retv || {}, parseListConfig(match[1]));
    }

    return retv;
}

function stripUnicodeBOM(text) {
    if (text.charCodeAt(0) === 0xFEFF) {
        return text.slice(1);
    }
    return text;
}

module.exports = (function() {

    var api = Object.create(new EventEmitter()),
        messages = [],
        currentConfig = null,
        currentScopes = null,
        scopeMap = null,
        scopeManager = null,
        currentFilename = null,
        controller = null,
        reportingConfig = [],
        sourceCode = null;

    function parse(text, config) {

        var parser,
            parserOptions = {
                loc: true,
                range: true,
                raw: true,
                tokens: true,
                comment: true,
                attachComment: true
            };

        try {
            parser = require(config.parser);
        } catch (ex) {
            messages.push({
                ruleId: null,
                fatal: true,
                severity: 2,
                source: null,
                message: ex.message,
                line: 0,
                column: 0
            });

            return null;
        }

        if (config.parserOptions) {
            parserOptions = lodash.assign({}, config.parserOptions, parserOptions);
        }

        try {
            return parser.parse(text, parserOptions);
        } catch (ex) {

            var message = ex.message.replace(/^line \d+:/i, "").trim();
            var source = (ex.lineNumber) ? SourceCode.splitLines(text)[ex.lineNumber] : null;

            messages.push({
                ruleId: null,
                fatal: true,
                severity: 2,
                source: source,
                message: "Parsing error: " + message,

                line: ex.lineNumber,
                column: ex.column
            });

            return null;
        }
    }

    function getRuleSeverity(ruleConfig) {
        if (typeof ruleConfig === "number") {
            return ruleConfig;
        } else if (Array.isArray(ruleConfig)) {
            return ruleConfig[0];
        } else {
            return 0;
        }
    }

    function getRuleOptions(ruleConfig) {
        if (Array.isArray(ruleConfig)) {
            return ruleConfig.slice(1);
        } else {
            return [];
        }
    }

    api.setMaxListeners(0);

    api.reset = function() {
        this.removeAllListeners();
        messages = [];
        currentConfig = null;
        currentScopes = null;
        scopeMap = null;
        scopeManager = null;
        controller = null;
        reportingConfig = [];
        sourceCode = null;
    };

    api.verify = function(textOrSourceCode, config, filenameOrOptions, saveState) {

        var ast,
            shebang,
            ecmaFeatures,
            ecmaVersion,
            allowInlineConfig,
            text = (typeof textOrSourceCode === "string") ? textOrSourceCode : null;

        if (typeof filenameOrOptions === "object") {
            currentFilename = filenameOrOptions.filename;
            allowInlineConfig = filenameOrOptions.allowInlineConfig;
            saveState = filenameOrOptions.saveState;
        } else {
            currentFilename = filenameOrOptions;
        }

        if (!saveState) {
            this.reset();
        }

        var envInFile = findEslintEnv(text || textOrSourceCode.text);
        if (envInFile) {
            if (!config || !config.env) {
                config = lodash.assign({}, config || {}, {env: envInFile});
            } else {
                config = lodash.assign({}, config);
                config.env = lodash.assign({}, config.env, envInFile);
            }
        }

        config = prepareConfig(config || {});

        if (text !== null) {
            if (text.trim().length === 0) {
                sourceCode = new SourceCode(text, blankScriptAST);
                return messages;
            }

            ast = parse(
                stripUnicodeBOM(text).replace(/^#!([^\r\n]+)/, function(match, captured) {
                    shebang = captured;
                    return "//" + captured;
                }),
                config
            );

            if (ast) {
                sourceCode = new SourceCode(text, ast);
            }

        } else {
            sourceCode = textOrSourceCode;
            ast = sourceCode.ast;
        }

        if (ast) {

            if (allowInlineConfig !== false) {
                config = modifyConfigsFromComments(currentFilename, ast, config, reportingConfig, messages);
            }

            ConfigOps.normalize(config);

            Object.keys(config.rules).filter(function(key) {
                return getRuleSeverity(config.rules[key]) > 0;
            }).forEach(function(key) {
                var ruleCreator,
                    severity,
                    options,
                    rule;

                ruleCreator = rules.get(key);
                if (!ruleCreator) {
                    var replacementMsg = getRuleReplacementMessage(key);
                    if (replacementMsg) {
                        ruleCreator = createStubRule(replacementMsg);
                    } else {
                        ruleCreator = createStubRule("Definition for rule '" + key + "' was not found");
                    }
                    rules.define(key, ruleCreator);
                }

                severity = getRuleSeverity(config.rules[key]);
                options = getRuleOptions(config.rules[key]);

                try {
                    var ruleContext = new RuleContext(
                        key, api, severity, options,
                        config.settings, config.parserOptions, config.parser, ruleCreator.meta);
                    rule = ruleCreator.create ? ruleCreator.create(ruleContext) :
                        ruleCreator(ruleContext);

                    Object.keys(rule).forEach(function(nodeType) {
                        api.on(nodeType, timing.enabled
                            ? timing.time(key, rule[nodeType])
                            : rule[nodeType]
                        );
                    });
                } catch (ex) {
                    ex.message = "Error while loading rule '" + key + "': " + ex.message;
                    throw ex;
                }
            });

            currentConfig = config;
            controller = new estraverse.Controller();

            ecmaFeatures = currentConfig.parserOptions.ecmaFeatures || {};
            ecmaVersion = currentConfig.parserOptions.ecmaVersion || 5;

            scopeManager = escope.analyze(ast, {
                ignoreEval: true,
                nodejsScope: ecmaFeatures.globalReturn,
                impliedStrict: ecmaFeatures.impliedStrict,
                ecmaVersion: ecmaVersion,
                sourceType: currentConfig.parserOptions.sourceType || "script",
                childVisitorKeys: espree.VisitorKeys,
                fallback: "none"
            });
            currentScopes = scopeManager.scopes;

            scopeMap = [];
            currentScopes.forEach(function(scope, index) {
                var range = scope.block.range[0];

                if (!scopeMap[range]) {
                    scopeMap[range] = index;
                }
            });

            addDeclaredGlobals(ast, currentScopes[0], currentConfig);

            if (shebang && ast.comments.length && ast.comments[0].value === shebang) {
                ast.comments.splice(0, 1);

                if (ast.body.length && ast.body[0].leadingComments && ast.body[0].leadingComments[0].value === shebang) {
                    ast.body[0].leadingComments.splice(0, 1);
                }
            }

            var eventGenerator = new NodeEventGenerator(api);
            eventGenerator = new CodePathAnalyzer(eventGenerator);
            eventGenerator = new CommentEventGenerator(eventGenerator, sourceCode);

            controller.traverse(ast, {
                enter: function(node, parent) {
                    node.parent = parent;
                    eventGenerator.enterNode(node);
                },
                leave: function(node) {
                    eventGenerator.leaveNode(node);
                },
                keys: espree.VisitorKeys
            });
        }

        messages.sort(function(a, b) {
            var lineDiff = a.line - b.line;

            if (lineDiff === 0) {
                return a.column - b.column;
            } else {
                return lineDiff;
            }
        });

        return messages;
    };

    api.report = function(ruleId, severity, node, location, message, opts, fix, meta) {
        if (node) {
            assert.strictEqual(typeof node, "object", "Node must be an object");
        }

        if (typeof location === "string") {
            assert.ok(node, "Node must be provided when reporting error if location is not provided");

            meta = fix;
            fix = opts;
            opts = message;
            message = location;
            location = node.loc.start;
        }
        if (isDisabledByReportingConfig(reportingConfig, ruleId, location)) {
            return;
        }

        if (opts) {
            message = message.replace(/\{\{\s*(.+?)\s*\}\}/g, function(fullMatch, term) {
                if (term in opts) {
                    return opts[term];
                }

                return fullMatch;
            });
        }

        var problem = {
            ruleId: ruleId,
            severity: severity,
            message: message,
            line: location.line,
            column: location.column + 1,   // switch to 1-base instead of 0-base
            nodeType: node && node.type,
            source: sourceCode.lines[location.line] || ""
        };

        if (fix && Array.isArray(fix.range) && (typeof fix.text === "string") && (!meta || !meta.docs || meta.docs.fixable)) {
            problem.fix = fix;
        }

        messages.push(problem);
    };

    api.getSourceCode = function() {
        return sourceCode;
    };

    var externalMethods = {
        getSource: "getText",
        getSourceLines: "getLines",
        getAllComments: "getAllComments",
        getNodeByRangeIndex: "getNodeByRangeIndex",
        getComments: "getComments",
        getJSDocComment: "getJSDocComment",
        getFirstToken: "getFirstToken",
        getFirstTokens: "getFirstTokens",
        getLastToken: "getLastToken",
        getLastTokens: "getLastTokens",
        getTokenAfter: "getTokenAfter",
        getTokenBefore: "getTokenBefore",
        getTokenByRangeStart: "getTokenByRangeStart",
        getTokens: "getTokens",
        getTokensAfter: "getTokensAfter",
        getTokensBefore: "getTokensBefore",
        getTokensBetween: "getTokensBetween"
    };

    Object.keys(externalMethods).forEach(function(methodName) {
        var exMethodName = externalMethods[methodName];

        api[methodName] = function(a, b, c, d, e) {
            if (sourceCode) {
                return sourceCode[exMethodName](a, b, c, d, e);
            }
            return null;
        };
    });

    api.getAncestors = function() {
        return controller.parents();
    };

    api.getScope = function() {
        var parents = controller.parents(),
            scope = currentScopes[0];

        if (parents.length) {

            var current = controller.current();
            if (currentConfig.parserOptions.ecmaVersion >= 6) {
                if (["BlockStatement", "SwitchStatement", "CatchClause", "FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"].indexOf(current.type) >= 0) {
                    parents.push(current);
                }
            } else {
                if (["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"].indexOf(current.type) >= 0) {
                    parents.push(current);
                }
            }

            for (var i = parents.length - 1; i >= 0; --i) {

                scope = scopeManager.acquire(parents[i], true);
                if (scope) {
                    if (scope.type === "function-expression-name") {
                        return scope.childScopes[0];
                    } else {
                        return scope;
                    }
                }

            }

        }

        return currentScopes[0];
    };

    api.markVariableAsUsed = function(name) {
        var scope = this.getScope(),
            hasGlobalReturn = currentConfig.parserOptions.ecmaFeatures && currentConfig.parserOptions.ecmaFeatures.globalReturn,
            specialScope = hasGlobalReturn || currentConfig.parserOptions.sourceType === "module",
            variables,
            i,
            len;

        if (scope.type === "global" && specialScope) {
            scope = scope.childScopes[0];
        }

        do {
            variables = scope.variables;
            for (i = 0, len = variables.length; i < len; i++) {
                if (variables[i].name === name) {
                    variables[i].eslintUsed = true;
                    return true;
                }
            }
        } while ( (scope = scope.upper) );

        return false;
    };

    api.getFilename = function() {
        if (typeof currentFilename === "string") {
            return currentFilename;
        } else {
            return "<input>";
        }
    };

    var defineRule = api.defineRule = function(ruleId, ruleModule) {
        rules.define(ruleId, ruleModule);
    };

    api.defineRules = function(rulesToDefine) {
        Object.getOwnPropertyNames(rulesToDefine).forEach(function(ruleId) {
            defineRule(ruleId, rulesToDefine[ruleId]);
        });
    };

    api.defaults = function() {
        return require("../conf/eslint.json");
    };

    api.getDeclaredVariables = function(node) {
        return (scopeManager && scopeManager.getDeclaredVariables(node)) || [];
    };

    return api;

}());

},
   {"../conf/blank-script.json":"/conf/blank-script.json","../conf/eslint.json":"/conf/eslint.json","../conf/replacements.json":"/conf/replacements.json","./code-path-analysis/code-path-analyzer":"/tmp/code-path-analysis/code-path-analyzer.js","./config/config-ops":"/tmp/config/config-ops.js","./config/config-validator":"/tmp/config/config-validator.js","./config/environments":"/tmp/config/environments.js","./rule-context":"/tmp/rule-context.js","./rules":"/tmp/rules.js","./timing":"/tmp/timing.js","./util/comment-event-generator":"/tmp/util/comment-event-generator.js","./util/node-event-generator":"/tmp/util/node-event-generator.js","./util/source-code":"/tmp/util/source-code.js","assert":"/node_modules/browserify/node_modules/assert/assert.js","escope":"/node_modules/escope/lib/index.js","espree":"espree","estraverse":"/node_modules/estraverse/estraverse.js","events":"/node_modules/browserify/node_modules/events/events.js","lodash":"/node_modules/lodash/lodash.js"}],

"/tmp/load-rules.js": [function(require,module,exports){
module.exports = function() {
    var rules = require('eslint-plugin-react').rules;
    Object.keys(rules).forEach(function(k) {rules['react/' + k] = rules[k]; });
    rules["accessor-pairs"] = require("./rules/accessor-pairs");
    rules["array-bracket-spacing"] = require("./rules/array-bracket-spacing");
    rules["array-callback-return"] = require("./rules/array-callback-return");
    rules["arrow-body-style"] = require("./rules/arrow-body-style");
    rules["arrow-parens"] = require("./rules/arrow-parens");
    rules["arrow-spacing"] = require("./rules/arrow-spacing");
    rules["block-scoped-var"] = require("./rules/block-scoped-var");
    rules["block-spacing"] = require("./rules/block-spacing");
    rules["brace-style"] = require("./rules/brace-style");
    rules["callback-return"] = require("./rules/callback-return");
    rules["camelcase"] = require("./rules/camelcase");
    rules["comma-dangle"] = require("./rules/comma-dangle");
    rules["comma-spacing"] = require("./rules/comma-spacing");
    rules["comma-style"] = require("./rules/comma-style");
    rules["complexity"] = require("./rules/complexity");
    rules["computed-property-spacing"] = require("./rules/computed-property-spacing");
    rules["consistent-return"] = require("./rules/consistent-return");
    rules["consistent-this"] = require("./rules/consistent-this");
    rules["constructor-super"] = require("./rules/constructor-super");
    rules["curly"] = require("./rules/curly");
    rules["default-case"] = require("./rules/default-case");
    rules["dot-location"] = require("./rules/dot-location");
    rules["dot-notation"] = require("./rules/dot-notation");
    rules["eol-last"] = require("./rules/eol-last");
    rules["eqeqeq"] = require("./rules/eqeqeq");
    rules["func-names"] = require("./rules/func-names");
    rules["func-style"] = require("./rules/func-style");
    rules["generator-star-spacing"] = require("./rules/generator-star-spacing");
    rules["global-require"] = require("./rules/global-require");
    rules["guard-for-in"] = require("./rules/guard-for-in");
    rules["handle-callback-err"] = require("./rules/handle-callback-err");
    rules["id-blacklist"] = require("./rules/id-blacklist");
    rules["id-length"] = require("./rules/id-length");
    rules["id-match"] = require("./rules/id-match");
    rules["indent"] = require("./rules/indent");
    rules["init-declarations"] = require("./rules/init-declarations");
    rules["jsx-quotes"] = require("./rules/jsx-quotes");
    rules["key-spacing"] = require("./rules/key-spacing");
    rules["keyword-spacing"] = require("./rules/keyword-spacing");
    rules["linebreak-style"] = require("./rules/linebreak-style");
    rules["lines-around-comment"] = require("./rules/lines-around-comment");
    rules["max-depth"] = require("./rules/max-depth");
    rules["max-len"] = require("./rules/max-len");
    rules["max-nested-callbacks"] = require("./rules/max-nested-callbacks");
    rules["max-params"] = require("./rules/max-params");
    rules["max-statements"] = require("./rules/max-statements");
    rules["new-cap"] = require("./rules/new-cap");
    rules["new-parens"] = require("./rules/new-parens");
    rules["newline-after-var"] = require("./rules/newline-after-var");
    rules["newline-before-return"] = require("./rules/newline-before-return");
    rules["newline-per-chained-call"] = require("./rules/newline-per-chained-call");
    rules["no-alert"] = require("./rules/no-alert");
    rules["no-array-constructor"] = require("./rules/no-array-constructor");
    rules["no-bitwise"] = require("./rules/no-bitwise");
    rules["no-caller"] = require("./rules/no-caller");
    rules["no-case-declarations"] = require("./rules/no-case-declarations");
    rules["no-catch-shadow"] = require("./rules/no-catch-shadow");
    rules["no-class-assign"] = require("./rules/no-class-assign");
    rules["no-cond-assign"] = require("./rules/no-cond-assign");
    rules["no-confusing-arrow"] = require("./rules/no-confusing-arrow");
    rules["no-console"] = require("./rules/no-console");
    rules["no-const-assign"] = require("./rules/no-const-assign");
    rules["no-constant-condition"] = require("./rules/no-constant-condition");
    rules["no-continue"] = require("./rules/no-continue");
    rules["no-control-regex"] = require("./rules/no-control-regex");
    rules["no-debugger"] = require("./rules/no-debugger");
    rules["no-delete-var"] = require("./rules/no-delete-var");
    rules["no-div-regex"] = require("./rules/no-div-regex");
    rules["no-dupe-args"] = require("./rules/no-dupe-args");
    rules["no-dupe-class-members"] = require("./rules/no-dupe-class-members");
    rules["no-dupe-keys"] = require("./rules/no-dupe-keys");
    rules["no-duplicate-case"] = require("./rules/no-duplicate-case");
    rules["no-else-return"] = require("./rules/no-else-return");
    rules["no-empty-character-class"] = require("./rules/no-empty-character-class");
    rules["no-empty-function"] = require("./rules/no-empty-function");
    rules["no-empty-pattern"] = require("./rules/no-empty-pattern");
    rules["no-empty"] = require("./rules/no-empty");
    rules["no-eq-null"] = require("./rules/no-eq-null");
    rules["no-eval"] = require("./rules/no-eval");
    rules["no-ex-assign"] = require("./rules/no-ex-assign");
    rules["no-extend-native"] = require("./rules/no-extend-native");
    rules["no-extra-bind"] = require("./rules/no-extra-bind");
    rules["no-extra-boolean-cast"] = require("./rules/no-extra-boolean-cast");
    rules["no-extra-label"] = require("./rules/no-extra-label");
    rules["no-extra-parens"] = require("./rules/no-extra-parens");
    rules["no-extra-semi"] = require("./rules/no-extra-semi");
    rules["no-fallthrough"] = require("./rules/no-fallthrough");
    rules["no-floating-decimal"] = require("./rules/no-floating-decimal");
    rules["no-func-assign"] = require("./rules/no-func-assign");
    rules["no-implicit-coercion"] = require("./rules/no-implicit-coercion");
    rules["no-implicit-globals"] = require("./rules/no-implicit-globals");
    rules["no-implied-eval"] = require("./rules/no-implied-eval");
    rules["no-inline-comments"] = require("./rules/no-inline-comments");
    rules["no-inner-declarations"] = require("./rules/no-inner-declarations");
    rules["no-invalid-regexp"] = require("./rules/no-invalid-regexp");
    rules["no-invalid-this"] = require("./rules/no-invalid-this");
    rules["no-irregular-whitespace"] = require("./rules/no-irregular-whitespace");
    rules["no-iterator"] = require("./rules/no-iterator");
    rules["no-label-var"] = require("./rules/no-label-var");
    rules["no-labels"] = require("./rules/no-labels");
    rules["no-lone-blocks"] = require("./rules/no-lone-blocks");
    rules["no-lonely-if"] = require("./rules/no-lonely-if");
    rules["no-loop-func"] = require("./rules/no-loop-func");
    rules["no-magic-numbers"] = require("./rules/no-magic-numbers");
    rules["no-mixed-requires"] = require("./rules/no-mixed-requires");
    rules["no-mixed-spaces-and-tabs"] = require("./rules/no-mixed-spaces-and-tabs");
    rules["no-multi-spaces"] = require("./rules/no-multi-spaces");
    rules["no-multi-str"] = require("./rules/no-multi-str");
    rules["no-multiple-empty-lines"] = require("./rules/no-multiple-empty-lines");
    rules["no-native-reassign"] = require("./rules/no-native-reassign");
    rules["no-negated-condition"] = require("./rules/no-negated-condition");
    rules["no-negated-in-lhs"] = require("./rules/no-negated-in-lhs");
    rules["no-nested-ternary"] = require("./rules/no-nested-ternary");
    rules["no-new-func"] = require("./rules/no-new-func");
    rules["no-new-object"] = require("./rules/no-new-object");
    rules["no-new-require"] = require("./rules/no-new-require");
    rules["no-new-symbol"] = require("./rules/no-new-symbol");
    rules["no-new-wrappers"] = require("./rules/no-new-wrappers");
    rules["no-new"] = require("./rules/no-new");
    rules["no-obj-calls"] = require("./rules/no-obj-calls");
    rules["no-octal-escape"] = require("./rules/no-octal-escape");
    rules["no-octal"] = require("./rules/no-octal");
    rules["no-param-reassign"] = require("./rules/no-param-reassign");
    rules["no-path-concat"] = require("./rules/no-path-concat");
    rules["no-plusplus"] = require("./rules/no-plusplus");
    rules["no-process-env"] = require("./rules/no-process-env");
    rules["no-process-exit"] = require("./rules/no-process-exit");
    rules["no-proto"] = require("./rules/no-proto");
    rules["no-redeclare"] = require("./rules/no-redeclare");
    rules["no-regex-spaces"] = require("./rules/no-regex-spaces");
    rules["no-restricted-globals"] = require("./rules/no-restricted-globals");
    rules["no-restricted-imports"] = require("./rules/no-restricted-imports");
    rules["no-restricted-modules"] = require("./rules/no-restricted-modules");
    rules["no-restricted-syntax"] = require("./rules/no-restricted-syntax");
    rules["no-return-assign"] = require("./rules/no-return-assign");
    rules["no-script-url"] = require("./rules/no-script-url");
    rules["no-self-assign"] = require("./rules/no-self-assign");
    rules["no-self-compare"] = require("./rules/no-self-compare");
    rules["no-sequences"] = require("./rules/no-sequences");
    rules["no-shadow-restricted-names"] = require("./rules/no-shadow-restricted-names");
    rules["no-shadow"] = require("./rules/no-shadow");
    rules["no-spaced-func"] = require("./rules/no-spaced-func");
    rules["no-sparse-arrays"] = require("./rules/no-sparse-arrays");
    rules["no-sync"] = require("./rules/no-sync");
    rules["no-ternary"] = require("./rules/no-ternary");
    rules["no-this-before-super"] = require("./rules/no-this-before-super");
    rules["no-throw-literal"] = require("./rules/no-throw-literal");
    rules["no-trailing-spaces"] = require("./rules/no-trailing-spaces");
    rules["no-undef-init"] = require("./rules/no-undef-init");
    rules["no-undef"] = require("./rules/no-undef");
    rules["no-undefined"] = require("./rules/no-undefined");
    rules["no-underscore-dangle"] = require("./rules/no-underscore-dangle");
    rules["no-unexpected-multiline"] = require("./rules/no-unexpected-multiline");
    rules["no-unmodified-loop-condition"] = require("./rules/no-unmodified-loop-condition");
    rules["no-unneeded-ternary"] = require("./rules/no-unneeded-ternary");
    rules["no-unreachable"] = require("./rules/no-unreachable");
    rules["no-unused-expressions"] = require("./rules/no-unused-expressions");
    rules["no-unused-labels"] = require("./rules/no-unused-labels");
    rules["no-unused-vars"] = require("./rules/no-unused-vars");
    rules["no-use-before-define"] = require("./rules/no-use-before-define");
    rules["no-useless-call"] = require("./rules/no-useless-call");
    rules["no-useless-concat"] = require("./rules/no-useless-concat");
    rules["no-useless-constructor"] = require("./rules/no-useless-constructor");
    rules["no-var"] = require("./rules/no-var");
    rules["no-void"] = require("./rules/no-void");
    rules["no-warning-comments"] = require("./rules/no-warning-comments");
    rules["no-whitespace-before-property"] = require("./rules/no-whitespace-before-property");
    rules["no-with"] = require("./rules/no-with");
    rules["object-curly-spacing"] = require("./rules/object-curly-spacing");
    rules["object-shorthand"] = require("./rules/object-shorthand");
    rules["one-var-declaration-per-line"] = require("./rules/one-var-declaration-per-line");
    rules["one-var"] = require("./rules/one-var");
    rules["operator-assignment"] = require("./rules/operator-assignment");
    rules["operator-linebreak"] = require("./rules/operator-linebreak");
    rules["padded-blocks"] = require("./rules/padded-blocks");
    rules["prefer-arrow-callback"] = require("./rules/prefer-arrow-callback");
    rules["prefer-const"] = require("./rules/prefer-const");
    rules["prefer-reflect"] = require("./rules/prefer-reflect");
    rules["prefer-rest-params"] = require("./rules/prefer-rest-params");
    rules["prefer-spread"] = require("./rules/prefer-spread");
    rules["prefer-template"] = require("./rules/prefer-template");
    rules["quote-props"] = require("./rules/quote-props");
    rules["quotes"] = require("./rules/quotes");
    rules["radix"] = require("./rules/radix");
    rules["require-jsdoc"] = require("./rules/require-jsdoc");
    rules["require-yield"] = require("./rules/require-yield");
    rules["semi-spacing"] = require("./rules/semi-spacing");
    rules["semi"] = require("./rules/semi");
    rules["sort-imports"] = require("./rules/sort-imports");
    rules["sort-vars"] = require("./rules/sort-vars");
    rules["space-before-blocks"] = require("./rules/space-before-blocks");
    rules["space-before-function-paren"] = require("./rules/space-before-function-paren");
    rules["space-in-parens"] = require("./rules/space-in-parens");
    rules["space-infix-ops"] = require("./rules/space-infix-ops");
    rules["space-unary-ops"] = require("./rules/space-unary-ops");
    rules["spaced-comment"] = require("./rules/spaced-comment");
    rules["strict"] = require("./rules/strict");
    rules["template-curly-spacing"] = require("./rules/template-curly-spacing");
    rules["use-isnan"] = require("./rules/use-isnan");
    rules["valid-jsdoc"] = require("./rules/valid-jsdoc");
    rules["valid-typeof"] = require("./rules/valid-typeof");
    rules["vars-on-top"] = require("./rules/vars-on-top");
    rules["wrap-iife"] = require("./rules/wrap-iife");
    rules["wrap-regex"] = require("./rules/wrap-regex");
    rules["yield-star-spacing"] = require("./rules/yield-star-spacing");
    rules["yoda"] = require("./rules/yoda");

    return rules;
};
},
   {"./rules/accessor-pairs":"/tmp/rules/accessor-pairs.js","./rules/array-bracket-spacing":"/tmp/rules/array-bracket-spacing.js","./rules/array-callback-return":"/tmp/rules/array-callback-return.js","./rules/arrow-body-style":"/tmp/rules/arrow-body-style.js","./rules/arrow-parens":"/tmp/rules/arrow-parens.js","./rules/arrow-spacing":"/tmp/rules/arrow-spacing.js","./rules/block-scoped-var":"/tmp/rules/block-scoped-var.js","./rules/block-spacing":"/tmp/rules/block-spacing.js","./rules/brace-style":"/tmp/rules/brace-style.js","./rules/callback-return":"/tmp/rules/callback-return.js","./rules/camelcase":"/tmp/rules/camelcase.js","./rules/comma-dangle":"/tmp/rules/comma-dangle.js","./rules/comma-spacing":"/tmp/rules/comma-spacing.js","./rules/comma-style":"/tmp/rules/comma-style.js","./rules/complexity":"/tmp/rules/complexity.js","./rules/computed-property-spacing":"/tmp/rules/computed-property-spacing.js","./rules/consistent-return":"/tmp/rules/consistent-return.js","./rules/consistent-this":"/tmp/rules/consistent-this.js","./rules/constructor-super":"/tmp/rules/constructor-super.js","./rules/curly":"/tmp/rules/curly.js","./rules/default-case":"/tmp/rules/default-case.js","./rules/dot-location":"/tmp/rules/dot-location.js","./rules/dot-notation":"/tmp/rules/dot-notation.js","./rules/eol-last":"/tmp/rules/eol-last.js","./rules/eqeqeq":"/tmp/rules/eqeqeq.js","./rules/func-names":"/tmp/rules/func-names.js","./rules/func-style":"/tmp/rules/func-style.js","./rules/generator-star-spacing":"/tmp/rules/generator-star-spacing.js","./rules/global-require":"/tmp/rules/global-require.js","./rules/guard-for-in":"/tmp/rules/guard-for-in.js","./rules/handle-callback-err":"/tmp/rules/handle-callback-err.js","./rules/id-blacklist":"/tmp/rules/id-blacklist.js","./rules/id-length":"/tmp/rules/id-length.js","./rules/id-match":"/tmp/rules/id-match.js","./rules/indent":"/tmp/rules/indent.js","./rules/init-declarations":"/tmp/rules/init-declarations.js","./rules/jsx-quotes":"/tmp/rules/jsx-quotes.js","./rules/key-spacing":"/tmp/rules/key-spacing.js","./rules/keyword-spacing":"/tmp/rules/keyword-spacing.js","./rules/linebreak-style":"/tmp/rules/linebreak-style.js","./rules/lines-around-comment":"/tmp/rules/lines-around-comment.js","./rules/max-depth":"/tmp/rules/max-depth.js","./rules/max-len":"/tmp/rules/max-len.js","./rules/max-nested-callbacks":"/tmp/rules/max-nested-callbacks.js","./rules/max-params":"/tmp/rules/max-params.js","./rules/max-statements":"/tmp/rules/max-statements.js","./rules/new-cap":"/tmp/rules/new-cap.js","./rules/new-parens":"/tmp/rules/new-parens.js","./rules/newline-after-var":"/tmp/rules/newline-after-var.js","./rules/newline-before-return":"/tmp/rules/newline-before-return.js","./rules/newline-per-chained-call":"/tmp/rules/newline-per-chained-call.js","./rules/no-alert":"/tmp/rules/no-alert.js","./rules/no-array-constructor":"/tmp/rules/no-array-constructor.js","./rules/no-bitwise":"/tmp/rules/no-bitwise.js","./rules/no-caller":"/tmp/rules/no-caller.js","./rules/no-case-declarations":"/tmp/rules/no-case-declarations.js","./rules/no-catch-shadow":"/tmp/rules/no-catch-shadow.js","./rules/no-class-assign":"/tmp/rules/no-class-assign.js","./rules/no-cond-assign":"/tmp/rules/no-cond-assign.js","./rules/no-confusing-arrow":"/tmp/rules/no-confusing-arrow.js","./rules/no-console":"/tmp/rules/no-console.js","./rules/no-const-assign":"/tmp/rules/no-const-assign.js","./rules/no-constant-condition":"/tmp/rules/no-constant-condition.js","./rules/no-continue":"/tmp/rules/no-continue.js","./rules/no-control-regex":"/tmp/rules/no-control-regex.js","./rules/no-debugger":"/tmp/rules/no-debugger.js","./rules/no-delete-var":"/tmp/rules/no-delete-var.js","./rules/no-div-regex":"/tmp/rules/no-div-regex.js","./rules/no-dupe-args":"/tmp/rules/no-dupe-args.js","./rules/no-dupe-class-members":"/tmp/rules/no-dupe-class-members.js","./rules/no-dupe-keys":"/tmp/rules/no-dupe-keys.js","./rules/no-duplicate-case":"/tmp/rules/no-duplicate-case.js","./rules/no-else-return":"/tmp/rules/no-else-return.js","./rules/no-empty":"/tmp/rules/no-empty.js","./rules/no-empty-character-class":"/tmp/rules/no-empty-character-class.js","./rules/no-empty-function":"/tmp/rules/no-empty-function.js","./rules/no-empty-pattern":"/tmp/rules/no-empty-pattern.js","./rules/no-eq-null":"/tmp/rules/no-eq-null.js","./rules/no-eval":"/tmp/rules/no-eval.js","./rules/no-ex-assign":"/tmp/rules/no-ex-assign.js","./rules/no-extend-native":"/tmp/rules/no-extend-native.js","./rules/no-extra-bind":"/tmp/rules/no-extra-bind.js","./rules/no-extra-boolean-cast":"/tmp/rules/no-extra-boolean-cast.js","./rules/no-extra-label":"/tmp/rules/no-extra-label.js","./rules/no-extra-parens":"/tmp/rules/no-extra-parens.js","./rules/no-extra-semi":"/tmp/rules/no-extra-semi.js","./rules/no-fallthrough":"/tmp/rules/no-fallthrough.js","./rules/no-floating-decimal":"/tmp/rules/no-floating-decimal.js","./rules/no-func-assign":"/tmp/rules/no-func-assign.js","./rules/no-implicit-coercion":"/tmp/rules/no-implicit-coercion.js","./rules/no-implicit-globals":"/tmp/rules/no-implicit-globals.js","./rules/no-implied-eval":"/tmp/rules/no-implied-eval.js","./rules/no-inline-comments":"/tmp/rules/no-inline-comments.js","./rules/no-inner-declarations":"/tmp/rules/no-inner-declarations.js","./rules/no-invalid-regexp":"/tmp/rules/no-invalid-regexp.js","./rules/no-invalid-this":"/tmp/rules/no-invalid-this.js","./rules/no-irregular-whitespace":"/tmp/rules/no-irregular-whitespace.js","./rules/no-iterator":"/tmp/rules/no-iterator.js","./rules/no-label-var":"/tmp/rules/no-label-var.js","./rules/no-labels":"/tmp/rules/no-labels.js","./rules/no-lone-blocks":"/tmp/rules/no-lone-blocks.js","./rules/no-lonely-if":"/tmp/rules/no-lonely-if.js","./rules/no-loop-func":"/tmp/rules/no-loop-func.js","./rules/no-magic-numbers":"/tmp/rules/no-magic-numbers.js","./rules/no-mixed-requires":"/tmp/rules/no-mixed-requires.js","./rules/no-mixed-spaces-and-tabs":"/tmp/rules/no-mixed-spaces-and-tabs.js","./rules/no-multi-spaces":"/tmp/rules/no-multi-spaces.js","./rules/no-multi-str":"/tmp/rules/no-multi-str.js","./rules/no-multiple-empty-lines":"/tmp/rules/no-multiple-empty-lines.js","./rules/no-native-reassign":"/tmp/rules/no-native-reassign.js","./rules/no-negated-condition":"/tmp/rules/no-negated-condition.js","./rules/no-negated-in-lhs":"/tmp/rules/no-negated-in-lhs.js","./rules/no-nested-ternary":"/tmp/rules/no-nested-ternary.js","./rules/no-new":"/tmp/rules/no-new.js","./rules/no-new-func":"/tmp/rules/no-new-func.js","./rules/no-new-object":"/tmp/rules/no-new-object.js","./rules/no-new-require":"/tmp/rules/no-new-require.js","./rules/no-new-symbol":"/tmp/rules/no-new-symbol.js","./rules/no-new-wrappers":"/tmp/rules/no-new-wrappers.js","./rules/no-obj-calls":"/tmp/rules/no-obj-calls.js","./rules/no-octal":"/tmp/rules/no-octal.js","./rules/no-octal-escape":"/tmp/rules/no-octal-escape.js","./rules/no-param-reassign":"/tmp/rules/no-param-reassign.js","./rules/no-path-concat":"/tmp/rules/no-path-concat.js","./rules/no-plusplus":"/tmp/rules/no-plusplus.js","./rules/no-process-env":"/tmp/rules/no-process-env.js","./rules/no-process-exit":"/tmp/rules/no-process-exit.js","./rules/no-proto":"/tmp/rules/no-proto.js","./rules/no-redeclare":"/tmp/rules/no-redeclare.js","./rules/no-regex-spaces":"/tmp/rules/no-regex-spaces.js","./rules/no-restricted-globals":"/tmp/rules/no-restricted-globals.js","./rules/no-restricted-imports":"/tmp/rules/no-restricted-imports.js","./rules/no-restricted-modules":"/tmp/rules/no-restricted-modules.js","./rules/no-restricted-syntax":"/tmp/rules/no-restricted-syntax.js","./rules/no-return-assign":"/tmp/rules/no-return-assign.js","./rules/no-script-url":"/tmp/rules/no-script-url.js","./rules/no-self-assign":"/tmp/rules/no-self-assign.js","./rules/no-self-compare":"/tmp/rules/no-self-compare.js","./rules/no-sequences":"/tmp/rules/no-sequences.js","./rules/no-shadow":"/tmp/rules/no-shadow.js","./rules/no-shadow-restricted-names":"/tmp/rules/no-shadow-restricted-names.js","./rules/no-spaced-func":"/tmp/rules/no-spaced-func.js","./rules/no-sparse-arrays":"/tmp/rules/no-sparse-arrays.js","./rules/no-sync":"/tmp/rules/no-sync.js","./rules/no-ternary":"/tmp/rules/no-ternary.js","./rules/no-this-before-super":"/tmp/rules/no-this-before-super.js","./rules/no-throw-literal":"/tmp/rules/no-throw-literal.js","./rules/no-trailing-spaces":"/tmp/rules/no-trailing-spaces.js","./rules/no-undef":"/tmp/rules/no-undef.js","./rules/no-undef-init":"/tmp/rules/no-undef-init.js","./rules/no-undefined":"/tmp/rules/no-undefined.js","./rules/no-underscore-dangle":"/tmp/rules/no-underscore-dangle.js","./rules/no-unexpected-multiline":"/tmp/rules/no-unexpected-multiline.js","./rules/no-unmodified-loop-condition":"/tmp/rules/no-unmodified-loop-condition.js","./rules/no-unneeded-ternary":"/tmp/rules/no-unneeded-ternary.js","./rules/no-unreachable":"/tmp/rules/no-unreachable.js","./rules/no-unused-expressions":"/tmp/rules/no-unused-expressions.js","./rules/no-unused-labels":"/tmp/rules/no-unused-labels.js","./rules/no-unused-vars":"/tmp/rules/no-unused-vars.js","./rules/no-use-before-define":"/tmp/rules/no-use-before-define.js","./rules/no-useless-call":"/tmp/rules/no-useless-call.js","./rules/no-useless-concat":"/tmp/rules/no-useless-concat.js","./rules/no-useless-constructor":"/tmp/rules/no-useless-constructor.js","./rules/no-var":"/tmp/rules/no-var.js","./rules/no-void":"/tmp/rules/no-void.js","./rules/no-warning-comments":"/tmp/rules/no-warning-comments.js","./rules/no-whitespace-before-property":"/tmp/rules/no-whitespace-before-property.js","./rules/no-with":"/tmp/rules/no-with.js","./rules/object-curly-spacing":"/tmp/rules/object-curly-spacing.js","./rules/object-shorthand":"/tmp/rules/object-shorthand.js","./rules/one-var":"/tmp/rules/one-var.js","./rules/one-var-declaration-per-line":"/tmp/rules/one-var-declaration-per-line.js","./rules/operator-assignment":"/tmp/rules/operator-assignment.js","./rules/operator-linebreak":"/tmp/rules/operator-linebreak.js","./rules/padded-blocks":"/tmp/rules/padded-blocks.js","./rules/prefer-arrow-callback":"/tmp/rules/prefer-arrow-callback.js","./rules/prefer-const":"/tmp/rules/prefer-const.js","./rules/prefer-reflect":"/tmp/rules/prefer-reflect.js","./rules/prefer-rest-params":"/tmp/rules/prefer-rest-params.js","./rules/prefer-spread":"/tmp/rules/prefer-spread.js","./rules/prefer-template":"/tmp/rules/prefer-template.js","./rules/quote-props":"/tmp/rules/quote-props.js","./rules/quotes":"/tmp/rules/quotes.js","./rules/radix":"/tmp/rules/radix.js","./rules/require-jsdoc":"/tmp/rules/require-jsdoc.js","./rules/require-yield":"/tmp/rules/require-yield.js","./rules/semi":"/tmp/rules/semi.js","./rules/semi-spacing":"/tmp/rules/semi-spacing.js","./rules/sort-imports":"/tmp/rules/sort-imports.js","./rules/sort-vars":"/tmp/rules/sort-vars.js","./rules/space-before-blocks":"/tmp/rules/space-before-blocks.js","./rules/space-before-function-paren":"/tmp/rules/space-before-function-paren.js","./rules/space-in-parens":"/tmp/rules/space-in-parens.js","./rules/space-infix-ops":"/tmp/rules/space-infix-ops.js","./rules/space-unary-ops":"/tmp/rules/space-unary-ops.js","./rules/spaced-comment":"/tmp/rules/spaced-comment.js","./rules/strict":"/tmp/rules/strict.js","./rules/template-curly-spacing":"/tmp/rules/template-curly-spacing.js","./rules/use-isnan":"/tmp/rules/use-isnan.js","./rules/valid-jsdoc":"/tmp/rules/valid-jsdoc.js","./rules/valid-typeof":"/tmp/rules/valid-typeof.js","./rules/vars-on-top":"/tmp/rules/vars-on-top.js","./rules/wrap-iife":"/tmp/rules/wrap-iife.js","./rules/wrap-regex":"/tmp/rules/wrap-regex.js","./rules/yield-star-spacing":"/tmp/rules/yield-star-spacing.js","./rules/yoda":"/tmp/rules/yoda.js","eslint-plugin-react":"/node_modules/eslint-plugin-react/index.js"}],

"/tmp/rule-context.js": [function(require,module,exports){
"use strict";

var RuleFixer = require("./util/rule-fixer");

var PASSTHROUGHS = [
    "getAllComments",
    "getAncestors",
    "getComments",
    "getDeclaredVariables",
    "getFilename",
    "getFirstToken",
    "getFirstTokens",
    "getJSDocComment",
    "getLastToken",
    "getLastTokens",
    "getNodeByRangeIndex",
    "getScope",
    "getSource",
    "getSourceLines",
    "getTokenAfter",
    "getTokenBefore",
    "getTokenByRangeStart",
    "getTokens",
    "getTokensAfter",
    "getTokensBefore",
    "getTokensBetween",
    "markVariableAsUsed"
];

function RuleContext(ruleId, eslint, severity, options, settings, parserOptions, parserPath, meta) {
    this.id = ruleId;
    this.options = options;
    this.settings = settings;
    this.parserOptions = parserOptions;
    this.parserPath = parserPath;
    this.meta = meta;

    this.eslint = eslint;
    this.severity = severity;

    Object.freeze(this);
}

RuleContext.prototype = {
    constructor: RuleContext,

    getSourceCode: function() {
        return this.eslint.getSourceCode();
    },

    report: function(nodeOrDescriptor, location, message, opts) {
        var descriptor,
            fix = null;

        if (arguments.length === 1) {
            descriptor = nodeOrDescriptor;

            if (typeof descriptor.fix === "function") {
                fix = descriptor.fix(new RuleFixer());
            }

            this.eslint.report(
                this.id,
                this.severity,
                descriptor.node,
                descriptor.loc || descriptor.node.loc.start,
                descriptor.message,
                descriptor.data,
                fix,
                this.meta
            );

            return;
        }

        this.eslint.report(
            this.id,
            this.severity,
            nodeOrDescriptor,
            location,
            message,
            opts,
            this.meta
        );
    }
};

PASSTHROUGHS.forEach(function(name) {
    this[name] = function(a, b, c, d, e) {
        return this.eslint[name](a, b, c, d, e);
    };
}, RuleContext.prototype);

module.exports = RuleContext;

},
   {"./util/rule-fixer":"/tmp/util/rule-fixer.js"}],

"/tmp/rules.js": [function(require,module,exports){
"use strict";

var loadRules = require("./load-rules");

var rules = Object.create(null);

function define(ruleId, ruleModule) {
    rules[ruleId] = ruleModule;
}

function load(rulesDir, cwd) {
    var newRules = loadRules(rulesDir, cwd);
    Object.keys(newRules).forEach(function(ruleId) {
        define(ruleId, newRules[ruleId]);
    });
}

function importPlugin(pluginRules, pluginName) {
    Object.keys(pluginRules).forEach(function(ruleId) {
        var qualifiedRuleId = pluginName + "/" + ruleId,
            rule = pluginRules[ruleId];

        define(qualifiedRuleId, rule);
    });
}

function get(ruleId) {
    if (typeof rules[ruleId] === "string") {
        return require(rules[ruleId]);
    } else {
        return rules[ruleId];
    }
}

function testClear() {
    rules = Object.create(null);
}

module.exports = {
    define: define,
    load: load,
    import: importPlugin,
    get: get,
    testClear: testClear,

    testReset: function() {
        testClear();
        load();
    }
};

load();

},
   {"./load-rules":"/tmp/load-rules.js"}],

"/tmp/rules/accessor-pairs.js": [function(require,module,exports){
"use strict";

function isIdentifier(node, name) {
    return node.type === "Identifier" && node.name === name;
}

function isArgumentOfMethodCall(node, index, object, property) {
    var parent = node.parent;
    return (
        parent.type === "CallExpression" &&
        parent.callee.type === "MemberExpression" &&
        parent.callee.computed === false &&
        isIdentifier(parent.callee.object, object) &&
        isIdentifier(parent.callee.property, property) &&
        parent.arguments[index] === node
    );
}

function isPropertyDescriptor(node) {
    if (isArgumentOfMethodCall(node, 2, "Object", "defineProperty") ||
        isArgumentOfMethodCall(node, 2, "Reflect", "defineProperty")
    ) {
        return true;
    }

    node = node.parent.parent;
    return node.type === "ObjectExpression" && (
        isArgumentOfMethodCall(node, 1, "Object", "create") ||
        isArgumentOfMethodCall(node, 1, "Object", "defineProperties")
    );
}

module.exports = {
    meta: {
        docs: {
            description: "Enforces getter/setter pairs in objects",
            category: "Best Practices",
            recommended: false
        },
        schema: [{
            "type": "object",
            "properties": {
                "getWithoutSet": {
                    "type": "boolean"
                },
                "setWithoutGet": {
                    "type": "boolean"
                }
            },
            "additionalProperties": false
        }]
    },
    create: function(context) {
        var config = context.options[0] || {};
        var checkGetWithoutSet = config.getWithoutSet === true;
        var checkSetWithoutGet = config.setWithoutGet !== false;

        function checkLonelySetGet(node) {
            var isSetPresent = false;
            var isGetPresent = false;
            var isDescriptor = isPropertyDescriptor(node);

            for (var i = 0, end = node.properties.length; i < end; i++) {
                var property = node.properties[i];

                var propToCheck = "";
                if (property.kind === "init") {
                    if (isDescriptor && !property.computed) {
                        propToCheck = property.key.name;
                    }
                } else {
                    propToCheck = property.kind;
                }

                switch (propToCheck) {
                    case "set":
                        isSetPresent = true;
                        break;

                    case "get":
                        isGetPresent = true;
                        break;

                    default:
                }

                if (isSetPresent && isGetPresent) {
                    break;
                }
            }

            if (checkSetWithoutGet && isSetPresent && !isGetPresent) {
                context.report(node, "Getter is not present");
            } else if (checkGetWithoutSet && isGetPresent && !isSetPresent) {
                context.report(node, "Setter is not present");
            }
        }

        return {
            "ObjectExpression": function(node) {
                if (checkSetWithoutGet || checkGetWithoutSet) {
                    checkLonelySetGet(node);
                }
            }
        };
    }
};

},
   {}],

"/tmp/rules/array-bracket-spacing.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = {
    meta: {
        docs: {
            description: "Enforce spacing inside array brackets",
            category: "Stylistic Issues",
            recommended: false,
            fixable: "whitespace"
        },
        schema: [
            {
                "enum": ["always", "never"]
            },
            {
                "type": "object",
                "properties": {
                    "singleValue": {
                        "type": "boolean"
                    },
                    "objectsInArrays": {
                        "type": "boolean"
                    },
                    "arraysInArrays": {
                        "type": "boolean"
                    }
                },
                "additionalProperties": false
            }
        ]
    },
    create: function(context) {
        var spaced = context.options[0] === "always",
            sourceCode = context.getSourceCode();

        function isOptionSet(option) {
            return context.options[1] ? context.options[1][option] === !spaced : false;
        }

        var options = {
            spaced: spaced,
            singleElementException: isOptionSet("singleValue"),
            objectsInArraysException: isOptionSet("objectsInArrays"),
            arraysInArraysException: isOptionSet("arraysInArrays")
        };

        function reportNoBeginningSpace(node, token) {
            context.report({
                node: node,
                loc: token.loc.start,
                message: "There should be no space after '" + token.value + "'",
                fix: function(fixer) {
                    var nextToken = context.getSourceCode().getTokenAfter(token);
                    return fixer.removeRange([token.range[1], nextToken.range[0]]);
                }
            });
        }

        function reportNoEndingSpace(node, token) {
            context.report({
                node: node,
                loc: token.loc.start,
                message: "There should be no space before '" + token.value + "'",
                fix: function(fixer) {
                    var previousToken = context.getSourceCode().getTokenBefore(token);
                    return fixer.removeRange([previousToken.range[1], token.range[0]]);
                }
            });
        }

        function reportRequiredBeginningSpace(node, token) {
            context.report({
                node: node,
                loc: token.loc.start,
                message: "A space is required after '" + token.value + "'",
                fix: function(fixer) {
                    return fixer.insertTextAfter(token, " ");
                }
            });
        }

        function reportRequiredEndingSpace(node, token) {
            context.report({
                node: node,
                loc: token.loc.start,
                message: "A space is required before '" + token.value + "'",
                fix: function(fixer) {
                    return fixer.insertTextBefore(token, " ");
                }
            });
        }

        function isObjectType(node) {
            return node && (node.type === "ObjectExpression" || node.type === "ObjectPattern");
        }

        function isArrayType(node) {
            return node && (node.type === "ArrayExpression" || node.type === "ArrayPattern");
        }

        function validateArraySpacing(node) {
            if (options.spaced && node.elements.length === 0) {
                return;
            }

            var first = context.getFirstToken(node),
                second = context.getFirstToken(node, 1),
                penultimate = context.getLastToken(node, 1),
                last = context.getLastToken(node),
                firstElement = node.elements[0],
                lastElement = node.elements[node.elements.length - 1];

            var openingBracketMustBeSpaced =
                options.objectsInArraysException && isObjectType(firstElement) ||
                options.arraysInArraysException && isArrayType(firstElement) ||
                options.singleElementException && node.elements.length === 1
                    ? !options.spaced : options.spaced;

            var closingBracketMustBeSpaced =
                options.objectsInArraysException && isObjectType(lastElement) ||
                options.arraysInArraysException && isArrayType(lastElement) ||
                options.singleElementException && node.elements.length === 1
                    ? !options.spaced : options.spaced;

            if (astUtils.isTokenOnSameLine(first, second)) {
                if (openingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(first, second)) {
                    reportRequiredBeginningSpace(node, first);
                }
                if (!openingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(first, second)) {
                    reportNoBeginningSpace(node, first);
                }
            }

            if (first !== penultimate && astUtils.isTokenOnSameLine(penultimate, last)) {
                if (closingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(penultimate, last)) {
                    reportRequiredEndingSpace(node, last);
                }
                if (!closingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(penultimate, last)) {
                    reportNoEndingSpace(node, last);
                }
            }
        }

        return {
            ArrayPattern: validateArraySpacing,
            ArrayExpression: validateArraySpacing
        };
    }
};

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/array-callback-return.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

var TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/;
var TARGET_METHODS = /^(?:every|filter|find(?:Index)?|map|reduce(?:Right)?|some|sort)$/;

function isReachable(segment) {
    return segment.reachable;
}

function getLocation(node, sourceCode) {
    if (node.type === "ArrowFunctionExpression") {
        return sourceCode.getTokenBefore(node.body);
    }
    return node.id || node;
}

function getIdentifierName(node) {
    return node.type === "Identifier" ? node.name : "";
}

function getConstantStringValue(node) {
    switch (node.type) {
        case "Literal":
            return String(node.value);

        case "TemplateLiteral":
            return node.expressions.length === 0
                ? node.quasis[0].value.cooked
                : "";

        default:
            return "";
    }
}

function isTargetMethod(node) {
    return (
        node.type === "MemberExpression" &&
        TARGET_METHODS.test(
            (node.computed ? getConstantStringValue : getIdentifierName)(node.property)
        )
    );
}

function isCallbackOfArrayMethod(node) {
    while (node) {
        var parent = node.parent;
        switch (parent.type) {
            case "LogicalExpression":
            case "ConditionalExpression":
                node = parent;
                break;

            case "ReturnStatement":
                var func = astUtils.getUpperFunction(parent);
                if (func === null || !astUtils.isCallee(func)) {
                    return false;
                }
                node = func.parent;
                break;

            case "CallExpression":
                if (astUtils.isArrayFromMethod(parent.callee)) {
                    return (
                        parent.arguments.length >= 2 &&
                        parent.arguments[1] === node
                    );
                }
                if (isTargetMethod(parent.callee)) {
                    return (
                        parent.arguments.length >= 1 &&
                        parent.arguments[0] === node
                    );
                }
                return false;

            default:
                return false;
        }
    }

    return false;
}

module.exports = function(context) {
    var funcInfo = {
        upper: null,
        codePath: null,
        hasReturn: false,
        shouldCheck: false
    };

    function checkLastSegment(node) {
        if (funcInfo.shouldCheck &&
            funcInfo.codePath.currentSegments.some(isReachable)
        ) {
            context.report({
                node: node,
                loc: getLocation(node, context.getSourceCode()).loc.start,
                message: funcInfo.hasReturn
                    ? "Expected to return a value at the end of this function."
                    : "Expected to return a value in this function."
            });
        }
    }

    return {
        "onCodePathStart": function(codePath, node) {
            funcInfo = {
                upper: funcInfo,
                codePath: codePath,
                hasReturn: false,
                shouldCheck:
                    TARGET_NODE_TYPE.test(node.type) &&
                    node.body.type === "BlockStatement" &&
                    isCallbackOfArrayMethod(node)
            };
        },

        "onCodePathEnd": function() {
            funcInfo = funcInfo.upper;
        },

        "ReturnStatement": function(node) {
            if (funcInfo.shouldCheck) {
                funcInfo.hasReturn = true;

                if (!node.argument) {
                    context.report({
                        node: node,
                        message: "Expected a return value."
                    });
                }
            }
        },

        "FunctionExpression:exit": checkLastSegment,
        "ArrowFunctionExpression:exit": checkLastSegment
    };
};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/arrow-body-style.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var always = context.options[0] === "always";
    var asNeeded = !context.options[0] || context.options[0] === "as-needed";

    function validate(node) {
        var arrowBody = node.body;
        if (arrowBody.type === "BlockStatement") {
            var blockBody = arrowBody.body;

            if (blockBody.length !== 1) {
                return;
            }

            if (asNeeded && blockBody[0].type === "ReturnStatement") {
                context.report({
                    node: node,
                    loc: arrowBody.loc.start,
                    message: "Unexpected block statement surrounding arrow body."
                });
            }
        } else {
            if (always) {
                context.report({
                    node: node,
                    loc: arrowBody.loc.start,
                    message: "Expected block statement surrounding arrow body."
                });
            }
        }
    }

    return {
        "ArrowFunctionExpression": validate
    };
};

module.exports.schema = [
    {
        "enum": ["always", "as-needed"]
    }
];

},
   {}],

"/tmp/rules/arrow-parens.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var message = "Expected parentheses around arrow function argument.";
    var asNeededMessage = "Unexpected parentheses around single function argument";
    var asNeeded = context.options[0] === "as-needed";

    function parens(node) {
        var token = context.getFirstToken(node);

        if (asNeeded && node.params.length === 1 && node.params[0].type === "Identifier") {
            if (token.type === "Punctuator" && token.value === "(") {
                context.report(node, asNeededMessage);
            }
            return;
        }

        if (token.type === "Identifier") {
            var after = context.getTokenAfter(token);

            if (after.value !== ")") {
                context.report(node, message);
            }
        }
    }

    return {
        "ArrowFunctionExpression": parens
    };
};

module.exports.schema = [
    {
        "enum": ["always", "as-needed"]
    }
];

},
   {}],

"/tmp/rules/arrow-spacing.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var rule = { before: true, after: true };
    var option = context.options[0] || {};
    rule.before = option.before !== false;
    rule.after = option.after !== false;

    function getTokens(node) {
        var t = context.getFirstToken(node);
        var before;
        while (t.type !== "Punctuator" || t.value !== "=>") {
            before = t;
            t = context.getTokenAfter(t);
        }
        var after = context.getTokenAfter(t);
        return { before: before, arrow: t, after: after };
    }

    function countSpaces(tokens) {
        var before = tokens.arrow.range[0] - tokens.before.range[1];
        var after = tokens.after.range[0] - tokens.arrow.range[1];
        return { before: before, after: after };
    }

    function spaces(node) {
        var tokens = getTokens(node);
        var countSpace = countSpaces(tokens);

        if (rule.before) {
            if (countSpace.before === 0) {
                context.report({
                    node: tokens.before,
                    message: "Missing space before =>",
                    fix: function(fixer) {
                        return fixer.insertTextBefore(tokens.arrow, " ");
                    }
                });
            }
        } else {
            if (countSpace.before > 0) {
                context.report({
                    node: tokens.before,
                    message: "Unexpected space before =>",
                    fix: function(fixer) {
                        return fixer.removeRange([tokens.before.range[1], tokens.arrow.range[0]]);
                    }
                });
            }
        }

        if (rule.after) {
            if (countSpace.after === 0) {
                context.report({
                    node: tokens.after,
                    message: "Missing space after =>",
                    fix: function(fixer) {
                        return fixer.insertTextAfter(tokens.arrow, " ");
                    }
                });
            }
        } else {
            if (countSpace.after > 0) {
                context.report({
                    node: tokens.after,
                    message: "Unexpected space after =>",
                    fix: function(fixer) {
                        return fixer.removeRange([tokens.arrow.range[1], tokens.after.range[0]]);
                    }
                });
            }
        }
    }

    return {
        "ArrowFunctionExpression": spaces
    };
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "before": {
                "type": "boolean"
            },
            "after": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/block-scoped-var.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var stack = [];

    function enterScope(node) {
        stack.push(node.range);
    }

    function exitScope() {
        stack.pop();
    }

    function report(reference) {
        var identifier = reference.identifier;
        context.report(
            identifier,
            "'{{name}}' used outside of binding context.",
            {name: identifier.name});
    }

    function checkForVariables(node) {
        if (node.kind !== "var") {
            return;
        }

        var scopeRange = stack[stack.length - 1];

        function isOutsideOfScope(reference) {
            var idRange = reference.identifier.range;
            return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];
        }

        var variables = context.getDeclaredVariables(node);
        for (var i = 0; i < variables.length; ++i) {
            variables[i]
                .references
                .filter(isOutsideOfScope)
                .forEach(report);
        }
    }

    return {
        "Program": function(node) {
            stack = [node.range];
        },

        "BlockStatement": enterScope,
        "BlockStatement:exit": exitScope,
        "ForStatement": enterScope,
        "ForStatement:exit": exitScope,
        "ForInStatement": enterScope,
        "ForInStatement:exit": exitScope,
        "ForOfStatement": enterScope,
        "ForOfStatement:exit": exitScope,
        "SwitchStatement": enterScope,
        "SwitchStatement:exit": exitScope,
        "CatchClause": enterScope,
        "CatchClause:exit": exitScope,

        "VariableDeclaration": checkForVariables
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/block-spacing.js": [function(require,module,exports){
"use strict";

var util = require("../ast-utils");

module.exports = function(context) {
    var always = (context.options[0] !== "never"),
        message = always ? "Requires a space" : "Unexpected space(s)",
        sourceCode = context.getSourceCode();

    function getOpenBrace(node) {
        if (node.type === "SwitchStatement") {
            if (node.cases.length > 0) {
                return context.getTokenBefore(node.cases[0]);
            }
            return context.getLastToken(node, 1);
        }
        return context.getFirstToken(node);
    }

    function isValid(left, right) {
        return (
            !util.isTokenOnSameLine(left, right) ||
            sourceCode.isSpaceBetweenTokens(left, right) === always
        );
    }

    function checkSpacingInsideBraces(node) {
        var openBrace = getOpenBrace(node);
        var closeBrace = context.getLastToken(node);
        var firstToken = sourceCode.getTokenOrCommentAfter(openBrace);
        var lastToken = sourceCode.getTokenOrCommentBefore(closeBrace);

        if (openBrace.type !== "Punctuator" ||
            openBrace.value !== "{" ||
            closeBrace.type !== "Punctuator" ||
            closeBrace.value !== "}" ||
            firstToken === closeBrace
        ) {
            return;
        }

        if (!always && firstToken.type === "Line") {
            return;
        }

        if (!isValid(openBrace, firstToken)) {
            context.report({
                node: node,
                loc: openBrace.loc.start,
                message: message + " after '{'.",
                fix: function(fixer) {
                    if (always) {
                        return fixer.insertTextBefore(firstToken, " ");
                    }

                    return fixer.removeRange([openBrace.range[1], firstToken.range[0]]);
                }
            });
        }
        if (!isValid(lastToken, closeBrace)) {
            context.report({
                node: node,
                loc: closeBrace.loc.start,
                message: message + " before '}'.",
                fix: function(fixer) {
                    if (always) {
                        return fixer.insertTextAfter(lastToken, " ");
                    }

                    return fixer.removeRange([lastToken.range[1], closeBrace.range[0]]);
                }
            });
        }
    }

    return {
        BlockStatement: checkSpacingInsideBraces,
        SwitchStatement: checkSpacingInsideBraces
    };
};

module.exports.schema = [
    {enum: ["always", "never"]}
];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/brace-style.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var style = context.options[0] || "1tbs",
        params = context.options[1] || {},
        sourceCode = context.getSourceCode();

    var OPEN_MESSAGE = "Opening curly brace does not appear on the same line as controlling statement.",
        OPEN_MESSAGE_ALLMAN = "Opening curly brace appears on the same line as controlling statement.",
        BODY_MESSAGE = "Statement inside of curly braces should be on next line.",
        CLOSE_MESSAGE = "Closing curly brace does not appear on the same line as the subsequent block.",
        CLOSE_MESSAGE_SINGLE = "Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.",
        CLOSE_MESSAGE_STROUSTRUP_ALLMAN = "Closing curly brace appears on the same line as the subsequent block.";

    function isBlock(node) {
        return node && node.type === "BlockStatement";
    }

    function isCurlyPunctuator(token) {
        return token.value === "{" || token.value === "}";
    }

    function checkBlock() {
        var blockProperties = arguments;

        return function(node) {
            [].forEach.call(blockProperties, function(blockProp) {
                var block = node[blockProp], previousToken, curlyToken, curlyTokenEnd, curlyTokensOnSameLine;

                if (!isBlock(block)) {
                    return;
                }

                previousToken = sourceCode.getTokenBefore(block);
                curlyToken = sourceCode.getFirstToken(block);
                curlyTokenEnd = sourceCode.getLastToken(block);
                curlyTokensOnSameLine = curlyToken.loc.start.line === curlyTokenEnd.loc.start.line;

                if (style !== "allman" && previousToken.loc.start.line !== curlyToken.loc.start.line) {
                    context.report(node, OPEN_MESSAGE);
                } else if (style === "allman" && previousToken.loc.start.line === curlyToken.loc.start.line && !params.allowSingleLine) {
                    context.report(node, OPEN_MESSAGE_ALLMAN);
                }

                if (!block.body.length || curlyTokensOnSameLine && params.allowSingleLine) {
                    return;
                }

                if (curlyToken.loc.start.line === block.body[0].loc.start.line) {
                    context.report(block.body[0], BODY_MESSAGE);
                } else if (curlyTokenEnd.loc.start.line === block.body[block.body.length - 1].loc.start.line) {
                    context.report(block.body[block.body.length - 1], CLOSE_MESSAGE_SINGLE);
                }
            });
        };
    }

    function checkIfStatement(node) {
        var tokens;

        checkBlock("consequent", "alternate")(node);

        if (node.alternate) {

            tokens = sourceCode.getTokensBefore(node.alternate, 2);

            if (style === "1tbs") {
                if (tokens[0].loc.start.line !== tokens[1].loc.start.line &&
                    node.consequent.type === "BlockStatement" &&
                    isCurlyPunctuator(tokens[0]) ) {
                    context.report(node.alternate, CLOSE_MESSAGE);
                }
            } else if (tokens[0].loc.start.line === tokens[1].loc.start.line) {
                context.report(node.alternate, CLOSE_MESSAGE_STROUSTRUP_ALLMAN);
            }

        }
    }

    function checkTryStatement(node) {
        var tokens;

        checkBlock("block", "finalizer")(node);

        if (isBlock(node.finalizer)) {
            tokens = sourceCode.getTokensBefore(node.finalizer, 2);
            if (style === "1tbs") {
                if (tokens[0].loc.start.line !== tokens[1].loc.start.line) {
                    context.report(node.finalizer, CLOSE_MESSAGE);
                }
            } else if (tokens[0].loc.start.line === tokens[1].loc.start.line) {
                context.report(node.finalizer, CLOSE_MESSAGE_STROUSTRUP_ALLMAN);
            }
        }
    }

    function checkCatchClause(node) {
        var previousToken = sourceCode.getTokenBefore(node),
            firstToken = sourceCode.getFirstToken(node);

        checkBlock("body")(node);

        if (isBlock(node.body)) {
            if (style === "1tbs") {
                if (previousToken.loc.start.line !== firstToken.loc.start.line) {
                    context.report(node, CLOSE_MESSAGE);
                }
            } else {
                if (previousToken.loc.start.line === firstToken.loc.start.line) {
                    context.report(node, CLOSE_MESSAGE_STROUSTRUP_ALLMAN);
                }
            }
        }
    }

    function checkSwitchStatement(node) {
        var tokens;
        if (node.cases && node.cases.length) {
            tokens = sourceCode.getTokensBefore(node.cases[0], 2);
        } else {
            tokens = sourceCode.getLastTokens(node, 3);
        }

        if (style !== "allman" && tokens[0].loc.start.line !== tokens[1].loc.start.line) {
            context.report(node, OPEN_MESSAGE);
        } else if (style === "allman" && tokens[0].loc.start.line === tokens[1].loc.start.line) {
            context.report(node, OPEN_MESSAGE_ALLMAN);
        }
    }

    return {
        "FunctionDeclaration": checkBlock("body"),
        "FunctionExpression": checkBlock("body"),
        "ArrowFunctionExpression": checkBlock("body"),
        "IfStatement": checkIfStatement,
        "TryStatement": checkTryStatement,
        "CatchClause": checkCatchClause,
        "DoWhileStatement": checkBlock("body"),
        "WhileStatement": checkBlock("body"),
        "WithStatement": checkBlock("body"),
        "ForStatement": checkBlock("body"),
        "ForInStatement": checkBlock("body"),
        "ForOfStatement": checkBlock("body"),
        "SwitchStatement": checkSwitchStatement
    };

};

module.exports.schema = [
    {
        "enum": ["1tbs", "stroustrup", "allman"]
    },
    {
        "type": "object",
        "properties": {
            "allowSingleLine": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/callback-return.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var callbacks = context.options[0] || ["callback", "cb", "next"];

    function findClosestParentOfType(node, types) {
        if (!node.parent) {
            return null;
        }
        if (types.indexOf(node.parent.type) === -1) {
            return findClosestParentOfType(node.parent, types);
        }
        return node.parent;
    }

    function isCallback(node) {
        return node.callee.type === "Identifier" && callbacks.indexOf(node.callee.name) > -1;
    }

    function isCallbackExpression(node, parentNode) {
        if (!parentNode || parentNode.type !== "ExpressionStatement") {
            return false;
        }

        if (parentNode.expression === node) {
            return true;
        }

        if (parentNode.expression.type === "BinaryExpression" || parentNode.expression.type === "LogicalExpression") {
            if (parentNode.expression.right === node) {
                return true;
            }
        }

        return false;
    }

    return {
        "CallExpression": function(node) {

            if (!isCallback(node)) {
                return;
            }

            var closestBlock = findClosestParentOfType(node, ["BlockStatement", "ReturnStatement", "ArrowFunctionExpression"]) || {},
                lastItem, parentType;

            if (closestBlock.type === "ReturnStatement" ) {
                return;
            }

            if (closestBlock.type === "ArrowFunctionExpression") {
                return;
            }

            if (closestBlock.type === "BlockStatement") {

                lastItem = closestBlock.body[closestBlock.body.length - 1];

                if (isCallbackExpression(node, lastItem)) {

                    parentType = closestBlock.parent.type;

                    if (parentType === "FunctionExpression" ||
                        parentType === "FunctionDeclaration" ||
                        parentType === "ArrowFunctionExpression"
                    ) {
                        return;
                    }

                }

                if (lastItem.type === "ReturnStatement") {

                    if (isCallbackExpression(node, closestBlock.body[closestBlock.body.length - 2])) {
                        return;
                    }
                }

            }

            if (findClosestParentOfType(node, ["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"])) {
                context.report(node, "Expected return with your callback function.");
            }

        }

    };
};

module.exports.schema = [{
    type: "array",
    items: { type: "string" }
}];

},
   {}],

"/tmp/rules/camelcase.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var reported = [];

    function isUnderscored(name) {

        return name.indexOf("_") > -1 && name !== name.toUpperCase();
    }

    function report(node) {
        if (reported.indexOf(node) < 0) {
            reported.push(node);
            context.report(node, "Identifier '{{name}}' is not in camel case.", { name: node.name });
        }
    }

    var options = context.options[0] || {},
        properties = options.properties || "";

    if (properties !== "always" && properties !== "never") {
        properties = "always";
    }

    return {

        "Identifier": function(node) {
            var name = node.name.replace(/^_+|_+$/g, ""),
                effectiveParent = (node.parent.type === "MemberExpression") ? node.parent.parent : node.parent;

            if (node.parent.type === "MemberExpression") {

                if (properties === "never") {
                    return;
                }

                if (node.parent.object.type === "Identifier" &&
                        node.parent.object.name === node.name &&
                        isUnderscored(name)) {
                    report(node);

                } else if (effectiveParent.type === "AssignmentExpression" &&
                        isUnderscored(name) &&
                        (effectiveParent.right.type !== "MemberExpression" ||
                        effectiveParent.left.type === "MemberExpression" &&
                        effectiveParent.left.property.name === node.name)) {
                    report(node);
                }

            } else if (node.parent.type === "Property") {
                if (properties === "never") {
                    return;
                }

                if (node.parent.parent && node.parent.parent.type === "ObjectPattern" &&
                        node.parent.key === node && node.parent.value !== node) {
                    return;
                }

                if (isUnderscored(name) && effectiveParent.type !== "CallExpression") {
                    report(node);
                }

            } else if (isUnderscored(name) && effectiveParent.type !== "CallExpression") {
                report(node);
            }
        }

    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "properties": {
                "enum": ["always", "never"]
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/comma-dangle.js": [function(require,module,exports){
"use strict";

var lodash = require("lodash");

function isTrailingCommaAllowed(node, lastItem) {
    switch (node.type) {
        case "ArrayPattern":
            return (
                lastItem.type !== "RestElement" &&
                lastItem.type !== "SpreadElement"
            );

        case "ArrayExpression":
            return (
                node.parent.type !== "ForOfStatement" ||
                node.parent.left !== node ||
                lastItem.type !== "SpreadElement"
            );

        default:
            return true;
    }
}

module.exports = function(context) {
    var mode = context.options[0];
    var UNEXPECTED_MESSAGE = "Unexpected trailing comma.";
    var MISSING_MESSAGE = "Missing trailing comma.";

    function isMultiline(node) {
        var lastItem = lodash.last(node.properties || node.elements || node.specifiers);
        if (!lastItem) {
            return false;
        }

        var sourceCode = context.getSourceCode(),
            penultimateToken = sourceCode.getLastToken(lastItem),
            lastToken = sourceCode.getTokenAfter(penultimateToken);

        while (lastToken.value === ")") {
            penultimateToken = lastToken;
            lastToken = sourceCode.getTokenAfter(lastToken);
        }

        if (lastToken.value === ",") {
            penultimateToken = lastToken;
            lastToken = sourceCode.getTokenAfter(lastToken);
        }

        return lastToken.loc.end.line !== penultimateToken.loc.end.line;
    }

    function forbidTrailingComma(node) {
        var lastItem = lodash.last(node.properties || node.elements || node.specifiers);
        if (!lastItem || (node.type === "ImportDeclaration" && lastItem.type !== "ImportSpecifier")) {
            return;
        }

        var sourceCode = context.getSourceCode(),
            trailingToken;

        if (node.type === "ObjectExpression" || node.type === "ArrayExpression") {
            trailingToken = sourceCode.getTokenBefore(sourceCode.getLastToken(node));
        } else {
            trailingToken = sourceCode.getTokenAfter(lastItem);
        }

        if (trailingToken.value === ",") {
            context.report(
                lastItem,
                trailingToken.loc.start,
                UNEXPECTED_MESSAGE);
        }
    }

    function forceTrailingComma(node) {
        var lastItem = lodash.last(node.properties || node.elements || node.specifiers);
        if (!lastItem || (node.type === "ImportDeclaration" && lastItem.type !== "ImportSpecifier")) {
            return;
        }
        if (!isTrailingCommaAllowed(node, lastItem)) {
            forbidTrailingComma(node);
            return;
        }

        var sourceCode = context.getSourceCode(),
            trailingToken;

        if (node.type === "ObjectExpression" || node.type === "ArrayExpression") {
            trailingToken = sourceCode.getTokenBefore(sourceCode.getLastToken(node));
        } else {
            trailingToken = sourceCode.getTokenAfter(lastItem);
        }

        if (trailingToken.value !== ",") {
            context.report(
                lastItem,
                lastItem.loc.end,
                MISSING_MESSAGE);
        }
    }

    function forceTrailingCommaIfMultiline(node) {
        if (isMultiline(node)) {
            forceTrailingComma(node);
        } else {
            forbidTrailingComma(node);
        }
    }

    function allowTrailingCommaIfMultiline(node) {
        if (!isMultiline(node)) {
            forbidTrailingComma(node);
        }
    }

    var checkForTrailingComma;
    if (mode === "always") {
        checkForTrailingComma = forceTrailingComma;
    } else if (mode === "always-multiline") {
        checkForTrailingComma = forceTrailingCommaIfMultiline;
    } else if (mode === "only-multiline") {
        checkForTrailingComma = allowTrailingCommaIfMultiline;
    } else {
        checkForTrailingComma = forbidTrailingComma;
    }

    return {
        "ObjectExpression": checkForTrailingComma,
        "ObjectPattern": checkForTrailingComma,
        "ArrayExpression": checkForTrailingComma,
        "ArrayPattern": checkForTrailingComma,
        "ImportDeclaration": checkForTrailingComma,
        "ExportNamedDeclaration": checkForTrailingComma
    };
};

module.exports.schema = [
    {
        "enum": ["always", "always-multiline", "only-multiline", "never"]
    }
];

},
   {"lodash":"/node_modules/lodash/lodash.js"}],

"/tmp/rules/comma-spacing.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {

    var sourceCode = context.getSourceCode();
    var tokensAndComments = sourceCode.tokensAndComments;

    var options = {
        before: context.options[0] ? !!context.options[0].before : false,
        after: context.options[0] ? !!context.options[0].after : true
    };

    var commaTokensToIgnore = [];

    function isComma(token) {
        return !!token && (token.type === "Punctuator") && (token.value === ",");
    }

    function report(node, dir, otherNode) {
        context.report({
            node: node,
            fix: function(fixer) {
                if (options[dir]) {
                    if (dir === "before") {
                        return fixer.insertTextBefore(node, " ");
                    } else {
                        return fixer.insertTextAfter(node, " ");
                    }
                } else {
                    var start, end;
                    var newText = "";

                    if (dir === "before") {
                        start = otherNode.range[1];
                        end = node.range[0];
                    } else {
                        start = node.range[1];
                        end = otherNode.range[0];
                    }

                    return fixer.replaceTextRange([start, end], newText);
                }
            },
            message: options[dir] ?
              "A space is required " + dir + " ','." :
              "There should be no space " + dir + " ','."
        });
    }

    function validateCommaItemSpacing(tokens, reportItem) {
        if (tokens.left && astUtils.isTokenOnSameLine(tokens.left, tokens.comma) &&
                (options.before !== sourceCode.isSpaceBetweenTokens(tokens.left, tokens.comma))
        ) {
            report(reportItem, "before", tokens.left);
        }

        if (tokens.right && !options.after && tokens.right.type === "Line") {
            return;
        }

        if (tokens.right && astUtils.isTokenOnSameLine(tokens.comma, tokens.right) &&
                (options.after !== sourceCode.isSpaceBetweenTokens(tokens.comma, tokens.right))
        ) {
            report(reportItem, "after", tokens.right);
        }
    }

    function addNullElementsToIgnoreList(node) {
        var previousToken = context.getFirstToken(node);

        node.elements.forEach(function(element) {
            var token;

            if (element === null) {
                token = context.getTokenAfter(previousToken);

                if (isComma(token)) {
                    commaTokensToIgnore.push(token);
                }
            } else {
                token = context.getTokenAfter(element);
            }

            previousToken = token;
        });
    }

    return {
        "Program:exit": function() {

            var previousToken,
                nextToken;

            tokensAndComments.forEach(function(token, i) {

                if (!isComma(token)) {
                    return;
                }

                if (token && token.type === "JSXText") {
                    return;
                }

                previousToken = tokensAndComments[i - 1];
                nextToken = tokensAndComments[i + 1];

                validateCommaItemSpacing({
                    comma: token,
                    left: isComma(previousToken) || commaTokensToIgnore.indexOf(token) > -1 ? null : previousToken,
                    right: isComma(nextToken) ? null : nextToken
                }, token);
            });
        },
        "ArrayExpression": addNullElementsToIgnoreList,
        "ArrayPattern": addNullElementsToIgnoreList

    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "before": {
                "type": "boolean"
            },
            "after": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/comma-style.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {

    var style = context.options[0] || "last",
        exceptions = {};

    if (context.options.length === 2 && context.options[1].hasOwnProperty("exceptions")) {
        exceptions = context.options[1].exceptions;
    }

    function isComma(token) {
        return !!token && (token.type === "Punctuator") && (token.value === ",");
    }

    function validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem) {

        if (astUtils.isTokenOnSameLine(commaToken, currentItemToken) &&
                astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {

            return;

        } else if (!astUtils.isTokenOnSameLine(commaToken, currentItemToken) &&
                !astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {

            context.report(reportItem, {
                line: commaToken.loc.end.line,
                column: commaToken.loc.start.column
            }, "Bad line breaking before and after ','.");

        } else if (style === "first" && !astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {

            context.report(reportItem, "',' should be placed first.");

        } else if (style === "last" && astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {

            context.report(reportItem, {
                line: commaToken.loc.end.line,
                column: commaToken.loc.end.column
            }, "',' should be placed last.");
        }
    }

    function validateComma(node, property) {
        var items = node[property],
            arrayLiteral = (node.type === "ArrayExpression"),
            previousItemToken;

        if (items.length > 1 || arrayLiteral) {

            previousItemToken = context.getFirstToken(node);

            items.forEach(function(item) {
                var commaToken = item ? context.getTokenBefore(item) : previousItemToken,
                    currentItemToken = item ? context.getFirstToken(item) : context.getTokenAfter(commaToken),
                    reportItem = item || currentItemToken;

                if (isComma(commaToken)) {
                    validateCommaItemSpacing(previousItemToken, commaToken,
                            currentItemToken, reportItem);
                }

                previousItemToken = item ? context.getLastToken(item) : previousItemToken;
            });

            if (arrayLiteral) {

                var lastToken = context.getLastToken(node),
                    nextToLastToken = context.getTokenBefore(lastToken);

                if (isComma(nextToLastToken)) {
                    validateCommaItemSpacing(
                        context.getTokenBefore(nextToLastToken),
                        nextToLastToken,
                        lastToken,
                        lastToken
                    );
                }
            }
        }
    }

    var nodes = {};

    if (!exceptions.VariableDeclaration) {
        nodes.VariableDeclaration = function(node) {
            validateComma(node, "declarations");
        };
    }
    if (!exceptions.ObjectExpression) {
        nodes.ObjectExpression = function(node) {
            validateComma(node, "properties");
        };
    }
    if (!exceptions.ArrayExpression) {
        nodes.ArrayExpression = function(node) {
            validateComma(node, "elements");
        };
    }

    return nodes;
};

module.exports.schema = [
    {
        "enum": ["first", "last"]
    },
    {
        "type": "object",
        "properties": {
            "exceptions": {
                "type": "object",
                "additionalProperties": {
                    "type": "boolean"
                }
            }
        },
        "additionalProperties": false
    }
];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/complexity.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var option = context.options[0],
        THRESHOLD = 20;

    if (typeof option === "object" && option.hasOwnProperty("maximum") && typeof option.maximum === "number") {
        THRESHOLD = option.maximum;
    }
    if (typeof option === "number") {
        THRESHOLD = option;
    }

    var fns = [];

    function startFunction() {
        fns.push(1);
    }

    function endFunction(node) {
        var complexity = fns.pop(),
            name = "anonymous";

        if (node.id) {
            name = node.id.name;
        } else if (node.parent.type === "MethodDefinition" || node.parent.type === "Property") {
            name = node.parent.key.name;
        }

        if (complexity > THRESHOLD) {
            context.report(node, "Function '{{name}}' has a complexity of {{complexity}}.", { name: name, complexity: complexity });
        }
    }

    function increaseComplexity() {
        if (fns.length) {
            fns[fns.length - 1] ++;
        }
    }

    function increaseSwitchComplexity(node) {
        if (node.test) {
            increaseComplexity(node);
        }
    }

    function increaseLogicalComplexity(node) {
        if (node.operator === "||") {
            increaseComplexity(node);
        }
    }

    return {
        "FunctionDeclaration": startFunction,
        "FunctionExpression": startFunction,
        "ArrowFunctionExpression": startFunction,
        "FunctionDeclaration:exit": endFunction,
        "FunctionExpression:exit": endFunction,
        "ArrowFunctionExpression:exit": endFunction,

        "CatchClause": increaseComplexity,
        "ConditionalExpression": increaseComplexity,
        "LogicalExpression": increaseLogicalComplexity,
        "ForStatement": increaseComplexity,
        "ForInStatement": increaseComplexity,
        "ForOfStatement": increaseComplexity,
        "IfStatement": increaseComplexity,
        "SwitchCase": increaseSwitchComplexity,
        "WhileStatement": increaseComplexity,
        "DoWhileStatement": increaseComplexity
    };

};

module.exports.schema = [
    {
        "oneOf": [
            {
                "type": "integer",
                "minimum": 0
            },
            {
                "type": "object",
                "properties": {
                    "maximum": {
                        "type": "integer",
                        "minimum": 0
                    }
                },
                "additionalProperties": false
            }
        ]
    }
];

},
   {}],

"/tmp/rules/computed-property-spacing.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {
    var sourceCode = context.getSourceCode();
    var propertyNameMustBeSpaced = context.options[0] === "always"; // default is "never"

    function reportNoBeginningSpace(node, token, tokenAfter) {
        context.report({
            node: node,
            loc: token.loc.start,
            message: "There should be no space after '" + token.value + "'",
            fix: function(fixer) {
                return fixer.removeRange([token.range[1], tokenAfter.range[0]]);
            }
        });
    }

    function reportNoEndingSpace(node, token, tokenBefore) {
        context.report({
            node: node,
            loc: token.loc.start,
            message: "There should be no space before '" + token.value + "'",
            fix: function(fixer) {
                return fixer.removeRange([tokenBefore.range[1], token.range[0]]);
            }
        });
    }

    function reportRequiredBeginningSpace(node, token) {
        context.report({
            node: node,
            loc: token.loc.start,
            message: "A space is required after '" + token.value + "'",
            fix: function(fixer) {
                return fixer.insertTextAfter(token, " ");
            }
        });
    }

    function reportRequiredEndingSpace(node, token) {
        context.report({
            node: node,
            loc: token.loc.start,
            message: "A space is required before '" + token.value + "'",
            fix: function(fixer) {
                return fixer.insertTextBefore(token, " ");
            }
        });
    }

    function checkSpacing(propertyName) {
        return function(node) {
            if (!node.computed) {
                return;
            }

            var property = node[propertyName];

            var before = context.getTokenBefore(property),
                first = context.getFirstToken(property),
                last = context.getLastToken(property),
                after = context.getTokenAfter(property);

            if (astUtils.isTokenOnSameLine(before, first)) {
                if (propertyNameMustBeSpaced) {
                    if (!sourceCode.isSpaceBetweenTokens(before, first) && astUtils.isTokenOnSameLine(before, first)) {
                        reportRequiredBeginningSpace(node, before);
                    }
                } else {
                    if (sourceCode.isSpaceBetweenTokens(before, first)) {
                        reportNoBeginningSpace(node, before, first);
                    }
                }
            }

            if (astUtils.isTokenOnSameLine(last, after)) {
                if (propertyNameMustBeSpaced) {
                    if (!sourceCode.isSpaceBetweenTokens(last, after) && astUtils.isTokenOnSameLine(last, after)) {
                        reportRequiredEndingSpace(node, after);
                    }
                } else {
                    if (sourceCode.isSpaceBetweenTokens(last, after)) {
                        reportNoEndingSpace(node, after, last);
                    }
                }
            }
        };
    }


    return {
        Property: checkSpacing("key"),
        MemberExpression: checkSpacing("property")
    };

};

module.exports.schema = [
    {
        "enum": ["always", "never"]
    }
];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/consistent-return.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

function isUnreachable(segment) {
    return !segment.reachable;
}

module.exports = function(context) {
    var funcInfo = null;

    function checkLastSegment(node) {
        var loc, type;

        if (!funcInfo.hasReturnValue ||
            funcInfo.codePath.currentSegments.every(isUnreachable) ||
            astUtils.isES5Constructor(node)
        ) {
            return;
        }

        if (node.type === "Program") {
            loc = {line: 1, column: 0};
            type = "program";
        } else if (node.type === "ArrowFunctionExpression") {
            loc = context.getSourceCode().getTokenBefore(node.body).loc.start;
            type = "function";
        } else if (
            node.parent.type === "MethodDefinition" ||
            (node.parent.type === "Property" && node.parent.method)
        ) {
            loc = node.parent.key.loc.start;
            type = "method";
        } else {
            loc = (node.id || node).loc.start;
            type = "function";
        }

        context.report({
            node: node,
            loc: loc,
            message: "Expected to return a value at the end of this {{type}}.",
            data: {type: type}
        });
    }

    return {
        "onCodePathStart": function(codePath) {
            funcInfo = {
                upper: funcInfo,
                codePath: codePath,
                hasReturn: false,
                hasReturnValue: false,
                message: ""
            };
        },
        "onCodePathEnd": function() {
            funcInfo = funcInfo.upper;
        },

        "ReturnStatement": function(node) {
            var hasReturnValue = Boolean(node.argument);

            if (!funcInfo.hasReturn) {
                funcInfo.hasReturn = true;
                funcInfo.hasReturnValue = hasReturnValue;
                funcInfo.message = "Expected " + (hasReturnValue ? "a" : "no") + " return value.";
            } else if (funcInfo.hasReturnValue !== hasReturnValue) {
                context.report({node: node, message: funcInfo.message});
            }
        },

        "Program:exit": checkLastSegment,
        "FunctionDeclaration:exit": checkLastSegment,
        "FunctionExpression:exit": checkLastSegment,
        "ArrowFunctionExpression:exit": checkLastSegment
    };
};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/consistent-this.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var aliases = [];

    if (context.options.length === 0) {
        aliases.push("that");
    } else {
        aliases = context.options;
    }

    function reportBadAssignment(node, alias) {
        context.report(node,
            "Designated alias '{{alias}}' is not assigned to 'this'.",
            { alias: alias });
    }

    function checkAssignment(node, name, value) {
        var isThis = value.type === "ThisExpression";

        if (aliases.indexOf(name) !== -1) {
            if (!isThis || node.operator && node.operator !== "=") {
                reportBadAssignment(node, name);
            }
        } else if (isThis) {
            context.report(node,
                "Unexpected alias '{{name}}' for 'this'.", { name: name });
        }
    }

    function checkWasAssigned(alias, scope) {
        var variable = scope.set.get(alias);

        if (!variable) {
            return;
        }

        if (variable.defs.some(function(def) {
            return def.node.type === "VariableDeclarator" &&
            def.node.init !== null;
        })) {
            return;
        }

        if (!variable.references.some(function(reference) {
            var write = reference.writeExpr;
            return (
                reference.from === scope &&
                write && write.type === "ThisExpression" &&
                write.parent.operator === "="
            );
        })) {
            variable.defs.map(function(def) {
                return def.node;
            }).forEach(function(node) {
                reportBadAssignment(node, alias);
            });
        }
    }

    function ensureWasAssigned() {
        var scope = context.getScope();

        aliases.forEach(function(alias) {
            checkWasAssigned(alias, scope);
        });
    }

    return {
        "Program:exit": ensureWasAssigned,
        "FunctionExpression:exit": ensureWasAssigned,
        "FunctionDeclaration:exit": ensureWasAssigned,

        "VariableDeclarator": function(node) {
            var id = node.id;
            var isDestructuring =
                id.type === "ArrayPattern" || id.type === "ObjectPattern";

            if (node.init !== null && !isDestructuring) {
                checkAssignment(node, id.name, node.init);
            }
        },

        "AssignmentExpression": function(node) {
            if (node.left.type === "Identifier") {
                checkAssignment(node, node.left.name, node.right);
            }
        }
    };

};

module.exports.schema = {
    "type": "array",
    "items": {
        "type": "string",
        "minLength": 1
    },
    "uniqueItems": true
};

},
   {}],

"/tmp/rules/constructor-super.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

function isConstructorFunction(node) {
    return (
        node.type === "FunctionExpression" &&
        node.parent.type === "MethodDefinition" &&
        node.parent.kind === "constructor"
    );
}

module.exports = function(context) {
    var funcInfo = null;

    var segInfoMap = Object.create(null);

    function isCalledInSomePath(segment) {
        return segInfoMap[segment.id].calledInSomePaths;
    }

    function isCalledInEveryPath(segment) {
        if (segment.nextSegments.length === 1 &&
            segment.nextSegments[0].isLoopedPrevSegment(segment)
        ) {
            return true;
        }
        return segInfoMap[segment.id].calledInEveryPaths;
    }

    return {
        "onCodePathStart": function(codePath, node) {
            if (isConstructorFunction(node)) {
                var classNode = node.parent.parent.parent;
                funcInfo = {
                    upper: funcInfo,
                    isConstructor: true,
                    hasExtends: Boolean(
                        classNode.superClass &&
                        !astUtils.isNullOrUndefined(classNode.superClass)
                    ),
                    codePath: codePath
                };
            } else {
                funcInfo = {
                    upper: funcInfo,
                    isConstructor: false,
                    hasExtends: false,
                    codePath: codePath
                };
            }
        },

        "onCodePathEnd": function(codePath, node) {
            var hasExtends = funcInfo.hasExtends;
            funcInfo = funcInfo.upper;
            if (!hasExtends) {
                return;
            }

            var segments = codePath.returnedSegments;
            var calledInEveryPaths = segments.every(isCalledInEveryPath);
            var calledInSomePaths = segments.some(isCalledInSomePath);
            if (!calledInEveryPaths) {
                context.report({
                    message: calledInSomePaths ?
                        "Lacked a call of 'super()' in some code paths." :
                        "Expected to call 'super()'.",
                    node: node.parent
                });
            }
        },

        "onCodePathSegmentStart": function(segment) {
            if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {
                return;
            }

            var info = segInfoMap[segment.id] = {
                calledInSomePaths: false,
                calledInEveryPaths: false,
                validNodes: []
            };

            var prevSegments = segment.prevSegments;
            if (prevSegments.length > 0) {
                info.calledInSomePaths = prevSegments.some(isCalledInSomePath);
                info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);
            }
        },

        "onCodePathSegmentLoop": function(fromSegment, toSegment) {
            if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {
                return;
            }

            var isRealLoop = toSegment.prevSegments.length >= 2;
            funcInfo.codePath.traverseSegments(
                {first: toSegment, last: fromSegment},
                function(segment) {
                    var info = segInfoMap[segment.id];

                    var prevSegments = segment.prevSegments;
                    info.calledInSomePaths = prevSegments.some(isCalledInSomePath);
                    info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);

                    if (info.calledInSomePaths || isRealLoop) {
                        var nodes = info.validNodes;
                        info.validNodes = [];

                        for (var i = 0; i < nodes.length; ++i) {
                            var node = nodes[i];
                            context.report({
                                message: "Unexpected duplicate 'super()'.",
                                node: node
                            });
                        }
                    }
                }
            );
        },

        "CallExpression:exit": function(node) {
            if (node.callee.type !== "Super") {
                return;
            }

            if (!(funcInfo && funcInfo.isConstructor)) {
                return;
            }

            if (funcInfo.hasExtends) {
                var segments = funcInfo.codePath.currentSegments;
                var duplicate = false;
                for (var i = 0; i < segments.length; ++i) {
                    var info = segInfoMap[segments[i].id];

                    duplicate = duplicate || info.calledInSomePaths;
                    info.calledInSomePaths = info.calledInEveryPaths = true;
                }

                if (duplicate) {
                    context.report({
                        message: "Unexpected duplicate 'super()'.",
                        node: node
                    });
                } else {
                    info.validNodes.push(node);
                }
            } else {
                context.report({
                    message: "Unexpected 'super()'.",
                    node: node
                });
            }
        },

        "Program:exit": function() {
            segInfoMap = Object.create(null);
        }
    };
};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/curly.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {

    var multiOnly = (context.options[0] === "multi");
    var multiLine = (context.options[0] === "multi-line");
    var multiOrNest = (context.options[0] === "multi-or-nest");
    var consistent = (context.options[1] === "consistent");

    function isCollapsedOneLiner(node) {
        var before = context.getTokenBefore(node),
            last = context.getLastToken(node);
        return before.loc.start.line === last.loc.end.line;
    }

    function isOneLiner(node) {
        var first = context.getFirstToken(node),
            last = context.getLastToken(node);

        return first.loc.start.line === last.loc.end.line;
    }

    function getElseKeyword(node) {
        var sourceCode = context.getSourceCode();
        var token = sourceCode.getTokenAfter(node.consequent);

        while (token.type !== "Keyword" || token.value !== "else") {
            token = sourceCode.getTokenAfter(token);
        }

        return token;
    }

    function requiresBraceOfConsequent(node) {
        if (node.alternate && node.consequent.type === "BlockStatement") {
            if (node.consequent.body.length >= 2) {
                return true;
            }

            node = node.consequent.body[0];
            while (node) {
                if (node.type === "IfStatement" && !node.alternate) {
                    return true;
                }
                node = astUtils.getTrailingStatement(node);
            }
        }

        return false;
    }

    function reportExpectedBraceError(node, name, suffix) {
        context.report({
            node: node,
            loc: (name !== "else" ? node : getElseKeyword(node)).loc.start,
            message: "Expected { after '{{name}}'{{suffix}}.",
            data: {
                name: name,
                suffix: (suffix ? " " + suffix : "")
            }
        });
    }

    function reportUnnecessaryBraceError(node, name, suffix) {
        context.report({
            node: node,
            loc: (name !== "else" ? node : getElseKeyword(node)).loc.start,
            message: "Unnecessary { after '{{name}}'{{suffix}}.",
            data: {
                name: name,
                suffix: (suffix ? " " + suffix : "")
            }
        });
    }

    function prepareCheck(node, body, name, suffix) {
        var hasBlock = (body.type === "BlockStatement");
        var expected = null;

        if (node.type === "IfStatement" && node.consequent === body && requiresBraceOfConsequent(node)) {
            expected = true;
        } else if (multiOnly) {
            if (hasBlock && body.body.length === 1) {
                expected = false;
            }
        } else if (multiLine) {
            if (!isCollapsedOneLiner(body)) {
                expected = true;
            }
        } else if (multiOrNest) {
            if (hasBlock && body.body.length === 1 && isOneLiner(body.body[0])) {
                expected = false;
            } else if (!isOneLiner(body)) {
                expected = true;
            }
        } else {
            expected = true;
        }

        return {
            actual: hasBlock,
            expected: expected,
            check: function() {
                if (this.expected !== null && this.expected !== this.actual) {
                    if (this.expected) {
                        reportExpectedBraceError(node, name, suffix);
                    } else {
                        reportUnnecessaryBraceError(node, name, suffix);
                    }
                }
            }
        };
    }

    function prepareIfChecks(node) {
        var preparedChecks = [];
        do {
            preparedChecks.push(prepareCheck(node, node.consequent, "if", "condition"));
            if (node.alternate && node.alternate.type !== "IfStatement") {
                preparedChecks.push(prepareCheck(node, node.alternate, "else"));
                break;
            }
            node = node.alternate;
        } while (node);

        if (consistent) {
            var expected = preparedChecks.some(function(preparedCheck) {
                if (preparedCheck.expected !== null) {
                    return preparedCheck.expected;
                }
                return preparedCheck.actual;
            });

            preparedChecks.forEach(function(preparedCheck) {
                preparedCheck.expected = expected;
            });
        }

        return preparedChecks;
    }

    return {
        "IfStatement": function(node) {
            if (node.parent.type !== "IfStatement") {
                prepareIfChecks(node).forEach(function(preparedCheck) {
                    preparedCheck.check();
                });
            }
        },

        "WhileStatement": function(node) {
            prepareCheck(node, node.body, "while", "condition").check();
        },

        "DoWhileStatement": function(node) {
            prepareCheck(node, node.body, "do").check();
        },

        "ForStatement": function(node) {
            prepareCheck(node, node.body, "for", "condition").check();
        },

        "ForInStatement": function(node) {
            prepareCheck(node, node.body, "for-in").check();
        },

        "ForOfStatement": function(node) {
            prepareCheck(node, node.body, "for-of").check();
        }
    };
};

module.exports.schema = {
    "anyOf": [
        {
            "type": "array",
            "items": [
                {
                    "enum": ["all"]
                }
            ],
            "minItems": 0,
            "maxItems": 1
        },
        {
            "type": "array",
            "items": [
                {
                    "enum": ["multi", "multi-line", "multi-or-nest"]
                },
                {
                    "enum": ["consistent"]
                }
            ],
            "minItems": 0,
            "maxItems": 2
        }
    ]
};

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/default-case.js": [function(require,module,exports){
"use strict";

var COMMENT_VALUE = "no default";

module.exports = function(context) {

    function last(collection) {
        return collection[collection.length - 1];
    }

    return {

        "SwitchStatement": function(node) {

            if (!node.cases.length) {
                return;
            }

            var hasDefault = node.cases.some(function(v) {
                return v.test === null;
            });

            if (!hasDefault) {

                var comment;
                var comments;

                var lastCase = last(node.cases);
                comments = context.getComments(lastCase).trailing;

                if (comments.length) {
                    comment = last(comments);
                }

                if (!comment || comment.value.trim() !== COMMENT_VALUE) {
                    context.report(node, "Expected a default case.");
                }
            }
        }
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/dot-location.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {

    var config = context.options[0],
        onObject = config === "object" || !config;

    function checkDotLocation(obj, prop, node) {
        var dot = context.getTokenBefore(prop);

        if (dot.type === "Punctuator" && dot.value === ".") {
            if (onObject) {
                if (!astUtils.isTokenOnSameLine(obj, dot)) {
                    context.report(node, dot.loc.start, "Expected dot to be on same line as object.");
                }
            } else if (!astUtils.isTokenOnSameLine(dot, prop)) {
                context.report(node, dot.loc.start, "Expected dot to be on same line as property.");
            }
        }
    }

    function checkNode(node) {
        checkDotLocation(node.object, node.property, node);
    }

    return {
        "MemberExpression": checkNode
    };
};

module.exports.schema = [
    {
        "enum": ["object", "property"]
    }
];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/dot-notation.js": [function(require,module,exports){
"use strict";

var validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/;
var keywords = require("../util/keywords");

module.exports = function(context) {
    var options = context.options[0] || {};
    var allowKeywords = options.allowKeywords === void 0 || !!options.allowKeywords;

    var allowPattern;
    if (options.allowPattern) {
        allowPattern = new RegExp(options.allowPattern);
    }

    return {
        "MemberExpression": function(node) {
            if (
                node.computed &&
                node.property.type === "Literal" &&
                validIdentifier.test(node.property.value) &&
                (allowKeywords || keywords.indexOf("" + node.property.value) === -1)
            ) {
                if (!(allowPattern && allowPattern.test(node.property.value))) {
                    context.report(node.property, "[" + JSON.stringify(node.property.value) + "] is better written in dot notation.");
                }
            }
            if (
                !allowKeywords &&
                !node.computed &&
                keywords.indexOf("" + node.property.name) !== -1
            ) {
                context.report(node.property, "." + node.property.name + " is a syntax error.");
            }
        }
    };
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "allowKeywords": {
                "type": "boolean"
            },
            "allowPattern": {
                "type": "string"
            }
        },
        "additionalProperties": false
    }
];

},
   {"../util/keywords":"/tmp/util/keywords.js"}],

"/tmp/rules/eol-last.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "Program": function checkBadEOF(node) {
            var src = context.getSource(),
                location = {column: 1},
                linebreakStyle = context.options[0] || "unix",
                linebreak = linebreakStyle === "unix" ? "\n" : "\r\n";

            if (src[src.length - 1] !== "\n") {
                location.line = src.split(/\n/g).length;
                context.report({
                    node: node,
                    loc: location,
                    message: "Newline required at end of file but not found.",
                    fix: function(fixer) {
                        return fixer.insertTextAfterRange([0, src.length], linebreak);
                    }
                });
            }
        }

    };

};

module.exports.schema = [
    {
        "enum": ["unix", "windows"]
    }
];

},
   {}],

"/tmp/rules/eqeqeq.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    function isTypeOf(node) {
        return node.type === "UnaryExpression" && node.operator === "typeof";
    }

    function isTypeOfBinary(node) {
        return isTypeOf(node.left) || isTypeOf(node.right);
    }

    function areLiteralsAndSameType(node) {
        return node.left.type === "Literal" && node.right.type === "Literal" &&
                typeof node.left.value === typeof node.right.value;
    }

    function isNullCheck(node) {
        return (node.right.type === "Literal" && node.right.value === null) ||
                (node.left.type === "Literal" && node.left.value === null);
    }

    function getOperatorLocation(node) {
        var opToken = context.getTokenAfter(node.left);
        return {line: opToken.loc.start.line, column: opToken.loc.start.column};
    }

    return {
        "BinaryExpression": function(node) {
            if (node.operator !== "==" && node.operator !== "!=") {
                return;
            }

            if (context.options[0] === "smart" && (isTypeOfBinary(node) ||
                    areLiteralsAndSameType(node) || isNullCheck(node))) {
                return;
            }

            if (context.options[0] === "allow-null" && isNullCheck(node)) {
                return;
            }

            context.report({
                node: node,
                loc: getOperatorLocation(node),
                message: "Expected '{{op}}=' and instead saw '{{op}}'.",
                data: { op: node.operator }
            });

        }
    };

};

module.exports.schema = [
    {
        "enum": ["smart", "allow-null"]
    }
];

},
   {}],

"/tmp/rules/func-names.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    function isObjectOrClassMethod() {
        var parent = context.getAncestors().pop();

        return (parent.type === "MethodDefinition" || (
            parent.type === "Property" && (
                parent.method ||
                parent.kind === "get" ||
                parent.kind === "set"
            )
        ));
    }

    return {
        "FunctionExpression": function(node) {

            var name = node.id && node.id.name;

            if (!name && !isObjectOrClassMethod()) {
                context.report(node, "Missing function expression name.");
            }
        }
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/func-style.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var style = context.options[0],
        allowArrowFunctions = context.options[1] && context.options[1].allowArrowFunctions === true,
        enforceDeclarations = (style === "declaration"),
        stack = [];

    var nodesToCheck = {
        "Program": function() {
            stack = [];
        },

        "FunctionDeclaration": function(node) {
            stack.push(false);

            if (!enforceDeclarations && node.parent.type !== "ExportDefaultDeclaration") {
                context.report(node, "Expected a function expression.");
            }
        },
        "FunctionDeclaration:exit": function() {
            stack.pop();
        },

        "FunctionExpression": function(node) {
            stack.push(false);

            if (enforceDeclarations && node.parent.type === "VariableDeclarator") {
                context.report(node.parent, "Expected a function declaration.");
            }
        },
        "FunctionExpression:exit": function() {
            stack.pop();
        },

        "ThisExpression": function() {
            if (stack.length > 0) {
                stack[stack.length - 1] = true;
            }
        }
    };

    if (!allowArrowFunctions) {
        nodesToCheck.ArrowFunctionExpression = function() {
            stack.push(false);
        };

        nodesToCheck["ArrowFunctionExpression:exit"] = function(node) {
            var hasThisExpr = stack.pop();

            if (enforceDeclarations && !hasThisExpr && node.parent.type === "VariableDeclarator") {
                context.report(node.parent, "Expected a function declaration.");
            }
        };
    }

    return nodesToCheck;

};

module.exports.schema = [
    {
        "enum": ["declaration", "expression"]
    },
    {
        "type": "object",
        "properties": {
            "allowArrowFunctions": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/generator-star-spacing.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var mode = (function(option) {
        if (!option || typeof option === "string") {
            return {
                before: { before: true, after: false },
                after: { before: false, after: true },
                both: { before: true, after: true },
                neither: { before: false, after: false }
            }[option || "before"];
        }
        return option;
    }(context.options[0]));

    function checkSpacing(side, leftToken, rightToken) {
        if (!!(rightToken.range[0] - leftToken.range[1]) !== mode[side]) {
            var after = leftToken.value === "*";
            var spaceRequired = mode[side];
            var node = after ? leftToken : rightToken;
            var type = spaceRequired ? "Missing" : "Unexpected";
            var message = type + " space " + side + " *.";
            context.report({
                node: node,
                message: message,
                fix: function(fixer) {
                    if (spaceRequired) {
                        if (after) {
                            return fixer.insertTextAfter(node, " ");
                        }
                        return fixer.insertTextBefore(node, " ");
                    }
                    return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
                }
            });
        }
    }

    function checkFunction(node) {
        var prevToken, starToken, nextToken;

        if (!node.generator) {
            return;
        }

        if (node.parent.method || node.parent.type === "MethodDefinition") {
            starToken = context.getTokenBefore(node, 1);
        } else {
            starToken = context.getFirstToken(node, 1);
        }

        prevToken = context.getTokenBefore(starToken);
        if (prevToken.value === "function" || prevToken.value === "static") {
            checkSpacing("before", prevToken, starToken);
        }

        nextToken = context.getTokenAfter(starToken);
        checkSpacing("after", starToken, nextToken);
    }

    return {
        "FunctionDeclaration": checkFunction,
        "FunctionExpression": checkFunction
    };

};

module.exports.schema = [
    {
        "oneOf": [
            {
                "enum": ["before", "after", "both", "neither"]
            },
            {
                "type": "object",
                "properties": {
                    "before": {"type": "boolean"},
                    "after": {"type": "boolean"}
                },
                "additionalProperties": false
            }
        ]
    }
];

},
   {}],

"/tmp/rules/global-require.js": [function(require,module,exports){
"use strict";

var ACCEPTABLE_PARENTS = [
    "AssignmentExpression",
    "VariableDeclarator",
    "MemberExpression",
    "ExpressionStatement",
    "CallExpression",
    "ConditionalExpression",
    "Program",
    "VariableDeclaration"
];

function findReference(scope, node) {
    var references = scope.references.filter(function(reference) {
        return reference.identifier.range[0] === node.range[0] &&
            reference.identifier.range[1] === node.range[1];
    });

    if (references.length === 1) {
        return references[0];
    } else {
        return null;
    }
}

function isShadowed(scope, node) {
    var reference = findReference(scope, node);
    return reference && reference.resolved && reference.resolved.defs.length > 0;
}

module.exports = function(context) {
    return {
        "CallExpression": function(node) {
            var currentScope = context.getScope(),
                isGoodRequire;

            if (node.callee.name === "require" && !isShadowed(currentScope, node.callee)) {
                isGoodRequire = context.getAncestors().every(function(parent) {
                    return ACCEPTABLE_PARENTS.indexOf(parent.type) > -1;
                });
                if (!isGoodRequire) {
                    context.report(node, "Unexpected require().");
                }
            }
        }
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/guard-for-in.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "ForInStatement": function(node) {

            var body = node.body.type === "BlockStatement" ? node.body.body[0] : node.body;

            if (body && body.type !== "IfStatement") {
                context.report(node, "The body of a for-in should be wrapped in an if statement to filter unwanted properties from the prototype.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/handle-callback-err.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var errorArgument = context.options[0] || "err";

    function isPattern(stringToCheck) {
        var firstChar = stringToCheck[0];
        return firstChar === "^";
    }

    function matchesConfiguredErrorName(name) {
        if (isPattern(errorArgument)) {
            var regexp = new RegExp(errorArgument);
            return regexp.test(name);
        }
        return name === errorArgument;
    }

    function getParameters(scope) {
        return scope.variables.filter(function(variable) {
            return variable.defs[0] && variable.defs[0].type === "Parameter";
        });
    }

    function checkForError(node) {
        var scope = context.getScope(),
            parameters = getParameters(scope),
            firstParameter = parameters[0];

        if (firstParameter && matchesConfiguredErrorName(firstParameter.name)) {
            if (firstParameter.references.length === 0) {
                context.report(node, "Expected error to be handled.");
            }
        }
    }

    return {
        "FunctionDeclaration": checkForError,
        "FunctionExpression": checkForError,
        "ArrowFunctionExpression": checkForError
    };

};

module.exports.schema = [
    {
        "type": "string"
    }
];

},
   {}],

"/tmp/rules/id-blacklist.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {


    var blacklist = context.options;


    function isInvalid(name) {
        return blacklist.indexOf(name) !== -1;
    }

    function shouldReport(effectiveParent, name) {
        return effectiveParent.type !== "CallExpression"
            && effectiveParent.type !== "NewExpression" &&
            isInvalid(name);
    }

    function report(node) {
        context.report(node, "Identifier '{{name}}' is blacklisted", {
            name: node.name
        });
    }

    return {

        "Identifier": function(node) {
            var name = node.name,
                effectiveParent = (node.parent.type === "MemberExpression") ? node.parent.parent : node.parent;

            if (node.parent.type === "MemberExpression") {

                if (node.parent.object.type === "Identifier" &&
                    node.parent.object.name === node.name) {
                    if (isInvalid(name)) {
                        report(node);
                    }

                } else if (effectiveParent.type === "AssignmentExpression" &&
                    (effectiveParent.right.type !== "MemberExpression" ||
                    effectiveParent.left.type === "MemberExpression" &&
                    effectiveParent.left.property.name === node.name)) {
                    if (isInvalid(name)) {
                        report(node);
                    }
                }

            } else if (node.parent.type === "Property") {

                if (shouldReport(effectiveParent, name)) {
                    report(node);
                }

            } else if (shouldReport(effectiveParent, name)) {
                report(node);
            }
        }

    };

};
module.exports.schema = {
    "type": "array",
    "items": {
        "type": "string"
    },
    "uniqueItems": true
};

},
   {}],

"/tmp/rules/id-length.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var options = context.options[0] || {};
    var minLength = typeof options.min !== "undefined" ? options.min : 2;
    var maxLength = typeof options.max !== "undefined" ? options.max : Infinity;
    var properties = options.properties !== "never";
    var exceptions = (options.exceptions ? options.exceptions : [])
        .reduce(function(obj, item) {
            obj[item] = true;

            return obj;
        }, {});

    var SUPPORTED_EXPRESSIONS = {
        "MemberExpression": properties && function(parent) {
            return !parent.computed && (
                parent.parent.left === parent || (
                    parent.parent.type === "Property" && parent.parent.value === parent &&
                    parent.parent.parent.type === "ObjectPattern" && parent.parent.parent.parent.left === parent.parent.parent
                )
            );
        },
        "AssignmentPattern": function(parent, node) {
            return parent.left === node;
        },
        "VariableDeclarator": function(parent, node) {
            return parent.id === node;
        },
        "Property": properties && function(parent, node) {
            return parent.key === node;
        },
        "ImportDefaultSpecifier": true,
        "RestElement": true,
        "FunctionExpression": true,
        "ArrowFunctionExpression": true,
        "ClassDeclaration": true,
        "FunctionDeclaration": true,
        "MethodDefinition": true,
        "CatchClause": true
    };

    return {
        Identifier: function(node) {
            var name = node.name;
            var parent = node.parent;

            var isShort = name.length < minLength;
            var isLong = name.length > maxLength;
            if (!(isShort || isLong) || exceptions[name]) {
                return;  // Nothing to report
            }

            var isValidExpression = SUPPORTED_EXPRESSIONS[parent.type];

            if (isValidExpression && (isValidExpression === true || isValidExpression(parent, node))) {
                context.report(
                    node,
                    isShort ?
                        "Identifier name '{{name}}' is too short. (< {{min}})" :
                        "Identifier name '{{name}}' is too long. (> {{max}})",
                    { name: name, min: minLength, max: maxLength }
                );
            }
        }
    };
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "min": {
                "type": "number"
            },
            "max": {
                "type": "number"
            },
            "exceptions": {
                "type": "array",
                "uniqueItems": true,
                "items": {
                    "type": "string"
                }
            },
            "properties": {
                "enum": ["always", "never"]
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/id-match.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var pattern = context.options[0] || "^.+$",
        regexp = new RegExp(pattern);

    var options = context.options[1] || {},
        properties = options.properties;

    properties = !!properties;


    function isInvalid(name) {
        return !regexp.test(name);
    }

    function shouldReport(effectiveParent, name) {
        return effectiveParent.type !== "CallExpression"
            && effectiveParent.type !== "NewExpression" &&
            isInvalid(name);
    }

    function report(node) {
        context.report(node, "Identifier '{{name}}' does not match the pattern '{{pattern}}'.", {
            name: node.name,
            pattern: pattern
        });
    }

    return {

        "Identifier": function(node) {
            var name = node.name,
                effectiveParent = (node.parent.type === "MemberExpression") ? node.parent.parent : node.parent;

            if (node.parent.type === "MemberExpression") {
                if (!properties) {
                    return;
                }

                if (node.parent.object.type === "Identifier" &&
                    node.parent.object.name === node.name) {
                    if (isInvalid(name)) {
                        report(node);
                    }

                } else if (effectiveParent.type === "AssignmentExpression" &&
                    (effectiveParent.right.type !== "MemberExpression" ||
                    effectiveParent.left.type === "MemberExpression" &&
                    effectiveParent.left.property.name === node.name)) {
                    if (isInvalid(name)) {
                        report(node);
                    }
                }

            } else if (node.parent.type === "Property") {
                if (!properties) {
                    return;
                }

                if (shouldReport(effectiveParent, name)) {
                    report(node);
                }

            } else if (shouldReport(effectiveParent, name)) {
                report(node);
            }
        }

    };

};

module.exports.schema = [
    {
        "type": "string"
    },
    {
        "type": "object",
        "properties": {
            "properties": {
                "type": "boolean"
            }
        }
    }
];

},
   {}],

"/tmp/rules/indent.js": [function(require,module,exports){
"use strict";

var util = require("util");
var lodash = require("lodash");

module.exports = function(context) {

    var MESSAGE = "Expected indentation of {{needed}} {{type}} {{characters}} but found {{gotten}}.";
    var DEFAULT_VARIABLE_INDENT = 1;

    var indentType = "space";
    var indentSize = 4;
    var options = {
        SwitchCase: 0,
        VariableDeclarator: {
            var: DEFAULT_VARIABLE_INDENT,
            let: DEFAULT_VARIABLE_INDENT,
            const: DEFAULT_VARIABLE_INDENT
        }
    };

    if (context.options.length) {
        if (context.options[0] === "tab") {
            indentSize = 1;
            indentType = "tab";
        } else /* istanbul ignore else : this will be caught by options validation */ if (typeof context.options[0] === "number") {
            indentSize = context.options[0];
            indentType = "space";
        }

        if (context.options[1]) {
            var opts = context.options[1];
            options.SwitchCase = opts.SwitchCase || 0;
            var variableDeclaratorRules = opts.VariableDeclarator;
            if (typeof variableDeclaratorRules === "number") {
                options.VariableDeclarator = {
                    var: variableDeclaratorRules,
                    let: variableDeclaratorRules,
                    const: variableDeclaratorRules
                };
            } else if (typeof variableDeclaratorRules === "object") {
                lodash.assign(options.VariableDeclarator, variableDeclaratorRules);
            }
        }
    }

    var indentPattern = {
        normal: indentType === "space" ? /^ +/ : /^\t+/,
        excludeCommas: indentType === "space" ? /^[ ,]+/ : /^[\t,]+/
    };

    var caseIndentStore = {};

    function report(node, needed, gotten, loc, isLastNodeCheck) {
        var msgContext = {
            needed: needed,
            type: indentType,
            characters: needed === 1 ? "character" : "characters",
            gotten: gotten
        };
        var indentChar = indentType === "space" ? " " : "\t";

        function getFixerFunction() {
            var rangeToFix = [];

            if (needed > gotten) {
                var spaces = "" + new Array(needed - gotten + 1).join(indentChar);  // replace with repeat in future

                if (isLastNodeCheck === true) {
                    rangeToFix = [
                        node.range[1] - 1,
                        node.range[1] - 1
                    ];
                } else {
                    rangeToFix = [
                        node.range[0],
                        node.range[0]
                    ];
                }

                return function(fixer) {
                    return fixer.insertTextBeforeRange(rangeToFix, spaces);
                };
            } else {
                if (isLastNodeCheck === true) {
                    rangeToFix = [
                        node.range[1] - (gotten - needed) - 1,
                        node.range[1] - 1
                    ];
                } else {
                    rangeToFix = [
                        node.range[0] - (gotten - needed),
                        node.range[0]
                    ];
                }

                return function(fixer) {
                    return fixer.removeRange(rangeToFix);
                };
            }
        }

        if (loc) {
            context.report({
                node: node,
                loc: loc,
                message: MESSAGE,
                data: msgContext,
                fix: getFixerFunction()
            });
        } else {
            context.report({
                node: node,
                message: MESSAGE,
                data: msgContext,
                fix: getFixerFunction()
            });
        }
    }

    function getNodeIndent(node, byLastLine, excludeCommas) {
        var token = byLastLine ? context.getLastToken(node) : context.getFirstToken(node);
        var src = context.getSource(token, token.loc.start.column);
        var regExp = excludeCommas ? indentPattern.excludeCommas : indentPattern.normal;
        var indent = regExp.exec(src);

        return indent ? indent[0].length : 0;
    }

    function isNodeFirstInLine(node, byEndLocation) {
        var firstToken = byEndLocation === true ? context.getLastToken(node, 1) : context.getTokenBefore(node),
            startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line,
            endLine = firstToken ? firstToken.loc.end.line : -1;

        return startLine !== endLine;
    }

    function checkNodeIndent(node, indent, excludeCommas) {
        var nodeIndent = getNodeIndent(node, false, excludeCommas);
        if (
            node.type !== "ArrayExpression" && node.type !== "ObjectExpression" &&
            nodeIndent !== indent && isNodeFirstInLine(node)
        ) {
            report(node, indent, nodeIndent);
        }
    }

    function checkNodesIndent(nodes, indent, excludeCommas) {
        nodes.forEach(function(node) {
            if (node.type === "IfStatement" && node.alternate) {
                var elseToken = context.getTokenBefore(node.alternate);
                checkNodeIndent(elseToken, indent, excludeCommas);
            }
            checkNodeIndent(node, indent, excludeCommas);
        });
    }

    function checkLastNodeLineIndent(node, lastLineIndent) {
        var lastToken = context.getLastToken(node);
        var endIndent = getNodeIndent(lastToken, true);

        if (endIndent !== lastLineIndent && isNodeFirstInLine(node, true)) {
            report(
                node,
                lastLineIndent,
                endIndent,
                { line: lastToken.loc.start.line, column: lastToken.loc.start.column },
                true
            );
        }
    }

    function checkFirstNodeLineIndent(node, firstLineIndent) {
        var startIndent = getNodeIndent(node, false);
        if (startIndent !== firstLineIndent && isNodeFirstInLine(node)) {
            report(
                node,
                firstLineIndent,
                startIndent,
                { line: node.loc.start.line, column: node.loc.start.column }
            );
        }
    }

    function getVariableDeclaratorNode(node) {
        var parent = node.parent;

        while (parent.type !== "VariableDeclarator" && parent.type !== "Program") {
            parent = parent.parent;
        }

        return parent.type === "VariableDeclarator" ? parent : null;
    }

    function isNodeInVarOnTop(node, varNode) {
        return varNode &&
            varNode.parent.loc.start.line === node.loc.start.line &&
            varNode.parent.declarations.length > 1;
    }

    function isArgBeforeCalleeNodeMultiline(node) {
        var parent = node.parent;

        if (parent.arguments.length >= 2 && parent.arguments[1] === node) {
            return parent.arguments[0].loc.end.line > parent.arguments[0].loc.start.line;
        }

        return false;
    }

    function checkIndentInFunctionBlock(node) {

        var calleeNode = node.parent; // FunctionExpression
        var indent;

        if (calleeNode.parent &&
            (calleeNode.parent.type === "Property" ||
            calleeNode.parent.type === "ArrayExpression")) {
            indent = getNodeIndent(calleeNode, false, false);
        } else {
            indent = getNodeIndent(calleeNode);
        }

        if (calleeNode.parent.type === "CallExpression") {
            var calleeParent = calleeNode.parent;

            if (calleeNode.type !== "FunctionExpression" && calleeNode.type !== "ArrowFunctionExpression") {
                if (calleeParent && calleeParent.loc.start.line < node.loc.start.line) {
                    indent = getNodeIndent(calleeParent);
                }
            } else {
                if (isArgBeforeCalleeNodeMultiline(calleeNode) &&
                    calleeParent.callee.loc.start.line === calleeParent.callee.loc.end.line &&
                    !isNodeFirstInLine(calleeNode)) {
                    indent = getNodeIndent(calleeParent);
                }
            }
        }

        indent += indentSize;

        var parentVarNode = getVariableDeclaratorNode(node);
        if (parentVarNode && isNodeInVarOnTop(node, parentVarNode)) {
            indent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
        }

        if (node.body.length > 0) {
            checkNodesIndent(node.body, indent);
        }

        checkLastNodeLineIndent(node, indent - indentSize);
    }


    function isSingleLineNode(node) {
        var lastToken = context.getLastToken(node),
            startLine = node.loc.start.line,
            endLine = lastToken.loc.end.line;

        return startLine === endLine;
    }

    function isFirstArrayElementOnSameLine(node) {
        if (node.type === "ArrayExpression" && node.elements[0]) {
            return node.elements[0].loc.start.line === node.loc.start.line && node.elements[0].type === "ObjectExpression";
        } else {
            return false;
        }
    }

    function checkIndentInArrayOrObjectBlock(node) {
        if (isSingleLineNode(node)) {
            return;
        }

        var elements = (node.type === "ArrayExpression") ? node.elements : node.properties;

        elements = elements.filter(function(elem) {
            return elem !== null;
        });

        if (elements.length > 0 && elements[0].loc.start.line === node.loc.start.line) {
            return;
        }

        var nodeIndent;
        var elementsIndent;
        var parentVarNode = getVariableDeclaratorNode(node);

        if (isNodeFirstInLine(node)) {
            var parent = node.parent;
            var effectiveParent = parent;

            if (parent.type === "MemberExpression") {
                if (isNodeFirstInLine(parent)) {
                    effectiveParent = parent.parent.parent;
                } else {
                    effectiveParent = parent.parent;
                }
            }
            nodeIndent = getNodeIndent(effectiveParent);
            if (parentVarNode && parentVarNode.loc.start.line !== node.loc.start.line) {
                if (parent.type !== "VariableDeclarator" || parentVarNode === parentVarNode.parent.declarations[0]) {
                    if (parentVarNode.loc.start.line === effectiveParent.loc.start.line) {
                        nodeIndent = nodeIndent + (indentSize * options.VariableDeclarator[parentVarNode.parent.kind]);
                    } else if (
                        parent.type === "ObjectExpression" ||
                        parent.type === "ArrayExpression" ||
                        parent.type === "CallExpression" ||
                        parent.type === "ArrowFunctionExpression" ||
                        parent.type === "NewExpression"
                    ) {
                        nodeIndent = nodeIndent + indentSize;
                    }
                }
            } else if (!parentVarNode && !isFirstArrayElementOnSameLine(parent) && effectiveParent.type !== "MemberExpression" && effectiveParent.type !== "ExpressionStatement" && effectiveParent.type !== "AssignmentExpression" && effectiveParent.type !== "Property") {
                nodeIndent = nodeIndent + indentSize;
            }

            elementsIndent = nodeIndent + indentSize;

            checkFirstNodeLineIndent(node, nodeIndent);
        } else {
            nodeIndent = getNodeIndent(node);
            elementsIndent = nodeIndent + indentSize;
        }

        if (isNodeInVarOnTop(node, parentVarNode)) {
            elementsIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
        }

        checkNodesIndent(elements, elementsIndent, true);

        if (elements.length > 0) {
            if (elements[elements.length - 1].loc.end.line === node.loc.end.line) {
                return;
            }
        }

        checkLastNodeLineIndent(node, elementsIndent - indentSize);
    }

    function isNodeBodyBlock(node) {
        return node.type === "BlockStatement" || (node.body && node.body.type === "BlockStatement") ||
            (node.consequent && node.consequent.type === "BlockStatement");
    }

    function blockIndentationCheck(node) {
        if (isSingleLineNode(node)) {
            return;
        }

        if (node.parent && (
                node.parent.type === "FunctionExpression" ||
                node.parent.type === "FunctionDeclaration" ||
                node.parent.type === "ArrowFunctionExpression"
        )) {
            checkIndentInFunctionBlock(node);
            return;
        }

        var indent;
        var nodesToCheck = [];

        var statementsWithProperties = [
            "IfStatement", "WhileStatement", "ForStatement", "ForInStatement", "ForOfStatement", "DoWhileStatement"
        ];

        if (node.parent && statementsWithProperties.indexOf(node.parent.type) !== -1 && isNodeBodyBlock(node)) {
            indent = getNodeIndent(node.parent);
        } else {
            indent = getNodeIndent(node);
        }

        if (node.type === "IfStatement" && node.consequent.type !== "BlockStatement") {
            nodesToCheck = [node.consequent];
        } else if (util.isArray(node.body)) {
            nodesToCheck = node.body;
        } else {
            nodesToCheck = [node.body];
        }

        if (nodesToCheck.length > 0) {
            checkNodesIndent(nodesToCheck, indent + indentSize);
        }

        if (node.type === "BlockStatement") {
            checkLastNodeLineIndent(node, indent);
        }
    }

    function filterOutSameLineVars(node) {
        return node.declarations.reduce(function(finalCollection, elem) {
            var lastElem = finalCollection[finalCollection.length - 1];

            if ((elem.loc.start.line !== node.loc.start.line && !lastElem) ||
                (lastElem && lastElem.loc.start.line !== elem.loc.start.line)) {
                finalCollection.push(elem);
            }

            return finalCollection;
        }, []);
    }

    function checkIndentInVariableDeclarations(node) {
        var elements = filterOutSameLineVars(node);
        var nodeIndent = getNodeIndent(node);
        var lastElement = elements[elements.length - 1];

        var elementsIndent = nodeIndent + indentSize * options.VariableDeclarator[node.kind];

        checkNodesIndent(elements, elementsIndent, true);

        if (context.getLastToken(node).loc.end.line <= lastElement.loc.end.line) {
            return;
        }

        var tokenBeforeLastElement = context.getTokenBefore(lastElement);

        if (tokenBeforeLastElement.value === ",") {
            checkLastNodeLineIndent(node, getNodeIndent(tokenBeforeLastElement));
        } else {
            checkLastNodeLineIndent(node, elementsIndent - indentSize);
        }
    }

    function blockLessNodes(node) {
        if (node.body.type !== "BlockStatement") {
            blockIndentationCheck(node);
        }
    }

    function expectedCaseIndent(node, switchIndent) {
        var switchNode = (node.type === "SwitchStatement") ? node : node.parent;
        var caseIndent;

        if (caseIndentStore[switchNode.loc.start.line]) {
            return caseIndentStore[switchNode.loc.start.line];
        } else {
            if (typeof switchIndent === "undefined") {
                switchIndent = getNodeIndent(switchNode);
            }

            if (switchNode.cases.length > 0 && options.SwitchCase === 0) {
                caseIndent = switchIndent;
            } else {
                caseIndent = switchIndent + (indentSize * options.SwitchCase);
            }

            caseIndentStore[switchNode.loc.start.line] = caseIndent;
            return caseIndent;
        }
    }

    return {
        "Program": function(node) {
            if (node.body.length > 0) {
                checkNodesIndent(node.body, getNodeIndent(node));
            }
        },

        "ClassBody": blockIndentationCheck,

        "BlockStatement": blockIndentationCheck,

        "WhileStatement": blockLessNodes,

        "ForStatement": blockLessNodes,

        "ForInStatement": blockLessNodes,

        "ForOfStatement": blockLessNodes,

        "DoWhileStatement": blockLessNodes,

        "IfStatement": function(node) {
            if (node.consequent.type !== "BlockStatement" && node.consequent.loc.start.line > node.loc.start.line) {
                blockIndentationCheck(node);
            }
        },

        "VariableDeclaration": function(node) {
            if (node.declarations[node.declarations.length - 1].loc.start.line > node.declarations[0].loc.start.line) {
                checkIndentInVariableDeclarations(node);
            }
        },

        "ObjectExpression": function(node) {
            checkIndentInArrayOrObjectBlock(node);
        },

        "ArrayExpression": function(node) {
            checkIndentInArrayOrObjectBlock(node);
        },

        "SwitchStatement": function(node) {
            var switchIndent = getNodeIndent(node);
            var caseIndent = expectedCaseIndent(node, switchIndent);
            checkNodesIndent(node.cases, caseIndent);


            checkLastNodeLineIndent(node, switchIndent);
        },

        "SwitchCase": function(node) {
            if (isSingleLineNode(node)) {
                return;
            }
            var caseIndent = expectedCaseIndent(node);
            checkNodesIndent(node.consequent, caseIndent + indentSize);
        }
    };

};

module.exports.schema = [
    {
        "oneOf": [
            {
                "enum": ["tab"]
            },
            {
                "type": "integer",
                "minimum": 0
            }
        ]
    },
    {
        "type": "object",
        "properties": {
            "SwitchCase": {
                "type": "integer",
                "minimum": 0
            },
            "VariableDeclarator": {
                "oneOf": [
                    {
                        "type": "integer",
                        "minimum": 0
                    },
                    {
                        "type": "object",
                        "properties": {
                            "var": {
                                "type": "integer",
                                "minimum": 0
                            },
                            "let": {
                                "type": "integer",
                                "minimum": 0
                            },
                            "const": {
                                "type": "integer",
                                "minimum": 0
                            }
                        }
                    }
                ]
            }
        },
        "additionalProperties": false
    }
];

},
   {"lodash":"/node_modules/lodash/lodash.js","util":"/node_modules/browserify/node_modules/util/util.js"}],

"/tmp/rules/init-declarations.js": [function(require,module,exports){
"use strict";

function isForLoop(block) {
    return block.type === "ForInStatement" ||
    block.type === "ForOfStatement" ||
    block.type === "ForStatement";
}

function isInitialized(node) {
    var declaration = node.parent;
    var block = declaration.parent;

    if (isForLoop(block)) {
        if (block.type === "ForStatement") {
            return block.init === declaration;
        }
        return block.left === declaration;
    }
    return Boolean(node.init);
}

module.exports = function(context) {

    var MODE_ALWAYS = "always",
        MODE_NEVER = "never";

    var mode = context.options[0] || MODE_ALWAYS;
    var params = context.options[1] || {};
    return {
        "VariableDeclaration:exit": function(node) {

            var kind = node.kind,
                declarations = node.declarations;

            for (var i = 0; i < declarations.length; ++i) {
                var declaration = declarations[i],
                    id = declaration.id,
                    initialized = isInitialized(declaration),
                    isIgnoredForLoop = params.ignoreForLoopInit && isForLoop(node.parent);
                if (id.type !== "Identifier") {
                    continue;
                }

                if (mode === MODE_ALWAYS && !initialized) {
                    context.report(declaration, "Variable '" + id.name + "' should be initialized on declaration.");
                } else if (mode === MODE_NEVER && kind !== "const" && initialized && !isIgnoredForLoop) {
                    context.report(declaration, "Variable '" + id.name + "' should not be initialized on declaration.");
                }
            }
        }
    };
};

module.exports.schema = {
    "anyOf": [
        {
            "type": "array",
            "items": [
                {
                    "enum": ["always"]
                }
            ],
            "minItems": 0,
            "maxItems": 1
        },
        {
            "type": "array",
            "items": [
                {
                    "enum": ["never"]
                },
                {
                    "type": "object",
                    "properties": {
                        "ignoreForLoopInit": {
                            "type": "boolean"
                        }
                    },
                    "additionalProperties": false
                }
            ],
            "minItems": 0,
            "maxItems": 2
        }
    ]
};

},
   {}],

"/tmp/rules/jsx-quotes.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

var QUOTE_SETTINGS = {
    "prefer-double": {
        quote: "\"",
        description: "singlequote",
        convert: function(str) {
            return str.replace(/'/g, "\"");
        }
    },
    "prefer-single": {
        quote: "'",
        description: "doublequote",
        convert: function(str) {
            return str.replace(/"/g, "'");
        }
    }
};

module.exports = function(context) {
    var quoteOption = context.options[0] || "prefer-double",
        setting = QUOTE_SETTINGS[quoteOption];

    function usesExpectedQuotes(node) {
        return node.value.indexOf(setting.quote) !== -1 || astUtils.isSurroundedBy(node.raw, setting.quote);
    }

    return {
        "JSXAttribute": function(node) {
            var attributeValue = node.value;

            if (attributeValue && astUtils.isStringLiteral(attributeValue) && !usesExpectedQuotes(attributeValue)) {
                context.report({
                    node: attributeValue,
                    message: "Unexpected usage of " + setting.description + ".",
                    fix: function(fixer) {
                        return fixer.replaceText(attributeValue, setting.convert(attributeValue.raw));
                    }
                });
            }
        }
    };
};

module.exports.schema = [
    {
        "enum": [ "prefer-single", "prefer-double" ]
    }
];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/key-spacing.js": [function(require,module,exports){
"use strict";

function containsLineTerminator(str) {
    return /[\n\r\u2028\u2029]/.test(str);
}

function last(arr) {
    return arr[arr.length - 1];
}

function continuesPropertyGroup(lastMember, candidate) {
    var groupEndLine = lastMember.loc.start.line,
        candidateStartLine = candidate.loc.start.line,
        comments, i;

    if (candidateStartLine - groupEndLine <= 1) {
        return true;
    }

    comments = candidate.leadingComments;
    if (
        comments &&
        comments[0].loc.start.line - groupEndLine <= 1 &&
        candidateStartLine - last(comments).loc.end.line <= 1
    ) {
        for (i = 1; i < comments.length; i++) {
            if (comments[i].loc.start.line - comments[i - 1].loc.end.line > 1) {
                return false;
            }
        }
        return true;
    }

    return false;
}

function isSingleLine(node) {
    return (node.loc.end.line === node.loc.start.line);
}

function initOptions(toOptions, fromOptions) {
    toOptions.mode = fromOptions.mode || "strict";

    if (typeof fromOptions.align !== "undefined") {
        toOptions.align = fromOptions.align;
    }

    if (typeof fromOptions.beforeColon !== "undefined") {
        toOptions.beforeColon = +fromOptions.beforeColon;
    } else {
        toOptions.beforeColon = 0;
    }

    if (typeof fromOptions.afterColon !== "undefined") {
        toOptions.afterColon = +fromOptions.afterColon;
    } else {
        toOptions.afterColon = 1;
    }

    return toOptions;
}

var messages = {
    key: "{{error}} space after {{computed}}key '{{key}}'.",
    value: "{{error}} space before value for {{computed}}key '{{key}}'."
};

module.exports = function(context) {

    var options = context.options[0] || {},
        multiLineOptions = initOptions({}, (options.multiLine || options)),
        singleLineOptions = initOptions({}, (options.singleLine || options));

    function isKeyValueProperty(property) {
        return !(
            property.method ||
            property.shorthand ||
            property.kind !== "init" ||
            property.type !== "Property" // Could be "ExperimentalSpreadProperty" or "SpreadProperty"
        );
    }

    function getLastTokenBeforeColon(node) {
        var prevNode;

        while (node && (node.type !== "Punctuator" || node.value !== ":")) {
            prevNode = node;
            node = context.getTokenAfter(node);
        }

        return prevNode;
    }

    function getNextColon(node) {

        while (node && (node.type !== "Punctuator" || node.value !== ":")) {
            node = context.getTokenAfter(node);
        }

        return node;
    }

    function getKey(property) {
        var key = property.key;

        if (property.computed) {
            return context.getSource().slice(key.range[0], key.range[1]);
        }

        return property.key.name || property.key.value;
    }

    function report(property, side, whitespace, expected, mode) {
        var diff = whitespace.length - expected,
            key = property.key,
            firstTokenAfterColon = context.getTokenAfter(getNextColon(key)),
            location = side === "key" ? key.loc.start : firstTokenAfterColon.loc.start;

        if ((
            diff && mode === "strict" ||
            diff < 0 && mode === "minimum" ||
            diff > 0 && !expected && mode === "minimum") &&
            !(expected && containsLineTerminator(whitespace))
        ) {
            context.report(property[side], location, messages[side], {
                error: diff > 0 ? "Extra" : "Missing",
                computed: property.computed ? "computed " : "",
                key: getKey(property)
            });
        }
    }

    function getKeyWidth(property) {
        var startToken, endToken;

        startToken = context.getFirstToken(property);
        endToken = getLastTokenBeforeColon(property.key);

        return endToken.range[1] - startToken.range[0];
    }

    function getPropertyWhitespace(property) {
        var whitespace = /(\s*):(\s*)/.exec(context.getSource().slice(
            property.key.range[1], property.value.range[0]
        ));

        if (whitespace) {
            return {
                beforeColon: whitespace[1],
                afterColon: whitespace[2]
            };
        }
        return null;
    }

    function createGroups(node) {
        if (node.properties.length === 1) {
            return [node.properties];
        }

        return node.properties.reduce(function(groups, property) {
            var currentGroup = last(groups),
                prev = last(currentGroup);

            if (!prev || continuesPropertyGroup(prev, property)) {
                currentGroup.push(property);
            } else {
                groups.push([property]);
            }

            return groups;
        }, [
            []
        ]);
    }

    function verifyGroupAlignment(properties) {
        var length = properties.length,
            widths = properties.map(getKeyWidth), // Width of keys, including quotes
            targetWidth = Math.max.apply(null, widths),
            i, property, whitespace, width,
            align = multiLineOptions.align,
            beforeColon = multiLineOptions.beforeColon,
            afterColon = multiLineOptions.afterColon,
            mode = multiLineOptions.mode;

        targetWidth += (align === "colon" ? beforeColon : afterColon);

        for (i = 0; i < length; i++) {
            property = properties[i];
            whitespace = getPropertyWhitespace(property);
            if (whitespace) { // Object literal getters/setters lack a colon
                width = widths[i];

                if (align === "value") {
                    report(property, "key", whitespace.beforeColon, beforeColon, mode);
                    report(property, "value", whitespace.afterColon, targetWidth - width, mode);
                } else { // align = "colon"
                    report(property, "key", whitespace.beforeColon, targetWidth - width, mode);
                    report(property, "value", whitespace.afterColon, afterColon, mode);
                }
            }
        }
    }

    function verifyAlignment(node) {
        createGroups(node).forEach(function(group) {
            verifyGroupAlignment(group.filter(isKeyValueProperty));
        });
    }

    function verifySpacing(node, lineOptions) {
        var actual = getPropertyWhitespace(node);
        if (actual) { // Object literal getters/setters lack colons
            report(node, "key", actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);
            report(node, "value", actual.afterColon, lineOptions.afterColon, lineOptions.mode);
        }
    }

    function verifyListSpacing(properties) {
        var length = properties.length;

        for (var i = 0; i < length; i++) {
            verifySpacing(properties[i], singleLineOptions);
        }
    }

    if (multiLineOptions.align) { // Verify vertical alignment

        return {
            "ObjectExpression": function(node) {
                if (isSingleLine(node)) {
                    verifyListSpacing(node.properties);
                } else {
                    verifyAlignment(node);
                }
            }
        };

    } else { // Obey beforeColon and afterColon in each property as configured

        return {
            "Property": function(node) {
                verifySpacing(node, isSingleLine(node) ? singleLineOptions : multiLineOptions);
            }
        };

    }

};

module.exports.schema = [{
    "anyOf": [
        {
            "type": "object",
            "properties": {
                "align": {
                    "enum": ["colon", "value"]
                },
                "mode": {
                    "enum": ["strict", "minimum"]
                },
                "beforeColon": {
                    "type": "boolean"
                },
                "afterColon": {
                    "type": "boolean"
                }
            },
            "additionalProperties": false
        },
        {
            "type": "object",
            "properties": {
                "singleLine": {
                    "type": "object",
                    "properties": {
                        "mode": {
                            "enum": ["strict", "minimum"]
                        },
                        "beforeColon": {
                            "type": "boolean"
                        },
                        "afterColon": {
                            "type": "boolean"
                        }
                    },
                    "additionalProperties": false
                },
                "multiLine": {
                    "type": "object",
                    "properties": {
                        "align": {
                            "enum": ["colon", "value"]
                        },
                        "mode": {
                            "enum": ["strict", "minimum"]
                        },
                        "beforeColon": {
                            "type": "boolean"
                        },
                        "afterColon": {
                            "type": "boolean"
                        }
                    },
                    "additionalProperties": false
                }
            },
            "additionalProperties": false
        }
    ]
}];

},
   {}],

"/tmp/rules/keyword-spacing.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils"),
    keywords = require("../util/keywords");

var PREV_TOKEN = /^[\)\]\}>]$/;
var NEXT_TOKEN = /^(?:[\(\[\{<~!]|\+\+?|--?)$/;
var PREV_TOKEN_M = /^[\)\]\}>*]$/;
var NEXT_TOKEN_M = /^[\{*]$/;
var TEMPLATE_OPEN_PAREN = /\$\{$/;
var TEMPLATE_CLOSE_PAREN = /^\}/;
var CHECK_TYPE = /^(?:JSXElement|RegularExpression|String|Template)$/;
var KEYS = keywords.concat(["as", "await", "from", "get", "let", "of", "set", "yield"]);

(function() {
    KEYS.sort();
    for (var i = 1; i < KEYS.length; ++i) {
        if (KEYS[i] === KEYS[i - 1]) {
            throw new Error("Duplication was found in the keyword list: " + KEYS[i]);
        }
    }
}());

function isOpenParenOfTemplate(token) {
    return token.type === "Template" && TEMPLATE_OPEN_PAREN.test(token.value);
}

function isCloseParenOfTemplate(token) {
    return token.type === "Template" && TEMPLATE_CLOSE_PAREN.test(token.value);
}

module.exports = function(context) {
    var sourceCode = context.getSourceCode();

    function expectSpaceBefore(token, pattern) {
        pattern = pattern || PREV_TOKEN;

        var prevToken = sourceCode.getTokenBefore(token);
        if (prevToken &&
            (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) &&
            !isOpenParenOfTemplate(prevToken) &&
            astUtils.isTokenOnSameLine(prevToken, token) &&
            !sourceCode.isSpaceBetweenTokens(prevToken, token)
        ) {
            context.report({
                loc: token.loc.start,
                message: "Expected space(s) before \"{{value}}\".",
                data: token,
                fix: function(fixer) {
                    return fixer.insertTextBefore(token, " ");
                }
            });
        }
    }

    function unexpectSpaceBefore(token, pattern) {
        pattern = pattern || PREV_TOKEN;

        var prevToken = sourceCode.getTokenBefore(token);
        if (prevToken &&
            (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) &&
            !isOpenParenOfTemplate(prevToken) &&
            astUtils.isTokenOnSameLine(prevToken, token) &&
            sourceCode.isSpaceBetweenTokens(prevToken, token)
        ) {
            context.report({
                loc: token.loc.start,
                message: "Unexpected space(s) before \"{{value}}\".",
                data: token,
                fix: function(fixer) {
                    return fixer.removeRange([prevToken.range[1], token.range[0]]);
                }
            });
        }
    }

    function expectSpaceAfter(token, pattern) {
        pattern = pattern || NEXT_TOKEN;

        var nextToken = sourceCode.getTokenAfter(token);
        if (nextToken &&
            (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) &&
            !isCloseParenOfTemplate(nextToken) &&
            astUtils.isTokenOnSameLine(token, nextToken) &&
            !sourceCode.isSpaceBetweenTokens(token, nextToken)
        ) {
            context.report({
                loc: token.loc.start,
                message: "Expected space(s) after \"{{value}}\".",
                data: token,
                fix: function(fixer) {
                    return fixer.insertTextAfter(token, " ");
                }
            });
        }
    }

    function unexpectSpaceAfter(token, pattern) {
        pattern = pattern || NEXT_TOKEN;

        var nextToken = sourceCode.getTokenAfter(token);
        if (nextToken &&
            (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) &&
            !isCloseParenOfTemplate(nextToken) &&
            astUtils.isTokenOnSameLine(token, nextToken) &&
            sourceCode.isSpaceBetweenTokens(token, nextToken)
        ) {
            context.report({
                loc: token.loc.start,
                message: "Unexpected space(s) after \"{{value}}\".",
                data: token,
                fix: function(fixer) {
                    return fixer.removeRange([token.range[1], nextToken.range[0]]);
                }
            });
        }
    }
    function noop() {}
    
    function parseOptions(options) {
        var before = !options || options.before !== false;
        var after = !options || options.after !== false;
        var defaultValue = {
            before: before ? expectSpaceBefore : unexpectSpaceBefore,
            after: after ? expectSpaceAfter : unexpectSpaceAfter
        };
        var overrides = (options && options.overrides) || {};
        var retv = Object.create(null);

        for (var i = 0; i < KEYS.length; ++i) {
            var key = KEYS[i];
            var override = overrides[key];

            if (override) {
                var thisBefore = ("before" in override) ? override.before : before;
                var thisAfter = ("after" in override) ? override.after : after;
                retv[key] = {
                    before: thisBefore ? expectSpaceBefore : unexpectSpaceBefore,
                    after: thisAfter ? expectSpaceAfter : unexpectSpaceAfter
                };
                if (typeof thisBefore != "boolean")
                    retv[key].before = noop;
                if (typeof thisAfter != "boolean")
                    retv[key].after = noop;
            } else {
                retv[key] = defaultValue;
            }
        }

        return retv;
    }

    var checkMethodMap = parseOptions(context.options[0]);

    function checkSpacingBefore(token, pattern) {
        checkMethodMap[token.value].before(token, pattern);
    }

    function checkSpacingAfter(token, pattern) {
        checkMethodMap[token.value].after(token, pattern);
    }

    function checkSpacingAround(token) {
        checkSpacingBefore(token);
        checkSpacingAfter(token);
    }

    function checkSpacingAroundFirstToken(node) {
        var firstToken = node && sourceCode.getFirstToken(node);
        if (firstToken && firstToken.type === "Keyword") {
            checkSpacingAround(firstToken);
        }
    }

    function checkSpacingBeforeFirstToken(node) {
        var firstToken = node && sourceCode.getFirstToken(node);
        if (firstToken && firstToken.type === "Keyword") {
            checkSpacingBefore(firstToken);
        }
    }

    function checkSpacingAroundTokenBefore(node) {
        if (node) {
            var token = sourceCode.getTokenBefore(node);
            while (token.type !== "Keyword") {
                token = sourceCode.getTokenBefore(token);
            }

            checkSpacingAround(token);
        }
    }

    function checkSpacingForClass(node) {
        checkSpacingAroundFirstToken(node);
        checkSpacingAroundTokenBefore(node.superClass);
    }

    function checkSpacingForIfStatement(node) {
        checkSpacingAroundFirstToken(node);
        checkSpacingAroundTokenBefore(node.alternate);
    }

    function checkSpacingForTryStatement(node) {
        checkSpacingAroundFirstToken(node);
        checkSpacingAroundFirstToken(node.handler);
        checkSpacingAroundTokenBefore(node.finalizer);
    }

    function checkSpacingForDoWhileStatement(node) {
        checkSpacingAroundFirstToken(node);
        checkSpacingAroundTokenBefore(node.test);
    }

    function checkSpacingForForInStatement(node) {
        checkSpacingAroundFirstToken(node);
        checkSpacingAroundTokenBefore(node.right);
    }

    function checkSpacingForForOfStatement(node) {
        checkSpacingAroundFirstToken(node);

        var token = sourceCode.getTokenBefore(node.right);
        while (token.value !== "of") {
            token = sourceCode.getTokenBefore(token);
        }
        checkSpacingAround(token);
    }

    function checkSpacingForModuleDeclaration(node) {
        var firstToken = sourceCode.getFirstToken(node);
        checkSpacingBefore(firstToken, PREV_TOKEN_M);
        checkSpacingAfter(firstToken, NEXT_TOKEN_M);

        if (node.source) {
            var fromToken = sourceCode.getTokenBefore(node.source);
            checkSpacingBefore(fromToken, PREV_TOKEN_M);
            checkSpacingAfter(fromToken, NEXT_TOKEN_M);
        }
    }

    function checkSpacingForImportNamespaceSpecifier(node) {
        var asToken = sourceCode.getFirstToken(node, 1);
        checkSpacingBefore(asToken, PREV_TOKEN_M);
    }

    function checkSpacingForProperty(node) {
        if (node.static) {
            checkSpacingAroundFirstToken(node);
        }
        if (node.kind === "get" || node.kind === "set") {
            var token = sourceCode.getFirstToken(
                node,
                node.static ? 1 : 0
            );
            checkSpacingAround(token);
        }
    }

    return {
        DebuggerStatement: checkSpacingAroundFirstToken,
        WithStatement: checkSpacingAroundFirstToken,

        BreakStatement: checkSpacingAroundFirstToken,
        ContinueStatement: checkSpacingAroundFirstToken,
        ReturnStatement: checkSpacingAroundFirstToken,
        ThrowStatement: checkSpacingAroundFirstToken,
        TryStatement: checkSpacingForTryStatement,

        IfStatement: checkSpacingForIfStatement,
        SwitchStatement: checkSpacingAroundFirstToken,
        SwitchCase: checkSpacingAroundFirstToken,

        DoWhileStatement: checkSpacingForDoWhileStatement,
        ForInStatement: checkSpacingForForInStatement,
        ForOfStatement: checkSpacingForForOfStatement,
        ForStatement: checkSpacingAroundFirstToken,
        WhileStatement: checkSpacingAroundFirstToken,

        ClassDeclaration: checkSpacingForClass,
        ExportNamedDeclaration: checkSpacingForModuleDeclaration,
        ExportDefaultDeclaration: checkSpacingAroundFirstToken,
        ExportAllDeclaration: checkSpacingForModuleDeclaration,
        FunctionDeclaration: checkSpacingBeforeFirstToken,
        ImportDeclaration: checkSpacingForModuleDeclaration,
        VariableDeclaration: checkSpacingAroundFirstToken,

        ClassExpression: checkSpacingForClass,
        FunctionExpression: checkSpacingBeforeFirstToken,
        NewExpression: checkSpacingBeforeFirstToken,
        Super: checkSpacingBeforeFirstToken,
        ThisExpression: checkSpacingBeforeFirstToken,
        UnaryExpression: checkSpacingBeforeFirstToken,
        YieldExpression: checkSpacingBeforeFirstToken,

        ImportNamespaceSpecifier: checkSpacingForImportNamespaceSpecifier,
        MethodDefinition: checkSpacingForProperty,
        Property: checkSpacingForProperty
    };
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "before": {"type": "boolean"},
            "after": {"type": "boolean"},
            "overrides": {
                "type": "object",
                "properties": KEYS.reduce(function(retv, key) {
                    retv[key] = {
                        "type": "object",
                        "properties": {
                            "before": {"type": "boolean"},
                            "after": {"type": "boolean"}
                        },
                        "additionalProperties": false
                    };
                    return retv;
                }, {}),
                "additionalProperties": false
            }
        },
        "additionalProperties": false
    }
];

},
   {"../ast-utils":"/tmp/ast-utils.js","../util/keywords":"/tmp/util/keywords.js"}],

"/tmp/rules/linebreak-style.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var EXPECTED_LF_MSG = "Expected linebreaks to be 'LF' but found 'CRLF'.",
        EXPECTED_CRLF_MSG = "Expected linebreaks to be 'CRLF' but found 'LF'.";

    function createFix(range, text) {
        return function(fixer) {
            return fixer.replaceTextRange(range, text);
        };
    }

    return {
        "Program": function checkForlinebreakStyle(node) {
            var linebreakStyle = context.options[0] || "unix",
                expectedLF = linebreakStyle === "unix",
                expectedLFChars = expectedLF ? "\n" : "\r\n",
                source = context.getSource(),
                pattern = /\r\n|\r|\n|\u2028|\u2029/g,
                match,
                index,
                range;

            var i = 0;
            while ((match = pattern.exec(source)) !== null) {
                i++;
                if (match[0] === expectedLFChars) {
                    continue;
                }

                index = match.index;
                range = [index, index + match[0].length];
                context.report({
                    node: node,
                    loc: {
                        line: i,
                        column: context.getSourceLines()[i - 1].length
                    },
                    message: expectedLF ? EXPECTED_LF_MSG : EXPECTED_CRLF_MSG,
                    fix: createFix(range, expectedLFChars)
                });
            }
        }
    };
};

module.exports.schema = [
    {
        "enum": ["unix", "windows"]
    }
];

},
   {}],

"/tmp/rules/lines-around-comment.js": [function(require,module,exports){
"use strict";

var lodash = require("lodash");

function getEmptyLineNums(lines) {
    var emptyLines = lines.map(function(line, i) {
        return {
            code: line.trim(),
            num: i + 1
        };
    }).filter(function(line) {
        return !line.code;
    }).map(function(line) {
        return line.num;
    });
    return emptyLines;
}

function getCommentLineNums(comments) {
    var lines = [];
    comments.forEach(function(token) {
        var start = token.loc.start.line;
        var end = token.loc.end.line;
        lines.push(start, end);
    });
    return lines;
}

function contains(val, array) {
    return array.indexOf(val) > -1;
}

module.exports = function(context) {

    var options = context.options[0] ? lodash.assign({}, context.options[0]) : {};
    options.beforeLineComment = options.beforeLineComment || false;
    options.afterLineComment = options.afterLineComment || false;
    options.beforeBlockComment = typeof options.beforeBlockComment !== "undefined" ? options.beforeBlockComment : true;
    options.afterBlockComment = options.afterBlockComment || false;
    options.allowBlockStart = options.allowBlockStart || false;
    options.allowBlockEnd = options.allowBlockEnd || false;

    var sourceCode = context.getSourceCode();
    function codeAroundComment(node) {
        var token;

        token = node;
        do {
            token = sourceCode.getTokenOrCommentBefore(token);
        } while (token && (token.type === "Block" || token.type === "Line"));

        if (token && token.loc.end.line === node.loc.start.line) {
            return true;
        }

        token = node;
        do {
            token = sourceCode.getTokenOrCommentAfter(token);
        } while (token && (token.type === "Block" || token.type === "Line"));

        if (token && token.loc.start.line === node.loc.end.line) {
            return true;
        }

        return false;
    }

    function isCommentInsideNodeType(node, parent, nodeType) {
        return parent.type === nodeType ||
            (parent.body && parent.body.type === nodeType) ||
            (parent.consequent && parent.consequent.type === nodeType);
    }

    function isCommentAtParentStart(node, nodeType) {
        var ancestors = context.getAncestors();
        var parent;

        if (ancestors.length) {
            parent = ancestors.pop();
        }

        return parent && isCommentInsideNodeType(node, parent, nodeType) &&
                node.loc.start.line - parent.loc.start.line === 1;
    }

    function isCommentAtParentEnd(node, nodeType) {
        var ancestors = context.getAncestors();
        var parent;

        if (ancestors.length) {
            parent = ancestors.pop();
        }

        return parent && isCommentInsideNodeType(node, parent, nodeType) &&
                parent.loc.end.line - node.loc.end.line === 1;
    }

    function isCommentAtBlockStart(node) {
        return isCommentAtParentStart(node, "ClassBody") || isCommentAtParentStart(node, "BlockStatement");
    }

    function isCommentAtBlockEnd(node) {
        return isCommentAtParentEnd(node, "ClassBody") || isCommentAtParentEnd(node, "BlockStatement");
    }

    function isCommentAtObjectStart(node) {
        return isCommentAtParentStart(node, "ObjectExpression") || isCommentAtParentStart(node, "ObjectPattern");
    }

    function isCommentAtObjectEnd(node) {
        return isCommentAtParentEnd(node, "ObjectExpression") || isCommentAtParentEnd(node, "ObjectPattern");
    }

    function isCommentAtArrayStart(node) {
        return isCommentAtParentStart(node, "ArrayExpression") || isCommentAtParentStart(node, "ArrayPattern");
    }

    function isCommentAtArrayEnd(node) {
        return isCommentAtParentEnd(node, "ArrayExpression") || isCommentAtParentEnd(node, "ArrayPattern");
    }

    function checkForEmptyLine(node, opts) {

        var lines = context.getSourceLines(),
            numLines = lines.length + 1,
            comments = context.getAllComments(),
            commentLines = getCommentLineNums(comments),
            emptyLines = getEmptyLineNums(lines),
            commentAndEmptyLines = commentLines.concat(emptyLines);

        var after = opts.after,
            before = opts.before;

        var prevLineNum = node.loc.start.line - 1,
            nextLineNum = node.loc.end.line + 1,
            commentIsNotAlone = codeAroundComment(node);

        var blockStartAllowed = options.allowBlockStart && isCommentAtBlockStart(node),
            blockEndAllowed = options.allowBlockEnd && isCommentAtBlockEnd(node),
            objectStartAllowed = options.allowObjectStart && isCommentAtObjectStart(node),
            objectEndAllowed = options.allowObjectEnd && isCommentAtObjectEnd(node),
            arrayStartAllowed = options.allowArrayStart && isCommentAtArrayStart(node),
            arrayEndAllowed = options.allowArrayEnd && isCommentAtArrayEnd(node);

        var exceptionStartAllowed = blockStartAllowed || objectStartAllowed || arrayStartAllowed;
        var exceptionEndAllowed = blockEndAllowed || objectEndAllowed || arrayEndAllowed;

        if (prevLineNum < 1) {
            before = false;
        }
        if (nextLineNum >= numLines) {
            after = false;
        }

        if (commentIsNotAlone) {
            return;
        }

        if (!exceptionStartAllowed && before && !contains(prevLineNum, commentAndEmptyLines)) {
            context.report(node, "Expected line before comment.");
        }

        if (!exceptionEndAllowed && after && !contains(nextLineNum, commentAndEmptyLines)) {
            context.report(node, "Expected line after comment.");
        }

    }

    return {

        "LineComment": function(node) {
            if (options.beforeLineComment || options.afterLineComment) {
                checkForEmptyLine(node, {
                    after: options.afterLineComment,
                    before: options.beforeLineComment
                });
            }
        },

        "BlockComment": function(node) {
            if (options.beforeBlockComment || options.afterBlockComment) {
                checkForEmptyLine(node, {
                    after: options.afterBlockComment,
                    before: options.beforeBlockComment
                });
            }
        }

    };
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "beforeBlockComment": {
                "type": "boolean"
            },
            "afterBlockComment": {
                "type": "boolean"
            },
            "beforeLineComment": {
                "type": "boolean"
            },
            "afterLineComment": {
                "type": "boolean"
            },
            "allowBlockStart": {
                "type": "boolean"
            },
            "allowBlockEnd": {
                "type": "boolean"
            },
            "allowObjectStart": {
                "type": "boolean"
            },
            "allowObjectEnd": {
                "type": "boolean"
            },
            "allowArrayStart": {
                "type": "boolean"
            },
            "allowArrayEnd": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {"lodash":"/node_modules/lodash/lodash.js"}],

"/tmp/rules/max-depth.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var functionStack = [],
        option = context.options[0],
        maxDepth = 4;

    if (typeof option === "object" && option.hasOwnProperty("maximum") && typeof option.maximum === "number") {
        maxDepth = option.maximum;
    }
    if (typeof option === "number") {
        maxDepth = option;
    }

    function startFunction() {
        functionStack.push(0);
    }

    function endFunction() {
        functionStack.pop();
    }

    function pushBlock(node) {
        var len = ++functionStack[functionStack.length - 1];

        if (len > maxDepth) {
            context.report(node, "Blocks are nested too deeply ({{depth}}).",
                    { depth: len });
        }
    }

    function popBlock() {
        functionStack[functionStack.length - 1]--;
    }

    return {
        "Program": startFunction,
        "FunctionDeclaration": startFunction,
        "FunctionExpression": startFunction,
        "ArrowFunctionExpression": startFunction,

        "IfStatement": function(node) {
            if (node.parent.type !== "IfStatement") {
                pushBlock(node);
            }
        },
        "SwitchStatement": pushBlock,
        "TryStatement": pushBlock,
        "DoWhileStatement": pushBlock,
        "WhileStatement": pushBlock,
        "WithStatement": pushBlock,
        "ForStatement": pushBlock,
        "ForInStatement": pushBlock,
        "ForOfStatement": pushBlock,

        "IfStatement:exit": popBlock,
        "SwitchStatement:exit": popBlock,
        "TryStatement:exit": popBlock,
        "DoWhileStatement:exit": popBlock,
        "WhileStatement:exit": popBlock,
        "WithStatement:exit": popBlock,
        "ForStatement:exit": popBlock,
        "ForInStatement:exit": popBlock,
        "ForOfStatement:exit": popBlock,

        "FunctionDeclaration:exit": endFunction,
        "FunctionExpression:exit": endFunction,
        "ArrowFunctionExpression:exit": endFunction,
        "Program:exit": endFunction
    };

};

module.exports.schema = [
    {
        "oneOf": [
            {
                "type": "integer",
                "minimum": 0
            },
            {
                "type": "object",
                "properties": {
                    "maximum": {
                        "type": "integer",
                        "minimum": 0
                    }
                },
                "additionalProperties": false
            }
        ]
    }
];

},
   {}],

"/tmp/rules/max-len.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var URL_REGEXP = /[^:/?#]:\/\/[^?#]/;

    function computeLineLength(line, tabWidth) {
        var extraCharacterCount = 0;
        line.replace(/\t/g, function(match, offset) {
            var totalOffset = offset + extraCharacterCount,
                previousTabStopOffset = tabWidth ? totalOffset % tabWidth : 0,
                spaceCount = tabWidth - previousTabStopOffset;
            extraCharacterCount += spaceCount - 1;  // -1 for the replaced tab
        });
        return line.length + extraCharacterCount;
    }

    var lastOption = context.options[context.options.length - 1];
    var options = typeof lastOption === "object" ? Object.create(lastOption) : {};
    if (typeof context.options[0] === "number") {
        options.code = context.options[0];
    }
    if (typeof context.options[1] === "number") {
        options.tabWidth = context.options[1];
    }

    var maxLength = options.code || 80,
        tabWidth = options.tabWidth || 4,
        ignorePattern = options.ignorePattern || null,
        ignoreComments = options.ignoreComments || false,
        ignoreTrailingComments = options.ignoreTrailingComments || options.ignoreComments || false,
        ignoreUrls = options.ignoreUrls || false,
        maxCommentLength = options.comments;

    if (ignorePattern) {
        ignorePattern = new RegExp(ignorePattern);
    }

    function isTrailingComment(line, lineNumber, comment) {
        return comment &&
            (comment.loc.start.line === lineNumber && lineNumber <= comment.loc.end.line) &&
            (comment.loc.end.line > lineNumber || comment.loc.end.column === line.length);
    }

    function isFullLineComment(line, lineNumber, comment) {
        var start = comment.loc.start,
            end = comment.loc.end;

        return comment &&
            (start.line < lineNumber || (start.line === lineNumber && start.column === 0)) &&
            (end.line > lineNumber || end.column === line.length);
    }

    function stripTrailingComment(line, lineNumber, comment) {
        return line.slice(0, comment.loc.start.column).replace(/\s+$/, "");
    }

    function checkProgramForMaxLength(node) {
        var lines = context.getSourceLines(),
            comments = ignoreComments || maxCommentLength ? context.getAllComments() : [],
            commentsIndex = 0;

        lines.forEach(function(line, i) {
            var lineNumber = i + 1;
            var lineIsComment = false;

            if (commentsIndex < comments.length) {
                do {
                    var comment = comments[++commentsIndex];
                } while (comment && comment.loc.start.line <= lineNumber);
                comment = comments[--commentsIndex];

                if (isFullLineComment(line, lineNumber, comment)) {
                    lineIsComment = true;
                } else if (ignoreTrailingComments && isTrailingComment(line, lineNumber, comment)) {
                    line = stripTrailingComment(line, lineNumber, comment);
                }
            }
            if (ignorePattern && ignorePattern.test(line) ||
                ignoreUrls && URL_REGEXP.test(line)) {
                return;
            }

            var lineLength = computeLineLength(line, tabWidth);

            if (lineIsComment && ignoreComments) {
                return;
            }

            if (lineIsComment && lineLength > maxCommentLength) {
                context.report(node, { line: lineNumber, column: 0 }, "Line " + (i + 1) + " exceeds the maximum comment line length of " + maxCommentLength + ".");
            } else if (lineLength > maxLength) {
                context.report(node, { line: lineNumber, column: 0 }, "Line " + (i + 1) + " exceeds the maximum line length of " + maxLength + ".");
            }
        });
    }


    return {
        "Program": checkProgramForMaxLength
    };

};

var OPTIONS_SCHEMA = {
    "type": "object",
    "properties": {
        "code": {
            "type": "integer",
            "minimum": 0
        },
        "comments": {
            "type": "integer",
            "minimum": 0
        },
        "tabWidth": {
            "type": "integer",
            "minimum": 0
        },
        "ignorePattern": {
            "type": "string"
        },
        "ignoreComments": {
            "type": "boolean"
        },
        "ignoreUrls": {
            "type": "boolean"
        },
        "ignoreTrailingComments": {
            "type": "boolean"
        }
    },
    "additionalProperties": false
};

var OPTIONS_OR_INTEGER_SCHEMA = {
    "anyOf": [
        OPTIONS_SCHEMA,
        {
            "type": "integer",
            "minimum": 0
        }
    ]
};

module.exports.schema = [
    OPTIONS_OR_INTEGER_SCHEMA,
    OPTIONS_OR_INTEGER_SCHEMA,
    OPTIONS_SCHEMA
];

},
   {}],

"/tmp/rules/max-nested-callbacks.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var option = context.options[0],
        THRESHOLD = 10;

    if (typeof option === "object" && option.hasOwnProperty("maximum") && typeof option.maximum === "number") {
        THRESHOLD = option.maximum;
    }
    if (typeof option === "number") {
        THRESHOLD = option;
    }

    var callbackStack = [];

    function checkFunction(node) {
        var parent = node.parent;

        if (parent.type === "CallExpression") {
            callbackStack.push(node);
        }

        if (callbackStack.length > THRESHOLD) {
            var opts = {num: callbackStack.length, max: THRESHOLD};
            context.report(node, "Too many nested callbacks ({{num}}). Maximum allowed is {{max}}.", opts);
        }
    }

    function popStack() {
        callbackStack.pop();
    }

    return {
        "ArrowFunctionExpression": checkFunction,
        "ArrowFunctionExpression:exit": popStack,

        "FunctionExpression": checkFunction,
        "FunctionExpression:exit": popStack
    };

};

module.exports.schema = [
    {
        "oneOf": [
            {
                "type": "integer",
                "minimum": 0
            },
            {
                "type": "object",
                "properties": {
                    "maximum": {
                        "type": "integer",
                        "minimum": 0
                    }
                },
                "additionalProperties": false
            }
        ]
    }
];

},
   {}],

"/tmp/rules/max-params.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var option = context.options[0],
        numParams = 3;

    if (typeof option === "object" && option.hasOwnProperty("maximum") && typeof option.maximum === "number") {
        numParams = option.maximum;
    }
    if (typeof option === "number") {
        numParams = option;
    }

    function checkFunction(node) {
        if (node.params.length > numParams) {
            context.report(node, "This function has too many parameters ({{count}}). Maximum allowed is {{max}}.", {
                count: node.params.length,
                max: numParams
            });
        }
    }

    return {
        "FunctionDeclaration": checkFunction,
        "ArrowFunctionExpression": checkFunction,
        "FunctionExpression": checkFunction
    };

};

module.exports.schema = [
    {
        "oneOf": [
            {
                "type": "integer",
                "minimum": 0
            },
            {
                "type": "object",
                "properties": {
                    "maximum": {
                        "type": "integer",
                        "minimum": 0
                    }
                },
                "additionalProperties": false
            }
        ]
    }
];

},
   {}],

"/tmp/rules/max-statements.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var functionStack = [],
        option = context.options[0],
        maxStatements = 10,
        ignoreTopLevelFunctions = context.options[1] && context.options[1].ignoreTopLevelFunctions || false,
        topLevelFunctions = [];

    if (typeof option === "object" && option.hasOwnProperty("maximum") && typeof option.maximum === "number") {
        maxStatements = option.maximum;
    }
    if (typeof option === "number") {
        maxStatements = option;
    }

    function reportIfTooManyStatements(node, count, max) {
        if (count > max) {
            context.report(
                node,
                "This function has too many statements ({{count}}). Maximum allowed is {{max}}.",
                { count: count, max: max });
        }
    }

    function startFunction() {
        functionStack.push(0);
    }

    function endFunction(node) {
        var count = functionStack.pop();
        if (ignoreTopLevelFunctions && functionStack.length === 0) {
            topLevelFunctions.push({ node: node, count: count});
        } else {
            reportIfTooManyStatements(node, count, maxStatements);
        }
    }

    function countStatements(node) {
        functionStack[functionStack.length - 1] += node.body.length;
    }

    return {
        "FunctionDeclaration": startFunction,
        "FunctionExpression": startFunction,
        "ArrowFunctionExpression": startFunction,

        "BlockStatement": countStatements,

        "FunctionDeclaration:exit": endFunction,
        "FunctionExpression:exit": endFunction,
        "ArrowFunctionExpression:exit": endFunction,

        "Program:exit": function() {
            if (topLevelFunctions.length === 1) {
                return;
            }

            topLevelFunctions.forEach(function(element) {
                var count = element.count;
                var node = element.node;
                reportIfTooManyStatements(node, count, maxStatements);
            });
        }
    };

};

module.exports.schema = [
    {
        "oneOf": [
            {
                "type": "integer",
                "minimum": 0
            },
            {
                "type": "object",
                "properties": {
                    "maximum": {
                        "type": "integer",
                        "minimum": 0
                    }
                },
                "additionalProperties": false
            }
        ]
    },
    {
        "type": "object",
        "properties": {
            "ignoreTopLevelFunctions": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/new-cap.js": [function(require,module,exports){
"use strict";

var lodash = require("lodash");

var CAPS_ALLOWED = [
    "Array",
    "Boolean",
    "Date",
    "Error",
    "Function",
    "Number",
    "Object",
    "RegExp",
    "String",
    "Symbol"
];

function checkArray(obj, key, fallback) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && !Array.isArray(obj[key])) {
        throw new TypeError(key + ", if provided, must be an Array");
    }
    return obj[key] || fallback;
}

function invert(map, key) {
    map[key] = true;
    return map;
}

function calculateCapIsNewExceptions(config) {
    var capIsNewExceptions = checkArray(config, "capIsNewExceptions", CAPS_ALLOWED);

    if (capIsNewExceptions !== CAPS_ALLOWED) {
        capIsNewExceptions = capIsNewExceptions.concat(CAPS_ALLOWED);
    }

    return capIsNewExceptions.reduce(invert, {});
}

module.exports = function(context) {

    var config = context.options[0] ? lodash.assign({}, context.options[0]) : {};
    config.newIsCap = config.newIsCap !== false;
    config.capIsNew = config.capIsNew !== false;
    var skipProperties = config.properties === false;

    var newIsCapExceptions = checkArray(config, "newIsCapExceptions", []).reduce(invert, {});

    var capIsNewExceptions = calculateCapIsNewExceptions(config);

    var listeners = {};

    function extractNameFromExpression(node) {

        var name = "",
            property;

        if (node.callee.type === "MemberExpression") {
            property = node.callee.property;

            if (property.type === "Literal" && (typeof property.value === "string")) {
                name = property.value;
            } else if (property.type === "Identifier" && !node.callee.computed) {
                name = property.name;
            }
        } else {
            name = node.callee.name;
        }
        return name;
    }

    function getCap(str) {
        var firstChar = str.charAt(0);

        var firstCharLower = firstChar.toLowerCase();
        var firstCharUpper = firstChar.toUpperCase();

        if (firstCharLower === firstCharUpper) {
            return "non-alpha";
        } else if (firstChar === firstCharLower) {
            return "lower";
        } else {
            return "upper";
        }
    }

    function isCapAllowed(allowedMap, node, calleeName) {
        if (allowedMap[calleeName] || allowedMap[context.getSource(node.callee)]) {
            return true;
        }

        if (calleeName === "UTC" && node.callee.type === "MemberExpression") {
            return node.callee.object.type === "Identifier" &&
                node.callee.object.name === "Date";
        }

        return skipProperties && node.callee.type === "MemberExpression";
    }

    function report(node, message) {
        var callee = node.callee;

        if (callee.type === "MemberExpression") {
            callee = callee.property;
        }

        context.report(node, callee.loc.start, message);
    }

    if (config.newIsCap) {
        listeners.NewExpression = function(node) {

            var constructorName = extractNameFromExpression(node);
            if (constructorName) {
                var capitalization = getCap(constructorName);
                var isAllowed = capitalization !== "lower" || isCapAllowed(newIsCapExceptions, node, constructorName);
                if (!isAllowed) {
                    report(node, "A constructor name should not start with a lowercase letter.");
                }
            }
        };
    }

    if (config.capIsNew) {
        listeners.CallExpression = function(node) {

            var calleeName = extractNameFromExpression(node);
            if (calleeName) {
                var capitalization = getCap(calleeName);
                var isAllowed = capitalization !== "upper" || isCapAllowed(capIsNewExceptions, node, calleeName);
                if (!isAllowed) {
                    report(node, "A function with a name starting with an uppercase letter should only be used as a constructor.");
                }
            }
        };
    }

    return listeners;
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "newIsCap": {
                "type": "boolean"
            },
            "capIsNew": {
                "type": "boolean"
            },
            "newIsCapExceptions": {
                "type": "array",
                "items": {
                    "type": "string"
                }
            },
            "capIsNewExceptions": {
                "type": "array",
                "items": {
                    "type": "string"
                }
            },
            "properties": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {"lodash":"/node_modules/lodash/lodash.js"}],

"/tmp/rules/new-parens.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "NewExpression": function(node) {
            var tokens = context.getTokens(node);
            var prenticesTokens = tokens.filter(function(token) {
                return token.value === "(" || token.value === ")";
            });
            if (prenticesTokens.length < 2) {
                context.report(node, "Missing '()' invoking a constructor");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/newline-after-var.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var ALWAYS_MESSAGE = "Expected blank line after variable declarations.",
        NEVER_MESSAGE = "Unexpected blank line after variable declarations.";

    var sourceCode = context.getSourceCode();

    var mode = context.options[0] === "never" ? "never" : "always";

    var commentEndLine = context.getAllComments().reduce(function(result, token) {
        result[token.loc.start.line] = token.loc.end.line;
        return result;
    }, {});


    function isVar(keyword) {
        return keyword === "var" || keyword === "let" || keyword === "const";
    }

    function isForTypeSpecifier(keyword) {
        return keyword === "ForStatement" || keyword === "ForInStatement" || keyword === "ForOfStatement";
    }

    function isExportSpecifier(nodeType) {
        return nodeType === "ExportNamedDeclaration" || nodeType === "ExportSpecifier" ||
            nodeType === "ExportDefaultDeclaration" || nodeType === "ExportAllDeclaration";
    }

    function isLastNode(node) {
        var token = sourceCode.getTokenAfter(node);
        return !token || (token.type === "Punctuator" && token.value === "}");
    }

    function hasBlankLineAfterComment(token, commentStartLine) {
        var commentEnd = commentEndLine[commentStartLine];
        if (commentEndLine[commentEnd + 1]) {
            return hasBlankLineAfterComment(token, commentEnd + 1);
        }
        return (token.loc.start.line > commentEndLine[commentStartLine] + 1);
    }

    function checkForBlankLine(node) {
        var lastToken = sourceCode.getLastToken(node),
            nextToken = sourceCode.getTokenAfter(node),
            nextLineNum = lastToken.loc.end.line + 1,
            noNextLineToken,
            hasNextLineComment;

        if (!nextToken) {
            return;
        }

        if (isForTypeSpecifier(node.parent.type)) {
            return;
        }

        if (isExportSpecifier(node.parent.type)) {
            return;
        }

        if (nextToken.type === "Keyword" && isVar(nextToken.value)) {
            return;
        }

        if (isLastNode(node)) {
            return;
        }

        noNextLineToken = nextToken.loc.start.line > nextLineNum;
        hasNextLineComment = (typeof commentEndLine[nextLineNum] !== "undefined");

        if (mode === "never" && noNextLineToken && !hasNextLineComment) {
            context.report(node, NEVER_MESSAGE, { identifier: node.name });
        }

        if (
            mode === "always" && (
                !noNextLineToken ||
                hasNextLineComment && !hasBlankLineAfterComment(nextToken, nextLineNum)
            )
        ) {
            context.report(node, ALWAYS_MESSAGE, { identifier: node.name });
        }
    }

    return {
        "VariableDeclaration": checkForBlankLine
    };

};

module.exports.schema = [
    {
        "enum": ["never", "always"]
    }
];

},
   {}],

"/tmp/rules/newline-before-return.js": [function(require,module,exports){

"use strict";

module.exports = function(context) {
    var sourceCode = context.getSourceCode();

    function isPrecededByTokens(node, testTokens) {
        var tokenBefore = sourceCode.getTokenBefore(node);

        return testTokens.some(function(token) {
            return tokenBefore.value === token;
        });
    }

    function isFirstNode(node) {
        var parentType = node.parent.type;

        if (node.parent.body) {
            return Array.isArray(node.parent.body)
              ? node.parent.body[0] === node
              : node.parent.body === node;
        }

        if (parentType === "IfStatement") {
            return isPrecededByTokens(node, ["else", ")"]);
        } else if (parentType === "DoWhileStatement") {
            return isPrecededByTokens(node, ["do"]);
        } else if (parentType === "SwitchCase") {
            return isPrecededByTokens(node, [":"]);
        } else {
            return isPrecededByTokens(node, [")"]);
        }
    }

    function calcCommentLines(node, tokenBefore) {
        var comments = sourceCode.getComments(node).leading;
        var numLinesComments = 0;

        if (!comments.length) {
            return numLinesComments;
        }

        comments.forEach(function(comment) {
            numLinesComments++;

            if (comment.type === "Block") {
                numLinesComments += comment.loc.end.line - comment.loc.start.line;
            }

            if (comment.loc.start.line === tokenBefore.loc.end.line) {
                numLinesComments--;
            }

            if (comment.loc.end.line === node.loc.start.line) {
                numLinesComments--;
            }
        });

        return numLinesComments;
    }

    function hasNewlineBefore(node) {
        var tokenBefore = sourceCode.getTokenBefore(node);
        var lineNumTokenBefore = tokenBefore.loc.end.line;
        var lineNumNode = node.loc.start.line;
        var commentLines = calcCommentLines(node, tokenBefore);

        return (lineNumNode - lineNumTokenBefore - commentLines) > 1;
    }

    function reportError(node, isExpected) {
        var expected = isExpected ? "Expected" : "Unexpected";

        context.report({
            node: node,
            message: expected + " newline before return statement."
        });
    }

    return {
        ReturnStatement: function(node) {
            if (isFirstNode(node) && hasNewlineBefore(node)) {
                reportError(node, false);
            } else if (!isFirstNode(node) && !hasNewlineBefore(node)) {
                reportError(node, true);
            }
        }
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/newline-per-chained-call.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var options = context.options[0] || {},
        ignoreChainWithDepth = options.ignoreChainWithDepth || 2;

    return {
        "CallExpression:exit": function(node) {
            if (!node.callee || node.callee.type !== "MemberExpression") {
                return;
            }

            var callee = node.callee;
            var parent = callee.object;
            var depth = 1;

            while (parent && parent.callee) {
                depth += 1;
                parent = parent.callee.object;
            }

            if (depth > ignoreChainWithDepth && callee.property.loc.start.line === callee.object.loc.end.line) {
                context.report(
                    callee.property,
                    callee.property.loc.start,
                    "Expected line break after `" + context.getSource(callee.object).replace(/\r\n|\r|\n/g, "\\n") + "`."
                );
            }
        }
    };
};

module.exports.schema = [{
    "type": "object",
    "properties": {
        "ignoreChainWithDepth": {
            "type": "integer",
            "minimum": 1,
            "maximum": 10
        }
    },
    "additionalProperties": false
}];

},
   {}],

"/tmp/rules/no-alert.js": [function(require,module,exports){
"use strict";

function isProhibitedIdentifier(name) {
    return /^(alert|confirm|prompt)$/.test(name);
}

function report(context, node, identifierName) {
    context.report(node, "Unexpected {{name}}.", { name: identifierName });
}

function getPropertyName(memberExpressionNode) {
    if (memberExpressionNode.computed) {
        if (memberExpressionNode.property.type === "Literal") {
            return memberExpressionNode.property.value;
        }
    } else {
        return memberExpressionNode.property.name;
    }
    return null;
}

function findReference(scope, node) {
    var references = scope.references.filter(function(reference) {
        return reference.identifier.range[0] === node.range[0] &&
            reference.identifier.range[1] === node.range[1];
    });

    if (references.length === 1) {
        return references[0];
    }
    return null;
}

function isShadowed(scope, globalScope, node) {
    var reference = findReference(scope, node);
    return reference && reference.resolved && reference.resolved.defs.length > 0;
}

function isGlobalThisReferenceOrGlobalWindow(scope, globalScope, node) {
    if (scope.type === "global" && node.type === "ThisExpression") {
        return true;
    } else if (node.name === "window") {
        return !isShadowed(scope, globalScope, node);
    }

    return false;
}

module.exports = function(context) {
    var globalScope;

    return {

        "Program": function() {
            globalScope = context.getScope();
        },

        "CallExpression": function(node) {
            var callee = node.callee,
                identifierName,
                currentScope = context.getScope();

            if (callee.type === "Identifier") {
                identifierName = callee.name;

                if (!isShadowed(currentScope, globalScope, callee) && isProhibitedIdentifier(callee.name)) {
                    report(context, node, identifierName);
                }

            } else if (callee.type === "MemberExpression" && isGlobalThisReferenceOrGlobalWindow(currentScope, globalScope, callee.object)) {
                identifierName = getPropertyName(callee);

                if (isProhibitedIdentifier(identifierName)) {
                    report(context, node, identifierName);
                }
            }

        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-array-constructor.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    function check(node) {
        if (
            node.arguments.length !== 1 &&
            node.callee.type === "Identifier" &&
            node.callee.name === "Array"
        ) {
            context.report(node, "The array literal notation [] is preferrable.");
        }
    }

    return {
        "CallExpression": check,
        "NewExpression": check
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-bitwise.js": [function(require,module,exports){
"use strict";

var BITWISE_OPERATORS = [
    "^", "|", "&", "<<", ">>", ">>>",
    "^=", "|=", "&=", "<<=", ">>=", ">>>=",
    "~"
];

module.exports = function(context) {
    var options = context.options[0] || {};
    var allowed = options.allow || [];
    var int32Hint = options.int32Hint === true;

    function report(node) {
        context.report(node, "Unexpected use of '{{operator}}'.", { operator: node.operator });
    }

    function hasBitwiseOperator(node) {
        return BITWISE_OPERATORS.indexOf(node.operator) !== -1;
    }

    function allowedOperator(node) {
        return allowed.indexOf(node.operator) !== -1;
    }

    function isInt32Hint(node) {
        return int32Hint && node.operator === "|" && node.right &&
          node.right.type === "Literal" && node.right.value === 0;
    }

    function checkNodeForBitwiseOperator(node) {
        if (hasBitwiseOperator(node) && !allowedOperator(node) && !isInt32Hint(node)) {
            report(node);
        }
    }

    return {
        "AssignmentExpression": checkNodeForBitwiseOperator,
        "BinaryExpression": checkNodeForBitwiseOperator,
        "UnaryExpression": checkNodeForBitwiseOperator
    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "allow": {
                "type": "array",
                "items": {
                    "enum": BITWISE_OPERATORS
                },
                "uniqueItems": true
            },
            "int32Hint": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/no-caller.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "MemberExpression": function(node) {
            var objectName = node.object.name,
                propertyName = node.property.name;

            if (objectName === "arguments" && !node.computed && propertyName && propertyName.match(/^calle[er]$/)) {
                context.report(node, "Avoid arguments.{{property}}.", { property: propertyName });
            }

        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-case-declarations.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    function isLexicalDeclaration(node) {
        switch (node.type) {
            case "FunctionDeclaration":
            case "ClassDeclaration":
                return true;
            case "VariableDeclaration":
                return node.kind !== "var";
            default:
                return false;
        }
    }

    return {
        "SwitchCase": function(node) {
            for (var i = 0; i < node.consequent.length; i++) {
                var statement = node.consequent[i];
                if (isLexicalDeclaration(statement)) {
                    context.report({
                        node: node,
                        message: "Unexpected lexical declaration in case block."
                    });
                }
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-catch-shadow.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {

    function paramIsShadowing(scope, name) {
        return astUtils.getVariableByName(scope, name) !== null;
    }

    return {

        "CatchClause": function(node) {
            var scope = context.getScope();

            if (scope.block === node) {
                scope = scope.upper;
            }

            if (paramIsShadowing(scope, node.param.name)) {
                context.report(node, "Value of '{{name}}' may be overwritten in IE 8 and earlier.",
                        { name: node.param.name });
            }
        }
    };

};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-class-assign.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {

    function checkVariable(variable) {
        astUtils.getModifyingReferences(variable.references).forEach(function(reference) {
            context.report(
                reference.identifier,
                "'{{name}}' is a class.",
                {name: reference.identifier.name});

        });
    }

    function checkForClass(node) {
        context.getDeclaredVariables(node).forEach(checkVariable);
    }

    return {
        "ClassDeclaration": checkForClass,
        "ClassExpression": checkForClass
    };

};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-cond-assign.js": [function(require,module,exports){
"use strict";

var NODE_DESCRIPTIONS = {
    "DoWhileStatement": "a 'do...while' statement",
    "ForStatement": "a 'for' statement",
    "IfStatement": "an 'if' statement",
    "WhileStatement": "a 'while' statement"
};

module.exports = function(context) {

    var prohibitAssign = (context.options[0] || "except-parens");

    function isConditionalTestExpression(node) {
        return node.parent &&
            node.parent.test &&
            node === node.parent.test;
    }

    function findConditionalAncestor(node) {
        var currentAncestor = node;

        do {
            if (isConditionalTestExpression(currentAncestor)) {
                return currentAncestor.parent;
            }
        } while ((currentAncestor = currentAncestor.parent));

        return null;
    }

    function isParenthesised(node) {
        var previousToken = context.getTokenBefore(node),
            nextToken = context.getTokenAfter(node);

        return previousToken.value === "(" && previousToken.range[1] <= node.range[0] &&
            nextToken.value === ")" && nextToken.range[0] >= node.range[1];
    }

    function isParenthesisedTwice(node) {
        var previousToken = context.getTokenBefore(node, 1),
            nextToken = context.getTokenAfter(node, 1);

        return isParenthesised(node) &&
            previousToken.value === "(" && previousToken.range[1] <= node.range[0] &&
            nextToken.value === ")" && nextToken.range[0] >= node.range[1];
    }

    function testForAssign(node) {
        if (node.test &&
            (node.test.type === "AssignmentExpression") &&
            (node.type === "ForStatement" ?
                !isParenthesised(node.test) :
                !isParenthesisedTwice(node.test)
            )
        ) {
            context.report({
                node: node,
                loc: node.test.loc.start,
                message: "Expected a conditional expression and instead saw an assignment."
            });
        }
    }

    function testForConditionalAncestor(node) {
        var ancestor = findConditionalAncestor(node);

        if (ancestor) {
            context.report(ancestor, "Unexpected assignment within {{type}}.", {
                type: NODE_DESCRIPTIONS[ancestor.type] || ancestor.type
            });
        }
    }

    if (prohibitAssign === "always") {
        return {
            "AssignmentExpression": testForConditionalAncestor
        };
    }

    return {
        "DoWhileStatement": testForAssign,
        "ForStatement": testForAssign,
        "IfStatement": testForAssign,
        "WhileStatement": testForAssign
    };

};

module.exports.schema = [
    {
        "enum": ["except-parens", "always"]
    }
];

},
   {}],

"/tmp/rules/no-confusing-arrow.js": [function(require,module,exports){
"use strict";

function isConditional(node) {
    return node.body && node.body.type === "ConditionalExpression";
}

module.exports = function(context) {
    function checkArrowFunc(node) {
        if (isConditional(node)) {
            context.report(node, "Arrow function used ambiguously with a conditional expression.");
        }
    }

    return {
        "ArrowFunctionExpression": checkArrowFunc
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-console.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "MemberExpression": function(node) {

            if (node.object.name === "console") {
                var blockConsole = true;

                if ( context.options.length > 0 ) {
                    var allowedProperties = context.options[0].allow;
                    var passedProperty = node.property.name;
                    var propertyIsAllowed = (allowedProperties.indexOf(passedProperty) > -1);

                    if (propertyIsAllowed) {
                        blockConsole = false;
                    }
                }

                if (blockConsole) {
                    context.report(node, "Unexpected console statement.");
                }
            }
        }
    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "allow": {
                "type": "array",
                "items": {
                    "type": "string"
                },
                "minItems": 1,
                "uniqueItems": true
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/no-const-assign.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {

    function checkVariable(variable) {
        astUtils.getModifyingReferences(variable.references).forEach(function(reference) {
            context.report(
                reference.identifier,
                "'{{name}}' is constant.",
                {name: reference.identifier.name});
        });
    }

    return {
        "VariableDeclaration": function(node) {
            if (node.kind === "const") {
                context.getDeclaredVariables(node).forEach(checkVariable);
            }
        }
    };

};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-constant-condition.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    function isConstant(node) {
        switch (node.type) {
            case "Literal":
            case "ArrowFunctionExpression":
            case "FunctionExpression":
            case "ObjectExpression":
            case "ArrayExpression":
                return true;
            case "UnaryExpression":
                return isConstant(node.argument);
            case "BinaryExpression":
            case "LogicalExpression":
                return isConstant(node.left) && isConstant(node.right) && node.operator !== "in";
            case "AssignmentExpression":
                return (node.operator === "=") && isConstant(node.right);
            case "SequenceExpression":
                return isConstant(node.expressions[node.expressions.length - 1]);
        }
        return false;
    }

    function checkConstantCondition(node) {
        if (node.test && isConstant(node.test)) {
            context.report(node, "Unexpected constant condition.");
        }
    }

    return {
        "ConditionalExpression": checkConstantCondition,
        "IfStatement": checkConstantCondition,
        "WhileStatement": checkConstantCondition,
        "DoWhileStatement": checkConstantCondition,
        "ForStatement": checkConstantCondition
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-continue.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {
        "ContinueStatement": function(node) {
            context.report(node, "Unexpected use of continue statement");
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-control-regex.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    function getRegExp(node) {
        if (node.value instanceof RegExp) {
            return node.value;
        } else if (typeof node.value === "string") {

            var parent = context.getAncestors().pop();
            if ((parent.type === "NewExpression" || parent.type === "CallExpression") &&
                parent.callee.type === "Identifier" && parent.callee.name === "RegExp"
            ) {
                try {
                    return new RegExp(node.value);
                } catch (ex) {
                    return null;
                }
            }
        }

        return null;
    }

    return {
        "Literal": function(node) {
            var computedValue,
                regex = getRegExp(node);

            if (regex) {
                computedValue = regex.toString();
                if (/[\x00-\x1f]/.test(computedValue)) {
                    context.report(node, "Unexpected control character in regular expression.");
                }
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-debugger.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {
        "DebuggerStatement": function(node) {
            context.report(node, "Unexpected 'debugger' statement.");
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-delete-var.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "UnaryExpression": function(node) {
            if (node.operator === "delete" && node.argument.type === "Identifier") {
                context.report(node, "Variables should not be deleted.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-div-regex.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "Literal": function(node) {
            var token = context.getFirstToken(node);

            if (token.type === "RegularExpression" && token.value[1] === "=") {
                context.report(node, "A regular expression literal can be confused with '/='.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-dupe-args.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    function isParameter(def) {
        return def.type === "Parameter";
    }

    function checkParams(node) {
        var variables = context.getDeclaredVariables(node);
        var keyMap = Object.create(null);

        for (var i = 0; i < variables.length; ++i) {
            var variable = variables[i];

            var key = "$" + variable.name; // to avoid __proto__.
            if (!isParameter(variable.defs[0]) || keyMap[key]) {
                continue;
            }
            keyMap[key] = true;

            var defs = variable.defs.filter(isParameter);
            if (defs.length >= 2) {
                context.report({
                    node: node,
                    message: "Duplicate param '{{name}}'.",
                    data: {name: variable.name}
                });
            }
        }
    }

    return {
        "FunctionDeclaration": checkParams,
        "FunctionExpression": checkParams
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-dupe-class-members.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var stack = [];

    function getState(name, isStatic) {
        var stateMap = stack[stack.length - 1];
        var key = "$" + name; // to avoid "__proto__".

        if (!stateMap[key]) {
            stateMap[key] = {
                nonStatic: {init: false, get: false, set: false},
                static: {init: false, get: false, set: false}
            };
        }

        return stateMap[key][isStatic ? "static" : "nonStatic"];
    }

    function getName(node) {
        switch (node.type) {
            case "Identifier": return node.name;
            case "Literal": return String(node.value);

            default: return "";
        }
    }

    return {
        "Program": function() {
            stack = [];
        },

        "ClassBody": function() {
            stack.push(Object.create(null));
        },

        "ClassBody:exit": function() {
            stack.pop();
        },

        "MethodDefinition": function(node) {
            if (node.computed) {
                return;
            }

            var name = getName(node.key);
            var state = getState(name, node.static);
            var isDuplicate = false;
            if (node.kind === "get") {
                isDuplicate = (state.init || state.get);
                state.get = true;
            } else if (node.kind === "set") {
                isDuplicate = (state.init || state.set);
                state.set = true;
            } else {
                isDuplicate = (state.init || state.get || state.set);
                state.init = true;
            }

            if (isDuplicate) {
                context.report(node, "Duplicate name '{{name}}'.", {name: name});
            }
        }
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-dupe-keys.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "ObjectExpression": function(node) {

            var nodeProps = Object.create(null);

            node.properties.forEach(function(property) {

                if (property.type !== "Property") {
                    return;
                }

                var keyName = property.key.name || property.key.value,
                    key = property.kind + "-" + keyName,
                    checkProperty = (!property.computed || property.key.type === "Literal");

                if (checkProperty) {
                    if (nodeProps[key]) {
                        context.report(node, property.loc.start, "Duplicate key '{{key}}'.", { key: keyName });
                    } else {
                        nodeProps[key] = true;
                    }
                }
            });

        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-duplicate-case.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {
        "SwitchStatement": function(node) {
            var mapping = {};

            node.cases.forEach(function(switchCase) {
                var key = context.getSource(switchCase.test);
                if (mapping[key]) {
                    context.report(switchCase, "Duplicate case label.");
                } else {
                    mapping[key] = switchCase;
                }
            });
        }
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-else-return.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    function displayReport(node) {
        context.report(node, "Unexpected 'else' after 'return'.");
    }

    function checkForReturn(node) {
        return node.type === "ReturnStatement";
    }

    function naiveHasReturn(node) {
        if (node.type === "BlockStatement") {
            var body = node.body,
                lastChildNode = body[body.length - 1];

            return lastChildNode && checkForReturn(lastChildNode);
        }
        return checkForReturn(node);
    }

    function hasElse(node) {
        return node.alternate && node.consequent && node.alternate.type !== "IfStatement";
    }

    function checkForIf(node) {
        return node.type === "IfStatement" && hasElse(node) &&
            naiveHasReturn(node.alternate) && naiveHasReturn(node.consequent);
    }

    function checkForReturnOrIf(node) {
        return checkForReturn(node) || checkForIf(node);
    }


    function alwaysReturns(node) {
        if (node.type === "BlockStatement") {
            return node.body.some(checkForReturnOrIf);
        } else {
            return checkForReturnOrIf(node);
        }
    }

    return {

        "IfStatement": function(node) {
            var parent = context.getAncestors().pop(),
                consequents,
                alternate;

            if (parent.type === "IfStatement" && parent.alternate === node) {
                return;
            }

            for (consequents = []; node.type === "IfStatement"; node = node.alternate) {
                if (!node.alternate) {
                    return;
                }
                consequents.push(node.consequent);
                alternate = node.alternate;
            }

            if (consequents.every(alwaysReturns)) {
                displayReport(alternate);
            }
        }

    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-empty-character-class.js": [function(require,module,exports){
"use strict";

var regex = /^\/([^\\[]|\\.|\[([^\\\]]|\\.)+\])*\/[gimuy]*$/;

module.exports = function(context) {

    return {

        "Literal": function(node) {
            var token = context.getFirstToken(node);
            if (token.type === "RegularExpression" && !regex.test(token.value)) {
                context.report(node, "Empty class.");
            }
        }

    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-empty-function.js": [function(require,module,exports){
"use strict";

var ALLOW_OPTIONS = Object.freeze([
    "functions",
    "arrowFunctions",
    "generatorFunctions",
    "methods",
    "generatorMethods",
    "getters",
    "setters",
    "constructors"
]);
var SHOW_KIND = Object.freeze({
    functions: "function",
    arrowFunctions: "arrow function",
    generatorFunctions: "generator function",
    asyncFunctions: "async function",
    methods: "method",
    generatorMethods: "generator method",
    asyncMethods: "async method",
    getters: "getter",
    setters: "setter",
    constructors: "constructor"
});

function getKind(node) {
    var parent = node.parent;
    var kind = "";

    if (node.type === "ArrowFunctionExpression") {
        return "arrowFunctions";
    }

    if (parent.type === "Property") {
        if (parent.kind === "get") {
            return "getters";
        }
        if (parent.kind === "set") {
            return "setters";
        }
        kind = parent.method ? "methods" : "functions";

    } else if (parent.type === "MethodDefinition") {
        if (parent.kind === "get") {
            return "getters";
        }
        if (parent.kind === "set") {
            return "setters";
        }
        if (parent.kind === "constructor") {
            return "constructors";
        }
        kind = "methods";

    } else {
        kind = "functions";
    }

    var prefix = "";
    if (node.generator) {
        prefix = "generator";
    } else if (node.async) {
        prefix = "async";
    } else {
        return kind;
    }
    return prefix + kind[0].toUpperCase() + kind.slice(1);
}

module.exports = function(context) {
    var options = context.options[0] || {};
    var allowed = options.allow || [];

    function reportIfEmpty(node) {
        var kind = getKind(node);

        if (allowed.indexOf(kind) === -1 &&
            node.body.type === "BlockStatement" &&
            node.body.body.length === 0 &&
            context.getComments(node.body).trailing.length === 0
        ) {
            context.report({
                node: node,
                loc: node.body.loc.start,
                message: "Unexpected empty " + SHOW_KIND[kind] + "."
            });
        }
    }

    return {
        ArrowFunctionExpression: reportIfEmpty,
        FunctionDeclaration: reportIfEmpty,
        FunctionExpression: reportIfEmpty
    };
};

module.exports.schema = [
    {
        type: "object",
        properties: {
            allow: {
                type: "array",
                items: {enum: ALLOW_OPTIONS},
                uniqueItems: true
            }
        },
        additionalProperties: false
    }
];

},
   {}],

"/tmp/rules/no-empty-pattern.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    return {
        "ObjectPattern": function(node) {
            if (node.properties.length === 0) {
                context.report(node, "Unexpected empty object pattern.");
            }
        },
        "ArrayPattern": function(node) {
            if (node.elements.length === 0) {
                context.report(node, "Unexpected empty array pattern.");
            }
        }
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-empty.js": [function(require,module,exports){
"use strict";

var FUNCTION_TYPE = /^(?:ArrowFunctionExpression|Function(?:Declaration|Expression))$/;

module.exports = function(context) {
    return {
        "BlockStatement": function(node) {
            if (node.body.length !== 0) {
                return;
            }

            if (FUNCTION_TYPE.test(node.parent.type)) {
                return;
            }

            if (context.getComments(node).trailing.length > 0) {
                return;
            }

            context.report(node, "Empty block statement.");
        },

        "SwitchStatement": function(node) {

            if (typeof node.cases === "undefined" || node.cases.length === 0) {
                context.report(node, "Empty switch statement.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-eq-null.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "BinaryExpression": function(node) {
            var badOperator = node.operator === "==" || node.operator === "!=";

            if (node.right.type === "Literal" && node.right.raw === "null" && badOperator ||
                    node.left.type === "Literal" && node.left.raw === "null" && badOperator) {
                context.report(node, "Use === to compare with null.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-eval.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

var candidatesOfGlobalObject = Object.freeze([
    "global",
    "window"
]);

function isIdentifier(node, name) {
    return node.type === "Identifier" && node.name === name;
}

function isConstant(node, name) {
    switch (node.type) {
        case "Literal":
            return node.value === name;

        case "TemplateLiteral":
            return (
                node.expressions.length === 0 &&
                node.quasis[0].value.cooked === name
            );

        default:
            return false;
    }
}

function isMember(node, name) {
    return (
        node.type === "MemberExpression" &&
        (node.computed ? isConstant : isIdentifier)(node.property, name)
    );
}

module.exports = function(context) {
    var allowIndirect = Boolean(
        context.options[0] &&
        context.options[0].allowIndirect
    );
    var sourceCode = context.getSourceCode();
    var funcInfo = null;

    function enterVarScope(node) {
        var strict = context.getScope().isStrict;

        funcInfo = {
            upper: funcInfo,
            node: node,
            strict: strict,
            defaultThis: false,
            initialized: strict
        };
    }

    function exitVarScope() {
        funcInfo = funcInfo.upper;
    }

    function report(node) {
        var locationNode = node;
        var parent = node.parent;

        if (node.type === "MemberExpression") {
            locationNode = node.property;
        }
        if (parent.type === "CallExpression" && parent.callee === node) {
            node = parent;
        }

        context.report({
            node: node,
            loc: locationNode.loc.start,
            message: "eval can be harmful."
        });
    }

    function reportAccessingEvalViaGlobalObject(globalScope) {
        for (var i = 0; i < candidatesOfGlobalObject.length; ++i) {
            var name = candidatesOfGlobalObject[i];
            var variable = astUtils.getVariableByName(globalScope, name);
            if (!variable) {
                continue;
            }

            var references = variable.references;
            for (var j = 0; j < references.length; ++j) {
                var identifier = references[j].identifier;
                var node = identifier.parent;

                while (isMember(node, name)) {
                    node = node.parent;
                }

                if (isMember(node, "eval")) {
                    report(node);
                }
            }
        }
    }

    function reportAccessingEval(globalScope) {
        var variable = astUtils.getVariableByName(globalScope, "eval");
        if (!variable) {
            return;
        }

        var references = variable.references;
        for (var i = 0; i < references.length; ++i) {
            var reference = references[i];
            var id = reference.identifier;

            if (id.name === "eval" && !astUtils.isCallee(id)) {
                report(id);
            }
        }
    }

    if (allowIndirect) {
        return {
            "CallExpression:exit": function(node) {
                var callee = node.callee;
                if (isIdentifier(callee, "eval")) {
                    report(callee);
                }
            }
        };
    }

    return {
        "CallExpression:exit": function(node) {
            var callee = node.callee;
            if (isIdentifier(callee, "eval")) {
                report(callee);
            }
        },

        "Program": function(node) {
            var scope = context.getScope(),
                features = context.parserOptions.ecmaFeatures || {},
                strict =
                    scope.isStrict ||
                    node.sourceType === "module" ||
                    (features.globalReturn && scope.childScopes[0].isStrict);

            funcInfo = {
                upper: null,
                node: node,
                strict: strict,
                defaultThis: true,
                initialized: true
            };
        },

        "Program:exit": function() {
            var globalScope = context.getScope();

            exitVarScope();
            reportAccessingEval(globalScope);
            reportAccessingEvalViaGlobalObject(globalScope);
        },

        "FunctionDeclaration": enterVarScope,
        "FunctionDeclaration:exit": exitVarScope,
        "FunctionExpression": enterVarScope,
        "FunctionExpression:exit": exitVarScope,
        "ArrowFunctionExpression": enterVarScope,
        "ArrowFunctionExpression:exit": exitVarScope,

        "ThisExpression": function(node) {
            if (!isMember(node.parent, "eval")) {
                return;
            }

            if (!funcInfo.initialized) {
                funcInfo.initialized = true;
                funcInfo.defaultThis = astUtils.isDefaultThisBinding(
                    funcInfo.node,
                    sourceCode
                );
            }
            if (!funcInfo.strict && funcInfo.defaultThis) {
                report(node.parent);
            }
        }
    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "allowIndirect": {"type": "boolean"}
        },
        "additionalProperties": false
    }
];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-ex-assign.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {

    function checkVariable(variable) {
        astUtils.getModifyingReferences(variable.references).forEach(function(reference) {
            context.report(
                reference.identifier,
                "Do not assign to the exception parameter.");
        });
    }

    return {
        "CatchClause": function(node) {
            context.getDeclaredVariables(node).forEach(checkVariable);
        }
    };

};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-extend-native.js": [function(require,module,exports){
"use strict";

var globals = require("globals");

module.exports = function(context) {

    var config = context.options[0] || {};
    var exceptions = config.exceptions || [];
    var modifiedBuiltins = Object.keys(globals.builtin).filter(function(builtin) {
        return builtin[0].toUpperCase() === builtin[0];
    });

    if (exceptions.length) {
        modifiedBuiltins = modifiedBuiltins.filter(function(builtIn) {
            return exceptions.indexOf(builtIn) === -1;
        });
    }

    return {

        "AssignmentExpression": function(node) {
            var lhs = node.left, affectsProto;

            if (lhs.type !== "MemberExpression" || lhs.object.type !== "MemberExpression") {
                return;
            }

            affectsProto = lhs.object.computed ?
                lhs.object.property.type === "Literal" && lhs.object.property.value === "prototype" :
                lhs.object.property.name === "prototype";

            if (!affectsProto) {
                return;
            }

            modifiedBuiltins.forEach(function(builtin) {
                if (lhs.object.object.name === builtin) {
                    context.report(node, builtin + " prototype is read only, properties should not be added.");
                }
            });
        },

        "CallExpression": function(node) {

            var callee = node.callee,
                subject,
                object;

            if (callee.type === "MemberExpression" &&
                callee.object.name === "Object" &&
                (callee.property.name === "defineProperty" || callee.property.name === "defineProperties")) {

                subject = node.arguments[0];
                object = subject && subject.object;
                if (object &&
                    object.type === "Identifier" &&
                    (modifiedBuiltins.indexOf(object.name) > -1) &&
                    subject.property.name === "prototype") {

                    context.report(node, object.name + " prototype is read only, properties should not be added.");
                }
            }

        }
    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "exceptions": {
                "type": "array",
                "items": {
                    "type": "string"
                },
                "uniqueItems": true
            }
        },
        "additionalProperties": false
    }
];

},
   {"globals":"/node_modules/globals/index.js"}],

"/tmp/rules/no-extra-bind.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var scopeInfo = null;

    function report(node) {
        context.report({
            node: node.parent.parent,
            message: "The function binding is unnecessary.",
            loc: node.parent.property.loc.start
        });
    }

    function getPropertyName(node) {
        if (node.computed) {
            switch (node.property.type) {
                case "Literal":
                    return String(node.property.value);
                case "TemplateLiteral":
                    if (node.property.expressions.length === 0) {
                        return node.property.quasis[0].value.cooked;
                    }
                default:
                    return false;
            }
        }
        return node.property.name;
    }

    function isCalleeOfBindMethod(node) {
        var parent = node.parent;
        var grandparent = parent.parent;
        return (
            grandparent &&
            grandparent.type === "CallExpression" &&
            grandparent.callee === parent &&
            grandparent.arguments.length === 1 &&
            parent.type === "MemberExpression" &&
            parent.object === node &&
            getPropertyName(parent) === "bind"
        );
    }

    function enterFunction(node) {
        scopeInfo = {
            isBound: isCalleeOfBindMethod(node),
            thisFound: false,
            upper: scopeInfo
        };
    }

    function exitFunction(node) {
        if (scopeInfo.isBound && !scopeInfo.thisFound) {
            report(node);
        }

        scopeInfo = scopeInfo.upper;
    }

    function exitArrowFunction(node) {
        if (isCalleeOfBindMethod(node)) {
            report(node);
        }
    }

    function markAsThisFound() {
        if (scopeInfo) {
            scopeInfo.thisFound = true;
        }
    }

    return {
        "ArrowFunctionExpression:exit": exitArrowFunction,
        "FunctionDeclaration": enterFunction,
        "FunctionDeclaration:exit": exitFunction,
        "FunctionExpression": enterFunction,
        "FunctionExpression:exit": exitFunction,
        "ThisExpression": markAsThisFound
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-extra-boolean-cast.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var BOOLEAN_NODE_TYPES = [
        "IfStatement",
        "DoWhileStatement",
        "WhileStatement",
        "ConditionalExpression",
        "ForStatement"
    ];

    function isInBooleanContext(node, parent) {
        return (
            (BOOLEAN_NODE_TYPES.indexOf(parent.type) !== -1 &&
                node === parent.test) ||
            (parent.type === "UnaryExpression" &&
                parent.operator === "!")
        );
    }


    return {
        "UnaryExpression": function(node) {
            var ancestors = context.getAncestors(),
                parent = ancestors.pop(),
                grandparent = ancestors.pop();

            if (node.operator !== "!" ||
                    parent.type !== "UnaryExpression" ||
                    parent.operator !== "!") {
                return;
            }

            if (isInBooleanContext(parent, grandparent) ||
                ((grandparent.type === "CallExpression" || grandparent.type === "NewExpression") &&
                    grandparent.callee.type === "Identifier" &&
                    grandparent.callee.name === "Boolean")
            ) {
                context.report(node, "Redundant double negation.");
            }
        },
        "CallExpression": function(node) {
            var parent = node.parent;

            if (node.callee.type !== "Identifier" || node.callee.name !== "Boolean") {
                return;
            }

            if (isInBooleanContext(node, parent)) {
                context.report(node, "Redundant Boolean call.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-extra-label.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {
    var scopeInfo = null;

    function enterBreakableStatement(node) {
        scopeInfo = {
            label: astUtils.getLabel(node),
            breakable: true,
            upper: scopeInfo
        };
    }

    function exitBreakableStatement() {
        scopeInfo = scopeInfo.upper;
    }

    function enterLabeledStatement(node) {
        if (!astUtils.isBreakableStatement(node.body)) {
            scopeInfo = {
                label: node.label.name,
                breakable: false,
                upper: scopeInfo
            };
        }
    }

    function exitLabeledStatement(node) {
        if (!astUtils.isBreakableStatement(node.body)) {
            scopeInfo = scopeInfo.upper;
        }
    }

    function reportIfUnnecessary(node) {
        if (!node.label) {
            return;
        }

        var labelNode = node.label;
        var label = labelNode.name;
        var info = scopeInfo;

        while (info) {
            if (info.breakable || info.label === label) {
                if (info.breakable && info.label === label) {
                    context.report({
                        node: labelNode,
                        message: "This label '{{name}}' is unnecessary.",
                        data: labelNode
                    });
                }
                return;
            }

            info = info.upper;
        }
    }

    return {
        "WhileStatement": enterBreakableStatement,
        "WhileStatement:exit": exitBreakableStatement,
        "DoWhileStatement": enterBreakableStatement,
        "DoWhileStatement:exit": exitBreakableStatement,
        "ForStatement": enterBreakableStatement,
        "ForStatement:exit": exitBreakableStatement,
        "ForInStatement": enterBreakableStatement,
        "ForInStatement:exit": exitBreakableStatement,
        "ForOfStatement": enterBreakableStatement,
        "ForOfStatement:exit": exitBreakableStatement,
        "SwitchStatement": enterBreakableStatement,
        "SwitchStatement:exit": exitBreakableStatement,
        "LabeledStatement": enterLabeledStatement,
        "LabeledStatement:exit": exitLabeledStatement,
        "BreakStatement": reportIfUnnecessary,
        "ContinueStatement": reportIfUnnecessary
    };
};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-extra-parens.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var ALL_NODES = context.options[0] !== "functions";
    var EXCEPT_COND_ASSIGN = ALL_NODES && context.options[1] && context.options[1].conditionalAssign === false;
    var sourceCode = context.getSourceCode();

    function ruleApplies(node) {
        return ALL_NODES || node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression";
    }

    function isParenthesised(node) {
        var previousToken = context.getTokenBefore(node),
            nextToken = context.getTokenAfter(node);

        return previousToken && nextToken &&
            previousToken.value === "(" && previousToken.range[1] <= node.range[0] &&
            nextToken.value === ")" && nextToken.range[0] >= node.range[1];
    }

    function isParenthesisedTwice(node) {
        var previousToken = context.getTokenBefore(node, 1),
            nextToken = context.getTokenAfter(node, 1);

        return isParenthesised(node) && previousToken && nextToken &&
            previousToken.value === "(" && previousToken.range[1] <= node.range[0] &&
            nextToken.value === ")" && nextToken.range[0] >= node.range[1];
    }

    function hasExcessParens(node) {
        return ruleApplies(node) && isParenthesised(node);
    }

    function hasDoubleExcessParens(node) {
        return ruleApplies(node) && isParenthesisedTwice(node);
    }

    function isCondAssignException(node) {
        return EXCEPT_COND_ASSIGN && node.test.type === "AssignmentExpression";
    }

    function hasExcessParensNoLineTerminator(token, node) {
        if (token.loc.end.line === node.loc.start.line) {
            return hasExcessParens(node);
        }

        return hasDoubleExcessParens(node);
    }

    function isHeadOfExpressionStatement(node) {
        var parent = node.parent;
        while (parent) {
            switch (parent.type) {
                case "SequenceExpression":
                    if (parent.expressions[0] !== node || isParenthesised(node)) {
                        return false;
                    }
                    break;

                case "UnaryExpression":
                case "UpdateExpression":
                    if (parent.prefix || isParenthesised(node)) {
                        return false;
                    }
                    break;

                case "BinaryExpression":
                case "LogicalExpression":
                    if (parent.left !== node || isParenthesised(node)) {
                        return false;
                    }
                    break;

                case "ConditionalExpression":
                    if (parent.test !== node || isParenthesised(node)) {
                        return false;
                    }
                    break;

                case "CallExpression":
                    if (parent.callee !== node || isParenthesised(node)) {
                        return false;
                    }
                    break;

                case "MemberExpression":
                    if (parent.object !== node || isParenthesised(node)) {
                        return false;
                    }
                    break;

                case "ExpressionStatement":
                    return true;

                default:
                    return false;
            }

            node = parent;
            parent = parent.parent;
        }

        throw new Error("unreachable");
    }

    function precedence(node) {

        switch (node.type) {
            case "SequenceExpression":
                return 0;

            case "AssignmentExpression":
            case "ArrowFunctionExpression":
            case "YieldExpression":
                return 1;

            case "ConditionalExpression":
                return 3;

            case "LogicalExpression":
                switch (node.operator) {
                    case "||":
                        return 4;
                    case "&&":
                        return 5;
                }

            case "BinaryExpression":
                switch (node.operator) {
                    case "|":
                        return 6;
                    case "^":
                        return 7;
                    case "&":
                        return 8;
                    case "==":
                    case "!=":
                    case "===":
                    case "!==":
                        return 9;
                    case "<":
                    case "<=":
                    case ">":
                    case ">=":
                    case "in":
                    case "instanceof":
                        return 10;
                    case "<<":
                    case ">>":
                    case ">>>":
                        return 11;
                    case "+":
                    case "-":
                        return 12;
                    case "*":
                    case "/":
                    case "%":
                        return 13;
                }
            case "UnaryExpression":
                return 14;
            case "UpdateExpression":
                return 15;
            case "CallExpression":
                if (node.callee.type === "FunctionExpression") {
                    return -1;
                }
                return 16;
            case "NewExpression":
                return 17;
        }
        return 18;
    }

    function report(node) {
        var previousToken = context.getTokenBefore(node);
        context.report(node, previousToken.loc.start, "Gratuitous parentheses around expression.");
    }

    function dryUnaryUpdate(node) {
        if (hasExcessParens(node.argument) && precedence(node.argument) >= precedence(node)) {
            report(node.argument);
        }
    }

    function dryCallNew(node) {
        if (hasExcessParens(node.callee) && precedence(node.callee) >= precedence(node) && !(
            node.type === "CallExpression" &&
            node.callee.type === "FunctionExpression" &&
            !hasDoubleExcessParens(node.callee)
        )) {
            report(node.callee);
        }
        if (node.arguments.length === 1) {
            if (hasDoubleExcessParens(node.arguments[0]) && precedence(node.arguments[0]) >= precedence({type: "AssignmentExpression"})) {
                report(node.arguments[0]);
            }
        } else {
            [].forEach.call(node.arguments, function(arg) {
                if (hasExcessParens(arg) && precedence(arg) >= precedence({type: "AssignmentExpression"})) {
                    report(arg);
                }
            });
        }
    }

    function dryBinaryLogical(node) {
        var prec = precedence(node);
        if (hasExcessParens(node.left) && precedence(node.left) >= prec) {
            report(node.left);
        }
        if (hasExcessParens(node.right) && precedence(node.right) > prec) {
            report(node.right);
        }
    }

    return {
        "ArrayExpression": function(node) {
            [].forEach.call(node.elements, function(e) {
                if (e && hasExcessParens(e) && precedence(e) >= precedence({type: "AssignmentExpression"})) {
                    report(e);
                }
            });
        },
        "ArrowFunctionExpression": function(node) {
            if (node.body.type !== "BlockStatement") {
                if (node.body.type !== "ObjectExpression" && hasExcessParens(node.body) && precedence(node.body) >= precedence({type: "AssignmentExpression"})) {
                    report(node.body);
                    return;
                }

                if (node.body.type === "ObjectExpression" && hasDoubleExcessParens(node.body)) {
                    report(node.body);
                    return;
                }
            }
        },
        "AssignmentExpression": function(node) {
            if (hasExcessParens(node.right) && precedence(node.right) >= precedence(node)) {
                report(node.right);
            }
        },
        "BinaryExpression": dryBinaryLogical,
        "CallExpression": dryCallNew,
        "ConditionalExpression": function(node) {
            if (hasExcessParens(node.test) && precedence(node.test) >= precedence({type: "LogicalExpression", operator: "||"})) {
                report(node.test);
            }
            if (hasExcessParens(node.consequent) && precedence(node.consequent) >= precedence({type: "AssignmentExpression"})) {
                report(node.consequent);
            }
            if (hasExcessParens(node.alternate) && precedence(node.alternate) >= precedence({type: "AssignmentExpression"})) {
                report(node.alternate);
            }
        },
        "DoWhileStatement": function(node) {
            if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {
                report(node.test);
            }
        },
        "ExpressionStatement": function(node) {
            var firstToken, secondToken, firstTokens;
            if (hasExcessParens(node.expression)) {
                firstTokens = context.getFirstTokens(node.expression, 2);
                firstToken = firstTokens[0];
                secondToken = firstTokens[1];

                if (
                    !firstToken ||
                    firstToken.value !== "{" &&
                    firstToken.value !== "function" &&
                    firstToken.value !== "class" &&
                    (
                        firstToken.value !== "let" ||
                        !secondToken ||
                        secondToken.value !== "["
                    )
                ) {
                    report(node.expression);
                }
            }
        },
        "ForInStatement": function(node) {
            if (hasExcessParens(node.right)) {
                report(node.right);
            }
        },
        "ForOfStatement": function(node) {
            if (hasExcessParens(node.right)) {
                report(node.right);
            }
        },
        "ForStatement": function(node) {
            if (node.init && hasExcessParens(node.init)) {
                report(node.init);
            }

            if (node.test && hasExcessParens(node.test) && !isCondAssignException(node)) {
                report(node.test);
            }

            if (node.update && hasExcessParens(node.update)) {
                report(node.update);
            }
        },
        "IfStatement": function(node) {
            if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {
                report(node.test);
            }
        },
        "LogicalExpression": dryBinaryLogical,
        "MemberExpression": function(node) {
            if (
                hasExcessParens(node.object) &&
                precedence(node.object) >= precedence(node) &&
                (
                    node.computed ||
                    !(
                        (node.object.type === "Literal" &&
                        typeof node.object.value === "number" &&
                        /^[0-9]+$/.test(context.getFirstToken(node.object).value))
                        ||
                        (node.object.type === "Literal" && node.object.regex)
                    )
                ) &&
                !(
                    (node.object.type === "FunctionExpression" || node.object.type === "ClassExpression") &&
                    isHeadOfExpressionStatement(node) &&
                    !hasDoubleExcessParens(node.object)
                )
            ) {
                report(node.object);
            }
            if (node.computed && hasExcessParens(node.property)) {
                report(node.property);
            }
        },
        "NewExpression": dryCallNew,
        "ObjectExpression": function(node) {
            [].forEach.call(node.properties, function(e) {
                var v = e.value;
                if (v && hasExcessParens(v) && precedence(v) >= precedence({type: "AssignmentExpression"})) {
                    report(v);
                }
            });
        },
        "ReturnStatement": function(node) {
            var returnToken = sourceCode.getFirstToken(node);

            if (node.argument &&
                    hasExcessParensNoLineTerminator(returnToken, node.argument) &&
                    !(node.argument.type === "Literal" && node.argument.regex)) {
                report(node.argument);
            }
        },
        "SequenceExpression": function(node) {
            [].forEach.call(node.expressions, function(e) {
                if (hasExcessParens(e) && precedence(e) >= precedence(node)) {
                    report(e);
                }
            });
        },
        "SwitchCase": function(node) {
            if (node.test && hasExcessParens(node.test)) {
                report(node.test);
            }
        },
        "SwitchStatement": function(node) {
            if (hasDoubleExcessParens(node.discriminant)) {
                report(node.discriminant);
            }
        },
        "ThrowStatement": function(node) {
            var throwToken = sourceCode.getFirstToken(node);

            if (hasExcessParensNoLineTerminator(throwToken, node.argument)) {
                report(node.argument);
            }
        },
        "UnaryExpression": dryUnaryUpdate,
        "UpdateExpression": dryUnaryUpdate,
        "VariableDeclarator": function(node) {
            if (node.init && hasExcessParens(node.init) &&
                    precedence(node.init) >= precedence({type: "AssignmentExpression"}) &&
                    !(node.init.type === "Literal" && node.init.regex)) {
                report(node.init);
            }
        },
        "WhileStatement": function(node) {
            if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {
                report(node.test);
            }
        },
        "WithStatement": function(node) {
            if (hasDoubleExcessParens(node.object)) {
                report(node.object);
            }
        },
        "YieldExpression": function(node) {
            var yieldToken;

            if (node.argument) {
                yieldToken = sourceCode.getFirstToken(node);

                if ((precedence(node.argument) >= precedence(node) &&
                        hasExcessParensNoLineTerminator(yieldToken, node.argument)) ||
                        hasDoubleExcessParens(node.argument)) {
                    report(node.argument);
                }
            }
        }
    };

};

module.exports.schema = {
    "anyOf": [
        {
            "type": "array",
            "items": [
                {
                    "enum": ["functions"]
                }
            ],
            "minItems": 0,
            "maxItems": 1
        },
        {
            "type": "array",
            "items": [
                {
                    "enum": ["all"]
                },
                {
                    "type": "object",
                    "properties": {
                        "conditionalAssign": {"type": "boolean"}
                    },
                    "additionalProperties": false
                }
            ],
            "minItems": 0,
            "maxItems": 2
        }
    ]
};

},
   {}],

"/tmp/rules/no-extra-semi.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    function report(nodeOrToken) {
        context.report({
            node: nodeOrToken,
            message: "Unnecessary semicolon.",
            fix: function(fixer) {
                return fixer.remove(nodeOrToken);
            }
        });
    }

    function checkForPartOfClassBody(firstToken) {
        for (var token = firstToken;
            token.type === "Punctuator" && token.value !== "}";
            token = context.getTokenAfter(token)
        ) {
            if (token.value === ";") {
                report(token);
            }
        }
    }

    return {
        "EmptyStatement": function(node) {
            var parent = node.parent,
                allowedParentTypes = ["ForStatement", "ForInStatement", "ForOfStatement", "WhileStatement", "DoWhileStatement"];

            if (allowedParentTypes.indexOf(parent.type) === -1) {
                report(node);
            }
        },

        "ClassBody": function(node) {
            checkForPartOfClassBody(context.getFirstToken(node, 1)); // 0 is `{`.
        },

        "MethodDefinition": function(node) {
            checkForPartOfClassBody(context.getTokenAfter(node));
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-fallthrough.js": [function(require,module,exports){
"use strict";

var lodash = require("lodash");

var FALLTHROUGH_COMMENT = /falls?\s?through/i;

function hasFallthroughComment(node, context) {
    var sourceCode = context.getSourceCode();
    var comment = lodash.last(sourceCode.getComments(node).leading);

    return Boolean(comment && FALLTHROUGH_COMMENT.test(comment.value));
}

function isReachable(segment) {
    return segment.reachable;
}

module.exports = function(context) {
    var currentCodePath = null;

    var fallthroughCase = null;

    return {
        "onCodePathStart": function(codePath) {
            currentCodePath = codePath;
        },
        "onCodePathEnd": function() {
            currentCodePath = currentCodePath.upper;
        },

        "SwitchCase": function(node) {
            if (fallthroughCase && !hasFallthroughComment(node, context)) {
                context.report({
                    message: "Expected a 'break' statement before '{{type}}'.",
                    data: {type: node.test ? "case" : "default"},
                    node: node
                });
            }
            fallthroughCase = null;
        },

        "SwitchCase:exit": function(node) {
            if (currentCodePath.currentSegments.some(isReachable) &&
                node.consequent.length > 0 &&
                lodash.last(node.parent.cases) !== node
            ) {
                fallthroughCase = node;
            }
        }
    };
};

module.exports.schema = [];

},
   {"lodash":"/node_modules/lodash/lodash.js"}],

"/tmp/rules/no-floating-decimal.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {
        "Literal": function(node) {

            if (typeof node.value === "number") {
                if (node.raw.indexOf(".") === 0) {
                    context.report(node, "A leading decimal point can be confused with a dot.");
                }
                if (node.raw.indexOf(".") === node.raw.length - 1) {
                    context.report(node, "A trailing decimal point can be confused with a dot.");
                }
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-func-assign.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {
    function checkReference(references) {
        astUtils.getModifyingReferences(references).forEach(function(reference) {
            context.report(
                reference.identifier,
                "'{{name}}' is a function.",
                {name: reference.identifier.name});
        });
    }

    function checkVariable(variable) {
        if (variable.defs[0].type === "FunctionName") {
            checkReference(variable.references);
        }
    }

    function checkForFunction(node) {
        context.getDeclaredVariables(node).forEach(checkVariable);
    }

    return {
        "FunctionDeclaration": checkForFunction,
        "FunctionExpression": checkForFunction
    };
};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-implicit-coercion.js": [function(require,module,exports){
"use strict";

var INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/;
var ALLOWABLE_OPERATORS = ["~", "!!", "+", "*"];

function parseOptions(options) {
    options = options || {};
    return {
        boolean: "boolean" in options ? Boolean(options.boolean) : true,
        number: "number" in options ? Boolean(options.number) : true,
        string: "string" in options ? Boolean(options.string) : true,
        allow: options.allow || []
    };
}

function isDoubleLogicalNegating(node) {
    return (
        node.operator === "!" &&
        node.argument.type === "UnaryExpression" &&
        node.argument.operator === "!"
    );
}

function isBinaryNegatingOfIndexOf(node) {
    return (
        node.operator === "~" &&
        node.argument.type === "CallExpression" &&
        node.argument.callee.type === "MemberExpression" &&
        node.argument.callee.property.type === "Identifier" &&
        INDEX_OF_PATTERN.test(node.argument.callee.property.name)
    );
}

function isMultiplyByOne(node) {
    return node.operator === "*" && (
        node.left.type === "Literal" && node.left.value === 1 ||
        node.right.type === "Literal" && node.right.value === 1
    );
}

function isNumeric(node) {
    return (
        node.type === "Literal" && typeof node.value === "number" ||
        node.type === "CallExpression" && (
            node.callee.name === "Number" ||
            node.callee.name === "parseInt" ||
            node.callee.name === "parseFloat"
        )
    );
}

function getNonNumericOperand(node) {
    var left = node.left,
        right = node.right;

    if (right.type !== "BinaryExpression" && !isNumeric(right)) {
        return right;
    }

    if (left.type !== "BinaryExpression" && !isNumeric(left)) {
        return left;
    }

    return null;
}

function isConcatWithEmptyString(node) {
    return node.operator === "+" && (
        (node.left.type === "Literal" && node.left.value === "") ||
        (node.right.type === "Literal" && node.right.value === "")
    );
}

function isAppendEmptyString(node) {
    return node.operator === "+=" && node.right.type === "Literal" && node.right.value === "";
}

function getOtherOperand(node, value) {
    if (node.left.type === "Literal" && node.left.value === value) {
        return node.right;
    }
    return node.left;
}
module.exports = function(context) {
    var options = parseOptions(context.options[0]),
        operatorAllowed = false;

    return {
        "UnaryExpression": function(node) {
            operatorAllowed = options.allow.indexOf("!!") >= 0;
            if (!operatorAllowed && options.boolean && isDoubleLogicalNegating(node)) {
                context.report(
                    node,
                    "use `Boolean({{code}})` instead.", {
                        code: context.getSource(node.argument.argument)
                    });
            }
            operatorAllowed = options.allow.indexOf("~") >= 0;
            if (!operatorAllowed && options.boolean && isBinaryNegatingOfIndexOf(node)) {
                context.report(
                    node,
                    "use `{{code}} !== -1` instead.", {
                        code: context.getSource(node.argument)
                    });
            }

            operatorAllowed = options.allow.indexOf("+") >= 0;
            if (!operatorAllowed && options.number && node.operator === "+" && !isNumeric(node.argument)) {
                context.report(
                    node,
                    "use `Number({{code}})` instead.", {
                        code: context.getSource(node.argument)
                    });
            }
        },

        "BinaryExpression:exit": function(node) {
            operatorAllowed = options.allow.indexOf("*") >= 0;
            var nonNumericOperand = !operatorAllowed && options.number && isMultiplyByOne(node) && getNonNumericOperand(node);
            if (nonNumericOperand) {
                context.report(
                    node,
                    "use `Number({{code}})` instead.", {
                        code: context.getSource(nonNumericOperand)
                    });
            }

            operatorAllowed = options.allow.indexOf("+") >= 0;
            if (!operatorAllowed && options.string && isConcatWithEmptyString(node)) {
                context.report(
                    node,
                    "use `String({{code}})` instead.", {
                        code: context.getSource(getOtherOperand(node, ""))
                    });
            }
        },

        "AssignmentExpression": function(node) {
            operatorAllowed = options.allow.indexOf("+") >= 0;
            if (options.string && isAppendEmptyString(node)) {
                context.report(
                    node,
                    "use `{{code}} = String({{code}})` instead.", {
                        code: context.getSource(getOtherOperand(node, ""))
                    });
            }
        }
    };
};

module.exports.schema = [{
    "type": "object",
    "properties": {
        "boolean": {
            "type": "boolean"
        },
        "number": {
            "type": "boolean"
        },
        "string": {
            "type": "boolean"
        },
        "allow": {
            "type": "array",
            "items": {
                "enum": ALLOWABLE_OPERATORS
            },
            "uniqueItems": true
        }
    },
    "additionalProperties": false
}];

},
   {}],

"/tmp/rules/no-implicit-globals.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    return {
        "Program": function() {
            var scope = context.getScope();

            scope.variables.forEach(function(variable) {
                if (variable.writeable) {
                    return;
                }

                variable.defs.forEach(function(def) {
                    if (def.type === "FunctionName" || (def.type === "Variable" && def.parent.kind === "var")) {
                        context.report(def.node, "Implicit global variable, assign as global property instead.");
                    }
                });
            });

            scope.implicit.variables.forEach(function(variable) {
                var scopeVariable = scope.set.get(variable.name);
                if (scopeVariable && scopeVariable.writeable) {
                    return;
                }

                variable.defs.forEach(function(def) {
                    context.report(def.node, "Implicit global variable, assign as global property instead.");
                });
            });
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-implied-eval.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var CALLEE_RE = /set(?:Timeout|Interval)|execScript/;

    var impliedEvalAncestorsStack = [];

    function last(arr) {
        return arr ? arr[arr.length - 1] : null;
    }

    function isImpliedEvalMemberExpression(node) {
        var object = node.object,
            property = node.property,
            hasImpliedEvalName = CALLEE_RE.test(property.name) || CALLEE_RE.test(property.value);

        return object.name === "window" && hasImpliedEvalName;
    }

    function isImpliedEvalCallExpression(node) {
        var isMemberExpression = (node.callee.type === "MemberExpression"),
            isIdentifier = (node.callee.type === "Identifier"),
            isImpliedEvalCallee =
                (isIdentifier && CALLEE_RE.test(node.callee.name)) ||
                (isMemberExpression && isImpliedEvalMemberExpression(node.callee));

        return isImpliedEvalCallee && node.arguments.length;
    }

    function hasImpliedEvalParent(node) {
        return node.parent === last(last(impliedEvalAncestorsStack)) &&
            (node.parent.type !== "CallExpression" || node === node.parent.arguments[0]);
    }

    function checkString(node) {
        if (hasImpliedEvalParent(node)) {
            var substack = impliedEvalAncestorsStack.pop();
            context.report(substack[0], "Implied eval. Consider passing a function instead of a string.");
        }
    }

    return {
        "CallExpression": function(node) {
            if (isImpliedEvalCallExpression(node)) {
                impliedEvalAncestorsStack.push([node]);
            }
        },

        "CallExpression:exit": function(node) {
            if (node === last(last(impliedEvalAncestorsStack))) {
                impliedEvalAncestorsStack.pop();
            }
        },

        "BinaryExpression": function(node) {
            if (node.operator === "+" && hasImpliedEvalParent(node)) {
                last(impliedEvalAncestorsStack).push(node);
            }
        },

        "BinaryExpression:exit": function(node) {
            if (node === last(last(impliedEvalAncestorsStack))) {
                last(impliedEvalAncestorsStack).pop();
            }
        },

        "Literal": function(node) {
            if (typeof node.value === "string") {
                checkString(node);
            }
        },

        "TemplateLiteral": function(node) {
            checkString(node);
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-inline-comments.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {

    function testCodeAroundComment(node) {

        var startLine = String(context.getSourceLines()[node.loc.start.line]);
        var endLine = String(context.getSourceLines()[node.loc.end.line]);

        var preamble = startLine.slice(0, node.loc.start.column).trim();

        var postamble = endLine.slice(node.loc.end.column).trim();

        var isDirective = astUtils.isDirectiveComment(node);

        if (!isDirective && (preamble || postamble)) {
            context.report(node, "Unexpected comment inline with code.");
        }
    }

    return {

        "LineComment": testCodeAroundComment,
        "BlockComment": testCodeAroundComment

    };
};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-inner-declarations.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    function nearestBody() {
        var ancestors = context.getAncestors(),
            ancestor = ancestors.pop(),
            generation = 1;

        while (ancestor && ["Program", "FunctionDeclaration",
                "FunctionExpression", "ArrowFunctionExpression"
                ].indexOf(ancestor.type) < 0) {
            generation += 1;
            ancestor = ancestors.pop();
        }

        return {
            type: ancestor.type,
            distance: generation
        };
    }

    function check(node) {
        var body = nearestBody(node),
            valid = ((body.type === "Program" && body.distance === 1) ||
                body.distance === 2);

        if (!valid) {
            context.report(node, "Move {{type}} declaration to {{body}} root.",
                {
                    type: (node.type === "FunctionDeclaration" ?
                        "function" : "variable"),
                    body: (body.type === "Program" ?
                        "program" : "function body")
                }
            );
        }
    }

    return {

        "FunctionDeclaration": check,
        "VariableDeclaration": function(node) {
            if (context.options[0] === "both" && node.kind === "var") {
                check(node);
            }
        }

    };

};

module.exports.schema = [
    {
        "enum": ["functions", "both"]
    }
];

},
   {}],

"/tmp/rules/no-invalid-regexp.js": [function(require,module,exports){
"use strict";

var espree = require("espree");

module.exports = function(context) {

    var options = context.options[0],
        allowedFlags = "";

    if (options && options.allowConstructorFlags) {
        allowedFlags = options.allowConstructorFlags.join("");
    }

    function isString(node) {
        return node && node.type === "Literal" && typeof node.value === "string";
    }

    function check(node) {
        if (node.callee.type === "Identifier" && node.callee.name === "RegExp" && isString(node.arguments[0])) {
            var flags = isString(node.arguments[1]) ? node.arguments[1].value : "";

            if (allowedFlags) {
                flags = flags.replace(new RegExp("[" + allowedFlags + "]", "gi"), "");
            }

            try {
                void new RegExp(node.arguments[0].value);
            } catch (e) {
                context.report(node, e.message);
            }

            if (flags) {

                try {
                    espree.parse("/./" + flags, context.parserOptions);
                } catch (ex) {
                    context.report(node, "Invalid flags supplied to RegExp constructor '" + flags + "'");
                }
            }

        }
    }

    return {
        "CallExpression": check,
        "NewExpression": check
    };

};

module.exports.schema = [{
    "type": "object",
    "properties": {
        "allowConstructorFlags": {
            "type": "array",
            "items": {
                "type": "string"
            }
        }
    },
    "additionalProperties": false
}];

},
   {"espree":"espree"}],

"/tmp/rules/no-invalid-this.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {
    var stack = [],
        sourceCode = context.getSourceCode();

    stack.getCurrent = function() {
        var current = this[this.length - 1];
        if (!current.init) {
            current.init = true;
            current.valid = !astUtils.isDefaultThisBinding(
                current.node,
                sourceCode);
        }
        return current;
    };

    function enterFunction(node) {
        stack.push({
            init: !context.getScope().isStrict,
            node: node,
            valid: true
        });
    }

    function exitFunction() {
        stack.pop();
    }

    return {
        "Program": function(node) {
            var scope = context.getScope(),
                features = context.parserOptions.ecmaFeatures || {};

            stack.push({
                init: true,
                node: node,
                valid: !(
                    scope.isStrict ||
                    node.sourceType === "module" ||
                    (features.globalReturn && scope.childScopes[0].isStrict)
                )
            });
        },
        "Program:exit": function() {
            stack.pop();
        },

        "FunctionDeclaration": enterFunction,
        "FunctionDeclaration:exit": exitFunction,
        "FunctionExpression": enterFunction,
        "FunctionExpression:exit": exitFunction,

        "ThisExpression": function(node) {
            var current = stack.getCurrent();
            if (current && !current.valid) {
                context.report(node, "Unexpected 'this'.");
            }
        }
    };
};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-irregular-whitespace.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var irregularWhitespace = /[\u0085\u00A0\ufeff\f\v\u00a0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u202f\u205f\u3000]+/mg,
        irregularLineTerminators = /[\u2028\u2029]/mg;

    var errors = [];

    var commentNodes = [];

    var options = context.options[0] || {};
    var skipComments = !!options.skipComments;

    function removeWhitespaceError(node) {
        var locStart = node.loc.start;
        var locEnd = node.loc.end;

        errors = errors.filter(function(error) {
            var errorLoc = error[1];
            if (errorLoc.line >= locStart.line && errorLoc.line <= locEnd.line) {
                if (errorLoc.column >= locStart.column && (errorLoc.column <= locEnd.column || errorLoc.line < locEnd.line)) {
                    return false;
                }
            }
            return true;
        });
    }

    function removeInvalidNodeErrorsInIdentifierOrLiteral(node) {
        if (typeof node.value === "string") {
            if (node.raw.match(irregularWhitespace) || node.raw.match(irregularLineTerminators)) {
                removeWhitespaceError(node);
            }
        }
    }

    function removeInvalidNodeErrorsInComment(node) {
        if (node.value.match(irregularWhitespace) || node.value.match(irregularLineTerminators)) {
            removeWhitespaceError(node);
        }
    }

    function checkForIrregularWhitespace(node) {
        var sourceLines = context.getSourceLines();

        sourceLines.forEach(function(sourceLine, lineIndex) {
            var lineNumber = lineIndex + 1,
                location,
                match;

            while ((match = irregularWhitespace.exec(sourceLine)) !== null) {
                location = {
                    line: lineNumber,
                    column: match.index
                };

                errors.push([node, location, "Irregular whitespace not allowed"]);
            }
        });
    }

    function checkForIrregularLineTerminators(node) {
        var source = context.getSource(),
            sourceLines = context.getSourceLines(),
            linebreaks = source.match(/\r\n|\r|\n|\u2028|\u2029/g),
            lastLineIndex = -1,
            lineIndex,
            location,
            match;

        while ((match = irregularLineTerminators.exec(source)) !== null) {
            lineIndex = linebreaks.indexOf(match[0], lastLineIndex + 1) || 0;

            location = {
                line: lineIndex + 1,
                column: sourceLines[lineIndex].length
            };

            errors.push([node, location, "Irregular whitespace not allowed"]);
            lastLineIndex = lineIndex;
        }
    }

    function rememberCommentNode(node) {
        commentNodes.push(node);
    }

    function noop() {}

    return {
        "Program": function(node) {
            checkForIrregularWhitespace(node);
            checkForIrregularLineTerminators(node);
        },

        "Identifier": removeInvalidNodeErrorsInIdentifierOrLiteral,
        "Literal": removeInvalidNodeErrorsInIdentifierOrLiteral,
        "LineComment": skipComments ? rememberCommentNode : noop,
        "BlockComment": skipComments ? rememberCommentNode : noop,
        "Program:exit": function() {

            if (skipComments) {
                commentNodes.forEach(removeInvalidNodeErrorsInComment);
            }

            errors.forEach(function(error) {
                context.report.apply(context, error);
            });
        }
    };
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "skipComments": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/no-iterator.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "MemberExpression": function(node) {

            if (node.property &&
                    (node.property.type === "Identifier" && node.property.name === "__iterator__" && !node.computed) ||
                    (node.property.type === "Literal" && node.property.value === "__iterator__")) {
                context.report(node, "Reserved name '__iterator__'.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-label-var.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {

    function findIdentifier(scope, name) {
        return astUtils.getVariableByName(scope, name) !== null;
    }

    return {

        "LabeledStatement": function(node) {

            var scope = context.getScope();

            if (findIdentifier(scope, node.label.name)) {
                context.report(node, "Found identifier with same name as label.");
            }
        }

    };

};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-labels.js": [function(require,module,exports){
"use strict";

var LOOP_TYPES = /^(?:While|DoWhile|For|ForIn|ForOf)Statement$/;

module.exports = function(context) {
    var options = context.options[0];
    var allowLoop = Boolean(options && options.allowLoop);
    var allowSwitch = Boolean(options && options.allowSwitch);
    var scopeInfo = null;

    function getBodyKind(node) {
        var type = node.type;

        if (LOOP_TYPES.test(type)) {
            return "loop";
        }
        if (type === "SwitchStatement") {
            return "switch";
        }
        return "other";
    }

    function isAllowed(kind) {
        switch (kind) {
            case "loop": return allowLoop;
            case "switch": return allowSwitch;
            default: return false;
        }
    }

    function getKind(label) {
        var info = scopeInfo;
        while (info) {
            if (info.label === label) {
                return info.kind;
            }
            info = info.upper;
        }

        return "other";
    }

    return {
        "LabeledStatement": function(node) {
            scopeInfo = {
                label: node.label.name,
                kind: getBodyKind(node.body),
                upper: scopeInfo
            };
        },

        "LabeledStatement:exit": function(node) {
            if (!isAllowed(scopeInfo.kind)) {
                context.report({
                    node: node,
                    message: "Unexpected labeled statement."
                });
            }

            scopeInfo = scopeInfo.upper;
        },

        "BreakStatement": function(node) {
            if (node.label && !isAllowed(getKind(node.label.name))) {
                context.report({
                    node: node,
                    message: "Unexpected label in break statement."
                });
            }
        },

        "ContinueStatement": function(node) {
            if (node.label && !isAllowed(getKind(node.label.name))) {
                context.report({
                    node: node,
                    message: "Unexpected label in continue statement."
                });
            }
        }
    };

};

module.exports.schema = [
    {
        type: "object",
        properties: {
            allowLoop: {
                type: "boolean"
            },
            allowSwitch: {
                type: "boolean"
            }
        },
        additionalProperties: false
    }
];

},
   {}],

"/tmp/rules/no-lone-blocks.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var loneBlocks = [],
        ruleDef;

    function report(node) {
        var parent = context.getAncestors().pop();
        context.report(node, parent.type === "Program" ?
            "Block is redundant." :
            "Nested block is redundant."
        );
    }

    function isLoneBlock() {
        var parent = context.getAncestors().pop();
        return parent.type === "BlockStatement" || parent.type === "Program";
    }

    function markLoneBlock() {
        if (loneBlocks.length === 0) {
            return;
        }

        var block = context.getAncestors().pop();

        if (loneBlocks[loneBlocks.length - 1] === block) {
            loneBlocks.pop();
        }
    }

    ruleDef = {
        BlockStatement: function(node) {
            if (isLoneBlock(node)) {
                report(node);
            }
        }
    };

    if (context.parserOptions.ecmaVersion >= 6) {
        ruleDef = {
            "BlockStatement": function(node) {
                if (isLoneBlock(node)) {
                    loneBlocks.push(node);
                }
            },
            "BlockStatement:exit": function(node) {
                if (loneBlocks.length > 0 && loneBlocks[loneBlocks.length - 1] === node) {
                    loneBlocks.pop();
                    report(node);
                }
            }
        };

        ruleDef.VariableDeclaration = function(node) {
            if (node.kind === "let" || node.kind === "const") {
                markLoneBlock(node);
            }
        };

        ruleDef.FunctionDeclaration = function(node) {
            if (context.getScope().isStrict) {
                markLoneBlock(node);
            }
        };

        ruleDef.ClassDeclaration = markLoneBlock;
    }

    return ruleDef;
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-lonely-if.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {
        "IfStatement": function(node) {
            var ancestors = context.getAncestors(),
                parent = ancestors.pop(),
                grandparent = ancestors.pop();

            if (parent && parent.type === "BlockStatement" &&
                    parent.body.length === 1 && grandparent &&
                    grandparent.type === "IfStatement" &&
                    parent === grandparent.alternate) {
                context.report(node, "Unexpected if as the only statement in an else block.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-loop-func.js": [function(require,module,exports){
"use strict";

function getContainingLoopNode(node) {
    var parent = node.parent;
    while (parent) {
        switch (parent.type) {
            case "WhileStatement":
            case "DoWhileStatement":
                return parent;

            case "ForStatement":
                if (parent.init !== node) {
                    return parent;
                }
                break;

            case "ForInStatement":
            case "ForOfStatement":
                if (parent.right !== node) {
                    return parent;
                }
                break;

            case "ArrowFunctionExpression":
            case "FunctionExpression":
            case "FunctionDeclaration":
                return null;

            default:
                break;
        }

        node = parent;
        parent = node.parent;
    }

    return null;
}

function getTopLoopNode(node, excludedNode) {
    var retv = null;
    var border = excludedNode ? excludedNode.range[1] : 0;

    while (node && node.range[0] >= border) {
        retv = node;
        node = getContainingLoopNode(node);
    }

    return retv;
}

function isSafe(funcNode, loopNode, reference) {
    var variable = reference.resolved;
    var definition = variable && variable.defs[0];
    var declaration = definition && definition.parent;
    var kind = (declaration && declaration.type === "VariableDeclaration")
        ? declaration.kind
        : "";

    if (kind === "const") {
        return true;
    }

    if (kind === "let" &&
        declaration.range[0] > loopNode.range[0] &&
        declaration.range[1] < loopNode.range[1]
    ) {
        return true;
    }

    var border = getTopLoopNode(
        loopNode,
        (kind === "let") ? declaration : null
    ).range[0];

    function isSafeReference(upperRef) {
        var id = upperRef.identifier;
        return (
            !upperRef.isWrite() ||
            variable.scope.variableScope === upperRef.from.variableScope &&
            id.range[0] < border
        );
    }

    return Boolean(variable) && variable.references.every(isSafeReference);
}

module.exports = function(context) {
    function checkForLoops(node) {
        var loopNode = getContainingLoopNode(node);
        if (!loopNode) {
            return;
        }

        var references = context.getScope().through;
        if (references.length > 0 &&
            !references.every(isSafe.bind(null, node, loopNode))
        ) {
            context.report(node, "Don't make functions within a loop");
        }
    }

    return {
        "ArrowFunctionExpression": checkForLoops,
        "FunctionExpression": checkForLoops,
        "FunctionDeclaration": checkForLoops
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-magic-numbers.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var config = context.options[0] || {},
        detectObjects = !!config.detectObjects,
        enforceConst = !!config.enforceConst,
        ignore = config.ignore || [],
        ignoreArrayIndexes = !!config.ignoreArrayIndexes;

    function isNumber(node) {
        return typeof node.value === "number";
    }

    function shouldIgnoreNumber(num) {
        return ignore.indexOf(num) !== -1;
    }

    function shouldIgnoreParseInt(parent, node) {
        return parent.type === "CallExpression" && node === parent.arguments[1] &&
            (parent.callee.name === "parseInt" ||
            parent.callee.type === "MemberExpression" &&
            parent.callee.object.name === "Number" &&
            parent.callee.property.name === "parseInt");
    }

    function shouldIgnoreJSXNumbers(parent) {
        return parent.type.indexOf("JSX") === 0;
    }

    function shouldIgnoreArrayIndexes(parent) {
        return parent.type === "MemberExpression" && ignoreArrayIndexes;
    }

    return {
        "Literal": function(node) {
            var parent = node.parent,
                value = node.value,
                raw = node.raw,
                okTypes = detectObjects ? [] : ["ObjectExpression", "Property", "AssignmentExpression"];

            if (!isNumber(node)) {
                return;
            }

            if (parent.type === "UnaryExpression" && parent.operator === "-") {
                node = parent;
                parent = node.parent;
                value = -value;
                raw = "-" + raw;
            }

            if (shouldIgnoreNumber(value) ||
                shouldIgnoreParseInt(parent, node) ||
                shouldIgnoreArrayIndexes(parent) ||
                shouldIgnoreJSXNumbers(parent)) {
                return;
            }

            if (parent.type === "VariableDeclarator") {
                if (enforceConst && parent.parent.kind !== "const") {
                    context.report({
                        node: node,
                        message: "Number constants declarations must use 'const'"
                    });
                }
            } else if (okTypes.indexOf(parent.type) === -1) {
                context.report({
                    node: node,
                    message: "No magic number: " + raw
                });
            }
        }
    };
};

module.exports.schema = [{
    "type": "object",
    "properties": {
        "detectObjects": {
            "type": "boolean"
        },
        "enforceConst": {
            "type": "boolean"
        },
        "ignore": {
            "type": "array",
            "items": {
                "type": "number"
            },
            "uniqueItems": true
        },
        "ignoreArrayIndexes": {
            "type": "boolean"
        }
    },
    "additionalProperties": false
}];

},
   {}],

"/tmp/rules/no-mixed-requires.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var grouping = false,
        allowCall = false,
        options = context.options[0];

    if (typeof options === "object") {
        grouping = options.grouping;
        allowCall = options.allowCall;
    } else {
        grouping = !!options;
    }

    function getBuiltinModules() {
        return [
            "assert", "buffer", "child_process", "cluster", "crypto",
            "dgram", "dns", "domain", "events", "fs", "http", "https",
            "net", "os", "path", "punycode", "querystring", "readline",
            "repl", "smalloc", "stream", "string_decoder", "tls", "tty",
            "url", "util", "v8", "vm", "zlib"
        ];
    }

    var BUILTIN_MODULES = getBuiltinModules();

    var DECL_REQUIRE = "require",
        DECL_UNINITIALIZED = "uninitialized",
        DECL_OTHER = "other";

    var REQ_CORE = "core",
        REQ_FILE = "file",
        REQ_MODULE = "module",
        REQ_COMPUTED = "computed";

    function getDeclarationType(initExpression) {
        if (!initExpression) {
            return DECL_UNINITIALIZED;
        }

        if (initExpression.type === "CallExpression" &&
            initExpression.callee.type === "Identifier" &&
            initExpression.callee.name === "require"
        ) {
            return DECL_REQUIRE;
        } else if (allowCall &&
            initExpression.type === "CallExpression" &&
            initExpression.callee.type === "CallExpression"
        ) {
            return getDeclarationType(initExpression.callee);
        } else if (initExpression.type === "MemberExpression") {
            return getDeclarationType(initExpression.object);
        }

        return DECL_OTHER;
    }

    function inferModuleType(initExpression) {
        if (initExpression.type === "MemberExpression") {
            return inferModuleType(initExpression.object);
        } else if (initExpression.arguments.length === 0) {
            return REQ_COMPUTED;
        }

        var arg = initExpression.arguments[0];

        if (arg.type !== "Literal" || typeof arg.value !== "string") {
            return REQ_COMPUTED;
        }

        if (BUILTIN_MODULES.indexOf(arg.value) !== -1) {
            return REQ_CORE;
        } else if (/^\.{0,2}\//.test(arg.value)) {
            return REQ_FILE;
        } else {
            return REQ_MODULE;
        }
    }

    function isMixed(declarations) {
        var contains = {};

        declarations.forEach(function(declaration) {
            var type = getDeclarationType(declaration.init);
            contains[type] = true;
        });

        return !!(
            contains[DECL_REQUIRE] &&
            (contains[DECL_UNINITIALIZED] || contains[DECL_OTHER])
        );
    }

    function isGrouped(declarations) {
        var found = {};

        declarations.forEach(function(declaration) {
            if (getDeclarationType(declaration.init) === DECL_REQUIRE) {
                found[inferModuleType(declaration.init)] = true;
            }
        });

        return Object.keys(found).length <= 1;
    }


    return {

        "VariableDeclaration": function(node) {

            if (isMixed(node.declarations)) {
                context.report(
                    node,
                    "Do not mix 'require' and other declarations."
                );
            } else if (grouping && !isGrouped(node.declarations)) {
                context.report(
                    node,
                    "Do not mix core, module, file and computed requires."
                );
            }
        }
    };

};

module.exports.schema = [
    {
        "oneOf": [
            {
                "type": "boolean"
            },
            {
                "type": "object",
                "properties": {
                    "grouping": {
                        "type": "boolean"
                    },
                    "allowCall": {
                        "type": "boolean"
                    }
                },
                "additionalProperties": false
            }
        ]
    }
];

},
   {}],

"/tmp/rules/no-mixed-spaces-and-tabs.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var smartTabs,
        ignoredLocs = [];

    switch (context.options[0]) {
        case true: // Support old syntax, maybe add deprecation warning here
        case "smart-tabs":
            smartTabs = true;
            break;
        default:
            smartTabs = false;
    }

    function beforeLoc(loc, line, column) {
        if (line < loc.start.line) {
            return true;
        }
        return line === loc.start.line && column < loc.start.column;
    }

    function afterLoc(loc, line, column) {
        if (line > loc.end.line) {
            return true;
        }
        return line === loc.end.line && column > loc.end.column;
    }

    return {

        "TemplateElement": function(node) {
            ignoredLocs.push(node.loc);
        },

        "Program:exit": function(node) {
            var regex = /^(?=[\t ]*(\t | \t))/,
                match,
                lines = context.getSourceLines(),
                comments = context.getAllComments();

            comments.forEach(function(comment) {
                ignoredLocs.push(comment.loc);
            });

            ignoredLocs.sort(function(first, second) {
                if (beforeLoc(first, second.start.line, second.start.column)) {
                    return 1;
                }

                if (beforeLoc(second, first.start.line, second.start.column)) {
                    return -1;
                }

                return 0;
            });

            if (smartTabs) {
                regex = /^(?=[\t ]* \t)/;
            }

            lines.forEach(function(line, i) {
                match = regex.exec(line);

                if (match) {
                    var lineNumber = i + 1,
                        column = match.index + 1;

                    for (var j = 0; j < ignoredLocs.length; j++) {
                        if (beforeLoc(ignoredLocs[j], lineNumber, column)) {
                            continue;
                        }
                        if (afterLoc(ignoredLocs[j], lineNumber, column)) {
                            continue;
                        }

                        return;
                    }

                    context.report(node, { line: lineNumber, column: column }, "Mixed spaces and tabs.");
                }
            });
        }

    };

};

module.exports.schema = [
    {
        "enum": ["smart-tabs", true, false]
    }
];

},
   {}],

"/tmp/rules/no-multi-spaces.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var exceptions = { "Property": true },
        hasExceptions = true,
        options = context.options[0],
        lastCommentIndex = 0;

    if (options && options.exceptions) {
        Object.keys(options.exceptions).forEach(function(key) {
            if (options.exceptions[key]) {
                exceptions[key] = true;
            } else {
                delete exceptions[key];
            }
        });
        hasExceptions = Object.keys(exceptions).length > 0;
    }

    function isIndexInComment(index, comments) {

        var comment;

        while (lastCommentIndex < comments.length) {

            comment = comments[lastCommentIndex];

            if (comment.range[0] <= index && index < comment.range[1]) {
                return true;
            } else if (index > comment.range[1]) {
                lastCommentIndex++;
            } else {
                break;
            }

        }

        return false;
    }

    return {
        "Program": function() {

            var source = context.getSource(),
                allComments = context.getAllComments(),
                pattern = /[^\n\r\u2028\u2029\t ].? {2,}/g,  // note: repeating space
                token,
                previousToken,
                parent;


            function createFix(leftToken, rightToken) {
                return function(fixer) {
                    return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], " ");
                };
            }

            while (pattern.test(source)) {

                if (!isIndexInComment(pattern.lastIndex, allComments)) {

                    token = context.getTokenByRangeStart(pattern.lastIndex);
                    if (token) {
                        previousToken = context.getTokenBefore(token);

                        if (hasExceptions) {
                            parent = context.getNodeByRangeIndex(pattern.lastIndex - 1);
                        }

                        if (!parent || !exceptions[parent.type]) {
                            context.report({
                                node: token,
                                loc: token.loc.start,
                                message: "Multiple spaces found before '{{value}}'.",
                                data: { value: token.value },
                                fix: createFix(previousToken, token)
                            });
                        }
                    }

                }
            }
        }
    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "exceptions": {
                "type": "object",
                "patternProperties": {
                    "^([A-Z][a-z]*)+$": {
                        "type": "boolean"
                    }
                },
                "additionalProperties": false
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/no-multi-str.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    function isJSXElement(node) {
        return node.type.indexOf("JSX") === 0;
    }

    return {

        "Literal": function(node) {
            var lineBreak = /\n/;

            if (lineBreak.test(node.raw) && !isJSXElement(node.parent)) {
                context.report(node, "Multiline support is limited to browsers supporting ES5 only.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-multiple-empty-lines.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var max = 2,
        maxEOF,
        maxBOF;

    var notEmpty = [];

    if (context.options.length) {
        max = context.options[0].max;
        maxEOF = context.options[0].maxEOF;
        maxBOF = context.options[0].maxBOF;
    }

    return {

        "TemplateLiteral": function(node) {
            var start = node.loc.start.line;
            var end = node.loc.end.line;
            while (start <= end) {
                notEmpty.push(start);
                start++;
            }
        },

        "Program:exit": function checkBlankLines(node) {
            var lines = context.getSourceLines(),
                currentLocation = -1,
                lastLocation,
                blankCounter = 0,
                location,
                firstOfEndingBlankLines,
                firstNonBlankLine = -1,
                trimmedLines = [];

            lines.forEach(function(str, i) {
                var trimmed = str.trim();
                if ((firstNonBlankLine === -1) && (trimmed !== "")) {
                    firstNonBlankLine = i;
                }

                trimmedLines.push(trimmed);
            });

            notEmpty.forEach(function(x, i) {
                trimmedLines[i] = x;
            });

            if (typeof maxEOF === "undefined") {
                if (trimmedLines[trimmedLines.length - 1] === "") {
                    trimmedLines = trimmedLines.slice(0, -1);
                }
                firstOfEndingBlankLines = trimmedLines.length;
            } else {
                firstOfEndingBlankLines = trimmedLines.length;
                while (trimmedLines[firstOfEndingBlankLines - 1] === ""
                        && firstOfEndingBlankLines > 0) {
                    firstOfEndingBlankLines--;
                }
            }

            if (firstNonBlankLine > maxBOF) {
                context.report(node, 0,
                        "Too many blank lines at the beginning of file. Max of " + maxBOF + " allowed.");
            }

            lastLocation = currentLocation;
            currentLocation = trimmedLines.indexOf("", currentLocation + 1);
            while (currentLocation !== -1) {
                lastLocation = currentLocation;
                currentLocation = trimmedLines.indexOf("", currentLocation + 1);
                if (lastLocation === currentLocation - 1) {
                    blankCounter++;
                } else {
                    location = {
                        line: lastLocation ,
                        column: 0
                    };
                    if (lastLocation < firstOfEndingBlankLines) {
                        if (blankCounter >= max) {
                            context.report(node, location,
                                    "More than " + max + " blank " + (max === 1 ? "line" : "lines") + " not allowed.");
                        }
                    } else {
                        if (blankCounter > maxEOF) {
                            context.report(node, location,
                                    "Too many blank lines at the end of file. Max of " + maxEOF + " allowed.");
                        }
                    }

                    blankCounter = 0;
                }
            }
        }
    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "max": {
                "type": "integer",
                "minimum": 0
            },
            "maxEOF": {
                "type": "integer",
                "minimum": 0
            },
            "maxBOF": {
                "type": "integer",
                "minimum": 0
            }
        },
        "required": ["max"],
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/no-native-reassign.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var config = context.options[0];
    var exceptions = (config && config.exceptions) || [];

    function checkReference(reference, index, references) {
        var identifier = reference.identifier;

        if (reference.init === false &&
            reference.isWrite() &&
            (index === 0 || references[index - 1].identifier !== identifier)
        ) {
            context.report({
                node: identifier,
                message: "{{name}} is a read-only native object.",
                data: identifier
            });
        }
    }

    function checkVariable(variable) {
        if (variable.writeable === false && exceptions.indexOf(variable.name) === -1) {
            variable.references.forEach(checkReference);
        }
    }

    return {
        "Program": function() {
            var globalScope = context.getScope();
            globalScope.variables.forEach(checkVariable);
        }
    };
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "exceptions": {
                "type": "array",
                "items": {"type": "string"},
                "uniqueItems": true
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/no-negated-condition.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    function hasElseWithoutCondition(node) {
        return node.alternate && node.alternate.type !== "IfStatement";
    }

    function isNegatedUnaryExpression(test) {
        return test.type === "UnaryExpression" && test.operator === "!";
    }

    function isNegatedBinaryExpression(test) {
        return test.type === "BinaryExpression" &&
            (test.operator === "!=" || test.operator === "!==");
    }

    function isNegatedIf(node) {
        return isNegatedUnaryExpression(node.test) || isNegatedBinaryExpression(node.test);
    }

    return {
        "IfStatement": function(node) {
            if (!hasElseWithoutCondition(node)) {
                return;
            }

            if (isNegatedIf(node)) {
                context.report(node, "Unexpected negated condition.");
            }
        },
        "ConditionalExpression": function(node) {
            if (isNegatedIf(node)) {
                context.report(node, "Unexpected negated condition.");
            }
        }
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-negated-in-lhs.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "BinaryExpression": function(node) {
            if (node.operator === "in" && node.left.type === "UnaryExpression" && node.left.operator === "!") {
                context.report(node, "The 'in' expression's left operand is negated");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-nested-ternary.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {
        "ConditionalExpression": function(node) {
            if (node.alternate.type === "ConditionalExpression" ||
                    node.consequent.type === "ConditionalExpression") {
                context.report(node, "Do not nest ternary expressions");
            }
        }
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-new-func.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    function validateCallee(node) {
        if (node.callee.name === "Function") {
            context.report(node, "The Function constructor is eval.");
        }
    }

    return {
        "NewExpression": validateCallee,
        "CallExpression": validateCallee
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-new-object.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "NewExpression": function(node) {
            if (node.callee.name === "Object") {
                context.report(node, "The object literal notation {} is preferrable.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-new-require.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "NewExpression": function(node) {
            if (node.callee.type === "Identifier" && node.callee.name === "require") {
                context.report(node, "Unexpected use of new with require.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-new-symbol.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {
        "Program:exit": function() {
            var globalScope = context.getScope();
            var variable = globalScope.set.get("Symbol");
            if (variable && variable.defs.length === 0) {
                variable.references.forEach(function(ref) {
                    var node = ref.identifier;
                    if (node.parent && node.parent.type === "NewExpression") {
                        context.report(node, "`Symbol` cannot be called as a constructor.");
                    }
                });
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-new-wrappers.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "NewExpression": function(node) {
            var wrapperObjects = ["String", "Number", "Boolean", "Math", "JSON"];
            if (wrapperObjects.indexOf(node.callee.name) > -1) {
                context.report(node, "Do not use {{fn}} as a constructor.", { fn: node.callee.name });
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-new.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "ExpressionStatement": function(node) {

            if (node.expression.type === "NewExpression") {
                context.report(node, "Do not use 'new' for side effects.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-obj-calls.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {
        "CallExpression": function(node) {

            if (node.callee.type === "Identifier") {
                var name = node.callee.name;
                if (name === "Math" || name === "JSON") {
                    context.report(node, "'{{name}}' is not a function.", { name: name });
                }
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-octal-escape.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "Literal": function(node) {
            if (typeof node.value !== "string") {
                return;
            }

            var match = node.raw.match(/^([^\\]|\\[^0-7])*\\([0-3][0-7]{1,2}|[4-7][0-7]|[0-7])/),
                octalDigit;

            if (match) {
                octalDigit = match[2];

                if (match[2] !== "0" || typeof match[3] !== "undefined") {
                    context.report(node, "Don't use octal: '\\{{octalDigit}}'. Use '\\u....' instead.",
                            { octalDigit: octalDigit });
                }
            }
        }

    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-octal.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "Literal": function(node) {
            if (typeof node.value === "number" && /^0[0-7]/.test(node.raw)) {
                context.report(node, "Octal literals should not be used.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-param-reassign.js": [function(require,module,exports){
"use strict";

var stopNodePattern = /(?:Statement|Declaration|Function(?:Expression)?|Program)$/;

module.exports = function(context) {
    var props = context.options[0] && Boolean(context.options[0].props);

    function isModifying(reference) {
        if (reference.isWrite()) {
            return true;
        }

        if (props) {
            var node = reference.identifier;
            var parent = node.parent;
            while (parent && !stopNodePattern.test(parent.type)) {
                switch (parent.type) {
                    case "AssignmentExpression":
                        return parent.left === node;

                    case "UpdateExpression":
                        return true;

                    case "UnaryExpression":
                        if (parent.operator === "delete") {
                            return true;
                        }
                        break;

                    case "CallExpression":
                        if (parent.callee !== node) {
                            return false;
                        }
                        break;

                    case "MemberExpression":
                        if (parent.property === node) {
                            return false;
                        }
                        break;

                    default:
                        break;
                }

                node = parent;
                parent = parent.parent;
            }
        }

        return false;
    }

    function checkReference(reference, index, references) {
        var identifier = reference.identifier;

        if (identifier &&
            !reference.init &&
            isModifying(reference) &&
            (index === 0 || references[index - 1].identifier !== identifier)
        ) {
            context.report(
                identifier,
                "Assignment to function parameter '{{name}}'.",
                {name: identifier.name});
        }
    }

    function checkVariable(variable) {
        if (variable.defs[0].type === "Parameter") {
            variable.references.forEach(checkReference);
        }
    }

    function checkForFunction(node) {
        context.getDeclaredVariables(node).forEach(checkVariable);
    }

    return {
        "FunctionDeclaration:exit": checkForFunction,
        "FunctionExpression:exit": checkForFunction,
        "ArrowFunctionExpression:exit": checkForFunction
    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "props": {"type": "boolean"}
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/no-path-concat.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var MATCHER = /^__(?:dir|file)name$/;

    return {

        "BinaryExpression": function(node) {

            var left = node.left,
                right = node.right;

            if (node.operator === "+" &&
                    ((left.type === "Identifier" && MATCHER.test(left.name)) ||
                    (right.type === "Identifier" && MATCHER.test(right.name)))
            ) {

                context.report(node, "Use path.join() or path.resolve() instead of + to create paths.");
            }
        }

    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-plusplus.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var config = context.options[0],
        allowInForAfterthought = false;

    if (typeof config === "object") {
        allowInForAfterthought = config.allowForLoopAfterthoughts === true;
    }

    return {

        "UpdateExpression": function(node) {
            if (allowInForAfterthought && node.parent.type === "ForStatement") {
                return;
            }
            context.report(node, "Unary operator '" + node.operator + "' used.");
        }

    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "allowForLoopAfterthoughts": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/no-process-env.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "MemberExpression": function(node) {
            var objectName = node.object.name,
                propertyName = node.property.name;

            if (objectName === "process" && !node.computed && propertyName && propertyName === "env") {
                context.report(node, "Unexpected use of process.env.");
            }

        }

    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-process-exit.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "CallExpression": function(node) {
            var callee = node.callee;

            if (callee.type === "MemberExpression" && callee.object.name === "process" &&
                callee.property.name === "exit"
            ) {
                context.report(node, "Don't use process.exit(); throw an error instead.");
            }
        }

    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-proto.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "MemberExpression": function(node) {

            if (node.property &&
                    (node.property.type === "Identifier" && node.property.name === "__proto__" && !node.computed) ||
                    (node.property.type === "Literal" && node.property.value === "__proto__")) {
                context.report(node, "The '__proto__' property is deprecated.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-redeclare.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var options = {
        builtinGlobals: Boolean(context.options[0] && context.options[0].builtinGlobals)
    };

    function findVariablesInScope(scope) {
        scope.variables.forEach(function(variable) {
            var hasBuiltin = options.builtinGlobals && "writeable" in variable;
            var count = (hasBuiltin ? 1 : 0) + variable.identifiers.length;

            if (count >= 2) {
                variable.identifiers.sort(function(a, b) {
                    return a.range[1] - b.range[1];
                });

                for (var i = (hasBuiltin ? 0 : 1), l = variable.identifiers.length; i < l; i++) {
                    context.report(
                        variable.identifiers[i],
                        "'{{a}}' is already defined",
                        {a: variable.name});
                }
            }
        });

    }

    function checkForGlobal(node) {
        var scope = context.getScope(),
            parserOptions = context.parserOptions,
            ecmaFeatures = parserOptions.ecmaFeatures || {};

        if (ecmaFeatures.globalReturn || node.sourceType === "module") {
            findVariablesInScope(scope.childScopes[0]);
        } else {
            findVariablesInScope(scope);
        }
    }

    function checkForBlock() {
        findVariablesInScope(context.getScope());
    }

    if (context.parserOptions.ecmaVersion >= 6) {
        return {
            "Program": checkForGlobal,
            "BlockStatement": checkForBlock,
            "SwitchStatement": checkForBlock
        };
    } else {
        return {
            "Program": checkForGlobal,
            "FunctionDeclaration": checkForBlock,
            "FunctionExpression": checkForBlock,
            "ArrowFunctionExpression": checkForBlock
        };
    }
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "builtinGlobals": {"type": "boolean"}
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/no-regex-spaces.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "Literal": function(node) {
            var token = context.getFirstToken(node),
                nodeType = token.type,
                nodeValue = token.value,
                multipleSpacesRegex = /( {2,})+?/,
                regexResults;

            if (nodeType === "RegularExpression") {
                regexResults = multipleSpacesRegex.exec(nodeValue);

                if (regexResults !== null) {
                    context.report(node, "Spaces are hard to count. Use {" + regexResults[0].length + "}.");
                }
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-restricted-globals.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var restrictedGlobals = context.options;

    if (restrictedGlobals.length === 0) {
        return {};
    }

    function reportReference(reference) {
        context.report(reference.identifier, "Unexpected use of '{{name}}'", {
            name: reference.identifier.name
        });
    }

    function isRestricted(name) {
        return restrictedGlobals.indexOf(name) >= 0;
    }

    return {
        "Program": function() {
            var scope = context.getScope();

            scope.variables.forEach(function(variable) {
                if (!variable.defs.length && isRestricted(variable.name)) {
                    variable.references.forEach(reportReference);
                }
            });

            scope.through.forEach(function(reference) {
                if (isRestricted(reference.identifier.name)) {
                    reportReference(reference);
                }
            });

        }
    };
};

module.exports.schema = {
    "type": "array",
    "items": {
        "type": "string"
    },
    "uniqueItems": true
};


},
   {}],

"/tmp/rules/no-restricted-imports.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var restrictedImports = context.options;

    if (restrictedImports.length === 0) {
        return {};
    }

    return {
        "ImportDeclaration": function(node) {
            if (node && node.source && node.source.value) {

                var value = node.source.value.trim();

                if (restrictedImports.indexOf(value) !== -1) {
                    context.report(node, "'{{importName}}' import is restricted from being used.", {
                        importName: value
                    });
                }
            }
        }
    };
};

module.exports.schema = {
    "type": "array",
    "items": {
        "type": "string"
    },
    "uniqueItems": true
};

},
   {}],

"/tmp/rules/no-restricted-modules.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var restrictedModules = context.options;

    if (restrictedModules.length === 0) {
        return {};
    }

    function isString(node) {
        return node && node.type === "Literal" && typeof node.value === "string";
    }

    function isRequireCall(node) {
        return node.callee.type === "Identifier" && node.callee.name === "require";
    }

    function getRestrictedModuleName(node) {
        var moduleName;

        if (node.arguments.length && isString(node.arguments[0])) {
            var argumentValue = node.arguments[0].value.trim();

            if (restrictedModules.indexOf(argumentValue) !== -1) {
                moduleName = argumentValue;
            }
        }

        return moduleName;
    }

    return {
        "CallExpression": function(node) {
            if (isRequireCall(node)) {
                var restrictedModuleName = getRestrictedModuleName(node);

                if (restrictedModuleName) {
                    context.report(node, "'{{moduleName}}' module is restricted from being used.", {
                        moduleName: restrictedModuleName
                    });
                }
            }
        }
    };
};

module.exports.schema = {
    "type": "array",
    "items": {
        "type": "string"
    },
    "uniqueItems": true
};

},
   {}],

"/tmp/rules/no-restricted-syntax.js": [function(require,module,exports){
"use strict";

var nodeTypes = require("espree").Syntax;

module.exports = function(context) {
    function warn(node) {
        context.report(node, "Using '{{type}}' is not allowed.", node);
    }

    return context.options.reduce(function(result, nodeType) {
        result[nodeType] = warn;

        return result;
    }, {});

};

module.exports.schema = {
    "type": "array",
    "items": [
        {
            "enum": Object.keys(nodeTypes).map(function(k) {
                return nodeTypes[k];
            })
        }
    ],
    "uniqueItems": true,
    "minItems": 0
};

},
   {"espree":"espree"}],

"/tmp/rules/no-return-assign.js": [function(require,module,exports){
"use strict";

function isAssignment(node) {
    return node && node.type === "AssignmentExpression";
}

function isEnclosedInParens(node, context) {
    var prevToken = context.getTokenBefore(node);
    var nextToken = context.getTokenAfter(node);

    return prevToken.value === "(" && nextToken.value === ")";
}

module.exports = function(context) {
    var always = (context.options[0] || "except-parens") !== "except-parens";

    function checkForAssignInReturn(nodeToCheck, nodeToReport, message) {
        if (isAssignment(nodeToCheck) && (always || !isEnclosedInParens(nodeToCheck, context))) {
            context.report(nodeToReport, message);
        }
    }

    return {
        "ReturnStatement": function(node) {
            var message = "Return statement should not contain assignment.";
            checkForAssignInReturn(node.argument, node, message);
        },
        "ArrowFunctionExpression": function(node) {
            if (node.body.type !== "BlockStatement") {
                var message = "Arrow function should not return assignment.";
                checkForAssignInReturn(node.body, node, message);
            }
        }
    };
};

module.exports.schema = [
    {
        "enum": ["except-parens", "always"]
    }
];

},
   {}],

"/tmp/rules/no-script-url.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "Literal": function(node) {

            var value;

            if (node.value && typeof node.value === "string") {
                value = node.value.toLowerCase();

                if (value.indexOf("javascript:") === 0) {
                    context.report(node, "Script URL is a form of eval.");
                }
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-self-assign.js": [function(require,module,exports){
"use strict";

function eachSelfAssignment(left, right, report) {
    var i, j;

    if (!left || !right) {
    } else if (
        left.type === "Identifier" &&
        right.type === "Identifier" &&
        left.name === right.name
    ) {
        report(right);
    } else if (
        left.type === "ArrayPattern" &&
        right.type === "ArrayExpression"
    ) {
        var end = Math.min(left.elements.length, right.elements.length);
        for (i = 0; i < end; ++i) {
            var rightElement = right.elements[i];

            eachSelfAssignment(left.elements[i], rightElement, report);

            if (rightElement && rightElement.type === "SpreadElement") {
                break;
            }
        }
    } else if (
        left.type === "RestElement" &&
        right.type === "SpreadElement"
    ) {
        eachSelfAssignment(left.argument, right.argument, report);
    } else if (
        left.type === "ObjectPattern" &&
        right.type === "ObjectExpression" &&
        right.properties.length >= 1
    ) {
        var startJ = 0;
        for (i = right.properties.length - 1; i >= 0; --i) {
            if (right.properties[i].type === "ExperimentalSpreadProperty") {
                startJ = i + 1;
                break;
            }
        }

        for (i = 0; i < left.properties.length; ++i) {
            for (j = startJ; j < right.properties.length; ++j) {
                eachSelfAssignment(
                    left.properties[i],
                    right.properties[j],
                    report
                );
            }
        }
    } else if (
        left.type === "Property" &&
        right.type === "Property" &&
        !left.computed &&
        !right.computed &&
        right.kind === "init" &&
        !right.method &&
        left.key.name === right.key.name
    ) {
        eachSelfAssignment(left.value, right.value, report);
    }
}

module.exports = function(context) {
    function report(node) {
        context.report({
            node: node,
            message: "'{{name}}' is assigned to itself.",
            data: node
        });
    }

    return {
        "AssignmentExpression": function(node) {
            if (node.operator === "=") {
                eachSelfAssignment(node.left, node.right, report);
            }
        }
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-self-compare.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "BinaryExpression": function(node) {
            var operators = ["===", "==", "!==", "!=", ">", "<", ">=", "<="];
            if (operators.indexOf(node.operator) > -1 &&
                (node.left.type === "Identifier" && node.right.type === "Identifier" && node.left.name === node.right.name ||
                node.left.type === "Literal" && node.right.type === "Literal" && node.left.value === node.right.value)) {
                context.report(node, "Comparing to itself is potentially pointless.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-sequences.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var parenthesized = {
        "DoWhileStatement": "test",
        "IfStatement": "test",
        "SwitchStatement": "discriminant",
        "WhileStatement": "test",
        "WithStatement": "object"

    };

    function requiresExtraParens(node) {
        return node.parent && parenthesized[node.parent.type] &&
                node === node.parent[parenthesized[node.parent.type]];
    }

    function isParenthesised(node) {
        var previousToken = context.getTokenBefore(node),
            nextToken = context.getTokenAfter(node);

        return previousToken && nextToken &&
            previousToken.value === "(" && previousToken.range[1] <= node.range[0] &&
            nextToken.value === ")" && nextToken.range[0] >= node.range[1];
    }

    function isParenthesisedTwice(node) {
        var previousToken = context.getTokenBefore(node, 1),
            nextToken = context.getTokenAfter(node, 1);

        return isParenthesised(node) && previousToken && nextToken &&
            previousToken.value === "(" && previousToken.range[1] <= node.range[0] &&
            nextToken.value === ")" && nextToken.range[0] >= node.range[1];
    }

    return {
        "SequenceExpression": function(node) {
            if (node.parent.type === "ForStatement" &&
                    (node === node.parent.init || node === node.parent.update)) {
                return;
            }

            if (requiresExtraParens(node)) {
                if (isParenthesisedTwice(node)) {
                    return;
                }
            } else {
                if (isParenthesised(node)) {
                    return;
                }
            }

            var child = context.getTokenAfter(node.expressions[0]);
            context.report(node, child.loc.start, "Unexpected use of comma operator.");
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-shadow-restricted-names.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var RESTRICTED = ["undefined", "NaN", "Infinity", "arguments", "eval"];

    function checkForViolation(id) {
        if (RESTRICTED.indexOf(id.name) > -1) {
            context.report(id, "Shadowing of global property '" + id.name + "'.");
        }
    }

    return {
        "VariableDeclarator": function(node) {
            checkForViolation(node.id);
        },
        "ArrowFunctionExpression": function(node) {
            [].map.call(node.params, checkForViolation);
        },
        "FunctionExpression": function(node) {
            if (node.id) {
                checkForViolation(node.id);
            }
            [].map.call(node.params, checkForViolation);
        },
        "FunctionDeclaration": function(node) {
            if (node.id) {
                checkForViolation(node.id);
                [].map.call(node.params, checkForViolation);
            }
        },
        "CatchClause": function(node) {
            checkForViolation(node.param);
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-shadow.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {

    var options = {
        builtinGlobals: Boolean(context.options[0] && context.options[0].builtinGlobals),
        hoist: (context.options[0] && context.options[0].hoist) || "functions",
        allow: (context.options[0] && context.options[0].allow) || []
    };

    function isAllowed(variable) {
        return options.allow.indexOf(variable.name) !== -1;
    }

    function isDuplicatedClassNameVariable(variable) {
        var block = variable.scope.block;
        return block.type === "ClassDeclaration" && block.id === variable.identifiers[0];
    }

    function isOnInitializer(variable, scopeVar) {
        var outerScope = scopeVar.scope;
        var outerDef = scopeVar.defs[0];
        var outer = outerDef && outerDef.parent && outerDef.parent.range;
        var innerScope = variable.scope;
        var innerDef = variable.defs[0];
        var inner = innerDef && innerDef.name.range;

        return (
            outer &&
            inner &&
            outer[0] < inner[0] &&
            inner[1] < outer[1] &&
            ((innerDef.type === "FunctionName" && innerDef.node.type === "FunctionExpression") || innerDef.node.type === "ClassExpression") &&
            outerScope === innerScope.upper
        );
    }

    function getNameRange(variable) {
        var def = variable.defs[0];
        return def && def.name.range;
    }

    function isInTdz(variable, scopeVar) {
        var outerDef = scopeVar.defs[0];
        var inner = getNameRange(variable);
        var outer = getNameRange(scopeVar);
        return (
            inner &&
            outer &&
            inner[1] < outer[0] &&
            (options.hoist !== "functions" || !outerDef || outerDef.node.type !== "FunctionDeclaration")
        );
    }

    function checkForShadows(scope) {
        var variables = scope.variables;
        for (var i = 0; i < variables.length; ++i) {
            var variable = variables[i];

            if (variable.identifiers.length === 0 ||
                isDuplicatedClassNameVariable(variable) ||
                isAllowed(variable)
            ) {
                continue;
            }

            var shadowed = astUtils.getVariableByName(scope.upper, variable.name);
            if (shadowed &&
                (shadowed.identifiers.length > 0 || (options.builtinGlobals && "writeable" in shadowed)) &&
                !isOnInitializer(variable, shadowed) &&
                !(options.hoist !== "all" && isInTdz(variable, shadowed))
            ) {
                context.report({
                    node: variable.identifiers[0],
                    message: "'{{name}}' is already declared in the upper scope.",
                    data: variable
                });
            }
        }
    }

    return {
        "Program:exit": function() {
            var globalScope = context.getScope();
            var stack = globalScope.childScopes.slice();
            var scope;

            while (stack.length) {
                scope = stack.pop();
                stack.push.apply(stack, scope.childScopes);
                checkForShadows(scope);
            }
        }
    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "builtinGlobals": {"type": "boolean"},
            "hoist": {"enum": ["all", "functions", "never"]},
            "allow": {
                "type": "array",
                "items": {
                    "type": "string"
                }
            }
        },
        "additionalProperties": false
    }
];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-spaced-func.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var sourceCode = context.getSourceCode();

    function detectOpenSpaces(node) {
        var lastCalleeToken = sourceCode.getLastToken(node.callee),
            prevToken = lastCalleeToken,
            parenToken = sourceCode.getTokenAfter(lastCalleeToken);

        while (
            parenToken &&
            parenToken.range[1] < node.range[1] &&
            parenToken.value !== "("
        ) {
            prevToken = parenToken;
            parenToken = sourceCode.getTokenAfter(parenToken);
        }

        if (parenToken &&
            parenToken.range[1] < node.range[1] &&
            sourceCode.isSpaceBetweenTokens(prevToken, parenToken)
        ) {
            context.report({
                node: node,
                loc: lastCalleeToken.loc.start,
                message: "Unexpected space between function name and paren.",
                fix: function(fixer) {
                    return fixer.removeRange([prevToken.range[1], parenToken.range[0]]);
                }
            });
        }
    }

    return {
        "CallExpression": detectOpenSpaces,
        "NewExpression": detectOpenSpaces
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-sparse-arrays.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {


    return {

        "ArrayExpression": function(node) {

            var emptySpot = node.elements.indexOf(null) > -1;

            if (emptySpot) {
                context.report(node, "Unexpected comma in middle of array.");
            }
        }

    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-sync.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "MemberExpression": function(node) {
            var propertyName = node.property.name,
                syncRegex = /.*Sync$/;

            if (syncRegex.exec(propertyName) !== null) {
                context.report(node, "Unexpected sync method: '" + propertyName + "'.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-ternary.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "ConditionalExpression": function(node) {
            context.report(node, "Ternary operator used.");
        }

    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-this-before-super.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

function isConstructorFunction(node) {
    return (
        node.type === "FunctionExpression" &&
        node.parent.type === "MethodDefinition" &&
        node.parent.kind === "constructor"
    );
}

module.exports = function(context) {
    var funcInfo = null;

    var segInfoMap = Object.create(null);

    function isCalled(segment) {
        return segInfoMap[segment.id].superCalled;
    }

    function isInConstructorOfDerivedClass() {
        return Boolean(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends);
    }

    function isBeforeCallOfSuper() {
        return (
            isInConstructorOfDerivedClass(funcInfo) &&
            !funcInfo.codePath.currentSegments.every(isCalled)
        );
    }

    function setInvalid(node) {
        var segments = funcInfo.codePath.currentSegments;
        for (var i = 0; i < segments.length; ++i) {
            segInfoMap[segments[i].id].invalidNodes.push(node);
        }
    }

    function setSuperCalled() {
        var segments = funcInfo.codePath.currentSegments;
        for (var i = 0; i < segments.length; ++i) {
            segInfoMap[segments[i].id].superCalled = true;
        }
    }

    return {
        "onCodePathStart": function(codePath, node) {
            if (isConstructorFunction(node)) {
                var classNode = node.parent.parent.parent;
                funcInfo = {
                    upper: funcInfo,
                    isConstructor: true,
                    hasExtends: Boolean(
                        classNode.superClass &&
                        !astUtils.isNullOrUndefined(classNode.superClass)
                    ),
                    codePath: codePath
                };
            } else {
                funcInfo = {
                    upper: funcInfo,
                    isConstructor: false,
                    hasExtends: false,
                    codePath: codePath
                };
            }
        },

        "onCodePathEnd": function(codePath) {
            var isDerivedClass = funcInfo.hasExtends;
            funcInfo = funcInfo.upper;
            if (!isDerivedClass) {
                return;
            }

            codePath.traverseSegments(function(segment, controller) {
                var info = segInfoMap[segment.id];

                for (var i = 0; i < info.invalidNodes.length; ++i) {
                    var invalidNode = info.invalidNodes[i];

                    context.report({
                        message: "'{{kind}}' is not allowed before 'super()'.",
                        node: invalidNode,
                        data: {
                            kind: invalidNode.type === "Super" ? "super" : "this"
                        }
                    });
                }

                if (info.superCalled) {
                    controller.skip();
                }
            });
        },

        "onCodePathSegmentStart": function(segment) {
            if (!isInConstructorOfDerivedClass(funcInfo)) {
                return;
            }

            segInfoMap[segment.id] = {
                superCalled: (
                    segment.prevSegments.length > 0 &&
                    segment.prevSegments.every(isCalled)
                ),
                invalidNodes: []
            };
        },

        "onCodePathSegmentLoop": function(fromSegment, toSegment) {
            if (!isInConstructorOfDerivedClass(funcInfo)) {
                return;
            }

            funcInfo.codePath.traverseSegments(
                {first: toSegment, last: fromSegment},
                function(segment, controller) {
                    var info = segInfoMap[segment.id];
                    if (info.superCalled) {
                        info.invalidNodes = [];
                        controller.skip();
                    } else if (
                        segment.prevSegments.length > 0 &&
                        segment.prevSegments.every(isCalled)
                    ) {
                        info.superCalled = true;
                        info.invalidNodes = [];
                    }
                }
            );
        },

        "ThisExpression": function(node) {
            if (isBeforeCallOfSuper()) {
                setInvalid(node);
            }
        },

        "Super": function(node) {
            if (!astUtils.isCallee(node) && isBeforeCallOfSuper()) {
                setInvalid(node);
            }
        },

        "CallExpression:exit": function(node) {
            if (node.callee.type === "Super" && isBeforeCallOfSuper()) {
                setSuperCalled();
            }
        },

        "Program:exit": function() {
            segInfoMap = Object.create(null);
        }
    };
};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-throw-literal.js": [function(require,module,exports){
"use strict";

function couldBeError(node) {
    switch (node.type) {
        case "Identifier":
        case "CallExpression":
        case "NewExpression":
        case "MemberExpression":
        case "TaggedTemplateExpression":
        case "YieldExpression":
            return true; // possibly an error object.

        case "AssignmentExpression":
            return couldBeError(node.right);

        case "SequenceExpression":
            var exprs = node.expressions;
            return exprs.length !== 0 && couldBeError(exprs[exprs.length - 1]);

        case "LogicalExpression":
            return couldBeError(node.left) || couldBeError(node.right);

        case "ConditionalExpression":
            return couldBeError(node.consequent) || couldBeError(node.alternate);

        default:
            return false;
    }
}

module.exports = function(context) {

    return {

        "ThrowStatement": function(node) {
            if (!couldBeError(node.argument)) {
                context.report(node, "Expected an object to be thrown.");
            } else if (node.argument.type === "Identifier") {
                if (node.argument.name === "undefined") {
                    context.report(node, "Do not throw undefined.");
                }
            }

        }

    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-trailing-spaces.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var BLANK_CLASS = "[ \t\u00a0\u2000-\u200b\u2028\u2029\u3000]",
        SKIP_BLANK = "^" + BLANK_CLASS + "*$",
        NONBLANK = BLANK_CLASS + "+$";

    var options = context.options[0] || {},
        skipBlankLines = options.skipBlankLines || false;

    function report(node, location, fixRange) {
        context.report({
            node: node,
            loc: location,
            message: "Trailing spaces not allowed.",
            fix: function(fixer) {
                return fixer.removeRange(fixRange);
            }
        });
    }


    return {

        "Program": function checkTrailingSpaces(node) {

            var src = context.getSource(),
                re = new RegExp(NONBLANK),
                skipMatch = new RegExp(SKIP_BLANK),
                matches, lines = src.split(/\r?\n/),
                linebreaks = context.getSource().match(/\r\n|\r|\n|\u2028|\u2029/g),
                location,
                totalLength = 0,
                fixRange = [];

            for (var i = 0, ii = lines.length; i < ii; i++) {
                matches = re.exec(lines[i]);

                var linebreakLength = linebreaks && linebreaks[i] ? linebreaks[i].length : 1;
                var lineLength = lines[i].length + linebreakLength;

                if (matches) {

                    if (skipBlankLines && skipMatch.test(lines[i])) {
                        continue;
                    }
                    location = {
                        line: i,
                        column: matches.index
                    };

                    fixRange = [totalLength + location.column, totalLength + lineLength - linebreakLength];

                    report(node, location, fixRange);
                }

                totalLength += lineLength;
            }
        }

    };
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "skipBlankLines": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/no-undef-init.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "VariableDeclarator": function(node) {
            var name = node.id.name,
                init = node.init && node.init.name;

            if (init === "undefined" && node.parent.kind !== "const") {
                context.report(node, "It's not necessary to initialize '{{name}}' to undefined.", { name: name });
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-undef.js": [function(require,module,exports){
"use strict";

function hasTypeOfOperator(node) {
    var parent = node.parent;
    return parent.type === "UnaryExpression" && parent.operator === "typeof";
}

module.exports = function(context) {
    var options = context.options[0];
    var considerTypeOf = options && options.typeof === true || false;

    return {
        "Program:exit": function(/* node */) {
            var globalScope = context.getScope();

            globalScope.through.forEach(function(ref) {
                var identifier = ref.identifier;

                if (!considerTypeOf && hasTypeOfOperator(identifier)) {
                    return;
                }

                context.report({
                    node: identifier,
                    message: "'{{name}}' is not defined.",
                    data: identifier
                });
            });
        }
    };
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "typeof": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/no-undefined.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "Identifier": function(node) {
            if (node.name === "undefined") {
                var parent = context.getAncestors().pop();
                if (!parent || parent.type !== "MemberExpression" || node !== parent.property || parent.computed) {
                    context.report(node, "Unexpected use of undefined.");
                }
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-underscore-dangle.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var options = context.options[0] || {};
    var ALLOWED_VARIABLES = options.allow ? options.allow : [];
    var allowAfterThis = typeof options.allowAfterThis !== "undefined" ? options.allowAfterThis : false;

    function isAllowed(identifier) {
        return ALLOWED_VARIABLES.some(function(ident) {
            return ident === identifier;
        });
    }

    function hasTrailingUnderscore(identifier) {
        var len = identifier.length;

        return identifier !== "_" && (identifier[0] === "_" || identifier[len - 1] === "_");
    }

    function isSpecialCaseIdentifierForMemberExpression(identifier) {
        return identifier === "__proto__";
    }

    function isSpecialCaseIdentifierInVariableExpression(identifier) {
        return identifier === "_";
    }

    function checkForTrailingUnderscoreInFunctionDeclaration(node) {
        if (node.id) {
            var identifier = node.id.name;

            if (typeof identifier !== "undefined" && hasTrailingUnderscore(identifier) && !isAllowed(identifier)) {
                context.report(node, "Unexpected dangling '_' in '" + identifier + "'.");
            }
        }
    }

    function checkForTrailingUnderscoreInVariableExpression(node) {
        var identifier = node.id.name;

        if (typeof identifier !== "undefined" && hasTrailingUnderscore(identifier) &&
            !isSpecialCaseIdentifierInVariableExpression(identifier) && !isAllowed(identifier)) {
            context.report(node, "Unexpected dangling '_' in '" + identifier + "'.");
        }
    }

    function checkForTrailingUnderscoreInMemberExpression(node) {
        var identifier = node.property.name,
            isMemberOfThis = node.object.type === "ThisExpression";

        if (typeof identifier !== "undefined" && hasTrailingUnderscore(identifier) &&
            !(isMemberOfThis && allowAfterThis) &&
            !isSpecialCaseIdentifierForMemberExpression(identifier) && !isAllowed(identifier)) {
            context.report(node, "Unexpected dangling '_' in '" + identifier + "'.");
        }
    }

    return {
        "FunctionDeclaration": checkForTrailingUnderscoreInFunctionDeclaration,
        "VariableDeclarator": checkForTrailingUnderscoreInVariableExpression,
        "MemberExpression": checkForTrailingUnderscoreInMemberExpression
    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "allow": {
                "type": "array",
                "items": {
                    "type": "string"
                }
            },
            "allowAfterThis": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/no-unexpected-multiline.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var FUNCTION_MESSAGE = "Unexpected newline between function and ( of function call.";
    var PROPERTY_MESSAGE = "Unexpected newline between object and [ of property access.";
    var TAGGED_TEMPLATE_MESSAGE = "Unexpected newline between template tag and template literal.";

    function checkForBreakAfter(node, msg) {
        var nodeExpressionEnd = node;
        var openParen = context.getTokenAfter(node);

        while (openParen.value === ")") {
            nodeExpressionEnd = openParen;
            openParen = context.getTokenAfter(nodeExpressionEnd);
        }

        if (openParen.loc.start.line !== nodeExpressionEnd.loc.end.line) {
            context.report(node, openParen.loc.start, msg, { char: openParen.value });
        }
    }

    return {

        "MemberExpression": function(node) {
            if (!node.computed) {
                return;
            }
            checkForBreakAfter(node.object, PROPERTY_MESSAGE);
        },

        "TaggedTemplateExpression": function(node) {
            if (node.tag.loc.end.line === node.quasi.loc.start.line) {
                return;
            }
            context.report(node, node.loc.start, TAGGED_TEMPLATE_MESSAGE);
        },

        "CallExpression": function(node) {
            if (node.arguments.length === 0) {
                return;
            }
            checkForBreakAfter(node.callee, FUNCTION_MESSAGE);
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-unmodified-loop-condition.js": [function(require,module,exports){
"use strict";

var Map = require("es6-map"),
    espree = require("espree"),
    estraverse = require("estraverse"),
    astUtils = require("../ast-utils");

var pushAll = Function.apply.bind(Array.prototype.push);
var SENTINEL_PATTERN = /(?:(?:Call|Class|Function|Member|New|Yield)Expression|Statement|Declaration)$/;
var LOOP_PATTERN = /^(?:DoWhile|For|While)Statement$/;
var GROUP_PATTERN = /^(?:BinaryExpression|ConditionalExpression)$/;
var SKIP_PATTERN = /^(?:ArrowFunction|Class|Function)Expression$/;
var DYNAMIC_PATTERN = /^(?:Call|Member|New|TaggedTemplate|Yield)Expression$/;

function isWriteReference(reference) {
    if (reference.init) {
        var def = reference.resolved && reference.resolved.defs[0];
        if (!def || def.type !== "Variable" || def.parent.kind !== "var") {
            return false;
        }
    }
    return reference.isWrite();
}

function isUnmodified(condition) {
    return !condition.modified;
}

function isUnmodifiedAndNotBelongToGroup(condition) {
    return !condition.modified && condition.groups.length === 0;
}

function isInRange(node, reference) {
    var or = node.range;
    var ir = reference.identifier.range;
    return or[0] <= ir[0] && ir[1] <= or[1];
}

var isInLoop = {
    WhileStatement: isInRange,
    DoWhileStatement: isInRange,
    ForStatement: function(node, reference) {
        return (
            isInRange(node, reference) &&
            !(node.init && isInRange(node.init, reference))
        );
    }
};

function hasDynamicExpressions(root) {
    var retv = false;

    estraverse.traverse(root, {
        enter: function(node) {
            if (DYNAMIC_PATTERN.test(node.type)) {
                retv = true;
                this.break();
            } else if (SKIP_PATTERN.test(node.type)) {
                this.skip();
            }
        },
        keys: espree.VisitorKeys
    });

    return retv;
}

function toLoopCondition(reference) {
    if (reference.init) {
        return null;
    }

    var groups = [];
    var child = reference.identifier;
    var node = child.parent;
    while (node) {
        if (SENTINEL_PATTERN.test(node.type)) {
            if (LOOP_PATTERN.test(node.type) && node.test === child) {
                return {
                    reference: reference,
                    groups: groups,
                    isInLoop: isInLoop[node.type].bind(null, node),
                    modified: false
                };
            }
            break;
        }

        if (GROUP_PATTERN.test(node.type)) {
            if (hasDynamicExpressions(node)) {
                break;
            } else {
                groups.push(node);
            }
        }

        child = node;
        node = node.parent;
    }

    return null;
}

function getEncloseFunctionDeclaration(reference) {
    var node = reference.identifier;

    while (node) {
        if (node.type === "FunctionDeclaration") {
            return node.id ? node : null;
        }

        node = node.parent;
    }

    return null;
}

function updateModifiedFlag(conditions, modifiers) {
    var funcNode, funcVar;

    for (var i = 0; i < conditions.length; ++i) {
        var condition = conditions[i];

        for (var j = 0; !condition.modified && j < modifiers.length; ++j) {
            var modifier = modifiers[j];
            var inLoop = condition.isInLoop(modifier) || Boolean(
                (funcNode = getEncloseFunctionDeclaration(modifier)) &&
                (funcVar = astUtils.getVariableByName(modifier.from.upper, funcNode.id.name)) &&
                funcVar.references.some(condition.isInLoop)
            );
            condition.modified = inLoop;
        }
    }
}

module.exports = function(context) {
    var groupMap = null;

    function report(condition) {
        var node = condition.reference.identifier;

        context.report({
            node: node,
            message: "'{{name}}' is not modified in this loop.",
            data: node
        });
    }

    function registerConditionsToGroup(conditions) {
        for (var i = 0; i < conditions.length; ++i) {
            var condition = conditions[i];

            for (var j = 0; j < condition.groups.length; ++j) {
                var be = condition.groups[j];
                var group = groupMap.get(be);
                if (!group) {
                    group = [];
                    groupMap.set(be, group);
                }
                group.push(condition);
            }
        }
    }

    function checkConditionsInGroup(conditions) {
        if (conditions.every(isUnmodified)) {
            conditions.forEach(report);
        }
    }

    function checkReferences(variable) {
        var conditions = variable
            .references
            .map(toLoopCondition)
            .filter(Boolean);

        if (conditions.length === 0) {
            return;
        }

        registerConditionsToGroup(conditions);

        var modifiers = variable.references.filter(isWriteReference);
        if (modifiers.length > 0) {
            updateModifiedFlag(conditions, modifiers);
        }

        conditions
            .filter(isUnmodifiedAndNotBelongToGroup)
            .forEach(report);
    }

    return {
        "Program:exit": function() {
            var queue = [context.getScope()];
            groupMap = new Map();

            var scope;
            while ((scope = queue.pop())) {
                pushAll(queue, scope.childScopes);
                scope.variables.forEach(checkReferences);
            }

            groupMap.forEach(checkConditionsInGroup);
            groupMap = null;
        }
    };
};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js","es6-map":"/node_modules/es6-map/index.js","espree":"espree","estraverse":"/node_modules/estraverse/estraverse.js"}],

"/tmp/rules/no-unneeded-ternary.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var options = context.options[0] || {};
    var defaultAssignment = options.defaultAssignment !== false;

    function isBooleanLiteral(node) {
        return node.type === "Literal" && typeof node.value === "boolean";
    }

    function matchesDefaultAssignment(node) {
        return node.test.type === "Identifier" &&
               node.consequent.type === "Identifier" &&
               node.test.name === node.consequent.name;
    }

    return {

        "ConditionalExpression": function(node) {
            if (isBooleanLiteral(node.alternate) && isBooleanLiteral(node.consequent)) {
                context.report(node, node.consequent.loc.start, "Unnecessary use of boolean literals in conditional expression");
            } else if (!defaultAssignment && matchesDefaultAssignment(node)) {
                context.report(node, node.consequent.loc.start, "Unnecessary use of conditional expression for default assignment");
            }
        }
    };
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "defaultAssignment": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/no-unreachable.js": [function(require,module,exports){
"use strict";

function isInitialized(node) {
    return Boolean(node.init);
}

function isUnreachable(segment) {
    return !segment.reachable;
}

module.exports = function(context) {
    var currentCodePath = null;

    function reportIfUnreachable(node) {
        if (currentCodePath.currentSegments.every(isUnreachable)) {
            context.report({message: "Unreachable code.", node: node});
        }
    }

    return {
        "onCodePathStart": function(codePath) {
            currentCodePath = codePath;
        },
        "onCodePathEnd": function() {
            currentCodePath = currentCodePath.upper;
        },

        BlockStatement: reportIfUnreachable,
        BreakStatement: reportIfUnreachable,
        ClassDeclaration: reportIfUnreachable,
        ContinueStatement: reportIfUnreachable,
        DebuggerStatement: reportIfUnreachable,
        DoWhileStatement: reportIfUnreachable,
        EmptyStatement: reportIfUnreachable,
        ExpressionStatement: reportIfUnreachable,
        ForInStatement: reportIfUnreachable,
        ForOfStatement: reportIfUnreachable,
        ForStatement: reportIfUnreachable,
        IfStatement: reportIfUnreachable,
        ImportDeclaration: reportIfUnreachable,
        LabeledStatement: reportIfUnreachable,
        ReturnStatement: reportIfUnreachable,
        SwitchStatement: reportIfUnreachable,
        ThrowStatement: reportIfUnreachable,
        TryStatement: reportIfUnreachable,
        VariableDeclaration: function(node) {
            if (node.kind !== "var" || node.declarations.some(isInitialized)) {
                reportIfUnreachable(node);
            }
        },
        WhileStatement: reportIfUnreachable,
        WithStatement: reportIfUnreachable,
        ExportNamedDeclaration: reportIfUnreachable,
        ExportDefaultDeclaration: reportIfUnreachable,
        ExportAllDeclaration: reportIfUnreachable
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-unused-expressions.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var config = context.options[0] || {},
        allowShortCircuit = config.allowShortCircuit || false,
        allowTernary = config.allowTernary || false;

    function looksLikeDirective(node) {
        return node.type === "ExpressionStatement" &&
            node.expression.type === "Literal" && typeof node.expression.value === "string";
    }

    function takeWhile(predicate, list) {
        for (var i = 0, l = list.length; i < l; ++i) {
            if (!predicate(list[i])) {
                break;
            }
        }
        return [].slice.call(list, 0, i);
    }

    function directives(node) {
        return takeWhile(looksLikeDirective, node.body);
    }

    function isDirective(node, ancestors) {
        var parent = ancestors[ancestors.length - 1],
            grandparent = ancestors[ancestors.length - 2];
        return (parent.type === "Program" || parent.type === "BlockStatement" &&
                (/Function/.test(grandparent.type))) &&
                directives(parent).indexOf(node) >= 0;
    }

    function isValidExpression(node) {
        if (allowTernary) {
            if (node.type === "ConditionalExpression") {
                return isValidExpression(node.consequent) && isValidExpression(node.alternate);
            }
        }
        if (allowShortCircuit) {
            if (node.type === "LogicalExpression") {
                return isValidExpression(node.right);
            }
        }

        return /^(?:Assignment|Call|New|Update|Yield)Expression$/.test(node.type) ||
            (node.type === "UnaryExpression" && ["delete", "void"].indexOf(node.operator) >= 0);
    }

    return {
        "ExpressionStatement": function(node) {
            if (!isValidExpression(node.expression) && !isDirective(node, context.getAncestors())) {
                context.report(node, "Expected an assignment or function call and instead saw an expression.");
            }
        }
    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "allowShortCircuit": {
                "type": "boolean"
            },
            "allowTernary": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/no-unused-labels.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var scopeInfo = null;

    function enterLabeledScope(node) {
        scopeInfo = {
            label: node.label.name,
            used: false,
            upper: scopeInfo
        };
    }

    function exitLabeledScope(node) {
        if (!scopeInfo.used) {
            context.report({
                node: node.label,
                message: "'{{name}}:' is defined but never used.",
                data: node.label
            });
        }

        scopeInfo = scopeInfo.upper;
    }

    function markAsUsed(node) {
        if (!node.label) {
            return;
        }

        var label = node.label.name;
        var info = scopeInfo;
        while (info) {
            if (info.label === label) {
                info.used = true;
                break;
            }
            info = info.upper;
        }
    }

    return {
        "LabeledStatement": enterLabeledScope,
        "LabeledStatement:exit": exitLabeledScope,
        "BreakStatement": markAsUsed,
        "ContinueStatement": markAsUsed
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-unused-vars.js": [function(require,module,exports){
"use strict";

var lodash = require("lodash");

module.exports = function(context) {

    var MESSAGE = "'{{name}}' is defined but never used";

    var config = {
        vars: "all",
        args: "after-used"
    };

    var firstOption = context.options[0];

    if (firstOption) {
        if (typeof firstOption === "string") {
            config.vars = firstOption;
        } else {
            config.vars = firstOption.vars || config.vars;
            config.args = firstOption.args || config.args;

            if (firstOption.varsIgnorePattern) {
                config.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern);
            }

            if (firstOption.argsIgnorePattern) {
                config.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern);
            }
        }
    }

    function isExported(variable) {

        var definition = variable.defs[0];

        if (definition) {

            var node = definition.node;
            if (node.type === "VariableDeclarator") {
                node = node.parent;
            } else if (definition.type === "Parameter") {
                return false;
            }

            return node.parent.type.indexOf("Export") === 0;
        } else {
            return false;
        }
    }

    function isReadRef(ref) {
        return ref.isRead();
    }

    function isSelfReference(ref, nodes) {
        var scope = ref.from;

        while (scope) {
            if (nodes.indexOf(scope.block) >= 0) {
                return true;
            }

            scope = scope.upper;
        }

        return false;
    }

    function isUsedVariable(variable) {
        var functionNodes = variable.defs.filter(function(def) {
                return def.type === "FunctionName";
            }).map(function(def) {
                return def.node;
            }),
            isFunctionDefinition = functionNodes.length > 0;

        return variable.references.some(function(ref) {
            return isReadRef(ref) && !(isFunctionDefinition && isSelfReference(ref, functionNodes));
        });
    }

    function collectUnusedVariables(scope, unusedVars) {
        var variables = scope.variables;
        var childScopes = scope.childScopes;
        var i, l;

        if (scope.type !== "TDZ" && (scope.type !== "global" || config.vars === "all")) {
            for (i = 0, l = variables.length; i < l; ++i) {
                var variable = variables[i];

                if (scope.type === "class" && scope.block.id === variable.identifiers[0]) {
                    continue;
                }
                if (scope.functionExpressionScope || variable.eslintUsed) {
                    continue;
                }
                if (scope.type === "function" && variable.name === "arguments" && variable.identifiers.length === 0) {
                    continue;
                }

                var def = variable.defs[0];
                if (def) {
                    var type = def.type;

                    if (type === "CatchClause") {
                        continue;
                    }

                    if (type === "Parameter") {
                        if (def.node.parent.type === "Property" && def.node.parent.kind === "set") {
                            continue;
                        }

                        if (config.args === "none") {
                            continue;
                        }

                        if (config.argsIgnorePattern && config.argsIgnorePattern.test(def.name.name)) {
                            continue;
                        }

                        if (config.args === "after-used" && def.index < def.node.params.length - 1) {
                            continue;
                        }
                    } else {
                        if (config.varsIgnorePattern && config.varsIgnorePattern.test(def.name.name)) {
                            continue;
                        }
                    }
                }

                if (!isUsedVariable(variable) && !isExported(variable)) {
                    unusedVars.push(variable);
                }
            }
        }

        for (i = 0, l = childScopes.length; i < l; ++i) {
            collectUnusedVariables(childScopes[i], unusedVars);
        }

        return unusedVars;
    }

    function getColumnInComment(variable, comment) {
        var namePattern = new RegExp("[\\s,]" + lodash.escapeRegExp(variable.name) + "(?:$|[\\s,:])", "g");

        namePattern.lastIndex = comment.value.indexOf("global") + 6;

        var match = namePattern.exec(comment.value);
        return match ? match.index + 1 : 0;
    }

    function getLocation(variable) {
        var comment = variable.eslintExplicitGlobalComment;
        var baseLoc = comment.loc.start;
        var column = getColumnInComment(variable, comment);
        var prefix = comment.value.slice(0, column);
        var lineInComment = (prefix.match(/\n/g) || []).length;

        if (lineInComment > 0) {
            column -= 1 + prefix.lastIndexOf("\n");
        } else {
            column += baseLoc.column + 2;
        }

        return {
            line: baseLoc.line + lineInComment,
            column: column
        };
    }

    return {
        "Program:exit": function(programNode) {
            var unusedVars = collectUnusedVariables(context.getScope(), []);

            for (var i = 0, l = unusedVars.length; i < l; ++i) {
                var unusedVar = unusedVars[i];

                if (unusedVar.eslintExplicitGlobal) {
                    context.report({
                        node: programNode,
                        loc: getLocation(unusedVar),
                        message: MESSAGE,
                        data: unusedVar
                    });
                } else if (unusedVar.defs.length > 0) {
                    context.report({
                        node: unusedVar.identifiers[0],
                        message: MESSAGE,
                        data: unusedVar
                    });
                }
            }
        }
    };

};

module.exports.schema = [
    {
        "oneOf": [
            {
                "enum": ["all", "local"]
            },
            {
                "type": "object",
                "properties": {
                    "vars": {
                        "enum": ["all", "local"]
                    },
                    "varsIgnorePattern": {
                        "type": "string"
                    },
                    "args": {
                        "enum": ["all", "after-used", "none"]
                    },
                    "argsIgnorePattern": {
                        "type": "string"
                    }
                }
            }
        ]
    }
];

},
   {"lodash":"/node_modules/lodash/lodash.js"}],

"/tmp/rules/no-use-before-define.js": [function(require,module,exports){
"use strict";

var SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/;

function parseOptions(options) {
    var functions = true;
    var classes = true;

    if (typeof options === "string") {
        functions = (options !== "nofunc");
    } else if (typeof options === "object" && options !== null) {
        functions = options.functions !== false;
        classes = options.classes !== false;
    }

    return {functions: functions, classes: classes};
}

function alwaysFalse() {
    return false;
}

function isFunction(variable) {
    return variable.defs[0].type === "FunctionName";
}

function isOuterClass(variable, reference) {
    return (
        variable.defs[0].type === "ClassName" &&
        variable.scope.variableScope !== reference.from.variableScope
    );
}

function isFunctionOrOuterClass(variable, reference) {
    return isFunction(variable, reference) || isOuterClass(variable, reference);
}

function isInRange(node, location) {
    return node && node.range[0] <= location && location <= node.range[1];
}

function isInInitializer(variable, reference) {
    if (variable.scope !== reference.from) {
        return false;
    }

    var node = variable.identifiers[0].parent;
    var location = reference.identifier.range[1];

    while (node) {
        if (node.type === "VariableDeclarator") {
            if (isInRange(node.init, location)) {
                return true;
            }
            break;
        } else if (node.type === "AssignmentPattern") {
            if (isInRange(node.right, location)) {
                return true;
            }
        } else if (SENTINEL_TYPE.test(node.type)) {
            break;
        }

        node = node.parent;
    }

    return false;
}

module.exports = function(context) {
    var options = parseOptions(context.options[0]);

    var isAllowed;
    if (options.functions && options.classes) {
        isAllowed = alwaysFalse;
    } else if (options.functions) {
        isAllowed = isOuterClass;
    } else if (options.classes) {
        isAllowed = isFunction;
    } else {
        isAllowed = isFunctionOrOuterClass;
    }

    function findVariablesInScope(scope) {
        scope.references.forEach(function(reference) {
            var variable = reference.resolved;

            if (reference.init ||
                !variable ||
                variable.identifiers.length === 0 ||
                (variable.identifiers[0].range[1] < reference.identifier.range[1] && !isInInitializer(variable, reference)) ||
                isAllowed(variable, reference)
            ) {
                return;
            }

            context.report({
                node: reference.identifier,
                message: "'{{name}}' was used before it was defined",
                data: reference.identifier
            });
        });
    }

    function findVariables() {
        var scope = context.getScope();
        findVariablesInScope(scope);
    }

    var ruleDefinition = {
        "Program:exit": function(node) {
            var scope = context.getScope(),
                ecmaFeatures = context.parserOptions.ecmaFeatures || {};

            findVariablesInScope(scope);

            if (ecmaFeatures.globalReturn || node.sourceType === "module") {
                findVariablesInScope(scope.childScopes[0]);
            }
        }
    };

    if (context.parserOptions.ecmaVersion >= 6) {
        ruleDefinition["BlockStatement:exit"] =
            ruleDefinition["SwitchStatement:exit"] = findVariables;

        ruleDefinition["ArrowFunctionExpression:exit"] = function(node) {
            if (node.body.type !== "BlockStatement") {
                findVariables(node);
            }
        };
    } else {
        ruleDefinition["FunctionExpression:exit"] =
            ruleDefinition["FunctionDeclaration:exit"] =
            ruleDefinition["ArrowFunctionExpression:exit"] = findVariables;
    }

    return ruleDefinition;
};

module.exports.schema = [
    {
        "oneOf": [
            {
                "enum": ["nofunc"]
            },
            {
                "type": "object",
                "properties": {
                    "functions": {"type": "boolean"},
                    "classes": {"type": "boolean"}
                },
                "additionalProperties": false
            }
        ]
    }
];

},
   {}],

"/tmp/rules/no-useless-call.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

function isCallOrNonVariadicApply(node) {
    return (
        node.callee.type === "MemberExpression" &&
        node.callee.property.type === "Identifier" &&
        node.callee.computed === false &&
        (
            (node.callee.property.name === "call" && node.arguments.length >= 1) ||
            (node.callee.property.name === "apply" && node.arguments.length === 2 && node.arguments[1].type === "ArrayExpression")
        )
    );
}

function equalTokens(left, right, context) {
    var tokensL = context.getTokens(left);
    var tokensR = context.getTokens(right);

    if (tokensL.length !== tokensR.length) {
        return false;
    }
    for (var i = 0; i < tokensL.length; ++i) {
        if (tokensL[i].type !== tokensR[i].type ||
            tokensL[i].value !== tokensR[i].value
        ) {
            return false;
        }
    }

    return true;
}

function isValidThisArg(expectedThis, thisArg, context) {
    if (!expectedThis) {
        return astUtils.isNullOrUndefined(thisArg);
    }
    return equalTokens(expectedThis, thisArg, context);
}

module.exports = function(context) {
    return {
        "CallExpression": function(node) {
            if (!isCallOrNonVariadicApply(node)) {
                return;
            }

            var applied = node.callee.object;
            var expectedThis = (applied.type === "MemberExpression") ? applied.object : null;
            var thisArg = node.arguments[0];

            if (isValidThisArg(expectedThis, thisArg, context)) {
                context.report(
                    node,
                    "unnecessary '.{{name}}()'.",
                    {name: node.callee.property.name});
            }
        }
    };
};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-useless-concat.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

function isConcatenation(node) {
    return node.type === "BinaryExpression" && node.operator === "+";
}

function getLeft(node) {
    var left = node.left;
    while (isConcatenation(left)) {
        left = left.right;
    }
    return left;
}

function getRight(node) {
    var right = node.right;
    while (isConcatenation(right)) {
        right = right.left;
    }
    return right;
}

module.exports = function(context) {
    return {
        BinaryExpression: function(node) {
            if (node.operator !== "+") {
                return;
            }

            var left = getLeft(node);
            var right = getRight(node);

            if (astUtils.isStringLiteral(left) &&
                astUtils.isStringLiteral(right) &&
                astUtils.isTokenOnSameLine(left, right)
            ) {
                var operatorToken = context.getTokenAfter(left);
                while (operatorToken.value !== "+") {
                    operatorToken = context.getTokenAfter(operatorToken);
                }

                context.report(
                    node,
                    operatorToken.loc.start,
                    "Unexpected string concatenation of literals.");
            }
        }
    };
};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-useless-constructor.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    function isRedundantSuperCall(body, ctorParams) {
        if (body.length !== 1 ||
            body[0].type !== "ExpressionStatement" ||
            body[0].expression.callee.type !== "Super") {
            return false;
        }

        var superArgs = body[0].expression.arguments;
        var firstSuperArg = superArgs[0];
        var lastSuperArgIndex = superArgs.length - 1;
        var lastSuperArg = superArgs[lastSuperArgIndex];
        var isSimpleParameterList = ctorParams.every(function(param) {
            return param.type === "Identifier" || param.type === "RestElement";
        });

        function isSameIdentifier(arg, index) {
            return (
                arg.type === "Identifier" &&
                arg.name === ctorParams[index].name
            );
        }

        var spreadsArguments =
            superArgs.length === 1 &&
            firstSuperArg.type === "SpreadElement" &&
            firstSuperArg.argument.name === "arguments";

        var passesParamsAsArgs =
            superArgs.length === ctorParams.length &&
            superArgs.every(isSameIdentifier) ||
            superArgs.length <= ctorParams.length &&
            superArgs.slice(0, -1).every(isSameIdentifier) &&
            lastSuperArg.type === "SpreadElement" &&
            ctorParams[lastSuperArgIndex].type === "RestElement" &&
            lastSuperArg.argument.name === ctorParams[lastSuperArgIndex].argument.name;

        return isSimpleParameterList && (spreadsArguments || passesParamsAsArgs);
    }

    function checkForConstructor(node) {
        if (node.kind !== "constructor") {
            return;
        }

        var body = node.value.body.body;

        if (!node.parent.parent.superClass && body.length === 0 ||
            node.parent.parent.superClass && isRedundantSuperCall(body, node.value.params)) {
            context.report(node, "Useless constructor.");
        }
    }


    return {
        "MethodDefinition": checkForConstructor
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-var.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {
        "VariableDeclaration": function(node) {
            if (node.kind === "var") {
                context.report(node, "Unexpected var, use let or const instead.");
            }
        }

    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-void.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {
        "UnaryExpression": function(node) {
            if (node.operator === "void") {
                context.report(node, "Expected 'undefined' and instead saw 'void'.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/no-warning-comments.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {

    var configuration = context.options[0] || {},
        warningTerms = configuration.terms || ["todo", "fixme", "xxx"],
        location = configuration.location || "start",
        selfConfigRegEx = /\bno-warning-comments\b/,
        warningRegExps;

    function convertToRegExp(term) {
        var escaped = term.replace(/[-\/\\$\^*+?.()|\[\]{}]/g, "\\$&"),
            suffix = /\w$/.test(term) ? "\\b" : "",
            prefix;

        if (location === "start") {
            prefix = "^\\s*";
        } else if (/^\w/.test(term)) {
            prefix = "\\b";
        } else {
            prefix = "";
        }

        return new RegExp(prefix + escaped + suffix, "i");
    }

    function commentContainsWarningTerm(comment) {
        var matches = [];

        warningRegExps.forEach(function(regex, index) {
            if (regex.test(comment)) {
                matches.push(warningTerms[index]);
            }
        });

        return matches;
    }

    function checkComment(node) {
        if (astUtils.isDirectiveComment(node) && selfConfigRegEx.test(node.value)) {
            return;
        }

        var matches = commentContainsWarningTerm(node.value);

        matches.forEach(function(matchedTerm) {
            context.report(node, "Unexpected '" + matchedTerm + "' comment.");
        });
    }

    warningRegExps = warningTerms.map(convertToRegExp);
    return {
        "BlockComment": checkComment,
        "LineComment": checkComment
    };
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "terms": {
                "type": "array",
                "items": {
                    "type": "string"
                }
            },
            "location": {
                "enum": ["start", "anywhere"]
            }
        },
        "additionalProperties": false
    }
];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-whitespace-before-property.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {
    var sourceCode = context.getSourceCode();

    function findOpeningBracket(node) {
        var token = sourceCode.getTokenBefore(node.property);

        while (token.value !== "[") {
            token = sourceCode.getTokenBefore(token);
        }
        return token;
    }

    function reportError(node) {
        context.report({
            node: node,
            message: "Unexpected whitespace before property {{propName}}.",
            data: {
                propName: sourceCode.getText(node.property)
            }
        });
    }

    return {
        MemberExpression: function(node) {
            var rightToken;
            var leftToken;

            if (!astUtils.isTokenOnSameLine(node.object, node.property)) {
                return;
            }

            if (node.computed) {
                rightToken = findOpeningBracket(node);
                leftToken = sourceCode.getTokenBefore(rightToken);
            } else {
                rightToken = sourceCode.getFirstToken(node.property);
                leftToken = sourceCode.getTokenBefore(rightToken, 1);
            }

            if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken)) {
                reportError(node);
            }
        }
    };
};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/no-with.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {
        "WithStatement": function(node) {
            context.report(node, "Unexpected use of 'with' statement.");
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/object-curly-spacing.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {
    var spaced = context.options[0] === "always",
        sourceCode = context.getSourceCode();

    function isOptionSet(option) {
        return context.options[1] ? context.options[1][option] === !spaced : false;
    }

    var options = {
        spaced: spaced,
        arraysInObjectsException: isOptionSet("arraysInObjects"),
        objectsInObjectsException: isOptionSet("objectsInObjects")
    };

    function reportNoBeginningSpace(node, token) {
        context.report({
            node: node,
            loc: token.loc.start,
            message: "There should be no space after '" + token.value + "'",
            fix: function(fixer) {
                var nextToken = context.getSourceCode().getTokenAfter(token);
                return fixer.removeRange([token.range[1], nextToken.range[0]]);
            }
        });
    }

    function reportNoEndingSpace(node, token) {
        context.report({
            node: node,
            loc: token.loc.start,
            message: "There should be no space before '" + token.value + "'",
            fix: function(fixer) {
                var previousToken = context.getSourceCode().getTokenBefore(token);
                return fixer.removeRange([previousToken.range[1], token.range[0]]);
            }
        });
    }

    function reportRequiredBeginningSpace(node, token) {
        context.report({
            node: node,
            loc: token.loc.start,
            message: "A space is required after '" + token.value + "'",
            fix: function(fixer) {
                return fixer.insertTextAfter(token, " ");
            }
        });
    }

    function reportRequiredEndingSpace(node, token) {
        context.report({
            node: node,
            loc: token.loc.start,
            message: "A space is required before '" + token.value + "'",
            fix: function(fixer) {
                return fixer.insertTextBefore(token, " ");
            }
        });
    }

    function validateBraceSpacing(node, first, second, penultimate, last) {
        var closingCurlyBraceMustBeSpaced =
            options.arraysInObjectsException && penultimate.value === "]" ||
            options.objectsInObjectsException && penultimate.value === "}"
                ? !options.spaced : options.spaced,
            firstSpaced, lastSpaced;

        if (astUtils.isTokenOnSameLine(first, second)) {
            firstSpaced = sourceCode.isSpaceBetweenTokens(first, second);
            if (options.spaced && !firstSpaced) {
                reportRequiredBeginningSpace(node, first);
            }
            if (!options.spaced && firstSpaced) {
                reportNoBeginningSpace(node, first);
            }
        }

        if (astUtils.isTokenOnSameLine(penultimate, last)) {
            lastSpaced = sourceCode.isSpaceBetweenTokens(penultimate, last);
            if (closingCurlyBraceMustBeSpaced && !lastSpaced) {
                reportRequiredEndingSpace(node, last);
            }
            if (!closingCurlyBraceMustBeSpaced && lastSpaced) {
                reportNoEndingSpace(node, last);
            }
        }
    }

    function checkForObject(node) {
        if (node.properties.length === 0) {
            return;
        }

        var first = sourceCode.getFirstToken(node),
            last = sourceCode.getLastToken(node),
            second = sourceCode.getTokenAfter(first),
            penultimate = sourceCode.getTokenBefore(last);

        validateBraceSpacing(node, first, second, penultimate, last);
    }

    function checkForImport(node) {
        if (node.specifiers.length === 0) {
            return;
        }

        var firstSpecifier = node.specifiers[0],
            lastSpecifier = node.specifiers[node.specifiers.length - 1];

        if (lastSpecifier.type !== "ImportSpecifier") {
            return;
        }
        if (firstSpecifier.type !== "ImportSpecifier") {
            firstSpecifier = node.specifiers[1];
        }

        var first = sourceCode.getTokenBefore(firstSpecifier),
            last = sourceCode.getTokenAfter(lastSpecifier);

        if (last.value === ",") {
            last = sourceCode.getTokenAfter(last);
        }

        var second = sourceCode.getTokenAfter(first),
            penultimate = sourceCode.getTokenBefore(last);

        validateBraceSpacing(node, first, second, penultimate, last);
    }

    function checkForExport(node) {
        if (node.specifiers.length === 0) {
            return;
        }

        var firstSpecifier = node.specifiers[0],
            lastSpecifier = node.specifiers[node.specifiers.length - 1],
            first = sourceCode.getTokenBefore(firstSpecifier),
            last = sourceCode.getTokenAfter(lastSpecifier);

        if (last.value === ",") {
            last = sourceCode.getTokenAfter(last);
        }

        var second = sourceCode.getTokenAfter(first),
            penultimate = sourceCode.getTokenBefore(last);

        validateBraceSpacing(node, first, second, penultimate, last);
    }

    return {
        ObjectPattern: checkForObject,

        ObjectExpression: checkForObject,

        ImportDeclaration: checkForImport,

        ExportNamedDeclaration: checkForExport
    };

};

module.exports.schema = [
    {
        "enum": ["always", "never"]
    },
    {
        "type": "object",
        "properties": {
            "arraysInObjects": {
                "type": "boolean"
            },
            "objectsInObjects": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/object-shorthand.js": [function(require,module,exports){
"use strict";

var OPTIONS = {
    always: "always",
    never: "never",
    methods: "methods",
    properties: "properties"
};

module.exports = function(context) {
    var APPLY = context.options[0] || OPTIONS.always;
    var APPLY_TO_METHODS = APPLY === OPTIONS.methods || APPLY === OPTIONS.always;
    var APPLY_TO_PROPS = APPLY === OPTIONS.properties || APPLY === OPTIONS.always;
    var APPLY_NEVER = APPLY === OPTIONS.never;

    var PARAMS = context.options[1] || {};
    var IGNORE_CONSTRUCTORS = PARAMS.ignoreConstructors;

    function isConstructor(name) {
        var firstChar = name.charAt(0);

        return firstChar === firstChar.toUpperCase();
    }

    return {
        "Property": function(node) {
            var isConciseProperty = node.method || node.shorthand,
                type;

            if (APPLY_NEVER && isConciseProperty) {
                type = node.method ? "method" : "property";
                context.report(node, "Expected longform " + type + " syntax.");
            }

            if (APPLY_NEVER || isConciseProperty) {
                return;
            }

            if (node.kind === "get" || node.kind === "set" || node.computed) {
                return;
            }

            if (node.value.type === "FunctionExpression" && !node.value.id && APPLY_TO_METHODS) {
                if (IGNORE_CONSTRUCTORS && isConstructor(node.key.name)) {
                    return;
                }

                context.report(node, "Expected method shorthand.");
            } else if (node.value.type === "Identifier" && node.key.name === node.value.name && APPLY_TO_PROPS) {

                context.report(node, "Expected property shorthand.");
            } else if (node.value.type === "Identifier" && node.key.type === "Literal" && node.key.value === node.value.name && APPLY_TO_PROPS) {

                context.report(node, "Expected property shorthand.");
            }
        }
    };

};

module.exports.schema = {
    "anyOf": [
        {
            "type": "array",
            "items": [
                {
                    "enum": ["always", "methods", "properties", "never"]
                }
            ],
            "minItems": 0,
            "maxItems": 1
        },
        {
            "type": "array",
            "items": [
                {
                    "enum": ["always", "methods"]
                },
                {
                    "type": "object",
                    "properties": {
                        "ignoreConstructors": {
                            "type": "boolean"
                        }
                    },
                    "additionalProperties": false
                }
            ],
            "minItems": 0,
            "maxItems": 2
        }
    ]
};

},
   {}],

"/tmp/rules/one-var-declaration-per-line.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var ERROR_MESSAGE = "Expected variable declaration to be on a new line.";
    var always = context.options[0] === "always";


    function isForTypeSpecifier(keyword) {
        return keyword === "ForStatement" || keyword === "ForInStatement" || keyword === "ForOfStatement";
    }

    function checkForNewLine(node) {
        if (isForTypeSpecifier(node.parent.type)) {
            return;
        }

        var declarations = node.declarations;
        var prev;
        declarations.forEach(function(current) {
            if (prev && prev.loc.end.line === current.loc.start.line) {
                if (always || prev.init || current.init) {
                    context.report({
                        node: node,
                        message: ERROR_MESSAGE,
                        loc: current.loc.start
                    });
                }
            }
            prev = current;
        });
    }

    return {
        "VariableDeclaration": checkForNewLine
    };

};

module.exports.schema = [
    {
        "enum": ["always", "initializations"]
    }
];

},
   {}],

"/tmp/rules/one-var.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var MODE_ALWAYS = "always",
        MODE_NEVER = "never";

    var mode = context.options[0] || MODE_ALWAYS;

    var options = {
    };

    if (typeof mode === "string") { // simple options configuration with just a string
        options.var = { uninitialized: mode, initialized: mode};
        options.let = { uninitialized: mode, initialized: mode};
        options.const = { uninitialized: mode, initialized: mode};
    } else if (typeof mode === "object") { // options configuration is an object
        if (mode.hasOwnProperty("var") && typeof mode.var === "string") {
            options.var = { uninitialized: mode.var, initialized: mode.var};
        }
        if (mode.hasOwnProperty("let") && typeof mode.let === "string") {
            options.let = { uninitialized: mode.let, initialized: mode.let};
        }
        if (mode.hasOwnProperty("const") && typeof mode.const === "string") {
            options.const = { uninitialized: mode.const, initialized: mode.const};
        }
        if (mode.hasOwnProperty("uninitialized")) {
            if (!options.var) {
                options.var = {};
            }
            if (!options.let) {
                options.let = {};
            }
            if (!options.const) {
                options.const = {};
            }
            options.var.uninitialized = mode.uninitialized;
            options.let.uninitialized = mode.uninitialized;
            options.const.uninitialized = mode.uninitialized;
        }
        if (mode.hasOwnProperty("initialized")) {
            if (!options.var) {
                options.var = {};
            }
            if (!options.let) {
                options.let = {};
            }
            if (!options.const) {
                options.const = {};
            }
            options.var.initialized = mode.initialized;
            options.let.initialized = mode.initialized;
            options.const.initialized = mode.initialized;
        }
    }

    var functionStack = [];
    var blockStack = [];

    function startBlock() {
        blockStack.push({
            let: {initialized: false, uninitialized: false},
            const: {initialized: false, uninitialized: false}
        });
    }

    function startFunction() {
        functionStack.push({initialized: false, uninitialized: false});
        startBlock();
    }

    function endBlock() {
        blockStack.pop();
    }

    function endFunction() {
        functionStack.pop();
        endBlock();
    }

    function recordTypes(statementType, declarations, currentScope) {
        for (var i = 0; i < declarations.length; i++) {
            if (declarations[i].init === null) {
                if (options[statementType] && options[statementType].uninitialized === MODE_ALWAYS) {
                    currentScope.uninitialized = true;
                }
            } else {
                if (options[statementType] && options[statementType].initialized === MODE_ALWAYS) {
                    currentScope.initialized = true;
                }
            }
        }
    }

    function getCurrentScope(statementType) {
        var currentScope;
        if (statementType === "var") {
            currentScope = functionStack[functionStack.length - 1];
        } else if (statementType === "let") {
            currentScope = blockStack[blockStack.length - 1].let;
        } else if (statementType === "const") {
            currentScope = blockStack[blockStack.length - 1].const;
        }
        return currentScope;
    }

    function countDeclarations(declarations) {
        var counts = { uninitialized: 0, initialized: 0 };
        for (var i = 0; i < declarations.length; i++) {
            if (declarations[i].init === null) {
                counts.uninitialized++;
            } else {
                counts.initialized++;
            }
        }
        return counts;
    }

    function hasOnlyOneStatement(statementType, declarations) {

        var declarationCounts = countDeclarations(declarations);
        var currentOptions = options[statementType] || {};
        var currentScope = getCurrentScope(statementType);

        if (currentOptions.uninitialized === MODE_ALWAYS && currentOptions.initialized === MODE_ALWAYS) {
            if (currentScope.uninitialized || currentScope.initialized) {
                return false;
            }
        }

        if (declarationCounts.uninitialized > 0) {
            if (currentOptions.uninitialized === MODE_ALWAYS && currentScope.uninitialized) {
                return false;
            }
        }
        if (declarationCounts.initialized > 0) {
            if (currentOptions.initialized === MODE_ALWAYS && currentScope.initialized) {
                return false;
            }
        }
        recordTypes(statementType, declarations, currentScope);
        return true;
    }


    return {
        "Program": startFunction,
        "FunctionDeclaration": startFunction,
        "FunctionExpression": startFunction,
        "ArrowFunctionExpression": startFunction,
        "BlockStatement": startBlock,
        "ForStatement": startBlock,
        "ForInStatement": startBlock,
        "ForOfStatement": startBlock,
        "SwitchStatement": startBlock,

        "VariableDeclaration": function(node) {
            var parent = node.parent,
                type, declarations, declarationCounts;

            type = node.kind;
            if (!options[type]) {
                return;
            }

            declarations = node.declarations;
            declarationCounts = countDeclarations(declarations);

            if (!hasOnlyOneStatement(type, declarations)) {
                if (options[type].initialized === MODE_ALWAYS && options[type].uninitialized === MODE_ALWAYS) {
                    context.report(node, "Combine this with the previous '" + type + "' statement.");
                } else {
                    if (options[type].initialized === MODE_ALWAYS) {
                        context.report(node, "Combine this with the previous '" + type + "' statement with initialized variables.");
                    }
                    if (options[type].uninitialized === MODE_ALWAYS) {
                        context.report(node, "Combine this with the previous '" + type + "' statement with uninitialized variables.");
                    }
                }
            }
            if (parent.type !== "ForStatement" || parent.init !== node) {
                var totalDeclarations = declarationCounts.uninitialized + declarationCounts.initialized;
                if (totalDeclarations > 1) {
                    if (options[type].initialized === MODE_NEVER && options[type].uninitialized === MODE_NEVER) {
                        context.report(node, "Split '" + type + "' declarations into multiple statements.");
                    } else if (options[type].initialized === MODE_NEVER && declarationCounts.initialized > 0) {
                        context.report(node, "Split initialized '" + type + "' declarations into multiple statements.");
                    } else if (options[type].uninitialized === MODE_NEVER && declarationCounts.uninitialized > 0) {
                        context.report(node, "Split uninitialized '" + type + "' declarations into multiple statements.");
                    }
                }
            }
        },

        "ForStatement:exit": endBlock,
        "ForOfStatement:exit": endBlock,
        "ForInStatement:exit": endBlock,
        "SwitchStatement:exit": endBlock,
        "BlockStatement:exit": endBlock,
        "Program:exit": endFunction,
        "FunctionDeclaration:exit": endFunction,
        "FunctionExpression:exit": endFunction,
        "ArrowFunctionExpression:exit": endFunction
    };

};

module.exports.schema = [
    {
        "oneOf": [
            {
                "enum": ["always", "never"]
            },
            {
                "type": "object",
                "properties": {
                    "var": {
                        "enum": ["always", "never"]
                    },
                    "let": {
                        "enum": ["always", "never"]
                    },
                    "const": {
                        "enum": ["always", "never"]
                    }
                },
                "additionalProperties": false
            },
            {
                "type": "object",
                "properties": {
                    "initialized": {
                        "enum": ["always", "never"]
                    },
                    "uninitialized": {
                        "enum": ["always", "never"]
                    }
                },
                "additionalProperties": false
            }
        ]
    }
];

},
   {}],

"/tmp/rules/operator-assignment.js": [function(require,module,exports){
"use strict";

function isCommutativeOperatorWithShorthand(operator) {
    return ["*", "&", "^", "|"].indexOf(operator) >= 0;
}

function isNonCommutativeOperatorWithShorthand(operator) {
    return ["+", "-", "/", "%", "<<", ">>", ">>>"].indexOf(operator) >= 0;
}

function same(a, b) {
    if (a.type !== b.type) {
        return false;
    }

    switch (a.type) {
        case "Identifier":
            return a.name === b.name;
        case "Literal":
            return a.value === b.value;
        case "MemberExpression":
            return same(a.object, b.object) && same(a.property, b.property);
        default:
            return false;
    }
}

module.exports = function(context) {

    function verify(node) {
        var expr, left, operator;

        if (node.operator !== "=" || node.right.type !== "BinaryExpression") {
            return;
        }

        left = node.left;
        expr = node.right;
        operator = expr.operator;

        if (isCommutativeOperatorWithShorthand(operator)) {
            if (same(left, expr.left) || same(left, expr.right)) {
                context.report(node, "Assignment can be replaced with operator assignment.");
            }
        } else if (isNonCommutativeOperatorWithShorthand(operator)) {
            if (same(left, expr.left)) {
                context.report(node, "Assignment can be replaced with operator assignment.");
            }
        }
    }

    function prohibit(node) {
        if (node.operator !== "=") {
            context.report(node, "Unexpected operator assignment shorthand.");
        }
    }

    return {
        "AssignmentExpression": context.options[0] !== "never" ? verify : prohibit
    };

};

module.exports.schema = [
    {
        "enum": ["always", "never"]
    }
];

},
   {}],

"/tmp/rules/operator-linebreak.js": [function(require,module,exports){
"use strict";

var lodash = require("lodash"),
    astUtils = require("../ast-utils");

module.exports = function(context) {

    var usedDefaultGlobal = !context.options[0];
    var globalStyle = context.options[0] || "after";
    var options = context.options[1] || {};
    var styleOverrides = options.overrides ? lodash.assign({}, options.overrides) : {};

    if (usedDefaultGlobal && !styleOverrides["?"]) {
        styleOverrides["?"] = "before";
    }

    if (usedDefaultGlobal && !styleOverrides[":"]) {
        styleOverrides[":"] = "before";
    }

    function validateNode(node, leftSide) {
        var leftToken = context.getLastToken(leftSide);
        var operatorToken = context.getTokenAfter(leftToken);

        while (operatorToken.value === ")") {
            leftToken = operatorToken;
            operatorToken = context.getTokenAfter(operatorToken);
        }

        var rightToken = context.getTokenAfter(operatorToken);
        var operator = operatorToken.value;
        var operatorStyleOverride = styleOverrides[operator];
        var style = operatorStyleOverride || globalStyle;

        if (astUtils.isTokenOnSameLine(leftToken, operatorToken) &&
                astUtils.isTokenOnSameLine(operatorToken, rightToken)) {

            return;

        } else if (operatorStyleOverride !== "ignore" && !astUtils.isTokenOnSameLine(leftToken, operatorToken) &&
                !astUtils.isTokenOnSameLine(operatorToken, rightToken)) {

            context.report(node, {
                line: operatorToken.loc.end.line,
                column: operatorToken.loc.end.column
            }, "Bad line breaking before and after '" + operator + "'.");

        } else if (style === "before" && astUtils.isTokenOnSameLine(leftToken, operatorToken)) {

            context.report(node, {
                line: operatorToken.loc.end.line,
                column: operatorToken.loc.end.column
            }, "'" + operator + "' should be placed at the beginning of the line.");

        } else if (style === "after" && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {

            context.report(node, {
                line: operatorToken.loc.end.line,
                column: operatorToken.loc.end.column
            }, "'" + operator + "' should be placed at the end of the line.");

        } else if (style === "none") {

            context.report(node, {
                line: operatorToken.loc.end.line,
                column: operatorToken.loc.end.column
            }, "There should be no line break before or after '" + operator + "'");

        }
    }

    function validateBinaryExpression(node) {
        validateNode(node, node.left);
    }

    return {
        "BinaryExpression": validateBinaryExpression,
        "LogicalExpression": validateBinaryExpression,
        "AssignmentExpression": validateBinaryExpression,
        "VariableDeclarator": function(node) {
            if (node.init) {
                validateNode(node, node.id);
            }
        },
        "ConditionalExpression": function(node) {
            validateNode(node, node.test);
            validateNode(node, node.consequent);
        }
    };
};

module.exports.schema = [
    {
        "enum": ["after", "before", "none", null]
    },
    {
        "type": "object",
        "properties": {
            "overrides": {
                "type": "object",
                "properties": {
                    "anyOf": {
                        "type": "string",
                        "enum": ["after", "before", "none", "ignore"]
                    }
                }
            }
        },
        "additionalProperties": false
    }
];

},
   {"../ast-utils":"/tmp/ast-utils.js","lodash":"/node_modules/lodash/lodash.js"}],

"/tmp/rules/padded-blocks.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var options = {};
    var config = context.options[0] || "always";

    if (typeof config === "string") {
        options.blocks = config === "always";
    } else {
        if (config.hasOwnProperty("blocks")) {
            options.blocks = config.blocks === "always";
        }
        if (config.hasOwnProperty("switches")) {
            options.switches = config.switches === "always";
        }
        if (config.hasOwnProperty("classes")) {
            options.classes = config.classes === "always";
        }
    }

    var ALWAYS_MESSAGE = "Block must be padded by blank lines.",
        NEVER_MESSAGE = "Block must not be padded by blank lines.";

    var sourceCode = context.getSourceCode();

    function getOpenBrace(node) {
        if (node.type === "SwitchStatement") {
            return sourceCode.getTokenBefore(node.cases[0]);
        }
        return sourceCode.getFirstToken(node);
    }

    function isComment(node) {
        return node.type === "Line" || node.type === "Block";
    }

    function isTokenTopPadded(token) {
        var tokenStartLine = token.loc.start.line,
            expectedFirstLine = tokenStartLine + 2,
            first,
            firstLine;

        first = token;
        do {
            first = sourceCode.getTokenOrCommentAfter(first);
        } while (isComment(first) && first.loc.start.line === tokenStartLine);

        firstLine = first.loc.start.line;
        return expectedFirstLine <= firstLine;
    }

    function isTokenBottomPadded(token) {
        var blockEnd = token.loc.end.line,
            expectedLastLine = blockEnd - 2,
            last,
            lastLine;

        last = token;
        do {
            last = sourceCode.getTokenOrCommentBefore(last);
        } while (isComment(last) && last.loc.end.line === blockEnd);

        lastLine = last.loc.end.line;
        return lastLine <= expectedLastLine;
    }

    function requirePaddingFor(node) {
        switch (node.type) {
            case "BlockStatement":
                return options.blocks;
            case "SwitchStatement":
                return options.switches;
            case "ClassBody":
                return options.classes;
            default:
                throw new Error("unreachable");
        }
    }

    function checkPadding(node) {
        var openBrace = getOpenBrace(node),
            closeBrace = sourceCode.getLastToken(node),
            blockHasTopPadding = isTokenTopPadded(openBrace),
            blockHasBottomPadding = isTokenBottomPadded(closeBrace);

        if (requirePaddingFor(node)) {
            if (!blockHasTopPadding) {
                context.report({
                    node: node,
                    loc: { line: openBrace.loc.start.line, column: openBrace.loc.start.column },
                    message: ALWAYS_MESSAGE
                });
            }
            if (!blockHasBottomPadding) {
                context.report({
                    node: node,
                    loc: {line: closeBrace.loc.end.line, column: closeBrace.loc.end.column - 1 },
                    message: ALWAYS_MESSAGE
                });
            }
        } else {
            if (blockHasTopPadding) {
                context.report({
                    node: node,
                    loc: { line: openBrace.loc.start.line, column: openBrace.loc.start.column },
                    message: NEVER_MESSAGE
                });
            }

            if (blockHasBottomPadding) {
                context.report({
                    node: node,
                    loc: {line: closeBrace.loc.end.line, column: closeBrace.loc.end.column - 1 },
                    message: NEVER_MESSAGE
                });
            }
        }
    }

    var rule = {};
    if (options.hasOwnProperty("switches")) {
        rule.SwitchStatement = function(node) {
            if (node.cases.length === 0) {
                return;
            }
            checkPadding(node);
        };
    }

    if (options.hasOwnProperty("blocks")) {
        rule.BlockStatement = function(node) {
            if (node.body.length === 0) {
                return;
            }
            checkPadding(node);
        };
    }

    if (options.hasOwnProperty("classes")) {
        rule.ClassBody = function(node) {
            if (node.body.length === 0) {
                return;
            }
            checkPadding(node);
        };
    }

    return rule;
};

module.exports.schema = [
    {
        "oneOf": [
            {
                "enum": ["always", "never"]
            },
            {
                "type": "object",
                "properties": {
                    "blocks": {
                        "enum": ["always", "never"]
                    },
                    "switches": {
                        "enum": ["always", "never"]
                    },
                    "classes": {
                        "enum": ["always", "never"]
                    }
                },
                "additionalProperties": false,
                "minProperties": 1
            }
        ]
    }
];

},
   {}],

"/tmp/rules/prefer-arrow-callback.js": [function(require,module,exports){
"use strict";

function isFunctionName(variable) {
    return variable && variable.defs[0].type === "FunctionName";
}

function checkMetaProperty(node, metaName, propertyName) {
    if (typeof node.meta === "string") {
        return node.meta === metaName && node.property === propertyName;
    }
    return node.meta.name === metaName && node.property.name === propertyName;
}

function getVariableOfArguments(scope) {
    var variables = scope.variables;
    for (var i = 0; i < variables.length; ++i) {
        var variable = variables[i];
        if (variable.name === "arguments") {
            return (variable.identifiers.length === 0) ? variable : null;
        }
    }

    return null;
}

function getCallbackInfo(node) {
    var retv = {isCallback: false, isLexicalThis: false};
    var parent = node.parent;
    while (node) {
        switch (parent.type) {
            case "LogicalExpression":
            case "ConditionalExpression":
                break;

            case "MemberExpression":
                if (parent.object === node &&
                    !parent.property.computed &&
                    parent.property.type === "Identifier" &&
                    parent.property.name === "bind" &&
                    parent.parent.type === "CallExpression" &&
                    parent.parent.callee === parent
                ) {
                    retv.isLexicalThis = (
                        parent.parent.arguments.length === 1 &&
                        parent.parent.arguments[0].type === "ThisExpression"
                    );
                    node = parent;
                    parent = parent.parent;
                } else {
                    return retv;
                }
                break;

            case "CallExpression":
            case "NewExpression":
                if (parent.callee !== node) {
                    retv.isCallback = true;
                }
                return retv;

            default:
                return retv;
        }

        node = parent;
        parent = parent.parent;
    }

    throw new Error("unreachable");
}

module.exports = function(context) {
    var stack = [];

    function enterScope() {
        stack.push({this: false, super: false, meta: false});
    }

    function exitScope() {
        return stack.pop();
    }

    return {
        Program: function() {
            stack = [];
        },

        ThisExpression: function() {
            var info = stack[stack.length - 1];
            if (info) {
                info.this = true;
            }
        },
        Super: function() {
            var info = stack[stack.length - 1];
            if (info) {
                info.super = true;
            }
        },
        MetaProperty: function(node) {
            var info = stack[stack.length - 1];
            if (info && checkMetaProperty(node, "new", "target")) {
                info.meta = true;
            }
        },

        FunctionDeclaration: enterScope,
        "FunctionDeclaration:exit": exitScope,

        FunctionExpression: enterScope,
        "FunctionExpression:exit": function(node) {
            var scopeInfo = exitScope();

            if (node.generator) {
                return;
            }

            var nameVar = context.getDeclaredVariables(node)[0];
            if (isFunctionName(nameVar) && nameVar.references.length > 0) {
                return;
            }

            var variable = getVariableOfArguments(context.getScope());
            if (variable && variable.references.length > 0) {
                return;
            }

            var callbackInfo = getCallbackInfo(node);
            if (callbackInfo.isCallback &&
                (!scopeInfo.this || callbackInfo.isLexicalThis) &&
                !scopeInfo.super &&
                !scopeInfo.meta
            ) {
                context.report(node, "Unexpected function expression.");
            }
        }
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/prefer-const.js": [function(require,module,exports){
"use strict";

var LOOP_TYPES = /^(?:While|DoWhile|For|ForIn|ForOf)Statement$/;
var FOR_IN_OF_TYPES = /^For(?:In|Of)Statement$/;
var SENTINEL_TYPES = /(?:Declaration|Statement)$/;
var END_POSITION_TYPES = /^(?:Assignment|Update)/;

function getWriteReferenceIfOnce(variable) {
    var retv = null;

    var references = variable.references;
    for (var i = 0; i < references.length; ++i) {
        var reference = references[i];

        if (reference.isWrite()) {
            if (retv && !(retv.init && reference.init)) {
                return null;
            }
            retv = reference;
        }
    }

    return retv;
}

function isInLoopHead(reference) {
    var node = reference.identifier;
    var parent = node.parent;
    var assignment = false;

    while (parent) {
        if (LOOP_TYPES.test(parent.type)) {
            return true;
        }

        if (assignment &&
            parent.type === "VariableDeclaration" &&
            FOR_IN_OF_TYPES.test(parent.parent.type) &&
            parent.parent.left === parent
        ) {
            return true;
        }
        if (parent.type === "AssignmentPattern") {
            assignment = true;
        }

        if (SENTINEL_TYPES.test(parent.type)) {
            break;
        }

        node = parent;
        parent = parent.parent;
    }

    return false;
}

function getEndPosition(writer) {
    var node = writer.identifier;
    var end = node.range[1];

    while ((node = node.parent)) {
        if (END_POSITION_TYPES.test(node.type)) {
            end = node.range[1];
        }
        if (SENTINEL_TYPES.test(node.type)) {
            break;
        }
    }

    return end;
}

function isInScope(writer) {
    var start = getEndPosition(writer);
    var end = writer.from.block.range[1];

    return function(reference) {
        if (!reference.isRead()) {
            return true;
        }

        var range = reference.identifier.range;
        return start <= range[0] && range[1] <= end;
    };
}

module.exports = function(context) {

    function checkForVariables(scope) {
        if (scope.type === "TDZ") {
            return;
        }

        var variables = scope.variables;
        for (var i = 0; i < variables.length; ++i) {
            var variable = variables[i];
            var def = variable.defs[0];
            var declaration = def && def.parent;
            var statement = declaration && declaration.parent;
            var references = variable.references;
            var identifier = variable.identifiers[0];

            if (!declaration ||
                declaration.type !== "VariableDeclaration" ||
                declaration.kind !== "let" ||
                (statement.type === "ForStatement" && statement.init === declaration)
            ) {
                continue;
            }

            var writer = getWriteReferenceIfOnce(variable);
            if (writer &&
                !(variable.eslintUsed && variable.scope !== writer.from) &&
                !isInLoopHead(writer) &&
                references.every(isInScope(writer))
            ) {
                context.report({
                    node: identifier,
                    message: "'{{name}}' is never reassigned, use 'const' instead.",
                    data: identifier
                });
            }
        }
    }

    var pushAll = Function.apply.bind(Array.prototype.push);

    return {
        "Program:exit": function() {
            var stack = [context.getScope()];
            while (stack.length) {
                var scope = stack.pop();
                pushAll(stack, scope.childScopes);

                checkForVariables(scope);
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/prefer-reflect.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var existingNames = {
        "apply": "Function.prototype.apply",
        "call": "Function.prototype.call",
        "defineProperty": "Object.defineProperty",
        "getOwnPropertyDescriptor": "Object.getOwnPropertyDescriptor",
        "getPrototypeOf": "Object.getPrototypeOf",
        "setPrototypeOf": "Object.setPrototypeOf",
        "isExtensible": "Object.isExtensible",
        "getOwnPropertyNames": "Object.getOwnPropertyNames",
        "preventExtensions": "Object.preventExtensions"
    };

    var reflectSubsitutes = {
        "apply": "Reflect.apply",
        "call": "Reflect.apply",
        "defineProperty": "Reflect.defineProperty",
        "getOwnPropertyDescriptor": "Reflect.getOwnPropertyDescriptor",
        "getPrototypeOf": "Reflect.getPrototypeOf",
        "setPrototypeOf": "Reflect.setPrototypeOf",
        "isExtensible": "Reflect.isExtensible",
        "getOwnPropertyNames": "Reflect.getOwnPropertyNames",
        "preventExtensions": "Reflect.preventExtensions"
    };

    var exceptions = (context.options[0] || {}).exceptions || [];

    function report(node, existing, substitute) {
        context.report(node, "Avoid using {{existing}}, instead use {{substitute}}", {
            existing: existing,
            substitute: substitute
        });
    }

    return {
        "CallExpression": function(node) {
            var methodName = (node.callee.property || {}).name;
            var isReflectCall = (node.callee.object || {}).name === "Reflect";
            var hasReflectSubsitute = reflectSubsitutes.hasOwnProperty(methodName);
            var userConfiguredException = exceptions.indexOf(methodName) !== -1;
            if (hasReflectSubsitute && !isReflectCall && !userConfiguredException) {
                report(node, existingNames[methodName], reflectSubsitutes[methodName]);
            }
        },
        "UnaryExpression": function(node) {
            var isDeleteOperator = node.operator === "delete";
            var targetsIdentifier = node.argument.type === "Identifier";
            var userConfiguredException = exceptions.indexOf("delete") !== -1;
            if (isDeleteOperator && !targetsIdentifier && !userConfiguredException) {
                report(node, "the delete keyword", "Reflect.deleteProperty");
            }
        }
    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "exceptions": {
                "type": "array",
                "items": {
                    "enum": [
                        "apply",
                        "call",
                        "delete",
                        "defineProperty",
                        "getOwnPropertyDescriptor",
                        "getPrototypeOf",
                        "setPrototypeOf",
                        "isExtensible",
                        "getOwnPropertyNames",
                        "preventExtensions"
                    ]
                },
                "uniqueItems": true
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/prefer-rest-params.js": [function(require,module,exports){
"use strict";

function getVariableOfArguments(scope) {
    var variables = scope.variables;
    for (var i = 0; i < variables.length; ++i) {
        var variable = variables[i];
        if (variable.name === "arguments") {
            return (variable.identifiers.length === 0) ? variable : null;
        }
    }

    return null;
}

module.exports = function(context) {

    function report(reference) {
        context.report({
            node: reference.identifier,
            message: "Use the rest parameters instead of 'arguments'."
        });
    }

    function checkForArguments() {
        var argumentsVar = getVariableOfArguments(context.getScope());
        if (argumentsVar) {
            argumentsVar.references.forEach(report);
        }
    }

    return {
        FunctionDeclaration: checkForArguments,
        FunctionExpression: checkForArguments
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/prefer-spread.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

function isVariadicApplyCalling(node) {
    return (
        node.callee.type === "MemberExpression" &&
        node.callee.property.type === "Identifier" &&
        node.callee.property.name === "apply" &&
        node.callee.computed === false &&
        node.arguments.length === 2 &&
        node.arguments[1].type !== "ArrayExpression"
    );
}

function equalTokens(left, right, context) {
    var tokensL = context.getTokens(left);
    var tokensR = context.getTokens(right);

    if (tokensL.length !== tokensR.length) {
        return false;
    }
    for (var i = 0; i < tokensL.length; ++i) {
        if (tokensL[i].type !== tokensR[i].type ||
            tokensL[i].value !== tokensR[i].value
        ) {
            return false;
        }
    }

    return true;
}

function isValidThisArg(expectedThis, thisArg, context) {
    if (!expectedThis) {
        return astUtils.isNullOrUndefined(thisArg);
    }
    return equalTokens(expectedThis, thisArg, context);
}

module.exports = function(context) {
    return {
        "CallExpression": function(node) {
            if (!isVariadicApplyCalling(node)) {
                return;
            }

            var applied = node.callee.object;
            var expectedThis = (applied.type === "MemberExpression") ? applied.object : null;
            var thisArg = node.arguments[0];

            if (isValidThisArg(expectedThis, thisArg, context)) {
                context.report(node, "use the spread operator instead of the '.apply()'.");
            }
        }
    };
};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/prefer-template.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

function isConcatenation(node) {
    return node.type === "BinaryExpression" && node.operator === "+";
}

function getTopConcatBinaryExpression(node) {
    while (isConcatenation(node.parent)) {
        node = node.parent;
    }
    return node;
}

function hasNonStringLiteral(node) {
    if (isConcatenation(node)) {
        return hasNonStringLiteral(node.right) || hasNonStringLiteral(node.left);
    }
    return !astUtils.isStringLiteral(node);
}

module.exports = function(context) {
    var done = Object.create(null);

    function checkForStringConcat(node) {
        if (!astUtils.isStringLiteral(node) || !isConcatenation(node.parent)) {
            return;
        }

        var topBinaryExpr = getTopConcatBinaryExpression(node.parent);

        if (done[topBinaryExpr.range[0]]) {
            return;
        }
        done[topBinaryExpr.range[0]] = true;

        if (hasNonStringLiteral(topBinaryExpr)) {
            context.report(
                topBinaryExpr,
                "Unexpected string concatenation.");
        }
    }

    return {
        Program: function() {
            done = Object.create(null);
        },

        Literal: checkForStringConcat,
        TemplateLiteral: checkForStringConcat
    };
};

module.exports.schema = [];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/quote-props.js": [function(require,module,exports){
"use strict";

var espree = require("espree"),
    keywords = require("../util/keywords");

module.exports = function(context) {

    var MODE = context.options[0],
        KEYWORDS = context.options[1] && context.options[1].keywords,
        CHECK_UNNECESSARY = !context.options[1] || context.options[1].unnecessary !== false,
        NUMBERS = context.options[1] && context.options[1].numbers,

        MESSAGE_UNNECESSARY = "Unnecessarily quoted property '{{property}}' found.",
        MESSAGE_UNQUOTED = "Unquoted property '{{property}}' found.",
        MESSAGE_NUMERIC = "Unquoted number literal '{{property}}' used as key.",
        MESSAGE_RESERVED = "Unquoted reserved word '{{property}}' used as key.";


    function isKeyword(tokenStr) {
        return keywords.indexOf(tokenStr) >= 0;
    }

    function areQuotesRedundant(tokens, skipNumberLiterals) {
        return tokens.length === 1 &&
            (["Identifier", "Keyword", "Null", "Boolean"].indexOf(tokens[0].type) >= 0 ||
            (tokens[0].type === "Numeric" && !skipNumberLiterals && "" + +tokens[0].value === tokens[0].value));
    }

    function checkUnnecessaryQuotes(node) {
        var key = node.key,
            isKeywordToken,
            tokens;

        if (node.method || node.computed || node.shorthand) {
            return;
        }

        if (key.type === "Literal" && typeof key.value === "string") {
            try {
                tokens = espree.tokenize(key.value);
            } catch (e) {
                return;
            }

            if (tokens.length !== 1) {
                return;
            }

            isKeywordToken = isKeyword(tokens[0].value);

            if (isKeywordToken && KEYWORDS) {
                return;
            }

            if (CHECK_UNNECESSARY && areQuotesRedundant(tokens, NUMBERS)) {
                context.report(node, MESSAGE_UNNECESSARY, {property: key.value});
            }
        } else if (KEYWORDS && key.type === "Identifier" && isKeyword(key.name)) {
            context.report(node, MESSAGE_RESERVED, {property: key.name});
        } else if (NUMBERS && key.type === "Literal" && typeof key.value === "number") {
            context.report(node, MESSAGE_NUMERIC, {property: key.value});
        }
    }

    function checkOmittedQuotes(node) {
        var key = node.key;

        if (!node.method && !node.computed && !node.shorthand && !(key.type === "Literal" && typeof key.value === "string")) {
            context.report(node, MESSAGE_UNQUOTED, {
                property: key.name || key.value
            });
        }
    }

    function checkConsistency(node, checkQuotesRedundancy) {
        var quotes = false,
            lackOfQuotes = false,
            necessaryQuotes = false;

        node.properties.forEach(function(property) {
            var key = property.key,
                tokens;

            if (!key || property.method || property.computed || property.shorthand) {
                return;
            }

            if (key.type === "Literal" && typeof key.value === "string") {

                quotes = true;

                if (checkQuotesRedundancy) {
                    try {
                        tokens = espree.tokenize(key.value);
                    } catch (e) {
                        necessaryQuotes = true;
                        return;
                    }

                    necessaryQuotes = necessaryQuotes || !areQuotesRedundant(tokens) || KEYWORDS && isKeyword(tokens[0].value);
                }
            } else if (KEYWORDS && checkQuotesRedundancy && key.type === "Identifier" && isKeyword(key.name)) {
                necessaryQuotes = true;
                context.report(node, "Properties should be quoted as '{{property}}' is a reserved word.", {property: key.name});
            } else {
                lackOfQuotes = true;
            }

            if (quotes && lackOfQuotes) {
                context.report(node, "Inconsistently quoted property '{{key}}' found.", {
                    key: key.name || key.value
                });
            }
        });

        if (checkQuotesRedundancy && quotes && !necessaryQuotes) {
            context.report(node, "Properties shouldn't be quoted as all quotes are redundant.");
        }
    }

    return {
        "Property": function(node) {
            if (MODE === "always" || !MODE) {
                checkOmittedQuotes(node);
            }
            if (MODE === "as-needed") {
                checkUnnecessaryQuotes(node);
            }
        },
        "ObjectExpression": function(node) {
            if (MODE === "consistent") {
                checkConsistency(node, false);
            }
            if (MODE === "consistent-as-needed") {
                checkConsistency(node, true);
            }
        }
    };

};

module.exports.schema = {
    "anyOf": [
        {
            "type": "array",
            "items": [
                {
                    "enum": ["always", "as-needed", "consistent", "consistent-as-needed"]
                }
            ],
            "minItems": 0,
            "maxItems": 1
        },
        {
            "type": "array",
            "items": [
                {
                    "enum": ["always", "as-needed", "consistent", "consistent-as-needed"]
                },
                {
                    "type": "object",
                    "properties": {
                        "keywords": {
                            "type": "boolean"
                        },
                        "unnecessary": {
                            "type": "boolean"
                        },
                        "numbers": {
                            "type": "boolean"
                        }
                    },
                    "additionalProperties": false
                }
            ],
            "minItems": 0,
            "maxItems": 2
        }
    ]
};

},
   {"../util/keywords":"/tmp/util/keywords.js","espree":"espree"}],

"/tmp/rules/quotes.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

var QUOTE_SETTINGS = {
    "double": {
        quote: "\"",
        alternateQuote: "'",
        description: "doublequote"
    },
    "single": {
        quote: "'",
        alternateQuote: "\"",
        description: "singlequote"
    },
    "backtick": {
        quote: "`",
        alternateQuote: "\"",
        description: "backtick"
    }
};
QUOTE_SETTINGS.double.convert =
QUOTE_SETTINGS.single.convert =
QUOTE_SETTINGS.backtick.convert = function(str) {
    var newQuote = this.quote;
    var oldQuote = str[0];
    if (newQuote === oldQuote) {
        return str;
    }
    return newQuote + str.slice(1, -1).replace(/\\(\${|\r\n?|\n|.)|["'`]|\${|(\r\n?|\n)/g, function(match, escaped, newline) {
        if (escaped === oldQuote || oldQuote === "`" && escaped === "${") {
            return escaped; // unescape
        }
        if (match === newQuote || newQuote === "`" && match === "${") {
            return "\\" + match; // escape
        }
        if (newline && oldQuote === "`") {
            return "\\n"; // escape newlines
        }
        return match;
    }) + newQuote;
};

var AVOID_ESCAPE = "avoid-escape",
    FUNCTION_TYPE = /^(?:Arrow)?Function(?:Declaration|Expression)$/;

module.exports = function(context) {

    var quoteOption = context.options[0],
        settings = QUOTE_SETTINGS[quoteOption || "double"],
        avoidEscape = context.options[1] === AVOID_ESCAPE,
        sourceCode = context.getSourceCode();

    function isJSXElement(node) {
        return node.type.indexOf("JSX") === 0;
    }

    function isDirective(node) {
        return (
            node.type === "ExpressionStatement" &&
            node.expression.type === "Literal" &&
            typeof node.expression.value === "string"
        );
    }

    function isPartOfDirectivePrologue(node) {
        var block = node.parent.parent;
        if (block.type !== "Program" && (block.type !== "BlockStatement" || !FUNCTION_TYPE.test(block.parent.type))) {
            return false;
        }

        for (var i = 0; i < block.body.length; ++i) {
            var statement = block.body[i];

            if (statement === node.parent) {
                return true;
            }
            if (!isDirective(statement)) {
                break;
            }
        }

        return false;
    }

    function isAllowedAsNonBacktick(node) {
        var parent = node.parent;

        switch (parent.type) {
            case "ExpressionStatement":
                return isPartOfDirectivePrologue(node);

            case "Property":
                return parent.key === node && !parent.computed;

            case "ImportDeclaration":
            case "ExportNamedDeclaration":
            case "ExportAllDeclaration":
                return parent.source === node;

            default:
                return false;
        }
    }

    return {

        "Literal": function(node) {
            var val = node.value,
                rawVal = node.raw,
                isValid;

            if (settings && typeof val === "string") {
                isValid = (quoteOption === "backtick" && isAllowedAsNonBacktick(node)) ||
                    isJSXElement(node.parent) ||
                    astUtils.isSurroundedBy(rawVal, settings.quote);

                if (!isValid && avoidEscape) {
                    isValid = astUtils.isSurroundedBy(rawVal, settings.alternateQuote) && rawVal.indexOf(settings.quote) >= 0;
                }

                if (!isValid) {
                    context.report({
                        node: node,
                        message: "Strings must use " + settings.description + ".",
                        fix: function(fixer) {
                            return fixer.replaceText(node, settings.convert(node.raw));
                        }
                    });
                }
            }
        },

        "TemplateLiteral": function(node) {

            if (quoteOption === "backtick" || node.parent.type === "TaggedTemplateExpression") {
                return;
            }

            var shouldWarn = node.quasis.length === 1 && (node.quasis[0].value.cooked.indexOf("\n") === -1);

            if (shouldWarn) {
                context.report({
                    node: node,
                    message: "Strings must use " + settings.description + ".",
                    fix: function(fixer) {
                        return fixer.replaceText(node, settings.convert(sourceCode.getText(node)));
                    }
                });
            }
        }
    };

};

module.exports.schema = [
    {
        "enum": ["single", "double", "backtick"]
    },
    {
        "enum": ["avoid-escape"]
    }
];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/radix.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var MODE_ALWAYS = "always",
        MODE_AS_NEEDED = "as-needed";

    var mode = context.options[0] || MODE_ALWAYS;

    return {
        "CallExpression": function(node) {

            var radix;

            if (!(node.callee.name === "parseInt" || (
                    node.callee.type === "MemberExpression" &&
                    node.callee.object.name === "Number" &&
                    node.callee.property.name === "parseInt"
                )
            )) {
                return;
            }

            if (node.arguments.length === 0) {
                context.report({
                    node: node,
                    message: "Missing parameters."
                });
            } else if (node.arguments.length < 2 && mode === MODE_ALWAYS) {
                context.report({
                    node: node,
                    message: "Missing radix parameter."
                });
            } else if (node.arguments.length > 1 && mode === MODE_AS_NEEDED &&
                (node.arguments[1] && node.arguments[1].type === "Literal" &&
                    node.arguments[1].value === 10)
            ) {
                context.report({
                    node: node,
                    message: "Redundant radix parameter."
                });
            } else {

                radix = node.arguments[1];

                if (radix &&
                    ((radix.type === "Literal" && typeof radix.value !== "number") ||
                    (radix.type === "Identifier" && radix.name === "undefined"))
                ) {
                    context.report({
                        node: node,
                        message: "Invalid radix parameter."
                    });
                }
            }

        }
    };

};

module.exports.schema = [
    {
        "enum": ["always", "as-needed"]
    }
];


},
   {}],

"/tmp/rules/require-jsdoc.js": [function(require,module,exports){
"use strict";

var lodash = require("lodash");

module.exports = function(context) {
    var source = context.getSourceCode();
    var DEFAULT_OPTIONS = {
        "FunctionDeclaration": true,
        "MethodDefinition": false,
        "ClassDeclaration": false
    };
    var options = lodash.assign(DEFAULT_OPTIONS, context.options[0] && context.options[0].require || {});

    function report(node) {
        context.report(node, "Missing JSDoc comment.");
    }

    function checkClassMethodJsDoc(node) {
        if (node.parent.type === "MethodDefinition") {
            var jsdocComment = source.getJSDocComment(node);

            if (!jsdocComment) {
                report(node);
            }
        }
    }

    function checkJsDoc(node) {
        var jsdocComment = source.getJSDocComment(node);

        if (!jsdocComment) {
            report(node);
        }
    }

    return {
        "FunctionDeclaration": function(node) {
            if (options.FunctionDeclaration) {
                checkJsDoc(node);
            }
        },
        "FunctionExpression": function(node) {
            if (options.MethodDefinition) {
                checkClassMethodJsDoc(node);
            }
        },
        "ClassDeclaration": function(node) {
            if (options.ClassDeclaration) {
                checkJsDoc(node);
            }
        }
    };
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "require": {
                "type": "object",
                "properties": {
                    "ClassDeclaration": {
                        "type": "boolean"
                    },
                    "MethodDefinition": {
                        "type": "boolean"
                    },
                    "FunctionDeclaration": {
                        "type": "boolean"
                    }
                },
                "additionalProperties": false
            }
        },
        "additionalProperties": false
    }
];

},
   {"lodash":"/node_modules/lodash/lodash.js"}],

"/tmp/rules/require-yield.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var stack = [];

    function beginChecking(node) {
        if (node.generator) {
            stack.push(0);
        }
    }

    function endChecking(node) {
        if (!node.generator) {
            return;
        }

        var countYield = stack.pop();
        if (countYield === 0 && node.body.body.length > 0) {
            context.report(
                node,
                "This generator function does not have 'yield'.");
        }
    }

    return {
        "FunctionDeclaration": beginChecking,
        "FunctionDeclaration:exit": endChecking,
        "FunctionExpression": beginChecking,
        "FunctionExpression:exit": endChecking,

        "YieldExpression": function() {
            if (stack.length > 0) {
                stack[stack.length - 1] += 1;
            }
        }
    };
};

module.exports.schema = [];

},
   {}],

"/tmp/rules/semi-spacing.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {

    var config = context.options[0],
        requireSpaceBefore = false,
        requireSpaceAfter = true,
        sourceCode = context.getSourceCode();

    if (typeof config === "object") {
        if (config.hasOwnProperty("before")) {
            requireSpaceBefore = config.before;
        }
        if (config.hasOwnProperty("after")) {
            requireSpaceAfter = config.after;
        }
    }

    function hasLeadingSpace(token) {
        var tokenBefore = context.getTokenBefore(token);
        return tokenBefore && astUtils.isTokenOnSameLine(tokenBefore, token) && sourceCode.isSpaceBetweenTokens(tokenBefore, token);
    }

    function hasTrailingSpace(token) {
        var tokenAfter = context.getTokenAfter(token);
        return tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter) && sourceCode.isSpaceBetweenTokens(token, tokenAfter);
    }

    function isLastTokenInCurrentLine(token) {
        var tokenAfter = context.getTokenAfter(token);
        return !(tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter));
    }

    function isFirstTokenInCurrentLine(token) {
        var tokenBefore = context.getTokenBefore(token);
        return !(tokenBefore && astUtils.isTokenOnSameLine(token, tokenBefore));
    }

    function isBeforeClosingParen(token) {
        var nextToken = context.getTokenAfter(token);
        return (
            nextToken &&
            nextToken.type === "Punctuator" &&
            (nextToken.value === "}" || nextToken.value === ")")
        );
    }

    function isSemicolon(token) {
        return token.type === "Punctuator" && token.value === ";";
    }

    function checkSemicolonSpacing(token, node) {
        var location;

        if (isSemicolon(token)) {
            location = token.loc.start;

            if (hasLeadingSpace(token)) {
                if (!requireSpaceBefore) {
                    context.report({
                        node: node,
                        loc: location,
                        message: "Unexpected whitespace before semicolon.",
                        fix: function(fixer) {
                            var tokenBefore = context.getTokenBefore(token);
                            return fixer.removeRange([tokenBefore.range[1], token.range[0]]);
                        }
                    });
                }
            } else {
                if (requireSpaceBefore) {
                    context.report({
                        node: node,
                        loc: location,
                        message: "Missing whitespace before semicolon.",
                        fix: function(fixer) {
                            return fixer.insertTextBefore(token, " ");
                        }
                    });
                }
            }

            if (!isFirstTokenInCurrentLine(token) && !isLastTokenInCurrentLine(token) && !isBeforeClosingParen(token)) {
                if (hasTrailingSpace(token)) {
                    if (!requireSpaceAfter) {
                        context.report({
                            node: node,
                            loc: location,
                            message: "Unexpected whitespace after semicolon.",
                            fix: function(fixer) {
                                var tokenAfter = context.getTokenAfter(token);
                                return fixer.removeRange([token.range[1], tokenAfter.range[0]]);
                            }
                        });
                    }
                } else {
                    if (requireSpaceAfter) {
                        context.report({
                            node: node,
                            loc: location,
                            message: "Missing whitespace after semicolon.",
                            fix: function(fixer) {
                                return fixer.insertTextAfter(token, " ");
                            }
                        });
                    }
                }
            }
        }
    }

    function checkNode(node) {
        var token = context.getLastToken(node);
        checkSemicolonSpacing(token, node);
    }

    return {
        "VariableDeclaration": checkNode,
        "ExpressionStatement": checkNode,
        "BreakStatement": checkNode,
        "ContinueStatement": checkNode,
        "DebuggerStatement": checkNode,
        "ReturnStatement": checkNode,
        "ThrowStatement": checkNode,
        "ForStatement": function(node) {
            if (node.init) {
                checkSemicolonSpacing(context.getTokenAfter(node.init), node);
            }

            if (node.test) {
                checkSemicolonSpacing(context.getTokenAfter(node.test), node);
            }
        }
    };
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "before": {
                "type": "boolean"
            },
            "after": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/semi.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var OPT_OUT_PATTERN = /[\[\(\/\+\-]/; // One of [(/+-
    var options = context.options[1];
    var never = context.options[0] === "never",
        exceptOneLine = options && options.omitLastInOneLineBlock === true,
        sourceCode = context.getSourceCode();

    function report(node, missing) {
        var message,
            fix,
            lastToken = sourceCode.getLastToken(node),
            loc = lastToken.loc;

        if (!missing) {
            message = "Missing semicolon.";
            loc = loc.end;
            fix = function(fixer) {
                return fixer.insertTextAfter(lastToken, ";");
            };
        } else {
            message = "Extra semicolon.";
            loc = loc.start;
            fix = function(fixer) {
                return fixer.remove(lastToken);
            };
        }

        context.report({
            node: node,
            loc: loc,
            message: message,
            fix: fix
        });

    }

    function isSemicolon(token) {
        return (token.type === "Punctuator" && token.value === ";");
    }

    function isUnnecessarySemicolon(lastToken) {
        var isDivider, isOptOutToken, lastTokenLine, nextToken, nextTokenLine;

        if (!isSemicolon(lastToken)) {
            return false;
        }

        nextToken = context.getTokenAfter(lastToken);

        if (!nextToken) {
            return true;
        }

        lastTokenLine = lastToken.loc.end.line;
        nextTokenLine = nextToken.loc.start.line;
        isOptOutToken = OPT_OUT_PATTERN.test(nextToken.value);
        isDivider = (nextToken.value === "}" || nextToken.value === ";");

        return (lastTokenLine !== nextTokenLine && !isOptOutToken) || isDivider;
    }

    function isOneLinerBlock(node) {
        var nextToken = context.getTokenAfter(node);
        if (!nextToken || nextToken.value !== "}") {
            return false;
        }

        var parent = node.parent;
        return parent && parent.type === "BlockStatement" &&
          parent.loc.start.line === parent.loc.end.line;
    }

    function checkForSemicolon(node) {
        var lastToken = context.getLastToken(node);

        if (never) {
            if (isUnnecessarySemicolon(lastToken)) {
                report(node, true);
            }
        } else {
            if (!isSemicolon(lastToken)) {
                if (!exceptOneLine || !isOneLinerBlock(node)) {
                    report(node);
                }
            } else {
                if (exceptOneLine && isOneLinerBlock(node)) {
                    report(node, true);
                }
            }
        }
    }

    function checkForSemicolonForVariableDeclaration(node) {
        var ancestors = context.getAncestors(),
            parentIndex = ancestors.length - 1,
            parent = ancestors[parentIndex];

        if ((parent.type !== "ForStatement" || parent.init !== node) &&
            (!/^For(?:In|Of)Statement/.test(parent.type) || parent.left !== node)
        ) {
            checkForSemicolon(node);
        }
    }

    return {
        "VariableDeclaration": checkForSemicolonForVariableDeclaration,
        "ExpressionStatement": checkForSemicolon,
        "ReturnStatement": checkForSemicolon,
        "ThrowStatement": checkForSemicolon,
        "DoWhileStatement": checkForSemicolon,
        "DebuggerStatement": checkForSemicolon,
        "BreakStatement": checkForSemicolon,
        "ContinueStatement": checkForSemicolon,
        "ImportDeclaration": checkForSemicolon,
        "ExportAllDeclaration": checkForSemicolon,
        "ExportNamedDeclaration": function(node) {
            if (!node.declaration) {
                checkForSemicolon(node);
            }
        },
        "ExportDefaultDeclaration": function(node) {
            if (!/(?:Class|Function)Declaration/.test(node.declaration.type)) {
                checkForSemicolon(node);
            }
        }
    };

};

module.exports.schema = {
    "anyOf": [
        {
            "type": "array",
            "items": [
                {
                    "enum": ["never"]
                }
            ],
            "minItems": 0,
            "maxItems": 1
        },
        {
            "type": "array",
            "items": [
                {
                    "enum": ["always"]
                },
                {
                    "type": "object",
                    "properties": {
                        "omitLastInOneLineBlock": {"type": "boolean"}
                    },
                    "additionalProperties": false
                }
            ],
            "minItems": 0,
            "maxItems": 2
        }
    ]
};

},
   {}],

"/tmp/rules/sort-imports.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var configuration = context.options[0] || {},
        ignoreCase = configuration.ignoreCase || false,
        ignoreMemberSort = configuration.ignoreMemberSort || false,
        memberSyntaxSortOrder = configuration.memberSyntaxSortOrder || ["none", "all", "multiple", "single"],
        previousDeclaration = null;

    function usedMemberSyntax(node) {
        if (node.specifiers.length === 0) {
            return "none";
        } else if (node.specifiers[0].type === "ImportNamespaceSpecifier") {
            return "all";
        } else if (node.specifiers.length === 1) {
            return "single";
        } else {
            return "multiple";
        }
    }

    function getMemberParameterGroupIndex(node) {
        return memberSyntaxSortOrder.indexOf(usedMemberSyntax(node));
    }

    function getFirstLocalMemberName(node) {
        if (node.specifiers[0]) {
            return node.specifiers[0].local.name;
        } else {
            return null;
        }
    }

    return {
        "ImportDeclaration": function(node) {
            if (previousDeclaration) {
                var currentLocalMemberName = getFirstLocalMemberName(node),
                    currentMemberSyntaxGroupIndex = getMemberParameterGroupIndex(node),
                    previousLocalMemberName = getFirstLocalMemberName(previousDeclaration),
                    previousMemberSyntaxGroupIndex = getMemberParameterGroupIndex(previousDeclaration);

                if (ignoreCase) {
                    previousLocalMemberName = previousLocalMemberName && previousLocalMemberName.toLowerCase();
                    currentLocalMemberName = currentLocalMemberName && currentLocalMemberName.toLowerCase();
                }

                if (currentMemberSyntaxGroupIndex !== previousMemberSyntaxGroupIndex) {
                    if (currentMemberSyntaxGroupIndex < previousMemberSyntaxGroupIndex) {
                        context.report({
                            node: node,
                            message: "Expected '{{syntaxA}}' syntax before '{{syntaxB}}' syntax.",
                            data: {
                                syntaxA: memberSyntaxSortOrder[currentMemberSyntaxGroupIndex],
                                syntaxB: memberSyntaxSortOrder[previousMemberSyntaxGroupIndex]
                            }
                        });
                    }
                } else {
                    if (previousLocalMemberName &&
                        currentLocalMemberName &&
                        currentLocalMemberName < previousLocalMemberName
                    ) {
                        context.report({
                            node: node,
                            message: "Imports should be sorted alphabetically."
                        });
                    }
                }
            }

            if (!ignoreMemberSort && node.specifiers.length > 1) {
                var previousSpecifier = null;
                var previousSpecifierName = null;

                for (var i = 0; i < node.specifiers.length; ++i) {
                    var currentSpecifier = node.specifiers[i];
                    if (currentSpecifier.type !== "ImportSpecifier") {
                        continue;
                    }

                    var currentSpecifierName = currentSpecifier.local.name;
                    if (ignoreCase) {
                        currentSpecifierName = currentSpecifierName.toLowerCase();
                    }

                    if (previousSpecifier && currentSpecifierName < previousSpecifierName) {
                        context.report({
                            node: currentSpecifier,
                            message: "Member '{{memberName}}' of the import declaration should be sorted alphabetically.",
                            data: {
                                memberName: currentSpecifier.local.name
                            }
                        });
                    }

                    previousSpecifier = currentSpecifier;
                    previousSpecifierName = currentSpecifierName;
                }
            }

            previousDeclaration = node;
        }
    };
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "ignoreCase": {
                "type": "boolean"
            },
            "memberSyntaxSortOrder": {
                "type": "array",
                "items": {
                    "enum": ["none", "all", "multiple", "single"]
                },
                "uniqueItems": true,
                "minItems": 4,
                "maxItems": 4
            },
            "ignoreMemberSort": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/sort-vars.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var configuration = context.options[0] || {},
        ignoreCase = configuration.ignoreCase || false;

    return {
        "VariableDeclaration": function(node) {
            node.declarations.reduce(function(memo, decl) {
                if (decl.id.type === "ObjectPattern" || decl.id.type === "ArrayPattern") {
                    return memo;
                }

                var lastVariableName = memo.id.name,
                    currenVariableName = decl.id.name;

                if (ignoreCase) {
                    lastVariableName = lastVariableName.toLowerCase();
                    currenVariableName = currenVariableName.toLowerCase();
                }

                if (currenVariableName < lastVariableName) {
                    context.report(decl, "Variables within the same declaration block should be sorted alphabetically");
                    return memo;
                } else {
                    return decl;
                }
            }, node.declarations[0]);
        }
    };
};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "ignoreCase": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/space-before-blocks.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {
    var config = context.options[0],
        sourceCode = context.getSourceCode(),
        checkFunctions = true,
        checkKeywords = true,
        checkClasses = true;

    if (typeof config === "object") {
        checkFunctions = config.functions !== "never";
        checkKeywords = config.keywords !== "never";
        checkClasses = config.classes !== "never";
    } else if (config === "never") {
        checkFunctions = false;
        checkKeywords = false;
        checkClasses = false;
    }

    function isConflicted(token) {
        return (token.type === "Punctuator" && token.value === "=>") || token.type === "Keyword";
    }

    function checkPrecedingSpace(node) {
        var precedingToken = context.getTokenBefore(node),
            hasSpace,
            parent,
            requireSpace;

        if (precedingToken && !isConflicted(precedingToken) && astUtils.isTokenOnSameLine(precedingToken, node)) {
            hasSpace = sourceCode.isSpaceBetweenTokens(precedingToken, node);
            parent = context.getAncestors().pop();
            if (parent.type === "FunctionExpression" || parent.type === "FunctionDeclaration") {
                requireSpace = checkFunctions;
            } else if (node.type === "ClassBody") {
                requireSpace = checkClasses;
            } else {
                requireSpace = checkKeywords;
            }

            if (requireSpace) {
                if (!hasSpace) {
                    context.report({
                        node: node,
                        message: "Missing space before opening brace.",
                        fix: function(fixer) {
                            return fixer.insertTextBefore(node, " ");
                        }
                    });
                }
            } else {
                if (hasSpace) {
                    context.report({
                        node: node,
                        message: "Unexpected space before opening brace.",
                        fix: function(fixer) {
                            return fixer.removeRange([precedingToken.range[1], node.range[0]]);
                        }
                    });
                }
            }
        }
    }

    function checkSpaceBeforeCaseBlock(node) {
        var cases = node.cases,
            firstCase,
            openingBrace;

        if (cases.length > 0) {
            firstCase = cases[0];
            openingBrace = context.getTokenBefore(firstCase);
        } else {
            openingBrace = context.getLastToken(node, 1);
        }

        checkPrecedingSpace(openingBrace);
    }

    return {
        "BlockStatement": checkPrecedingSpace,
        "ClassBody": checkPrecedingSpace,
        "SwitchStatement": checkSpaceBeforeCaseBlock
    };

};

module.exports.schema = [
    {
        "oneOf": [
            {
                "enum": ["always", "never"]
            },
            {
                "type": "object",
                "properties": {
                    "keywords": {
                        "enum": ["always", "never"]
                    },
                    "functions": {
                        "enum": ["always", "never"]
                    },
                    "classes": {
                        "enum": ["always", "never"]
                    }
                },
                "additionalProperties": false
            }
        ]
    }
];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/space-before-function-paren.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var configuration = context.options[0],
        sourceCode = context.getSourceCode(),
        requireAnonymousFunctionSpacing = true,
        requireNamedFunctionSpacing = true;

    if (typeof configuration === "object") {
        requireAnonymousFunctionSpacing = configuration.anonymous !== "never";
        requireNamedFunctionSpacing = configuration.named !== "never";
    } else if (configuration === "never") {
        requireAnonymousFunctionSpacing = false;
        requireNamedFunctionSpacing = false;
    }

    function isNamedFunction(node) {
        var parent;

        if (node.id) {
            return true;
        }

        parent = node.parent;
        return parent.type === "MethodDefinition" ||
            (parent.type === "Property" &&
                (
                    parent.kind === "get" ||
                    parent.kind === "set" ||
                    parent.method
                )
            );
    }

    function validateSpacingBeforeParentheses(node) {
        var isNamed = isNamedFunction(node),
            leftToken,
            rightToken,
            location;

        if (node.generator && !isNamed) {
            return;
        }

        rightToken = sourceCode.getFirstToken(node);
        while (rightToken.value !== "(") {
            rightToken = sourceCode.getTokenAfter(rightToken);
        }
        leftToken = context.getTokenBefore(rightToken);
        location = leftToken.loc.end;

        if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken)) {
            if ((isNamed && !requireNamedFunctionSpacing) || (!isNamed && !requireAnonymousFunctionSpacing)) {
                context.report({
                    node: node,
                    loc: location,
                    message: "Unexpected space before function parentheses.",
                    fix: function(fixer) {
                        return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
                    }
                });
            }
        } else {
            if ((isNamed && requireNamedFunctionSpacing) || (!isNamed && requireAnonymousFunctionSpacing)) {
                context.report({
                    node: node,
                    loc: location,
                    message: "Missing space before function parentheses.",
                    fix: function(fixer) {
                        return fixer.insertTextAfter(leftToken, " ");
                    }
                });
            }
        }
    }

    return {
        "FunctionDeclaration": validateSpacingBeforeParentheses,
        "FunctionExpression": validateSpacingBeforeParentheses
    };
};

module.exports.schema = [
    {
        "oneOf": [
            {
                "enum": ["always", "never"]
            },
            {
                "type": "object",
                "properties": {
                    "anonymous": {
                        "enum": ["always", "never"]
                    },
                    "named": {
                        "enum": ["always", "never"]
                    }
                },
                "additionalProperties": false
            }
        ]
    }
];

},
   {}],

"/tmp/rules/space-in-parens.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

module.exports = function(context) {

    var MISSING_SPACE_MESSAGE = "There must be a space inside this paren.",
        REJECTED_SPACE_MESSAGE = "There should be no spaces inside this paren.",
        ALWAYS = context.options[0] === "always",

        exceptionsArrayOptions = (context.options.length === 2) ? context.options[1].exceptions : [],
        options = {},
        exceptions;

    if (exceptionsArrayOptions.length) {
        options.braceException = exceptionsArrayOptions.indexOf("{}") !== -1;
        options.bracketException = exceptionsArrayOptions.indexOf("[]") !== -1;
        options.parenException = exceptionsArrayOptions.indexOf("()") !== -1;
        options.empty = exceptionsArrayOptions.indexOf("empty") !== -1;
    }

    function getExceptions() {
        var openers = [],
            closers = [];
        if (options.braceException) {
            openers.push("{");
            closers.push("}");
        }

        if (options.bracketException) {
            openers.push("[");
            closers.push("]");
        }

        if (options.parenException) {
            openers.push("(");
            closers.push(")");
        }

        if (options.empty) {
            openers.push(")");
            closers.push("(");
        }

        return {
            openers: openers,
            closers: closers
        };
    }

    var sourceCode = context.getSourceCode();

    function isOpenerException(token) {
        return token.type === "Punctuator" && exceptions.openers.indexOf(token.value) >= 0;
    }

    function isCloserException(token) {
        return token.type === "Punctuator" && exceptions.closers.indexOf(token.value) >= 0;
    }

    function shouldOpenerHaveSpace(left, right) {
        if (sourceCode.isSpaceBetweenTokens(left, right)) {
            return false;
        }

        if (ALWAYS) {
            if (right.type === "Punctuator" && right.value === ")") {
                return false;
            }
            return !isOpenerException(right);
        } else {
            return isOpenerException(right);
        }
    }

    function shouldCloserHaveSpace(left, right) {
        if (left.type === "Punctuator" && left.value === "(") {
            return false;
        }

        if (sourceCode.isSpaceBetweenTokens(left, right)) {
            return false;
        }

        if (ALWAYS) {
            return !isCloserException(left);
        } else {
            return isCloserException(left);
        }
    }

    function shouldOpenerRejectSpace(left, right) {
        if (right.type === "Line") {
            return false;
        }

        if (!astUtils.isTokenOnSameLine(left, right)) {
            return false;
        }

        if (!sourceCode.isSpaceBetweenTokens(left, right)) {
            return false;
        }

        if (ALWAYS) {
            return isOpenerException(right);
        } else {
            return !isOpenerException(right);
        }
    }

    function shouldCloserRejectSpace(left, right) {
        if (left.type === "Punctuator" && left.value === "(") {
            return false;
        }

        if (!astUtils.isTokenOnSameLine(left, right)) {
            return false;
        }

        if (!sourceCode.isSpaceBetweenTokens(left, right)) {
            return false;
        }

        if (ALWAYS) {
            return isCloserException(left);
        } else {
            return !isCloserException(left);
        }
    }

    return {
        "Program": function checkParenSpaces(node) {
            var tokens, prevToken, nextToken;
            exceptions = getExceptions();
            tokens = sourceCode.tokensAndComments;

            tokens.forEach(function(token, i) {
                prevToken = tokens[i - 1];
                nextToken = tokens[i + 1];

                if (token.type !== "Punctuator") {
                    return;
                }

                if (token.value !== "(" && token.value !== ")") {
                    return;
                }

                if (token.value === "(" && shouldOpenerHaveSpace(token, nextToken)) {
                    context.report({
                        node: node,
                        loc: token.loc.start,
                        message: MISSING_SPACE_MESSAGE,
                        fix: function(fixer) {
                            return fixer.insertTextAfter(token, " ");
                        }
                    });
                } else if (token.value === "(" && shouldOpenerRejectSpace(token, nextToken)) {
                    context.report({
                        node: node,
                        loc: token.loc.start,
                        message: REJECTED_SPACE_MESSAGE,
                        fix: function(fixer) {
                            return fixer.removeRange([token.range[1], nextToken.range[0]]);
                        }
                    });
                } else if (token.value === ")" && shouldCloserHaveSpace(prevToken, token)) {
                    context.report({
                        node: node,
                        loc: token.loc.start,
                        message: MISSING_SPACE_MESSAGE,
                        fix: function(fixer) {
                            return fixer.insertTextBefore(token, " ");
                        }
                    });
                } else if (token.value === ")" && shouldCloserRejectSpace(prevToken, token)) {
                    context.report({
                        node: node,
                        loc: token.loc.start,
                        message: REJECTED_SPACE_MESSAGE,
                        fix: function(fixer) {
                            return fixer.removeRange([prevToken.range[1], token.range[0]]);
                        }
                    });
                }
            });
        }
    };

};

module.exports.schema = [
    {
        "enum": ["always", "never"]
    },
    {
        "type": "object",
        "properties": {
            "exceptions": {
                "type": "array",
                "items": {
                    "enum": ["{}", "[]", "()", "empty"]
                },
                "uniqueItems": true
            }
        },
        "additionalProperties": false
    }
];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/space-infix-ops.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var int32Hint = context.options[0] ? context.options[0].int32Hint === true : false;

    var OPERATORS = [
        "*", "/", "%", "+", "-", "<<", ">>", ">>>", "<", "<=", ">", ">=", "in",
        "instanceof", "==", "!=", "===", "!==", "&", "^", "|", "&&", "||", "=",
        "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "&=", "^=", "|=",
        "?", ":", ",", "**"
    ];

    function getFirstNonSpacedToken(left, right) {
        var op, tokens = context.getTokensBetween(left, right, 1);
        for (var i = 1, l = tokens.length - 1; i < l; ++i) {
            op = tokens[i];
            if (
                op.type === "Punctuator" &&
                OPERATORS.indexOf(op.value) >= 0 &&
                (tokens[i - 1].range[1] >= op.range[0] || op.range[1] >= tokens[i + 1].range[0])
            ) {
                return op;
            }
        }
        return null;
    }

    function report(mainNode, culpritToken) {
        context.report({
            node: mainNode,
            loc: culpritToken.loc.start,
            message: "Infix operators must be spaced.",
            fix: function(fixer) {
                var previousToken = context.getTokenBefore(culpritToken);
                var afterToken = context.getTokenAfter(culpritToken);
                var fixString = "";

                if (culpritToken.range[0] - previousToken.range[1] === 0) {
                    fixString = " ";
                }

                fixString += culpritToken.value;

                if (afterToken.range[0] - culpritToken.range[1] === 0) {
                    fixString += " ";
                }

                return fixer.replaceText(culpritToken, fixString);
            }
        });
    }

    function checkBinary(node) {
        var nonSpacedNode = getFirstNonSpacedToken(node.left, node.right);

        if (nonSpacedNode) {
            if (!(int32Hint && context.getSource(node).substr(-2) === "|0")) {
                report(node, nonSpacedNode);
            }
        }
    }

    function checkConditional(node) {
        var nonSpacedConsequesntNode = getFirstNonSpacedToken(node.test, node.consequent);
        var nonSpacedAlternateNode = getFirstNonSpacedToken(node.consequent, node.alternate);

        if (nonSpacedConsequesntNode) {
            report(node, nonSpacedConsequesntNode);
        } else if (nonSpacedAlternateNode) {
            report(node, nonSpacedAlternateNode);
        }
    }

    function checkVar(node) {
        var nonSpacedNode;

        if (node.init) {
            nonSpacedNode = getFirstNonSpacedToken(node.id, node.init);
            if (nonSpacedNode) {
                report(node, nonSpacedNode);
            }
        }
    }

    return {
        "AssignmentExpression": checkBinary,
        "AssignmentPattern": checkBinary,
        "BinaryExpression": checkBinary,
        "LogicalExpression": checkBinary,
        "ConditionalExpression": checkConditional,
        "VariableDeclarator": checkVar
    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "int32Hint": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/space-unary-ops.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var options = context.options && Array.isArray(context.options) && context.options[0] || { words: true, nonwords: false };

    function isFirstBangInBangBangExpression(node) {
        return node && node.type === "UnaryExpression" && node.argument.operator === "!" &&
            node.argument && node.argument.type === "UnaryExpression" && node.argument.operator === "!";
    }

    function isArgumentObjectExpression(node) {
        return node.argument && node.argument.type && node.argument.type === "ObjectExpression";
    }

    function checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, word) {
        word = word || firstToken.value;

        if (options.words) {
            if (secondToken.range[0] === firstToken.range[1]) {
                context.report({
                    node: node,
                    message: "Unary word operator '" + word + "' must be followed by whitespace.",
                    fix: function(fixer) {
                        return fixer.insertTextAfter(firstToken, " ");
                    }
                });
            }
        }

        if (!options.words && isArgumentObjectExpression(node)) {
            if (secondToken.range[0] > firstToken.range[1]) {
                context.report({
                    node: node,
                    message: "Unexpected space after unary word operator '" + word + "'.",
                    fix: function(fixer) {
                        return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
                    }
                });
            }
        }
    }

    function checkForSpaces(node) {
        var tokens = context.getFirstTokens(node, 2),
            firstToken = tokens[0],
            secondToken = tokens[1];

        if ((node.type === "NewExpression" || node.prefix) && firstToken.type === "Keyword") {
            checkUnaryWordOperatorForSpaces(node, firstToken, secondToken);
            return;
        }

        if (options.nonwords) {
            if (node.prefix) {
                if (isFirstBangInBangBangExpression(node)) {
                    return;
                }
                if (firstToken.range[1] === secondToken.range[0]) {
                    context.report({
                        node: node,
                        message: "Unary operator '" + firstToken.value + "' must be followed by whitespace.",
                        fix: function(fixer) {
                            return fixer.insertTextAfter(firstToken, " ");
                        }
                    });
                }
            } else {
                if (firstToken.range[1] === secondToken.range[0]) {
                    context.report({
                        node: node,
                        message: "Space is required before unary expressions '" + secondToken.value + "'.",
                        fix: function(fixer) {
                            return fixer.insertTextBefore(secondToken, " ");
                        }
                    });
                }
            }
        } else {
            if (node.prefix) {
                if (secondToken.range[0] > firstToken.range[1]) {
                    context.report({
                        node: node,
                        message: "Unexpected space after unary operator '" + firstToken.value + "'.",
                        fix: function(fixer) {
                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
                        }
                    });
                }
            } else {
                if (secondToken.range[0] > firstToken.range[1]) {
                    context.report({
                        node: node,
                        message: "Unexpected space before unary operator '" + secondToken.value + "'.",
                        fix: function(fixer) {
                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
                        }
                    });
                }
            }
        }
    }

    return {
        "UnaryExpression": checkForSpaces,
        "UpdateExpression": checkForSpaces,
        "NewExpression": checkForSpaces,
        "YieldExpression": function(node) {
            var tokens = context.getFirstTokens(node, 3),
                word = "yield";

            if (!node.argument || node.delegate) {
                return;
            }

            checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], word);
        }
    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "words": {
                "type": "boolean"
            },
            "nonwords": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/rules/spaced-comment.js": [function(require,module,exports){
"use strict";

var lodash = require("lodash");

function escape(s) {
    var isOneChar = s.length === 1;
    s = lodash.escapeRegExp(s);
    return isOneChar ? s : "(?:" + s + ")";
}

function escapeAndRepeat(s) {
    return escape(s) + "+";
}

function parseMarkersOption(markers) {
    markers = markers ? markers.slice(0) : [];

    if (markers.indexOf("*") === -1) {
        markers.push("*");
    }

    return markers;
}

function createAlwaysStylePattern(markers, exceptions) {
    var pattern = "^";

    if (markers.length === 1) {
        pattern += escape(markers[0]);
    } else {
        pattern += "(?:";
        pattern += markers.map(escape).join("|");
        pattern += ")";
    }
    pattern += "?"; // or nothing.

    if (exceptions.length === 0) {
        pattern += "\\s";
    } else {
        pattern += "(?:\\s|";
        if (exceptions.length === 1) {
            pattern += escapeAndRepeat(exceptions[0]);
        } else {
            pattern += "(?:";
            pattern += exceptions.map(escapeAndRepeat).join("|");
            pattern += ")";
        }
        pattern += "(?:$|[\n\r]))"; // the sequence continues until the end.
    }
    return new RegExp(pattern);
}

function createNeverStylePattern(markers) {
    var pattern = "^(" + markers.map(escape).join("|") + ")?[ \t]+";
    return new RegExp(pattern);
}

module.exports = function(context) {
    var requireSpace = context.options[0] !== "never";

    var config = context.options[1] || {};
    var styleRules = ["block", "line"].reduce(function(rule, type) {
        var markers = parseMarkersOption(config[type] && config[type].markers || config.markers);
        var exceptions = config[type] && config[type].exceptions || config.exceptions || [];

        rule[type] = {
            regex: requireSpace ? createAlwaysStylePattern(markers, exceptions) : createNeverStylePattern(markers),
            hasExceptions: exceptions.length > 0,
            markers: new RegExp("^(" + markers.map(escape).join("|") + ")")
        };

        return rule;
    }, {});

    function report(node, message, match) {
        var type = node.type.toLowerCase(),
            commentIdentifier = type === "block" ? "/*" : "//";

        context.report({
            node: node,
            fix: function(fixer) {
                var start = node.range[0],
                    end = start + 2;

                if (requireSpace) {
                    if (match) {
                        end += match[0].length;
                    }
                    return fixer.insertTextAfterRange([start, end], " ");
                } else {
                    end += match[0].length;
                    return fixer.replaceTextRange([start, end], commentIdentifier + (match[1] ? match[1] : ""));
                }
            },
            message: message
        });
    }

    function checkCommentForSpace(node) {
        var type = node.type.toLowerCase(),
            rule = styleRules[type],
            commentIdentifier = type === "block" ? "/*" : "//";

        if (node.value.length === 0 || type === "block") {
            return;
        }

        if (requireSpace) {
            if (!rule.regex.test(node.value)) {
                var hasMarker = rule.markers.exec(node.value);
                var marker = hasMarker ? commentIdentifier + hasMarker[0] : commentIdentifier;
                if (rule.hasExceptions) {
                    report(node, "Expected exception block, space or tab after '" + marker + "' in comment.", hasMarker);
                } else {
                    report(node, "Expected space or tab after '" + marker + "' in comment.", hasMarker);
                }
            }
        } else {
            var matched = rule.regex.exec(node.value);
            if (matched) {
                if (!matched[1]) {
                    report(node, "Unexpected space or tab after '" + commentIdentifier + "' in comment.", matched);
                } else {
                    report(node, "Unexpected space or tab after marker (" + matched[1] + ") in comment.", matched);
                }
            }
        }
    }

    return {

        "LineComment": checkCommentForSpace,
        "BlockComment": checkCommentForSpace

    };
};

module.exports.schema = [
    {
        "enum": ["always", "never"]
    },
    {
        "type": "object",
        "properties": {
            "exceptions": {
                "type": "array",
                "items": {
                    "type": "string"
                }
            },
            "markers": {
                "type": "array",
                "items": {
                    "type": "string"
                }
            },
            "line": {
                "type": "object",
                "properties": {
                    "exceptions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "markers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "additionalProperties": false
            },
            "block": {
                "type": "object",
                "properties": {
                    "exceptions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "markers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "additionalProperties": false
            }
        },
        "additionalProperties": false
    }
];

},
   {"lodash":"/node_modules/lodash/lodash.js"}],

"/tmp/rules/strict.js": [function(require,module,exports){
"use strict";

var lodash = require("lodash");

var messages = {
    function: "Use the function form of 'use strict'.",
    global: "Use the global form of 'use strict'.",
    multiple: "Multiple 'use strict' directives.",
    never: "Strict mode is not permitted.",
    unnecessary: "Unnecessary 'use strict' directive.",
    module: "'use strict' is unnecessary inside of modules.",
    implied: "'use strict' is unnecessary when implied strict mode is enabled.",
    unnecessaryInClasses: "'use strict' is unnecessary inside of classes."
};

function getUseStrictDirectives(statements) {
    var directives = [],
        i, statement;

    for (i = 0; i < statements.length; i++) {
        statement = statements[i];

        if (
            statement.type === "ExpressionStatement" &&
            statement.expression.type === "Literal" &&
            statement.expression.value === "use strict"
        ) {
            directives[i] = statement;
        } else {
            break;
        }
    }

    return directives;
}

module.exports = function(context) {

    var mode = context.options[0] || "safe",
        ecmaFeatures = context.parserOptions.ecmaFeatures || {},
        scopes = [],
        classScopes = [],
        rule;

    if (ecmaFeatures.impliedStrict) {
        mode = "implied";
    } else if (mode === "safe") {
        mode = ecmaFeatures.globalReturn ? "global" : "function";
    }

    function reportSlice(nodes, start, end, message) {
        var i;

        for (i = start; i < end; i++) {
            context.report(nodes[i], message);
        }
    }

    function reportAll(nodes, message) {
        reportSlice(nodes, 0, nodes.length, message);
    }

    function reportAllExceptFirst(nodes, message) {
        reportSlice(nodes, 1, nodes.length, message);
    }

    function enterFunctionInFunctionMode(node, useStrictDirectives) {
        var isInClass = classScopes.length > 0,
            isParentGlobal = scopes.length === 0 && classScopes.length === 0,
            isParentStrict = scopes.length > 0 && scopes[scopes.length - 1],
            isStrict = useStrictDirectives.length > 0;

        if (isStrict) {
            if (isParentStrict) {
                context.report(useStrictDirectives[0], messages.unnecessary);
            } else if (isInClass) {
                context.report(useStrictDirectives[0], messages.unnecessaryInClasses);
            }

            reportAllExceptFirst(useStrictDirectives, messages.multiple);
        } else if (isParentGlobal) {
            context.report(node, messages.function);
        }

        scopes.push(isParentStrict || isStrict);
    }

    function exitFunctionInFunctionMode() {
        scopes.pop();
    }

    function enterFunction(node) {
        var isBlock = node.body.type === "BlockStatement",
            useStrictDirectives = isBlock ?
                getUseStrictDirectives(node.body.body) : [];

        if (mode === "function") {
            enterFunctionInFunctionMode(node, useStrictDirectives);
        } else {
            reportAll(useStrictDirectives, messages[mode]);
        }
    }

    rule = {
        "Program": function(node) {
            var useStrictDirectives = getUseStrictDirectives(node.body);

            if (node.sourceType === "module") {
                mode = "module";
            }

            if (mode === "global") {
                if (node.body.length > 0 && useStrictDirectives.length === 0) {
                    context.report(node, messages.global);
                }
                reportAllExceptFirst(useStrictDirectives, messages.multiple);
            } else {
                reportAll(useStrictDirectives, messages[mode]);
            }
        },
        "FunctionDeclaration": enterFunction,
        "FunctionExpression": enterFunction,
        "ArrowFunctionExpression": enterFunction
    };

    if (mode === "function") {
        lodash.assign(rule, {
            "ClassBody": function() {
                classScopes.push(true);
            },
            "ClassBody:exit": function() {
                classScopes.pop();
            },

            "FunctionDeclaration:exit": exitFunctionInFunctionMode,
            "FunctionExpression:exit": exitFunctionInFunctionMode,
            "ArrowFunctionExpression:exit": exitFunctionInFunctionMode
        });
    }

    return rule;
};

module.exports.schema = [
    {
        "enum": ["never", "global", "function", "safe"]
    }
];

},
   {"lodash":"/node_modules/lodash/lodash.js"}],

"/tmp/rules/template-curly-spacing.js": [function(require,module,exports){
"use strict";

var astUtils = require("../ast-utils");

var OPEN_PAREN = /\$\{$/;
var CLOSE_PAREN = /^\}/;

module.exports = function(context) {
    var sourceCode = context.getSourceCode();
    var always = context.options[0] === "always";
    var prefix = always ? "Expected" : "Unexpected";

    function checkSpacingBefore(token) {
        var prevToken = sourceCode.getTokenBefore(token);
        if (prevToken &&
            CLOSE_PAREN.test(token.value) &&
            astUtils.isTokenOnSameLine(prevToken, token) &&
            sourceCode.isSpaceBetweenTokens(prevToken, token) !== always
        ) {
            context.report({
                loc: token.loc.start,
                message: prefix + " space(s) before '}'.",
                fix: function(fixer) {
                    if (always) {
                        return fixer.insertTextBefore(token, " ");
                    }
                    return fixer.removeRange([
                        prevToken.range[1],
                        token.range[0]
                    ]);
                }
            });
        }
    }

    function checkSpacingAfter(token) {
        var nextToken = sourceCode.getTokenAfter(token);
        if (nextToken &&
            OPEN_PAREN.test(token.value) &&
            astUtils.isTokenOnSameLine(token, nextToken) &&
            sourceCode.isSpaceBetweenTokens(token, nextToken) !== always
        ) {
            context.report({
                loc: {
                    line: token.loc.end.line,
                    column: token.loc.end.column - 2
                },
                message: prefix + " space(s) after '${'.",
                fix: function(fixer) {
                    if (always) {
                        return fixer.insertTextAfter(token, " ");
                    }
                    return fixer.removeRange([
                        token.range[1],
                        nextToken.range[0]
                    ]);
                }
            });
        }
    }

    return {
        TemplateElement: function(node) {
            var token = sourceCode.getFirstToken(node);
            checkSpacingBefore(token);
            checkSpacingAfter(token);
        }
    };
};

module.exports.schema = [
    {enum: ["always", "never"]}
];

},
   {"../ast-utils":"/tmp/ast-utils.js"}],

"/tmp/rules/use-isnan.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {
        "BinaryExpression": function(node) {
            if (/^(?:[<>]|[!=]=)=?$/.test(node.operator) && (node.left.name === "NaN" || node.right.name === "NaN")) {
                context.report(node, "Use the isNaN function to compare with NaN.");
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/valid-jsdoc.js": [function(require,module,exports){
"use strict";

var doctrine = require("doctrine");

module.exports = function(context) {

    var options = context.options[0] || {},
        prefer = options.prefer || {},
        sourceCode = context.getSourceCode(),

        requireReturn = options.requireReturn !== false,
        requireParamDescription = options.requireParamDescription !== false,
        requireReturnDescription = options.requireReturnDescription !== false,
        requireReturnType = options.requireReturnType !== false,
        preferType = options.preferType || {},
        checkPreferType = Object.keys(preferType).length !== 0;

    var fns = [];

    function isTypeClass(node) {
        return node.type === "ClassExpression" || node.type === "ClassDeclaration";
    }

    function startFunction(node) {
        fns.push({
            returnPresent: (node.type === "ArrowFunctionExpression" && node.body.type !== "BlockStatement") ||
                isTypeClass(node)
        });
    }

    function addReturn(node) {
        var functionState = fns[fns.length - 1];

        if (functionState && node.argument !== null) {
            functionState.returnPresent = true;
        }
    }

    function isValidReturnType(tag) {
        return tag.type === null || tag.type.name === "void" || tag.type.type === "UndefinedLiteral";
    }

    function canTypeBeValidated(type) {
        return type !== "UndefinedLiteral" && // {undefined} as there is no name property available.
               type !== "NullLiteral" && // {null}
               type !== "NullableLiteral" && // {?}
               type !== "FunctionType" && // {function(a)}
               type !== "AllLiteral"; // {*}
    }

    function getCurrentExpectedTypes(type) {
        var currentType;
        var expectedType;

        if (!type.name) {
            currentType = type.expression.name;
        } else {
            currentType = type.name;
        }

        expectedType = preferType[currentType];

        return {
            currentType: currentType,
            expectedType: expectedType
        };
    }

    function validateTagType(tag, jsdocNode) {
        if (!tag.type || !canTypeBeValidated(tag.type.type)) {
            return;
        }

        var typesToCheck = [];
        var elements = [];

        if (tag.type.type === "TypeApplication") { // {Array.<String>}
            elements = tag.type.applications;
            typesToCheck.push(getCurrentExpectedTypes(tag.type));
        } else if (tag.type.type === "RecordType") { // {{20:String}}
            elements = tag.type.fields;
        } else if (tag.type.type === "UnionType") { // {String|number|Test}
            elements = tag.type.elements;
        } else {
            typesToCheck.push(getCurrentExpectedTypes(tag.type));
        }

        elements.forEach(function(type) {
            type = type.value ? type.value : type; // we have to use type.value for RecordType
            if (canTypeBeValidated(type.type)) {
                typesToCheck.push(getCurrentExpectedTypes(type));
            }
        });

        typesToCheck.forEach(function(type) {
            if (type.expectedType &&
                type.expectedType !== type.currentType) {
                context.report({
                    node: jsdocNode,
                    message: "Use '{{expectedType}}' instead of '{{currentType}}'.",
                    data: {
                        currentType: type.currentType,
                        expectedType: type.expectedType
                    }
                });
            }
        });
    }

    function checkJSDoc(node) {
        var jsdocNode = sourceCode.getJSDocComment(node),
            functionData = fns.pop(),
            hasReturns = false,
            hasConstructor = false,
            isInterface = false,
            isOverride = false,
            params = Object.create(null),
            jsdoc;

        if (jsdocNode) {

            try {
                jsdoc = doctrine.parse(jsdocNode.value, {
                    strict: true,
                    unwrap: true,
                    sloppy: true
                });
            } catch (ex) {

                if (/braces/i.test(ex.message)) {
                    context.report(jsdocNode, "JSDoc type missing brace.");
                } else {
                    context.report(jsdocNode, "JSDoc syntax error.");
                }

                return;
            }

            jsdoc.tags.forEach(function(tag) {

                switch (tag.title.toLowerCase()) {

                    case "param":
                    case "arg":
                    case "argument":
                        if (!tag.type) {
                            context.report(jsdocNode, "Missing JSDoc parameter type for '{{name}}'.", { name: tag.name });
                        }

                        if (!tag.description && requireParamDescription) {
                            context.report(jsdocNode, "Missing JSDoc parameter description for '{{name}}'.", { name: tag.name });
                        }

                        if (params[tag.name]) {
                            context.report(jsdocNode, "Duplicate JSDoc parameter '{{name}}'.", { name: tag.name });
                        } else if (tag.name.indexOf(".") === -1) {
                            params[tag.name] = 1;
                        }
                        break;

                    case "return":
                    case "returns":
                        hasReturns = true;

                        if (!requireReturn && !functionData.returnPresent && (tag.type === null || !isValidReturnType(tag))) {
                            context.report(jsdocNode, "Unexpected @" + tag.title + " tag; function has no return statement.");
                        } else {
                            if (requireReturnType && !tag.type) {
                                context.report(jsdocNode, "Missing JSDoc return type.");
                            }

                            if (!isValidReturnType(tag) && !tag.description && requireReturnDescription) {
                                context.report(jsdocNode, "Missing JSDoc return description.");
                            }
                        }

                        break;

                    case "constructor":
                    case "class":
                        hasConstructor = true;
                        break;

                    case "override":
                    case "inheritdoc":
                        isOverride = true;
                        break;

                    case "interface":
                        isInterface = true;
                        break;

                }

                if (prefer.hasOwnProperty(tag.title) && tag.title !== prefer[tag.title]) {
                    context.report(jsdocNode, "Use @{{name}} instead.", { name: prefer[tag.title] });
                }

                if (checkPreferType) {
                    validateTagType(tag, jsdocNode);
                }
            });

            if (!isOverride && !hasReturns && !hasConstructor && !isInterface &&
                node.parent.kind !== "get" && node.parent.kind !== "constructor" &&
                node.parent.kind !== "set" && !isTypeClass(node)) {
                if (requireReturn || functionData.returnPresent) {
                    context.report(jsdocNode, "Missing JSDoc @" + (prefer.returns || "returns") + " for function.");
                }
            }

            var jsdocParams = Object.keys(params);

            if (node.params) {
                node.params.forEach(function(param, i) {
                    var name = param.name;

                    if (param.type === "Identifier") {
                        if (jsdocParams[i] && (name !== jsdocParams[i])) {
                            context.report(jsdocNode, "Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.", {
                                name: name,
                                jsdocName: jsdocParams[i]
                            });
                        } else if (!params[name] && !isOverride) {
                            context.report(jsdocNode, "Missing JSDoc for parameter '{{name}}'.", {
                                name: name
                            });
                        }
                    }
                });
            }

            if (options.matchDescription) {
                var regex = new RegExp(options.matchDescription);

                if (!regex.test(jsdoc.description)) {
                    context.report(jsdocNode, "JSDoc description does not satisfy the regex pattern.");
                }
            }

        }

    }

    return {
        "ArrowFunctionExpression": startFunction,
        "FunctionExpression": startFunction,
        "FunctionDeclaration": startFunction,
        "ClassExpression": startFunction,
        "ClassDeclaration": startFunction,
        "ArrowFunctionExpression:exit": checkJSDoc,
        "FunctionExpression:exit": checkJSDoc,
        "FunctionDeclaration:exit": checkJSDoc,
        "ClassExpression:exit": checkJSDoc,
        "ClassDeclaration:exit": checkJSDoc,
        "ReturnStatement": addReturn
    };

};

module.exports.schema = [
    {
        "type": "object",
        "properties": {
            "prefer": {
                "type": "object",
                "additionalProperties": {
                    "type": "string"
                }
            },
            "preferType": {
                "type": "object",
                "additionalProperties": {
                    "type": "string"
                }
            },
            "requireReturn": {
                "type": "boolean"
            },
            "requireParamDescription": {
                "type": "boolean"
            },
            "requireReturnDescription": {
                "type": "boolean"
            },
            "matchDescription": {
                "type": "string"
            },
            "requireReturnType": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {"doctrine":"/node_modules/doctrine/lib/doctrine.js"}],

"/tmp/rules/valid-typeof.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var VALID_TYPES = ["symbol", "undefined", "object", "boolean", "number", "string", "function"],
        OPERATORS = ["==", "===", "!=", "!=="];

    return {

        "UnaryExpression": function(node) {
            var parent, sibling;

            if (node.operator === "typeof") {
                parent = context.getAncestors().pop();

                if (parent.type === "BinaryExpression" && OPERATORS.indexOf(parent.operator) !== -1) {
                    sibling = parent.left === node ? parent.right : parent.left;

                    if (sibling.type === "Literal" && VALID_TYPES.indexOf(sibling.value) === -1) {
                        context.report(sibling, "Invalid typeof comparison value");
                    }
                }
            }
        }

    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/vars-on-top.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var errorMessage = "All 'var' declarations must be at the top of the function scope.";

    function looksLikeDirective(node) {
        return node.type === "ExpressionStatement" &&
            node.expression.type === "Literal" && typeof node.expression.value === "string";
    }

    function looksLikeImport(node) {
        return node.type === "ImportDeclaration" || node.type === "ImportSpecifier" ||
            node.type === "ImportDefaultSpecifier" || node.type === "ImportNamespaceSpecifier";
    }

    function isVarOnTop(node, statements) {
        var i = 0, l = statements.length;

        for (; i < l; ++i) {
            if (!looksLikeDirective(statements[i]) && !looksLikeImport(statements[i])) {
                break;
            }
        }

        for (; i < l; ++i) {
            if (statements[i].type !== "VariableDeclaration") {
                return false;
            }
            if (statements[i] === node) {
                return true;
            }
        }

        return false;
    }

    function globalVarCheck(node, parent) {
        if (!isVarOnTop(node, parent.body)) {
            context.report(node, errorMessage);
        }
    }

    function blockScopeVarCheck(node, parent, grandParent) {
        if (!(/Function/.test(grandParent.type) &&
                parent.type === "BlockStatement" &&
                isVarOnTop(node, parent.body))) {
            context.report(node, errorMessage);
        }
    }

    return {
        "VariableDeclaration": function(node) {
            var ancestors = context.getAncestors();
            var parent = ancestors.pop();
            var grandParent = ancestors.pop();

            if (node.kind === "var") { // check variable is `var` type and not `let` or `const`
                if (parent.type === "Program") { // That means its a global variable
                    globalVarCheck(node, parent);
                } else {
                    blockScopeVarCheck(node, parent, grandParent);
                }
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/wrap-iife.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    var style = context.options[0] || "outside";

    function wrapped(node) {
        var previousToken = context.getTokenBefore(node),
            nextToken = context.getTokenAfter(node);
        return previousToken && previousToken.value === "(" &&
            nextToken && nextToken.value === ")";
    }

    return {

        "CallExpression": function(node) {
            if (node.callee.type === "FunctionExpression") {
                var callExpressionWrapped = wrapped(node),
                    functionExpressionWrapped = wrapped(node.callee);

                if (!callExpressionWrapped && !functionExpressionWrapped) {
                    context.report(node, "Wrap an immediate function invocation in parentheses.");
                } else if (style === "inside" && !functionExpressionWrapped) {
                    context.report(node, "Wrap only the function expression in parens.");
                } else if (style === "outside" && !callExpressionWrapped) {
                    context.report(node, "Move the invocation into the parens that contain the function.");
                }
            }
        }
    };

};

module.exports.schema = [
    {
        "enum": ["outside", "inside", "any"]
    }
];

},
   {}],

"/tmp/rules/wrap-regex.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {

    return {

        "Literal": function(node) {
            var token = context.getFirstToken(node),
                nodeType = token.type,
                source,
                grandparent,
                ancestors;

            if (nodeType === "RegularExpression") {
                source = context.getTokenBefore(node);
                ancestors = context.getAncestors();
                grandparent = ancestors[ancestors.length - 1];

                if (grandparent.type === "MemberExpression" && grandparent.object === node &&
                    (!source || source.value !== "(")) {
                    context.report(node, "Wrap the regexp literal in parens to disambiguate the slash.");
                }
            }
        }
    };

};

module.exports.schema = [];

},
   {}],

"/tmp/rules/yield-star-spacing.js": [function(require,module,exports){
"use strict";

module.exports = function(context) {
    var sourceCode = context.getSourceCode();

    var mode = (function(option) {
        if (!option || typeof option === "string") {
            return {
                before: { before: true, after: false },
                after: { before: false, after: true },
                both: { before: true, after: true },
                neither: { before: false, after: false }
            }[option || "after"];
        }
        return option;
    }(context.options[0]));

    function checkSpacing(side, leftToken, rightToken) {
        if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken) !== mode[side]) {
            var after = leftToken.value === "*";
            var spaceRequired = mode[side];
            var node = after ? leftToken : rightToken;
            var type = spaceRequired ? "Missing" : "Unexpected";
            var message = type + " space " + side + " *.";
            context.report({
                node: node,
                message: message,
                fix: function(fixer) {
                    if (spaceRequired) {
                        if (after) {
                            return fixer.insertTextAfter(node, " ");
                        }
                        return fixer.insertTextBefore(node, " ");
                    }
                    return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
                }
            });
        }
    }

    function checkExpression(node) {
        if (!node.delegate) {
            return;
        }

        var tokens = sourceCode.getFirstTokens(node, 3);
        var yieldToken = tokens[0];
        var starToken = tokens[1];
        var nextToken = tokens[2];

        checkSpacing("before", yieldToken, starToken);
        checkSpacing("after", starToken, nextToken);
    }

    return {
        "YieldExpression": checkExpression
    };

};

module.exports.schema = [
    {
        "oneOf": [
            {
                "enum": ["before", "after", "both", "neither"]
            },
            {
                "type": "object",
                "properties": {
                    "before": {"type": "boolean"},
                    "after": {"type": "boolean"}
                },
                "additionalProperties": false
            }
        ]
    }
];

},
   {}],

"/tmp/rules/yoda.js": [function(require,module,exports){
"use strict";

function isComparisonOperator(operator) {
    return (/^(==|===|!=|!==|<|>|<=|>=)$/).test(operator);
}

function isEqualityOperator(operator) {
    return (/^(==|===)$/).test(operator);
}

function isRangeTestOperator(operator) {
    return ["<", "<="].indexOf(operator) >= 0;
}

function looksLikeLiteral(node) {
    return (node.type === "UnaryExpression" &&
        node.operator === "-" &&
        node.prefix &&
        node.argument.type === "Literal" &&
        typeof node.argument.value === "number");
}

function getNormalizedLiteral(node) {
    if (node.type === "Literal") {
        return node;
    }

    if (looksLikeLiteral(node)) {
        return {
            type: "Literal",
            value: -node.argument.value,
            raw: "-" + node.argument.value
        };
    }

    return null;
}

function same(a, b) {
    if (a.type !== b.type) {
        return false;
    }

    switch (a.type) {
        case "Identifier":
            return a.name === b.name;
        case "Literal":
            return a.value === b.value;
        case "MemberExpression":
            return same(a.object, b.object) && same(a.property, b.property);
        case "ThisExpression":
            return true;
        default:
            return false;
    }
}

module.exports = function(context) {

    var always = (context.options[0] === "always");
    var exceptRange = (context.options[1] && context.options[1].exceptRange);
    var onlyEquality = (context.options[1] && context.options[1].onlyEquality);

    function isRangeTest(node) {
        var left = node.left,
            right = node.right;

        function isBetweenTest() {
            var leftLiteral, rightLiteral;

            return (node.operator === "&&" &&
                (leftLiteral = getNormalizedLiteral(left.left)) &&
                (rightLiteral = getNormalizedLiteral(right.right)) &&
                leftLiteral.value <= rightLiteral.value &&
                same(left.right, right.left));
        }

        function isOutsideTest() {
            var leftLiteral, rightLiteral;

            return (node.operator === "||" &&
                (leftLiteral = getNormalizedLiteral(left.right)) &&
                (rightLiteral = getNormalizedLiteral(right.left)) &&
                leftLiteral.value <= rightLiteral.value &&
                same(left.left, right.right));
        }

        function isParenWrapped() {
            var tokenBefore, tokenAfter;

            return ((tokenBefore = context.getTokenBefore(node)) &&
                tokenBefore.value === "(" &&
                (tokenAfter = context.getTokenAfter(node)) &&
                tokenAfter.value === ")");
        }

        return (node.type === "LogicalExpression" &&
            left.type === "BinaryExpression" &&
            right.type === "BinaryExpression" &&
            isRangeTestOperator(left.operator) &&
            isRangeTestOperator(right.operator) &&
            (isBetweenTest() || isOutsideTest()) &&
            isParenWrapped());
    }

    return {
        "BinaryExpression": always ? function(node) {

            if (
                (node.right.type === "Literal" || looksLikeLiteral(node.right)) &&
                !(node.left.type === "Literal" || looksLikeLiteral(node.left)) &&
                !(!isEqualityOperator(node.operator) && onlyEquality) &&
                isComparisonOperator(node.operator) &&
                !(exceptRange && isRangeTest(context.getAncestors().pop()))
            ) {
                context.report(node, "Expected literal to be on the left side of " + node.operator + ".");
            }

        } : function(node) {

            if (
                (node.left.type === "Literal" || looksLikeLiteral(node.left)) &&
                !(node.right.type === "Literal" || looksLikeLiteral(node.right)) &&
                !(!isEqualityOperator(node.operator) && onlyEquality) &&
                isComparisonOperator(node.operator) &&
                !(exceptRange && isRangeTest(context.getAncestors().pop()))
            ) {
                context.report(node, "Expected literal to be on the right side of " + node.operator + ".");
            }

        }
    };

};

module.exports.schema = [
    {
        "enum": ["always", "never"]
    },
    {
        "type": "object",
        "properties": {
            "exceptRange": {
                "type": "boolean"
            },
            "onlyEquality": {
                "type": "boolean"
            }
        },
        "additionalProperties": false
    }
];

},
   {}],

"/tmp/timing.js": [function(require,module,exports){
(function (process){
"use strict";

function alignLeft(str, len, ch) {
    return str + new Array(len - str.length + 1).join(ch || " ");
}

function alignRight(str, len, ch) {
    return new Array(len - str.length + 1).join(ch || " ") + str;
}

var enabled = !!process.env.TIMING;

var HEADERS = ["Rule", "Time (ms)", "Relative"];
var ALIGN = [alignLeft, alignRight, alignRight];

function display(data) {
    var total = 0;
    var rows = Object.keys(data)
        .map(function(key) {
            var time = data[key];
            total += time;
            return [key, time];
        })
        .sort(function(a, b) {
            return b[1] - a[1];
        })
        .slice(0, 10);

    rows.forEach(function(row) {
        row.push((row[1] * 100 / total).toFixed(1) + "%");
        row[1] = row[1].toFixed(3);
    });

    rows.unshift(HEADERS);

    var widths = [];
    rows.forEach(function(row) {
        var len = row.length, i, n;
        for (i = 0; i < len; i++) {
            n = row[i].length;
            if (!widths[i] || n > widths[i]) {
                widths[i] = n;
            }
        }
    });

    var table = rows.map(function(row) {
        return row.map(function(cell, index) {
            return ALIGN[index](cell, widths[index]);
        }).join(" | ");
    });
    table.splice(1, 0, widths.map(function(w, index) {
        if (index !== 0 && index !== widths.length - 1) {
            w++;
        }

        return ALIGN[index](":", w + 1, "-");
    }).join("|"));

    console.log(table.join("\n"));
}

module.exports = (function() {

    var data = Object.create(null);

    function time(key, fn) {
        if (typeof data[key] === "undefined") {
            data[key] = 0;
        }

        return function() {
            var t = process.hrtime();
            fn.apply(null, Array.prototype.slice.call(arguments));
            t = process.hrtime(t);
            data[key] += t[0] * 1e3 + t[1] / 1e6;
        };
    }

    if (enabled) {
        process.on("exit", function() {
            display(data);
        });
    }

    return {
        time: time,
        enabled: enabled
    };

}());

}).call(this,require('_process'))
},
   {"_process":"/node_modules/browserify/node_modules/process/browser.js"}],

"/tmp/token-store.js": [function(require,module,exports){
"use strict";

module.exports = function(tokens) {
    var api = {},
        starts = Object.create(null),
        ends = Object.create(null),
        index, length, range;

    function get(start, end) {
        var result = [],
            i;

        for (i = Math.max(0, start); i < end && i < length; i++) {
            result.push(tokens[i]);
        }

        return result;
    }

    function lastTokenIndex(node) {
        var end = node.range[1],
            cursor = ends[end];

        if (typeof cursor === "undefined") {
            cursor = starts[end] - 1;
        }

        if (isNaN(cursor)) {
            cursor = length - 1;
        }

        return cursor;
    }

    for (index = 0, length = tokens.length; index < length; index++) {
        range = tokens[index].range;
        starts[range[0]] = index;
        ends[range[1]] = index;
    }

    api.getTokensBefore = function(node, beforeCount) {
        var first = starts[node.range[0]];
        return get(first - (beforeCount || 0), first);
    };

    api.getTokenBefore = function(node, skip) {
        return tokens[starts[node.range[0]] - (skip || 0) - 1];
    };

    api.getTokensAfter = function(node, afterCount) {
        var start = lastTokenIndex(node) + 1;
        return get(start, start + (afterCount || 0));
    };

    api.getTokenAfter = function(node, skip) {
        return tokens[lastTokenIndex(node) + (skip || 0) + 1];
    };

    api.getTokens = function(node, beforeCount, afterCount) {
        return get(
            starts[node.range[0]] - (beforeCount || 0),
            lastTokenIndex(node) + (afterCount || 0) + 1
        );
    };

    api.getFirstTokens = function(node, count) {
        var first = starts[node.range[0]];
        return get(
            first,
            Math.min(lastTokenIndex(node) + 1, first + (count || 0))
        );
    };

    api.getFirstToken = function(node, skip) {
        return tokens[starts[node.range[0]] + (skip || 0)];
    };

    api.getLastTokens = function(node, count) {
        var last = lastTokenIndex(node) + 1;
        return get(Math.max(starts[node.range[0]], last - (count || 0)), last);
    };

    api.getLastToken = function(node, skip) {
        return tokens[lastTokenIndex(node) - (skip || 0)];
    };

    api.getTokensBetween = function(left, right, padding) {
        padding = padding || 0;
        return get(
            lastTokenIndex(left) + 1 - padding,
            starts[right.range[0]] + padding
        );
    };

    api.getTokenByRangeStart = function(startIndex) {
        return (tokens[starts[startIndex]] || null);
    };

    return api;
};

},
   {}],

"/tmp/util/comment-event-generator.js": [function(require,module,exports){
"use strict";

function emitComments(comments, emitter, locs, eventName) {
    if (comments.length > 0) {
        comments.forEach(function(node) {
            var index = locs.indexOf(node.loc);
            if (index >= 0) {
                locs.splice(index, 1);
            } else {
                locs.push(node.loc);
                emitter.emit(node.type + eventName, node);
            }
        });
    }
}

function emitCommentsEnter(generator, comments) {
    emitComments(
        comments,
        generator.emitter,
        generator.commentLocsEnter,
        "Comment");
}

function emitCommentsExit(generator, comments) {
    emitComments(
        comments,
        generator.emitter,
        generator.commentLocsExit,
        "Comment:exit");
}

function CommentEventGenerator(originalEventGenerator, sourceCode) {
    this.original = originalEventGenerator;
    this.emitter = originalEventGenerator.emitter;
    this.sourceCode = sourceCode;
    this.commentLocsEnter = [];
    this.commentLocsExit = [];
}

CommentEventGenerator.prototype = {
    constructor: CommentEventGenerator,

    enterNode: function enterNode(node) {
        var comments = this.sourceCode.getComments(node);

        emitCommentsEnter(this, comments.leading);
        this.original.enterNode(node);
        emitCommentsEnter(this, comments.trailing);
    },

    leaveNode: function leaveNode(node) {
        var comments = this.sourceCode.getComments(node);

        emitCommentsExit(this, comments.trailing);
        this.original.leaveNode(node);
        emitCommentsExit(this, comments.leading);
    }
};

module.exports = CommentEventGenerator;

},
   {}],

"/tmp/util/keywords.js": [function(require,module,exports){
"use strict";

module.exports = [
    "abstract",
    "boolean",
    "break",
    "byte",
    "case",
    "catch",
    "char",
    "class",
    "const",
    "continue",
    "debugger",
    "default",
    "delete",
    "do",
    "double",
    "else",
    "enum",
    "export",
    "extends",
    "false",
    "final",
    "finally",
    "float",
    "for",
    "function",
    "goto",
    "if",
    "implements",
    "import",
    "in",
    "instanceof",
    "int",
    "interface",
    "long",
    "native",
    "new",
    "null",
    "package",
    "private",
    "protected",
    "public",
    "return",
    "short",
    "static",
    "super",
    "switch",
    "synchronized",
    "this",
    "throw",
    "throws",
    "transient",
    "true",
    "try",
    "typeof",
    "var",
    "void",
    "volatile",
    "while",
    "with"
];

},
   {}],

"/tmp/util/node-event-generator.js": [function(require,module,exports){
"use strict";

function NodeEventGenerator(emitter) {
    this.emitter = emitter;
}

NodeEventGenerator.prototype = {
    constructor: NodeEventGenerator,

    enterNode: function enterNode(node) {
        this.emitter.emit(node.type, node);
    },

    leaveNode: function leaveNode(node) {
        this.emitter.emit(node.type + ":exit", node);
    }
};

module.exports = NodeEventGenerator;

},
   {}],

"/tmp/util/rule-fixer.js": [function(require,module,exports){
"use strict";

function insertTextAt(index, text) {
    return {
        range: [index, index],
        text: text
    };
}

function RuleFixer() {
    Object.freeze(this);
}

RuleFixer.prototype = {
    constructor: RuleFixer,

    insertTextAfter: function(nodeOrToken, text) {
        return this.insertTextAfterRange(nodeOrToken.range, text);
    },

    insertTextAfterRange: function(range, text) {
        return insertTextAt(range[1], text);
    },

    insertTextBefore: function(nodeOrToken, text) {
        return this.insertTextBeforeRange(nodeOrToken.range, text);
    },

    insertTextBeforeRange: function(range, text) {
        return insertTextAt(range[0], text);
    },

    replaceText: function(nodeOrToken, text) {
        return this.replaceTextRange(nodeOrToken.range, text);
    },

    replaceTextRange: function(range, text) {
        return {
            range: range,
            text: text
        };
    },

    remove: function(nodeOrToken) {
        return this.removeRange(nodeOrToken.range);
    },

    removeRange: function(range) {
        return {
            range: range,
            text: ""
        };
    }

};


module.exports = RuleFixer;

},
   {}],

"/tmp/util/source-code.js": [function(require,module,exports){
"use strict";

var lodash = require("lodash"),
    createTokenStore = require("../token-store.js"),
    espree = require("espree"),
    estraverse = require("estraverse");

function validate(ast) {

    if (!ast.tokens) {
        throw new Error("AST is missing the tokens array.");
    }

    if (!ast.comments) {
        throw new Error("AST is missing the comments array.");
    }

    if (!ast.loc) {
        throw new Error("AST is missing location information.");
    }

    if (!ast.range) {
        throw new Error("AST is missing range information");
    }
}

function findJSDocComment(comments, line) {

    if (comments) {
        for (var i = comments.length - 1; i >= 0; i--) {
            if (comments[i].type === "Block" && comments[i].value.charAt(0) === "*") {

                if (line - comments[i].loc.end.line <= 1) {
                    return comments[i];
                } else {
                    break;
                }
            }
        }
    }

    return null;
}

function looksLikeExport(astNode) {
    return astNode.type === "ExportDefaultDeclaration" || astNode.type === "ExportNamedDeclaration" ||
        astNode.type === "ExportAllDeclaration" || astNode.type === "ExportSpecifier";
}


function SourceCode(text, ast) {
    validate(ast);

    this.hasBOM = (text.charCodeAt(0) === 0xFEFF);

    this.text = (this.hasBOM ? text.slice(1) : text);

    this.ast = ast;

    this.lines = SourceCode.splitLines(this.text);

    this.tokensAndComments = ast.tokens.concat(ast.comments).sort(function(left, right) {
        return left.range[0] - right.range[0];
    });

    var tokenStore = createTokenStore(ast.tokens);
    Object.keys(tokenStore).forEach(function(methodName) {
        this[methodName] = tokenStore[methodName];
    }, this);

    var tokensAndCommentsStore = createTokenStore(this.tokensAndComments);
    this.getTokenOrCommentBefore = tokensAndCommentsStore.getTokenBefore;
    this.getTokenOrCommentAfter = tokensAndCommentsStore.getTokenAfter;

    Object.freeze(this);
    Object.freeze(this.lines);
}

SourceCode.splitLines = function(text) {
    return text.split(/\r\n|\r|\n|\u2028|\u2029/g);
};

SourceCode.prototype = {
    constructor: SourceCode,

    getText: function(node, beforeCount, afterCount) {
        if (node) {
            return this.text.slice(Math.max(node.range[0] - (beforeCount || 0), 0),
                node.range[1] + (afterCount || 0));
        } else {
            return this.text;
        }

    },

    getLines: function() {
        return this.lines;
    },

    getAllComments: function() {
        return this.ast.comments;
    },

    getComments: function(node) {

        var leadingComments = node.leadingComments || [],
            trailingComments = node.trailingComments || [];

        if (node.type === "Program") {
            if (node.body.length === 0) {
                leadingComments = node.comments;
            }
        }

        return {
            leading: leadingComments,
            trailing: trailingComments
        };
    },

    getJSDocComment: function(node) {

        var parent = node.parent;

        switch (node.type) {
            case "ClassDeclaration":
            case "FunctionDeclaration":
                if (looksLikeExport(parent)) {
                    return findJSDocComment(parent.leadingComments, parent.loc.start.line);
                }
                return findJSDocComment(node.leadingComments, node.loc.start.line);

            case "ClassExpression":
                return findJSDocComment(parent.parent.leadingComments, parent.parent.loc.start.line);

            case "ArrowFunctionExpression":
            case "FunctionExpression":

                if (parent.type !== "CallExpression" && parent.type !== "NewExpression") {
                    while (parent && !parent.leadingComments && !/Function/.test(parent.type) && parent.type !== "MethodDefinition" && parent.type !== "Property") {
                        parent = parent.parent;
                    }

                    return parent && (parent.type !== "FunctionDeclaration") ? findJSDocComment(parent.leadingComments, parent.loc.start.line) : null;
                } else if (node.leadingComments) {
                    return findJSDocComment(node.leadingComments, node.loc.start.line);
                }

            default:
                return null;
        }
    },

    getNodeByRangeIndex: function(index) {
        var result = null;
        var resultParent = null;

        estraverse.traverse(this.ast, {
            enter: function(node, parent) {
                if (node.range[0] <= index && index < node.range[1]) {
                    result = node;
                    resultParent = parent;
                } else {
                    this.skip();
                }
            },
            leave: function(node) {
                if (node === result) {
                    this.break();
                }
            },
            keys: espree.VisitorKeys
        });

        return result ? lodash.assign({parent: resultParent}, result) : null;
    },

    isSpaceBetweenTokens: function(first, second) {
        var text = this.text.slice(first.range[1], second.range[0]);
        return /\s/.test(text.replace(/\/\*.*?\*\//g, ""));
    }
};


module.exports = SourceCode;

},
   {"../token-store.js":"/tmp/token-store.js","espree":"espree","estraverse":"/node_modules/estraverse/estraverse.js","lodash":"/node_modules/lodash/lodash.js"}]},{},["/tmp/eslint.js"])("/tmp/eslint.js")
});
})()